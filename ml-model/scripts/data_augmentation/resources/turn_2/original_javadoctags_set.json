[
   [
      "@param pinMap the used pinMap. Is required to handle aliases correctly",
      "@param v the vector to transform",
      "@param timeout the timeout in milliseconds to wait for data.\n               <p>\n               0 means standard timeout value, -1 means \"ludicrous time\" (essentially never times out).",
      "@throws IllegalArgumentException if maxDigits is not in [1..1024]",
      "@param timeout the timeout in milliseconds to wait for data.\n                 <p>\n                 0 means standard timeout value, -1 means \"ludicrous time\" (essentially never times out).",
      "@param maxDigits the maximum number of digits to read.\n                 <p>\n                 Must be in [1..1024].",
      "@param predicate the predicate to call, not null",
      "@throws IllegalArgumentException if the predicate is null",
      "@throws NullPointerException if either argument is null",
      "@param predicate the predicate to use as an end of loop test, not null",
      "@param closure the closure to call repeatedly, not null",
      "@throws NullPointerException if the method name is null",
      "@throws NullPointerException if the closures array is null",
      "@throws NullPointerException if any closure in the array is null",
      "@throws NullPointerException if the closures collection is null",
      "@throws IllegalArgumentException if the closures collection is empty",
      "@throws NullPointerException if the predicate or closure is null",
      "@throws NullPointerException if the predicate or either closure is null",
      "@throws NullPointerException if any element in the arrays is null",
      "@throws NullPointerException if the either array is null",
      "@throws IllegalArgumentException if the arrays have different sizes",
      "@param predicates an array of predicates to check, not null",
      "@param closures an array of closures to call, not null",
      "@throws IllegalArgumentException if the arrays are different sizes",
      "@throws NullPointerException if the map is null"
   ],
   [
      "@throws NullPointerException if any closure in the map is null",
      "@throws IllegalArgumentException if the map is empty",
      "@throws NullPointerException if map is null",
      "@param map the map to decorate, must not be null",
      "@param loadFactor the load factor, must be > 0.0f and generally < 1.0f",
      "@throws IllegalArgumentException if the initial capacity is negative",
      "@throws IllegalArgumentException if the load factor is less than zero",
      "@throws NullPointerException if iterator is null",
      "@throws IllegalArgumentException if offset is negative",
      "@param closure the closure to call, not null",
      "@throws NullPointerException if the closure is null",
      "@return the transformed result",
      "@throws NullPointerException if bag is null",
      "@param bag the sorted bag to decorate, must not be null",
      "@throws NullPointerException if <code>array</code> is <code>null</code>",
      "@throws UnsupportedOperationException always",
      "@param predicate the predicate used to evaluate when the loop terminates, not null",
      "@param closure the closure the execute, not null",
      "@param doLoop true to act as a do-while loop, always executing the closure once",
      "@throws IllegalArgumentException if set is null",
      "@param set the set to decorate, must not be null",
      "@throws NullPointerException if set or list is null",
      "@param list the list to decorate, must not be null",
      "@throws IllegalArgumentException if either the set or list is not empty",
      "@param set the set to decorate, must be empty and not null"
   ],
   [
      "@param list the list to decorate, must be empty and not null",
      "@throws NullPointerException if set is null",
      "@throws NullPointerException if list is null",
      "@throws NullPointerException if the predicate is null",
      "@param predicate the predicate to decorate, not null",
      "@throws FunctorException if input is null",
      "@param bag the bag to decorate, must not be null",
      "@throws IllegalArgumentException if the map is not empty",
      "@param map the map to decorate, not null",
      "@throws NullPointerException if the key is null",
      "@param key the non-null MultiKey object",
      "@throws NullPointerException if the mapToCopy or any key within is null",
      "@param removeAllowed true if remove is allowed",
      "@throws NullPointerException if the key is null and null keys are invalid",
      "@throws NullPointerException if map or either of the transformers is null",
      "@param keyTransformer the transformer to use for key conversion, must not be null",
      "@param valueTransformer the transformer to use for value conversion, must not be null",
      "@return the transformed object",
      "@param map the map to wrap, must not be null",
      "@throws NullPointerException if the transformer is null",
      "@throws NullPointerException if set or predicate is null",
      "@param predicate the predicate to use for validation, must not be null",
      "@throws NullPointerException if the enumeration parameter is <code>null</code>.",
      "@param enumeration the enumeration to traverse, which should not be <code>null</code>.",
      "@param multipleUse <code>true</code> if the new iterable can be used in multiple iterations"
   ],
   [
      "@param value1 the first value to compare, may be null",
      "@param value2 the second value to compare, may be null",
      "@throws IndexOutOfBoundsException if the index is less than 0; equal to\nthe size of the list and endMakerAllowed is false; or greater than the\nsize of the list",
      "@throws NullPointerException if {@code coll} is {@code null}",
      "@param coll the <code>BoundedCollection</code> to decorate, must not be null",
      "@throws NullPointerException if coll is null",
      "@param predicate1 the first predicate to check, not null",
      "@param predicate2 the second predicate to check, not null",
      "@throws NullPointerException if either predicate is null",
      "@throws NullPointerException if collection or transformer is null",
      "@param coll the collection to decorate, must not be null",
      "@param transformer the transformer to use for conversion, must not be null",
      "@param collection the collection to decorate, must not be null",
      "@return a transformed object",
      "@return the key",
      "@return the value",
      "@return true always",
      "@return false always",
      "@return true if the map contains the key",
      "@throws NullPointerException if multiset is null",
      "@param multiset the multiset to decorate, must not be null",
      "@throws NullPointerException if multiset or lock is null",
      "@param lock the lock to use, must not be null",
      "@return the predicates being decorated",
      "@throws NullPointerException if either iterator is null"
   ],
   [
      "@throws NullPointerException if any iterator is null",
      "@throws NullPointerException if the iterator is null",
      "@param iterator the iterator to decorate, must not be null",
      "@param keyPredicate the predicate to validate the keys, null means no check",
      "@param valuePredicate the predicate to validate to values, null means no check",
      "@return the value itself",
      "@throws NullPointerException if the specified array is null",
      "@throws NullPointerException if bag or lock is null",
      "@throws NullPointerException if collection is null",
      "@throws NullPointerException if the transformer or the predicate is null",
      "@throws NullPointerException if the class is null",
      "@param type the type to check for, may not be null",
      "@throws NullPointerException if the methodName is null.",
      "@param methodName the method name to call on the input object, may not be null",
      "@param predicate1 the first predicate, may not be null",
      "@param predicate2 the second predicate, may not be null",
      "@throws NullPointerException if the predicates array is null",
      "@throws NullPointerException if any predicate in the array is null",
      "@param predicates an array of predicates to check, may not be null",
      "@param predicate the predicate for the bag, must not be null",
      "@throws NullPointerException if the Bag or Transformer is null",
      "@param bag the bag to predicate, must not be null",
      "@param transformer the transformer for the bag, must not be null",
      "@return an empty Bag",
      "@return an empty sorted Bag"
   ],
   [
      "@throws NullPointerException if methodName is null",
      "@throws NullPointerException if the collection is null",
      "@throws NullPointerException if comparator is null",
      "@throws NullPointerException if comparator or criterion is null",
      "@param pair the pair to copy, must not be null",
      "@throws NullPointerException if the entry is null",
      "@param entry the entry to copy, must not be null",
      "@throws NullPointerException if queue is null",
      "@param queue the queue to decorate, must not be null",
      "@throws NullPointerException if the specified value is null and nulls are invalid",
      "@throws NullPointerException if map or transformer is null",
      "@throws NullPointerException if map or factory is null",
      "@param factory the factory to use to create entries, must not be null",
      "@param transformer the transformer to use as a factory to create entries, must not be null",
      "@throws NullPointerException if the value is null and null value are invalid",
      "@param predicates the predicates to check, not cloned, not null",
      "@param predicates the predicates to check, cloned, not null",
      "@throws NullPointerException if <i>obj1</i> is <code>null</code>,\n        or when <code>((Comparable)obj1).compareTo(obj2)</code> does",
      "@throws NullPointerException if the classToInstantiate is null",
      "@throws NullPointerException if the object cannot be added because its null",
      "@throws NullPointerException if the argument is null",
      "@param get to wrap, must not be null",
      "@param put to wrap, must not be null",
      "@throws NullPointerException if the list is null",
      "@throws FunctorException always"
   ],
   [
      "@throws NullPointerException if classToInstantiate is null",
      "@param classToInstantiate the class to instantiate, not null",
      "@throws NullPointerException if list or transformer is null",
      "@throws NullPointerException if trie is null",
      "@param trie the trie to make unmodifiable, must not be null",
      "@param reverse false = forward sort; true = reverse sort",
      "@param reverse false = forward sort order; true = reverse sort order",
      "@return immutable empty collection",
      "@return an empty collection if the argument is <code>null</code>",
      "@param a the first collection, must not be null",
      "@param b the second collection, must not be null",
      "@param a the collection to subtract from, must not be null",
      "@param b the collection to subtract, must not be null",
      "@param coll1 the first collection, must not be null",
      "@param coll2 the second collection, must not be null",
      "@param coll the collection to get the cardinality map for, must not be null",
      "@param a the first (sub?) collection, must not be null",
      "@param b the second (super?) collection, must not be null",
      "@return <code>true</code> iff <i>a</i> is a <i>proper</i> sub-collection of <i>b</i>",
      "@throws NullPointerException if the equator is null",
      "@return closure",
      "@return the last element in the collection, or null if either collection or closure is null",
      "@return the last element in the collection, or null if either iterator or closure is null",
      "@throws NullPointerException if the input collection is null",
      "@param inputCollection the collection to get the input from, may not be null"
   ],
   [
      "@param outputCollection the collection to output into, may not be null if the inputCollection\n  and predicate or not null",
      "@param outputCollection the collection to output selected elements into, may not be null if the\n  inputCollection and predicate are not null",
      "@param rejectedCollection the collection to output rejected elements into, may not be null if the\n  inputCollection or predicate are not null",
      "@return the outputCollection",
      "@throws NullPointerException if the outputCollection is null and both, inputCollection and\n  transformer are not null",
      "@param outputCollection the collection to output into, may not be null if inputCollection\n  and transformer are not null",
      "@throws NullPointerException if the output collection is null and both, inputIterator and\n  transformer are not null",
      "@param outputCollection the collection to output into, may not be null if inputIterator\n  and transformer are not null",
      "@param collection the collection to add to, must not be null",
      "@throws NullPointerException if the collection or iterator is null",
      "@param iterable the iterable of elements to add, must not be null",
      "@param iterator the iterator of elements to add, must not be null",
      "@throws NullPointerException if the collection or enumeration is null",
      "@param enumeration the enumeration of elements to add, must not be null",
      "@throws NullPointerException if the collection or array is null",
      "@param elements the array of elements to add, must not be null",
      "@throws IndexOutOfBoundsException if the index is invalid",
      "@return the size of the specified collection or 0 if the object was null",
      "@return true if empty or null",
      "@return true if non-null and non-empty",
      "@throws IndexOutOfBoundsException if the index is negative.",
      "@throws NullPointerException if either collection is null",
      "@throws NullPointerException if either collection or the comparator is null",
      "@param collection the collection to create permutations for, may not be null",
      "@throws NullPointerException if either parameter is null"
   ],
   [
      "@throws NullPointerException if any of the parameters is null",
      "@param collection the collection to synchronize, must not be null",
      "@param collection the collection to make unmodifiable, must not be null",
      "@throws NullPointerException if the Collection is null",
      "@param collection the collection to predicate, must not be null",
      "@param predicate the predicate for the collection, must not be null",
      "@throws NullPointerException if the Collection or Transformer is null",
      "@param transformer the transformer for the collection, must not be null",
      "@throws IllegalArgumentException if collection is empty or contains more than one element",
      "@throws NullPointerException if bag or predicate is null",
      "@throws IllegalArgumentException if the key array is null",
      "@param keys the array of keys, not null",
      "@param makeClone true to clone the array, false to assign it",
      "@param map the map to decorate, may not be null",
      "@throws NullPointerException if expiringPolicy is null",
      "@throws NullPointerException if the map or expiringPolicy is null.",
      "@param map the map to decorate, must not be null.",
      "@throws NullPointerException if the map is null.",
      "@throws NullPointerException if the time unit is null.",
      "@param timeUnit the unit of time for the <code>timeToLive</code>\n       parameter, must not be null.",
      "@throws NullPointerException if the map or time unit is null.",
      "@throws NullPointerException if the MultiSet is null",
      "@param multiset the multiset to synchronize, must not be null",
      "@param multiset the multiset whose unmodifiable view is to be returned, must not be null",
      "@throws NullPointerException if the MultiSet or Predicate is null"
   ],
   [
      "@param multiset the multiset to predicate, must not be null",
      "@param predicate the predicate for the multiset, must not be null",
      "@return an empty MultiSet",
      "@param set the list to decorate, must not be null",
      "@param predicate predicate to switch on, not null",
      "@param trueClosure closure used if true, not null",
      "@param falseClosure closure used if false, not null",
      "@throws NullPointerException if any argument is null",
      "@param values the values to add to the collection at the key, null ignored",
      "@throws NullPointerException if list or predicate is null",
      "@param factory the factory to call, not null",
      "@throws NullPointerException if the factory is null",
      "@throws IllegalArgumentException if the specified initial size\n is negative",
      "@return true if the stack is currently empty",
      "@throws EmptyStackException if the stack is empty",
      "@return the top item on the stack",
      "@throws EmptyStackException if there are not enough items on the\n stack to satisfy this request",
      "@return the item just pushed",
      "@return the 1-based depth into the stack of the object, or -1 if not found",
      "@throws NullPointerException if the value is null",
      "@return the value to which this map maps the specified key,\n or null if the map contains no mapping for this key",
      "@return the key to which this map maps the specified value,\n or null if the map contains no mapping for this value.",
      "@throws NoSuchElementException if this map is empty",
      "@throws NullPointerException if list or factory is null",
      "@param factory the factory to use for creation, must not be null"
   ],
   [
      "@throws NullPointerException if node is null",
      "@param node Node, who's child nodes are wrapped by this class. Must not be null",
      "@throws NullPointerException if nodeList is null",
      "@param nodeList node list, which is wrapped by this class. Must not be null",
      "@param keyTransformer the transformer to use for key conversion, null means no conversion",
      "@param valueTransformer the transformer to use for value conversion, null means no conversion",
      "@param keyTransformer the transformer to use for key conversion, null means no transformation",
      "@param valueTransformer the transformer to use for value conversion, null means no transformation",
      "@throws NullPointerException if either the key or value is null",
      "@param key the key to add, must not be null",
      "@param value the value to add, must not be null",
      "@throws NullPointerException (optional) if the map limits the values to\n non-null and null was specified",
      "@throws NullPointerException if array is null",
      "@param predicates array of predicates, cloned, no nulls",
      "@param closures matching array of closures, cloned, no nulls",
      "@throws NullPointerException if the queue is null",
      "@param queue the queue to make unmodifiable, must not be null",
      "@throws NullPointerException if the queue or predicate is null",
      "@param queue the queue to predicate, must not be null",
      "@param predicate the predicate used to evaluate new elements, must not be null",
      "@throws NullPointerException if the queue or transformer is null",
      "@param transformer the transformer for the queue, must not be null",
      "@return an empty {@link Queue}",
      "@return whether the sets are equal by value comparison",
      "@throws NullPointerException if the set is null"
   ],
   [
      "@param set the set to synchronize, must not be null",
      "@param set the set to make unmodifiable, must not be null",
      "@throws NullPointerException if the set or predicate is null",
      "@param set the set to predicate, must not be null",
      "@param predicate the predicate for the set, must not be null",
      "@throws NullPointerException if the set or transformer is null",
      "@param set the set to transform, must not be null",
      "@param transformer the transformer for the set, must not be null",
      "@param set the set to order, must not be null",
      "@param set the sorted set to synchronize, must not be null",
      "@param set the sorted set to make unmodifiable, must not be null",
      "@param set the sorted set to predicate, must not be null",
      "@param predicate the predicate for the sorted set, must not be null",
      "@param set the navigable set to make unmodifiable, must not be null",
      "@param set the navigable set to predicate, must not be null",
      "@param predicate the predicate for the navigable set, must not be null",
      "@param set the navigable set to transform, must not be null",
      "@throws NullPointerException if either input set is null",
      "@param a the first set, must not be null",
      "@param b the second set, must not be null",
      "@param a the set to subtract from, must not be null",
      "@param b the set to subtract, must not be null",
      "@return whether the two objects are equal.",
      "@param key the key to store",
      "@param value the value to store"
   ],
   [
      "@return the previous value mapped to this key",
      "@throws UnsupportedOperationException if the <code>put</code> method is not supported",
      "@throws ClassCastException (optional) if the map limits the type of the\n value and the specified value is inappropriate",
      "@throws IllegalArgumentException (optional) if the map limits the values\n in some way and the value was invalid",
      "@param value the value to find the key for",
      "@return the mapped key, or <code>null</code> if not found",
      "@param value the value to find the key-value pair for",
      "@return the key that was removed, <code>null</code> if nothing removed",
      "@throws UnsupportedOperationException if this method is not supported\n by the implementation",
      "@return an inverted bidirectional map",
      "@return a set view of the values contained in this map",
      "@param o1 the first object to be equated.",
      "@param o2 the second object to be equated.",
      "@param o the object to calculate the hash for.",
      "@return the hash of the object.",
      "@param object the object to search for",
      "@return the number of occurrences of the object, zero if not found",
      "@param object the object to update",
      "@param count the number of occurrences of the object",
      "@return the number of occurrences of the object before this operation, zero\n  if the object was not contained in the multiset",
      "@param object the object to add",
      "@return <code>true</code> always, as the size of the MultiSet is increased\n  in any case",
      "@param occurrences the number of occurrences to add, may be zero,\n  in which case no change is made to the multiset",
      "@return the number of occurrences of the object in the multiset before\n  this operation; possibly zero",
      "@param object the object to remove"
   ],
   [
      "@return <code>true</code> if this call changed the collection",
      "@param occurrences the number of occurrences to remove, may be zero,\n  in which case no change is made to the multiset",
      "@return the number of occurrences of the object in the multiset\n  before the operation; possibly zero",
      "@return the Set of unique MultiSet elements",
      "@return the Set of MultiSet entries",
      "@return iterator over all elements in the MultiSet",
      "@return the total size of the multiset",
      "@param coll the collection to check against",
      "@return <code>true</code> if the MultiSet contains all the collection",
      "@param coll the collection of elements to remove",
      "@return <code>true</code> if this call changed the multiset",
      "@param coll the collection of elements to retain",
      "@param obj the object to compare to",
      "@return true if equal",
      "@return the hash code of the MultiSet",
      "@param <E> the element type",
      "@return an iterator over nothing",
      "@return a list iterator over nothing",
      "@return an ordered iterator over nothing",
      "@param <K> the key type",
      "@param <V> the value type",
      "@return a map iterator over nothing",
      "@param object the single object over which to iterate",
      "@return a singleton iterator over the object",
      "@return a singleton list iterator over the object"
   ],
   [
      "@param array the array over which to iterate",
      "@return an iterator over the array",
      "@throws IllegalArgumentException if the array is not an array",
      "@param start the index to start iterating at",
      "@return an iterator over part of the array",
      "@param end the index to finish iterating at",
      "@throws IndexOutOfBoundsException if array bounds are invalid",
      "@return a list iterator over the array",
      "@return a list iterator over part of the array",
      "@param iterator the iterator to decorate",
      "@param max the maximum number of elements returned by this iterator",
      "@return a new bounded iterator",
      "@param offset the index of the first element of the decorated iterator to return",
      "@param iterator the iterator to make immutable",
      "@return an immutable version of the iterator",
      "@param listIterator the iterator to make immutable",
      "@param mapIterator the iterator to make immutable",
      "@return a combination iterator over the iterators",
      "@throws ClassCastException if the iterators collection contains the wrong object type",
      "@param comparator the comparator to use, may be null for natural order",
      "@param root the root object to start iterating from, null results in an empty iterator",
      "@return a new object graph iterator",
      "@param <I> the input type",
      "@param <O> the output type",
      "@return a new transforming iterator"
   ],
   [
      "@return a new filtered iterator",
      "@return a new looping iterator",
      "@return a new, single use {@link Iterator}",
      "@return a peeking iterator",
      "@return a pushback iterator",
      "@param offset the first number of elements to skip",
      "@return a new skipping iterator",
      "@param a the first iterator to interleave",
      "@param b the second iterator to interleave",
      "@param c the third iterator to interleave",
      "@param iterators the array of iterators to interleave",
      "@return an iterator, interleaving the decorated iterators",
      "@return a new iterator",
      "@return a new enumeration",
      "@return a new, single use {@link Iterable}",
      "@return a new, multiple use iterable",
      "@return an array of the iterator contents",
      "@param arrayClass the class of array to create",
      "@throws ArrayStoreException if the arrayClass is invalid",
      "@return a list of the iterator contents",
      "@param estimatedSize the initial size of the ArrayList",
      "@param obj the object to convert to an iterator",
      "@return a suitable iterator, never null",
      "@param iterator the iterator to use, may be null",
      "@param <E> the type of object the {@link Iterator} contains"
   ],
   [
      "@param iterator the iterator to get the input from, may be null",
      "@param iterator the iterator to search, may be null",
      "@return the first element of the iterator which matches the predicate or null if none could be found",
      "@return the index of the first element which matches the predicate or -1 if none matches",
      "@param iterator the {@link Iterator} to use, may be null",
      "@return true if any element of the collection matches the predicate, false otherwise",
      "@return true if every element of the collection matches the predicate or if the\n  collection is empty, false otherwise",
      "@return true if the iterator is exhausted or null, false otherwise",
      "@param iterator the iterator to check, may be null",
      "@param object the object to check",
      "@return true if the object is contained in the iterator, false otherwise",
      "@param <E> the type of object in the {@link Iterator}",
      "@param iterator the iterator to get a value from",
      "@param index the index to get",
      "@return the object at the specified index",
      "@return the number of elements contained in the iterator",
      "@param iterator the iterator to convert to a string, may be null",
      "@return a string representation of {@code iterator}",
      "@param transformer the transformer used to get a string representation of an element",
      "@param delimiter the string to delimit elements",
      "@param prefix the prefix, prepended to the string representation",
      "@param suffix the suffix, appended to the string representation",
      "@param <E> the object type to compare",
      "@return a comparator which uses natural order",
      "@return a {@link ComparatorChain} formed from the input comparators"
   ],
   [
      "@throws ClassCastException if the comparators collection contains the wrong object type",
      "@param comparator the comparator to reverse",
      "@return a comparator that reverses the order of the input comparator",
      "@param trueFirst when <code>true</code>, sort\n       <code>true</code> {@link Boolean}s before\n       <code>false</code> {@link Boolean}s.",
      "@return a comparator that sorts booleans",
      "@param comparator the comparator that wants to allow nulls",
      "@return a version of that comparator that allows nulls",
      "@param <I> the input object type of the transformed comparator",
      "@param <O> the object type of the decorated comparator",
      "@param comparator the sort order to use",
      "@param transformer the transformer to use",
      "@return a comparator that transforms its input objects before comparing them",
      "@param o1 the first object to compare",
      "@param o2 the second object to compare",
      "@return the smaller of the two objects",
      "@return the larger of the two objects",
      "@param msg the error message.",
      "@param rootCause the exception or error that caused this exception\n                  to be thrown.",
      "@param normalMap the normal direction map",
      "@param reverseMap the reverse direction map",
      "@param inverseMap this map, which is the inverse in the new map",
      "@return a map iterator",
      "@return the keySet view",
      "@return the keySet iterator",
      "@return the values view"
   ],
   [
      "@return the values iterator",
      "@return the entrySet view",
      "@return the entrySet iterator",
      "@param inverseBidiMap the inverse BidiMap",
      "@return an unmodifiable BidiMap",
      "@return the decorated map",
      "@return an unmodifiable OrderedBidiMap",
      "@return an inverted unmodifiable bidirectional map",
      "@return new bidi map",
      "@param map the map whose mappings are to be placed in this map",
      "@return an unmodifiable SortedBidiMap",
      "@param inverseMap the inverse BidiMap",
      "@return a new ordered map iterator",
      "@param keyComparator the comparator",
      "@param valueComparator the values comparator to use",
      "@return the number of key-value mappings in this map",
      "@return true if the map is empty",
      "@param key key whose presence in this map is to be tested",
      "@return true if this map contains a mapping for the specified key",
      "@throws ClassCastException if the key is of an inappropriate type",
      "@param value value whose presence in this map is to be tested",
      "@return true if this map contains a mapping for the specified value",
      "@throws ClassCastException if the value is of an inappropriate type",
      "@param key key whose associated value is to be returned",
      "@param key key with which the specified value is to be  associated"
   ],
   [
      "@param value value to be associated with the specified key",
      "@return the previous value for the key",
      "@param map the map to copy from",
      "@param key key whose mapping is to be removed from the map.",
      "@return previous value associated with specified key,\n or null if there was no mapping for key.",
      "@param value value whose associated key is to be returned.",
      "@param value value whose mapping is to be removed from the map",
      "@return previous key associated with specified value,\n or null if there was no mapping for value.",
      "@return the first (lowest) key currently in this sorted map",
      "@return the last (highest) key currently in this sorted map",
      "@param key the key to search for next from",
      "@return the next key, null if no match or at end",
      "@param key the key to search for previous from",
      "@return the previous key, null if no match or at start",
      "@return a set view of the keys contained in this map.",
      "@return a set view of the values contained in this map.",
      "@return the inverse map",
      "@return the hash code value for this map",
      "@return a standard format string version of the map",
      "@param key the key, always the main map key",
      "@param value the value, always the main map value",
      "@param data the key or value to be looked up",
      "@param index the KEY or VALUE int",
      "@return the desired Node, or null if there is no mapping of the\n        specified data",
      "@param node the node to be searched from"
   ],
   [
      "@return the specified node",
      "@param o1 the first object",
      "@param o2 the second object",
      "@return negative value if o1 &lt; o2; 0 if o1 == o2; positive\n        value if o1 &gt; o2",
      "@param node the node from which we will start searching",
      "@return the smallest node, from the specified node, in the\n        specified mapping",
      "@return the greatest node, from the specified node",
      "@param from the node whose color we're copying; may be null",
      "@param to the node whose color we're changing; may be null",
      "@param node the node (may be null) in question",
      "@param node the node to be rotated",
      "@param insertedNode the node to be inserted",
      "@param dataElement the KEY or VALUE int",
      "@param deletedNode the node to be deleted",
      "@param replacementNode the node being replaced",
      "@param x one node",
      "@param y another node",
      "@param o the object being checked",
      "@param index the KEY or VALUE int (used to put the right word in the\n             exception message)",
      "@throws NullPointerException if o is null",
      "@throws ClassCastException if o is not Comparable",
      "@param key the key to be checked",
      "@throws NullPointerException if key is null",
      "@throws ClassCastException if key is not Comparable",
      "@param value the value to be checked"
   ],
   [
      "@throws NullPointerException if value is null",
      "@throws ClassCastException if value is not Comparable",
      "@throws NullPointerException if key or value is null",
      "@throws ClassCastException if key or value is not Comparable",
      "@param newNode the node to be inserted",
      "@throws IllegalArgumentException if the node already exists\n                                    in the value mapping",
      "@param type the KEY or VALUE int",
      "@return the string form of this map",
      "@param map the map to copy",
      "@throws ClassCastException if the keys/values in the map are\n not Comparable or are not mutually comparable",
      "@throws NullPointerException if any key or value in the map is null",
      "@param <K> the type of key in the map",
      "@param <V> the type of value in the map",
      "@return immutable and empty <code>MultiValuedMap</code>",
      "@param map the map, may be null",
      "@return an empty {@link MultiValuedMap} if the argument is null",
      "@param map the map to check, may be null",
      "@param map the {@link MultiValuedMap} to use",
      "@param key the key to look up",
      "@return a new <code>ListValuedMap</code>",
      "@return a new {@link SetValuedMap}",
      "@return an unmodifiable {@link MultiValuedMap} backed by the provided map",
      "@return a transformed <code>MultiValuedMap</code> backed by the given map",
      "@return <code>true</code> if the collection is full",
      "@return the maximum number of elements the collection can hold"
   ],
   [
      "@param <E> the type of the elements in the collection",
      "@return a new unmodifiable bounded collection",
      "@throws IllegalArgumentException if coll is not a {@code BoundedCollection}",
      "@return total number of elements in all contained containers",
      "@return true if all of the contained collections are empty",
      "@param obj the object to search for",
      "@return true if obj is contained in any of the contained collections",
      "@return an <code>IteratorChain</code> instance which supports\n <code>remove()</code>. Iteration occurs over contained collections in\n the order they were added, but this behavior should not be relied upon.",
      "@return an object array of all the elements in the collection",
      "@param <T> the type of the elements in the collection",
      "@param array the array to use, populating if possible",
      "@return an array of all the elements in the collection",
      "@param obj the object to add",
      "@return {@code true} if the collection was modified",
      "@throws UnsupportedOperationException if CollectionMutator hasn't been set",
      "@throws UnsupportedOperationException if add is unsupported",
      "@throws ClassCastException if the object cannot be added due to its type",
      "@throws IllegalArgumentException if the object cannot be added",
      "@param obj the object being removed",
      "@return true if the collection is changed",
      "@throws UnsupportedOperationException if removed is unsupported",
      "@throws ClassCastException if the object cannot be removed due to its type",
      "@throws NullPointerException if the object cannot be removed because its null",
      "@throws IllegalArgumentException if the object cannot be removed",
      "@param coll the collection to check for"
   ],
   [
      "@return true if all elements contained",
      "@param coll the collection to add",
      "@return true if the collection was modified",
      "@param coll the collection to remove",
      "@throws UnsupportedOperationException if removeAll is unsupported",
      "@throws UnsupportedOperationException if retainAll is unsupported",
      "@throws UnsupportedOperationException if clear is unsupported",
      "@param mutator the mutator to use",
      "@param compositeCollection the Collection to be appended to the composite",
      "@param compositeCollection1 the Collection to be appended to the composite",
      "@param compositeCollection2 the Collection to be appended to the composite",
      "@param compositeCollections the Collections to be appended to the composite",
      "@param coll collection to be removed",
      "@return A new ArrayList containing all of the elements in this composite.\n        The new collection is <i>not</i> backed by this composite.",
      "@return Unmodifiable list of all collections in this composite.",
      "@return CollectionMutator<E>",
      "@param compositeCollections the collections to composite",
      "@return a new transformed collection",
      "@return a new transformed Collection",
      "@param object the object to transform",
      "@param coll the collection to transform",
      "@param predicate the predicate to use",
      "@return a new Builder for predicated collections",
      "@return a new Builder for predicated collections that ignores null values.",
      "@return a new predicated collection"
   ],
   [
      "@throws IllegalArgumentException if the collection contains invalid elements",
      "@param object the object being added",
      "@throws IllegalArgumentException if the add is invalid",
      "@return the result of adding to the underlying collection",
      "@param coll the collection being added",
      "@param <K> the index object type.",
      "@throws NullPointerException if the predicates collection is null",
      "@throws NullPointerException if any predicate in the collection is null",
      "@param predicates a collection of predicates to check, may not be null",
      "@return the <code>not</code> predicate",
      "@param transformer the transformer to wrap, may not be null",
      "@throws NullPointerException if the predicate is null.",
      "@param predicate the predicate to wrap, may not be null",
      "@return the predicate",
      "@return <code>true</code>, always",
      "@param trueTransformer transformer used if true, not null",
      "@param falseTransformer transformer used if false, not null",
      "@return a new empty FluentIterable",
      "@throws NullPointerException if iterable is null",
      "@param iterable the iterable to wrap into a FluentIterable, may not be null",
      "@throws NullPointerException if other is null",
      "@param other the other iterable to combine, may not be null",
      "@param other the other iterable to collate, may not be null",
      "@throws NullPointerException if predicate is null",
      "@throws IllegalArgumentException if maxSize is negative"
   ],
   [
      "@throws IllegalArgumentException if elementsToSkip is negative",
      "@throws NullPointerException if transformer is null",
      "@param other the other iterable to interleave, may not be null",
      "@throws NullPointerException if either of the provided iterables is null",
      "@param others the iterables to interleave, may not be null",
      "@param predicate the predicate to use, may not be null",
      "@throws NullPointerException if closure is null",
      "@param closure the closure to apply to each element, may not be null",
      "@throws IndexOutOfBoundsException if the provided position is outside the\n  valid range of this iterable: [0, size)",
      "@throws NullPointerException if either a or b is null",
      "@param a the first iterable, may not be null",
      "@param b the second iterable, may not be null",
      "@param c the third iterable, may not be null",
      "@param d the fourth iterable, may not be null",
      "@param iterables the iterables to combine, may not be null",
      "@param <C> the collection type.",
      "@param coll the decorated {@link Collection}.",
      "@param keyTransformer the {@link Transformer} for generating index keys.",
      "@return the created {@link IndexedCollection}.",
      "@throws IllegalArgumentException if the object maps to an existing key and the index\n  enforces a uniqueness constraint",
      "@param key key to look up",
      "@return element found",
      "@return a collection of elements found, or null if {@code contains(key) == false}",
      "@param object the object to index",
      "@param coll decorated {@link Collection}"
   ],
   [
      "@param keyTransformer {@link Transformer} for generating index keys",
      "@param map map to use as index",
      "@param uniqueIndex if the index shall enforce uniqueness of index keys",
      "@return a new synchronized collection",
      "@return the decorated collection",
      "@return an iterator that must be manually synchronized on the collection",
      "@return an unmodifiable collection",
      "@param coll the decorated collection",
      "@param <T> the type that the factory creates",
      "@return the factory",
      "@param <T> the \"type\" of null object the factory should return.",
      "@param constantToReturn the constant object to return each time in the factory",
      "@return the <code>constant</code> factory.",
      "@param prototype the object to clone each time in the factory",
      "@return the <code>prototype</code> factory, or a {@link ConstantFactory#NULL_INSTANCE} if\nthe {@code prototype} is {@code null}",
      "@throws IllegalArgumentException if the prototype cannot be cloned",
      "@param classToInstantiate the Class to instantiate each time in the factory",
      "@return the <code>reflection</code> factory",
      "@param paramTypes parameter types for the constructor, can be null",
      "@param args the arguments to pass to the constructor, can be null",
      "@throws IllegalArgumentException if the paramTypes and args don't match",
      "@throws IllegalArgumentException if the constructor doesn't exist",
      "@param <T> the element type",
      "@param list the list, possibly <code>null</code>",
      "@return an empty list if the argument is <code>null</code>"
   ],
   [
      "@param list the list, possibly {@code null}",
      "@param list1 the first list",
      "@param list2 the second list",
      "@return the intersection of those two lists",
      "@param list1 the list to subtract from",
      "@param list2 the list to subtract",
      "@return a new list containing the results",
      "@return a new list containing the sum of those lists",
      "@return a new list containing the union of those lists",
      "@param predicate the predicate to use, may be null",
      "@return the elements matching the predicate (new list)",
      "@return the elements <b>not</b> matching the predicate (new list)",
      "@param list1 the first list, may be null",
      "@param list2 the second list, may be null",
      "@param list the list to generate the hashCode for, may be null",
      "@return the hash code",
      "@param collection the collection whose contents are the target of the #retailAll operation",
      "@param retain the collection containing the elements to be retained in the returned collection",
      "@return a <code>List</code> containing all the elements of <code>c</code>\nthat occur at least once in <code>retain</code>.",
      "@param collection the collection from which items are removed (in the returned collection)",
      "@param remove the items to be removed from the returned <code>collection</code>",
      "@return a <code>List</code> containing all the elements of <code>c</code> except\nany elements that also occur in <code>remove</code>.",
      "@return a synchronized list backed by the given list",
      "@return an unmodifiable list backed by the given list",
      "@return a predicated list backed by the given list"
   ],
   [
      "@return a transformed list backed by the given list",
      "@return a lazy list backed by the given list",
      "@return a fixed-size list backed by that list",
      "@param list the List to search, may be null",
      "@return the first index of an Object in the List which matches the predicate or -1 if none could be found",
      "@param a the first list",
      "@param b the second list",
      "@return the longest common subsequence",
      "@param equator the equator used to test object equality",
      "@param a the first sequence",
      "@param b the second sequence",
      "@return the longest common subsequence as {@link String}",
      "@param list the list to return consecutive sublists of",
      "@param size the desired size of each sublist (the last may be smaller)",
      "@return a list of consecutive sublists",
      "@param input the input to execute on",
      "@throws ClassCastException (runtime) if the input is the wrong class",
      "@throws IllegalArgumentException (runtime) if the input is invalid",
      "@throws FunctorException (runtime) if any other error occurs",
      "@param map the map to use",
      "@return the value in the Map, <code>null</code> if null map input",
      "@return the value in the Map as a String, <code>null</code> if null map input",
      "@return the value in the Map as a Boolean, <code>null</code> if null map input",
      "@return the value in the Map as a Number, <code>null</code> if null map input",
      "@return the value in the Map as a Byte, <code>null</code> if null map input"
   ],
   [
      "@return the value in the Map as a Short, <code>null</code> if null map input",
      "@return the value in the Map as a Integer, <code>null</code> if null map input",
      "@return the value in the Map as a Long, <code>null</code> if null map input",
      "@return the value in the Map as a Float, <code>null</code> if null map input",
      "@return the value in the Map as a Double, <code>null</code> if null map input",
      "@return the value in the Map as a Map, <code>null</code> if null map input",
      "@param map the map whose value to look up",
      "@param key the key of the value to look up in that map",
      "@return the value in the map, or defaultValue if the original value\n  is null or the map is null",
      "@return the value in the map as a string, or defaultValue if the\n  original value is null, the map is null or the string conversion fails",
      "@param defaultValue what to return if the value is null or if the\n  conversion fails",
      "@return the value in the map as a boolean, or defaultValue if the\n  original value is null, the map is null or the boolean conversion fails",
      "@return the value in the map as a number, or defaultValue if the\n  original value is null, the map is null or the number conversion fails",
      "@return the value in the map as a number, or defaultValue if the\n  original value is null, the map is null or the map conversion fails",
      "@return the value in the Map as a Boolean, <code>false</code> if null map input",
      "@return the value in the Map as a byte, <code>0</code> if null map input",
      "@return the value in the Map as a short, <code>0</code> if null map input",
      "@return the value in the Map as an int, <code>0</code> if null map input",
      "@return the value in the Map as a long, <code>0L</code> if null map input",
      "@return the value in the Map as a float, <code>0.0F</code> if null map input",
      "@return the value in the Map as a double, <code>0.0</code> if null map input",
      "@param defaultValue return if the value is null or if the conversion fails",
      "@return the value in the Map as a Boolean, <code>defaultValue</code> if null map input",
      "@return the value in the Map as a byte, <code>defaultValue</code> if null map input",
      "@return the value in the Map as a short, <code>defaultValue</code> if null map input"
   ],
   [
      "@return the value in the Map as an int, <code>defaultValue</code> if null map input",
      "@return the value in the Map as a long, <code>defaultValue</code> if null map input",
      "@return the value in the Map as a float, <code>defaultValue</code> if null map input",
      "@return the value in the Map as a double, <code>defaultValue</code> if null map input",
      "@param map the map to convert to a Properties object",
      "@return the properties object",
      "@throws NullPointerException if a key or value in the provided map is {@code null}",
      "@return the hashmap containing the data",
      "@param label The label to be used, may be <code>null</code>.\n If <code>null</code>, the label is not output.\n It typically represents the name of the property in a bean or similar.",
      "@param map The map to print, may be <code>null</code>.\n If <code>null</code>, the text 'null' is output.",
      "@throws NullPointerException if the stream is <code>null</code>",
      "@param label The label to be used, may be <code>null</code>.\n  If <code>null</code>, the label is not output.\n  It typically represents the name of the property in a bean or similar.",
      "@param map The map to print, may be <code>null</code>.\n  If <code>null</code>, the text 'null' is output.",
      "@param out the stream to print to",
      "@param label the label to be used, may be <code>null</code>.\n  If <code>null</code>, the label is not output.\n  It typically represents the name of the property in a bean or similar.",
      "@param map the map to print, may be <code>null</code>.\n  If <code>null</code>, the text 'null' is output",
      "@param lineage a stack consisting of any maps in which the previous\n  argument is contained. This is checked to avoid infinite recursion when\n  printing the output",
      "@param debug flag indicating whether type names should be output.",
      "@param out the stream to indent",
      "@return a new HashMap containing the inverted data",
      "@param key the key",
      "@return the input map",
      "@throws IllegalArgumentException if sub-array or entry matching used and an entry is invalid",
      "@throws ClassCastException if the array contents is mixed",
      "@param map the map, possibly <code>null</code>"
   ],
   [
      "@return an empty map if the argument is <code>null</code>",
      "@return a synchronized map backed by the given map",
      "@return an unmodifiable map backed by the given map",
      "@return a predicated map backed by the given map",
      "@return a transformed map backed by the given map",
      "@return a fixed-size map backed by that map",
      "@return a lazy map backed by the given map",
      "@return an ordered map backed by the given map",
      "@param map the map to decorate",
      "@return a multi-value map backed by the given map which returns ArrayLists of values.",
      "@param <C> the collection class type",
      "@param collectionClass the type of collections to return from the map\n  (must contain public no-arg constructor and extend Collection)",
      "@return a multi-value map backed by the given map which returns collections of the specified type",
      "@param collectionFactory a factor which creates collection objects",
      "@return a multi-value map backed by the given map which returns collections\n  created by the specified collection factory",
      "@param map the <code>Map</code> to populate.",
      "@param elements the <code>Iterable</code> containing the input values for the map.",
      "@param keyTransformer the <code>Transformer</code> used to transform the element into a key value",
      "@param <E> the type of object contained in the {@link Iterable}",
      "@param valueTransformer the <code>Transformer</code> used to transform the element into a value",
      "@param map the <code>MultiMap</code> to populate.",
      "@param elements the <code>Iterable</code> to use as input values for the map.",
      "@param map to wrap if necessary.",
      "@return IterableMap<K, V>",
      "@param sortedMap to wrap if necessary"
   ],
   [
      "@return {@link IterableSortedMap}<K, V>",
      "@param input the object to be transformed, should be left unchanged",
      "@throws FunctorException (runtime) if the transform cannot be completed",
      "@param <T> the object type",
      "@return the singleton instance",
      "@return <code>o.hashCode()</code> if <code>o</code> is non-\n        <code>null</code>, else {@link #HASHCODE_NULL}.",
      "@param <T> the input type",
      "@param input the input object to transform",
      "@param <I> input type for the transformer",
      "@param <O> output type for the transformer",
      "@param predicate predicate to switch on",
      "@param trueTransformer transformer used if true",
      "@param falseTransformer transformer used if false",
      "@return the <code>if</code> transformer",
      "@param <T> input and output type for the transformer",
      "@return the transformer",
      "@param <T> the type that the predicate queries",
      "@param object the object to compare to",
      "@param object the input object",
      "@return true if input is the same object as the stored value",
      "@param <E> the type that the closure acts on",
      "@param input the input object",
      "@param <T> the type of the object to transform",
      "@return the <code>closure</code> transformer",
      "@return the closure"
   ],
   [
      "@param predicates the predicates to copy",
      "@return the cloned predicates",
      "@param <T> the type of object the returned predicate should \"accept\"",
      "@param predicate the predicate to coerce.",
      "@return the coerced predicate.",
      "@param predicates the predicates to validate",
      "@return predicate array",
      "@param closures the closures to copy",
      "@return the cloned closures",
      "@param closures the closures to validate",
      "@param <T> the type of object the returned closure should \"accept\"",
      "@param closure the closure to coerce.",
      "@return the coerced closure.",
      "@param transformers the transformers to copy",
      "@return a clone of the transformers",
      "@param transformers the transformers to validate",
      "@param <T> the type of object the returned transformer should \"accept\"",
      "@param transformer the transformer to coerce.",
      "@return the coerced transformer.",
      "@param transformer the transformer to decorate",
      "@return true if decorated transformer returns Boolean.TRUE",
      "@throws FunctorException if the transformer returns an invalid type",
      "@return Transformer<I, O> that always returns null.",
      "@param input the input object which is ignored",
      "@return the stored constant"
   ],
   [
      "@return the constant",
      "@param constantToReturn the constant to return each time",
      "@return the <code>predicate</code> transformer",
      "@return the <code>while</code> closure",
      "@return true is do-while, false if while",
      "@param count the number of times to execute the closure",
      "@return the <code>for</code> closure",
      "@return the count",
      "@return true if decorated predicate returns true or input is null",
      "@return the predicate as the only element in an array",
      "@param predicate the predicate to call after the null check",
      "@param transformer the transformer to call",
      "@param predicate the predicate to call with the result of the transform",
      "@param object the input object which will be transformed",
      "@return true if decorated predicate returns true",
      "@param predicate the predicate to decorate",
      "@return the <code>any</code> predicate",
      "@return the <code>one</code> predicate",
      "@return true if none of decorated predicates return true",
      "@return never",
      "@param transformers matching array of transformers, cloned, no nulls",
      "@return the <code>chained</code> transformer",
      "@throws NullPointerException if any element in the array is null",
      "@param map a map of predicates to transformers",
      "@return the <code>switch</code> transformer"
   ],
   [
      "@throws NullPointerException if any transformer in the map is null",
      "@throws ClassCastException if the map elements are of the wrong type",
      "@return a copy of the predicates",
      "@return a copy of the transformers",
      "@return the default transformer",
      "@param clone if {@code true} the input arguments will be cloned",
      "@param predicates array of predicates, no nulls",
      "@param transformers matching array of transformers, no nulls",
      "@param defaultTransformer the transformer to use if no match, null means return null",
      "@param transformer the transformer to call, null means nop",
      "@return the <code>transformer</code> closure",
      "@return the <code>and</code> predicate",
      "@return true if either decorated predicate returns true",
      "@param <T> the input/output type",
      "@return the transformed result which is the input",
      "@param map the map, not cloned",
      "@return the map",
      "@param map the map to use for lookup, not cloned",
      "@param <T> the type the factory creates",
      "@param closures the closures to chain, copied, no nulls",
      "@return the <code>chained</code> closure",
      "@param closures a collection of closures to chain",
      "@throws NullPointerException if any closure in the collection is null",
      "@param input the input object passed to each closure",
      "@return a copy of the closures"
   ],
   [
      "@param clone if {@code true} the input argument will be cloned",
      "@param closures the closures to chain, no nulls",
      "@return true if both decorated predicates return true",
      "@return the predicates",
      "@return true if input is of stored type",
      "@return the type",
      "@param type the type to check for",
      "@param methodName the method name to call",
      "@return an invoker transformer",
      "@param paramTypes the parameter types of the method",
      "@param args the arguments to pass to the method",
      "@throws IllegalArgumentException if paramTypes does not match args",
      "@return the transformed result, null if null input",
      "@param methodName the method to call",
      "@param paramTypes the constructor parameter types",
      "@param args the constructor arguments",
      "@param <T> the type of the objects to be cloned",
      "@return true if predicate returns false",
      "@param <T> the type of the constant",
      "@return the stored constant value",
      "@param transformers the transformers to chain, copied, no nulls",
      "@param transformers a collection of transformers to chain",
      "@throws NullPointerException if any transformer in the collection is null",
      "@param object the input object passed to the first transformer",
      "@param transformers the transformers to chain, no nulls"
   ],
   [
      "@param comparator the comparator to use for comparison",
      "@param criterion the criterion to use to evaluate comparison",
      "@param target the target object to compare to",
      "@return {@code true} if the comparison succeeds according to the selected criterion",
      "@throws IllegalStateException if the criterion is invalid (really not possible)",
      "@throws FunctorException (runtime) if the closure execution resulted in a\n            checked exception.",
      "@throws Throwable if the closure execution resulted in a checked\n            exception.",
      "@return the <code>all</code> predicate",
      "@return true if all decorated predicates return true",
      "@return true if decorated predicate returns true, false if input is null",
      "@return true if any decorated predicate return true",
      "@return the <code>factory</code> transformer",
      "@param object the object to evaluate",
      "@return true if not null",
      "@param defaultClosure the closure to use if no match, null means nop",
      "@throws IllegalArgumentException if the array lengths of predicates and closures do not match",
      "@param predicatesAndClosures a map of predicates to closures",
      "@return the <code>switch</code> closure",
      "@return the default closure",
      "@param closures matching array of closures, no nulls",
      "@return true if this is the first time the object is seen",
      "@param <T> the type of the objects to be created",
      "@return Transformer<Class<? extends T>, T>",
      "@return an instantiate transformer",
      "@return true if only one decorated predicate returns true"
   ],
   [
      "@param equator the equator to use for comparison",
      "@return true if input object equals stored value",
      "@param paramTypes the constructor parameter types, cloned",
      "@param args the constructor arguments, cloned",
      "@return a new instantiate factory",
      "@return the new object",
      "@param classToInstantiate the class to instantiate",
      "@param trueClosure closure used if true",
      "@return the <code>if</code> closure",
      "@param falseClosure closure used if false",
      "@return <code>true</code> if the iterator has a previous element",
      "@return the previous element in the iteration",
      "@throws java.util.NoSuchElementException if the iteration is finished",
      "@param comparator Comparator with the forward sort order",
      "@param comparator Comparator to add to the end of the chain",
      "@param index index of the Comparator to replace",
      "@param comparator Comparator to place at the given index",
      "@throws IndexOutOfBoundsException if index &lt; 0 or index &gt;= size()",
      "@param comparator Comparator to set",
      "@param index Index of the ComparatorChain",
      "@return Comparator count",
      "@return true = ComparatorChain cannot be modified; false =\n        ComparatorChain can still be modified.",
      "@throws UnsupportedOperationException if the {@link ComparatorChain} is locked",
      "@throws UnsupportedOperationException if the {@link ComparatorChain} is empty",
      "@return -1, 0, or 1"
   ],
   [
      "@throws UnsupportedOperationException if the ComparatorChain does not contain at least one Comparator",
      "@return a suitable hash code",
      "@param object the object to compare with",
      "@param comparator First comparator in the Comparator chain",
      "@param comparator First Comparator in the ComparatorChain",
      "@param list List of Comparators",
      "@param list List of Comparators.  NOTE: This constructor does not perform a\n              defensive copy of the list",
      "@param bits Sort order for each Comparator.  Extra bits are ignored,\n              unless extra Comparators are added by another method.",
      "@return the true first singleton BooleanComparator",
      "@return the false first singleton BooleanComparator",
      "@param trueFirst when <code>true</code>, sort\n<code>true</code> <code>Boolean</code>s before <code>false</code>",
      "@return a singleton BooleanComparator instance",
      "@param b1 the first boolean to compare",
      "@param b2 the second boolean to compare",
      "@return negative if obj1 is less, positive if greater, zero if equal",
      "@throws NullPointerException when either argument <code>null</code>",
      "@return a hash code for this comparator.",
      "@return the trueFirst flag",
      "@param trueFirst when <code>true</code>, sort\n <code>true</code> boolean values before <code>false</code>",
      "@param obj1 the first object to compare",
      "@param obj2 the second object to compare",
      "@param comparator Comparator to reverse",
      "@return the singleton ComparableComparator",
      "@throws ClassCastException if <i>obj1</i> is not a <code>Comparable</code>,\n        or when <code>((Comparable)obj1).compareTo(obj2)</code> does",
      "@return {@code true} if equal"
   ],
   [
      "@param obj1 the first object to transform then compare",
      "@param obj2 the second object to transform then compare",
      "@param transformer what will transform the arguments to <code>compare</code>",
      "@param decorated the decorated Comparator",
      "@return true if attempts to change the FixedOrderComparator yield an\n UnsupportedOperationException, false if it can be changed.",
      "@return {@link UnknownObjectBehavior}",
      "@param unknownObjectBehavior the flag for unknown behaviour -\nUNKNOWN_AFTER, UNKNOWN_BEFORE or UNKNOWN_THROW_EXCEPTION",
      "@param obj the item to be added to the Comparator.",
      "@return true if obj has been added for the first time, false if\n it was already known to the Comparator.",
      "@param existingObj an item already in the Comparator's set of\n known objects",
      "@param newObj an item to be added to the Comparator's set of\n known objects",
      "@return true if newObj has been added for the first time, false if\n it was already known to the Comparator.",
      "@throws IllegalArgumentException if existingObject is not in the\n Comparator's set of known objects.",
      "@throws IllegalArgumentException if obj1 or obj2 are not known\n to this Comparator and an alternative behavior has not been set\n via {@link #setUnknownObjectBehavior(UnknownObjectBehavior)}.",
      "@param items the items that the comparator can compare in order",
      "@param o2 the object to compare it to.",
      "@return <code>-1</code> if <code>o1</code> is \"lower\" than (less than,\n before, etc.) <code>o2</code>; <code>1</code> if <code>o1</code> is\n \"higher\" than (greater than, after, etc.) <code>o2</code>; or\n <code>0</code> if <code>o1</code> and <code>o2</code> are equal.",
      "@param obj the object to compare this comparator with.",
      "@return <code>true</code> if the specified object is a NullComparator\n with equivalent <code>null</code> comparison behavior\n (i.e. <code>null</code> high or low) and with equivalent underlying\n non-<code>null</code> object comparators.",
      "@param nullsAreHigh a <code>true</code> value indicates that\n <code>null</code> should be compared as higher than a\n non-<code>null</code> object.  A <code>false</code> value indicates\n that <code>null</code> should be compared as lower than a\n non-<code>null</code> object.",
      "@param collection the collection, possibly <code>null</code>",
      "@param <O> the generic type that is able to represent the types contained\n       in both input collections.",
      "@return the union of the two collections",
      "@return the intersection of the two collections",
      "@return the symmetric difference of the two collections"
   ],
   [
      "@return a new collection with the results",
      "@param p the condition used to determine which elements of <i>b</i> are\n       subtracted.",
      "@return <code>true</code> iff the intersection of the collections has the same cardinality\n  as the set of unique elements from the second collection",
      "@return <code>true</code> iff the intersection of the collections is non-empty",
      "@param <O> the type of object in the returned {@link Map}. This is a super type of <I>.",
      "@return the populated cardinality map",
      "@return <code>true</code> iff <i>a</i> is a sub-collection of <i>b</i>",
      "@return <code>true</code> iff the collections contain the same elements with the same cardinalities.",
      "@param equator the Equator used for testing equality",
      "@param obj the object to find the cardinality of",
      "@param coll the {@link Iterable} to search",
      "@param <O> the type of object that the {@link Iterable} may contain.",
      "@return the the number of occurrences of obj in coll",
      "@param <T> the type of object the {@link Iterable} contains",
      "@param collection the collection to search, may be null",
      "@return the first element of the collection which matches the predicate or null if none could be found",
      "@param <C> the closure type",
      "@param collection the collection to get the input from, may be null",
      "@param closure the closure to perform, may be null",
      "@param <T> the type of object the {@link Iterator} contains",
      "@param <T> the type of object the {@link Collection} contains",
      "@param predicate the predicate to use as a filter, may be null",
      "@return true if the collection is modified by this call, false otherwise.",
      "@param <C> the type of object the {@link Collection} contains",
      "@param collection the {@link Collection} to get the input from, may be null"
   ],
   [
      "@param transformer the transformer to perform, may be null",
      "@param <C> the type of object the {@link Iterable} contains",
      "@param input the {@link Iterable} to get the input from, may be null",
      "@return the number of matches for the predicate in the collection",
      "@return true if at least one element of the collection matches the predicate",
      "@return true if every element of the collection matches the predicate or if the\ncollection is empty, false otherwise",
      "@param <O> the type of object the {@link Iterable} contains",
      "@param <R> the type of the output {@link Collection}",
      "@param inputCollection the collection to get the input from, may be null",
      "@return outputCollection",
      "@param <I> the type of object in the input collection",
      "@param <O> the type of object in the output collection",
      "@param transformer the transformer to use, may be null",
      "@return the transformed result (new list)",
      "@param inputIterator the iterator to get the input from, may be null",
      "@param <R> the type of the output collection",
      "@return the output collection with the transformed input added",
      "@throws NullPointerException if either iterable or predicate is null",
      "@param iterable the iterable to filter, may not be null",
      "@param predicate the predicate used to filter elements, may not be null",
      "@param iterable the iterable to limit, may not be null",
      "@param maxSize the maximum number of elements, must not be negative",
      "@param iterable the iterable to loop, may not be null",
      "@param iterable the iterable to use, may not be null",
      "@param elementsToSkip the number of elements to skip from the start, must not be negative"
   ],
   [
      "@throws NullPointerException if either iterable or transformer is null",
      "@param iterable the iterable to transform, may not be null",
      "@param transformer the transformer, must not be null",
      "@param first the first iterable, may not be null",
      "@param others the array of iterables to interleave, may not be null",
      "@param closure the closure to perform, may not be null",
      "@return the last element in the iterable, or null if iterable is null or empty",
      "@return true if the iterable is null or empty, false otherwise",
      "@throws NullPointerException if equator is null",
      "@param equator the equator to use to check, may not be null",
      "@throws NullPointerException if any predicate is null",
      "@param predicates the predicates to use, may not be null",
      "@throws NullPointerException if {@code transformer} is null",
      "@throws NullPointerException if either transformer, delimiter, prefix or suffix is null",
      "@throws NullPointerException if the argument or any of its contents is null",
      "@throws NullPointerException if the specified key is null and this map\n  does not permit null keys (optional)",
      "@throws NullPointerException if the value is null and null values are not supported\n  by the used collection types (optional)",
      "@throws NullPointerException if the key is null and null keys are invalid (optional)",
      "@throws NullPointerException if the specified iterable is null, or if this map\n  does not permit null keys or values, and the specified key or values contain\n  null (optional)",
      "@param values the values to add to the collection at the key, may not be null",
      "@throws NullPointerException if the specified map is null, or if this map\n  does not permit null keys or values, and the specified map\n  contains null keys or values (optional)",
      "@param map mappings to be stored in this map, may not be null",
      "@return the values that were removed",
      "@throws IllegalArgumentException if count is negative",
      "@throws IllegalArgumentException if occurrences is negative"
   ],
   [
      "@throws NullPointerException if the array is null",
      "@throws UnsupportedOperationException if the comparator is locked",
      "@throws NullPointerException if unknownObjectBehavior is null",
      "@throws UnsupportedOperationException if a comparison has been performed",
      "@throws UnsupportedOperationException if a comparison has already been made",
      "@param keyTransformer the predicate to validate the keys, null means no transformation",
      "@param valueTransformer the predicate to validate to values, null means no transformation",
      "@param entry the <code>Map.Entry</code> to decorate, must not be null",
      "@return the outputCollection with the transformed input added",
      "@param object the object to add, if null it will not be added",
      "@return true if the collection changed",
      "@return a boolean indicating whether the collection has changed or not.",
      "@return {@code true} if the collections was changed, {@code false} otherwise",
      "@return {@code true} if the collection was changed, {@code false} otherwise",
      "@param <T> the type of object in the {@link Iterator}",
      "@throws IllegalArgumentException if the object type is invalid",
      "@param index the index to check.",
      "@param iterable the {@link Iterable} to get a value from",
      "@param <T> the type of object in the {@link Iterable}.",
      "@param object the object to get a value from",
      "@param <K> the key type in the {@link Map}",
      "@param <V> the key type in the {@link Map}",
      "@param map the object to get a value from",
      "@param object the object to get the size of, may be null",
      "@throws IllegalArgumentException thrown if object is not recognised"
   ],
   [
      "@param coll the collection to check, may be null",
      "@param array the array to reverse",
      "@param coll the collection to check",
      "@return true if the BoundedCollection is full",
      "@return the maximum size of the BoundedCollection, -1 if no maximum size",
      "@param <O> the element type",
      "@return a new sorted List, containing the elements of Collection a and b",
      "@param includeDuplicates if {@code true} duplicate elements will be retained, otherwise\n  they will be removed in the output collection",
      "@param c the comparator to use for the merge.",
      "@return an unordered collection of all permutations of the input collection",
      "@return a <code>Collection</code> containing all the elements of <code>collection</code>\nthat occur at least once in <code>retain</code>.",
      "@param <E> the type of object the {@link Collection} contains",
      "@param collection the collection whose contents are the target of the {@code retainAll} operation",
      "@return a <code>Collection</code> containing all the elements of <code>collection</code>\nthat occur at least once in <code>retain</code> according to the <code>equator</code>",
      "@return a <code>Collection</code> containing all the elements of <code>collection</code> except\nany elements that also occur in <code>remove</code>.",
      "@param remove the items to be removed from the returned collection",
      "@return a <code>Collection</code> containing all the elements of <code>collection</code>\nexcept any element that if equal according to the <code>equator</code>",
      "@return a synchronized collection backed by the given collection",
      "@return an unmodifiable collection backed by the given collection",
      "@param <C> the type of objects in the Collection.",
      "@return a predicated collection backed by the given collection",
      "@return a transformed collection backed by the given collection",
      "@param <E> collection type",
      "@param collection to read",
      "@return sole member of collection"
   ],
   [
      "@param key the key to retrieve",
      "@return the {@code List} of values, implementations should return an\n  empty {@code List} for no mapping",
      "@param key the key to remove values from",
      "@return the {@code List} of values removed, implementations\n  typically return an empty, unmodifiable {@code List} for no mapping found",
      "@throws UnsupportedOperationException if the map is unmodifiable",
      "@return MapIterator<K, V>",
      "@param <J> the input key type",
      "@param <K> the output key type",
      "@param <U> the input value type",
      "@param <V> the output value type",
      "@return a new transformed map",
      "@param out the output stream",
      "@param in the input stream",
      "@param map the map to transform",
      "@param value the value to transform",
      "@return the transformed value",
      "@return a new object",
      "@throws FunctorException (runtime) if the factory cannot create an object",
      "@return an empty iterable",
      "@return a new iterable, combining the provided iterables",
      "@return a filtered view on the specified iterable",
      "@param comparator the comparator defining an ordering over the elements,\n  may be null, in which case natural ordering will be used",
      "@return a bounded view on the specified iterable",
      "@return a view of the iterable, providing an infinite loop over its elements",
      "@return a reversed view of the specified iterable"
   ],
   [
      "@return a view of the specified iterable, skipping the first N elements",
      "@param <I> the input element type",
      "@param <O> the output element type",
      "@return a transformed view of the specified iterable",
      "@return a unique view of the specified iterable",
      "@return an unmodifiable view of the specified iterable",
      "@return a new iterable, interleaving the provided iterables",
      "@param iterable the iterable, may be null",
      "@return an empty iterable if the argument is null",
      "@param iterable the iterator to use, may be null",
      "@param <E> the type of object the {@link Iterable} contains",
      "@param iterable the iterable to get the input from, may be null",
      "@param iterable the iterable to search, may be null",
      "@return the first element of the iterable which matches the predicate or null if none could be found",
      "@param iterable the {@link Iterable} to use, may be null",
      "@param iterable the {@link Iterable to use}, may be null",
      "@param iterable the iterable to check, may be null",
      "@return true if the object is contained in the iterable, false otherwise",
      "@param <E> the element type that the {@link Iterable} may contain",
      "@param <T> the element type of the object to find",
      "@param iterable the {@link Iterable} to search",
      "@return the the number of occurrences of obj in iterable",
      "@param iterable the {@link Iterable} to get a value from, may be null",
      "@return the number of elements contained in the iterable",
      "@param iterable the iterable to partition, may be null"
   ],
   [
      "@return a list containing the output collections",
      "@param iterable the collection to get the input from, may be null",
      "@param partitionFactory the factory used to create the output collections",
      "@param iterable the iterable to use, may be null",
      "@param iterable the iterable to convert to a string, may be null",
      "@return a string representation of {@code iterable}",
      "@param iterable the iterable to check",
      "@param iterable the iterable, possibly <code>null</code>",
      "@return an empty iterator if the argument is <code>null</code>",
      "@return <code>true</code> if the object was not already in the <code>uniqueSet</code>",
      "@param nCopies the number of copies to add",
      "@param nCopies the number of copies to remove",
      "@return the Set of unique Bag elements",
      "@return the total size of the Bag",
      "@return <code>true</code> if the Bag contains all the collection",
      "@param coll the collection to retain",
      "@return iterator over all elements in the Bag",
      "@param object the object to evaluate, should not be changed",
      "@return true or false",
      "@throws FunctorException (runtime) if the predicate encounters a problem",
      "@return the comparator in use, or null if natural ordering",
      "@return the first element in the sorted bag",
      "@return the last element in the sorted bag",
      "@return an unmodifiable trie backed by the given trie",
      "@param transformer the transformer to run each time in the closure, null means nop"
   ],
   [
      "@param count the number of times to loop",
      "@param closure the closure to call repeatedly",
      "@return the <code>do-while</code> closure",
      "@param methodName the name of the method",
      "@return the <code>invoker</code> closure",
      "@param paramTypes the parameter types",
      "@param args the arguments",
      "@param closures an array of closures to chain",
      "@param predicate the validating predicate",
      "@param trueClosure the closure called if the predicate is true",
      "@param predicate the predicate to switch on",
      "@param falseClosure the closure called if the predicate is false",
      "@param defaultClosure the default to call if no predicate matches",
      "@param objectsAndClosures a map of objects to closures",
      "@return a new unmodifiable trie",
      "@return the number of bits per element",
      "@return the bit length of the key",
      "@param bitIndex the bit index to check",
      "@param lengthInBits the maximum key length in bits to check",
      "@return {@code true} if the bit is set in the given key and\n  {@code bitIndex} &lt; {@code lengthInBits}, {@code false} otherwise.",
      "@param key the key to use",
      "@param offsetInBits the bit offset in the key",
      "@param lengthInBits the maximum key length in bits to use",
      "@param other the other key to use",
      "@param otherOffsetInBits the bit offset in the other key"
   ],
   [
      "@param otherLengthInBits the maximum key length in bits for the other key",
      "@return the bit index where the key and other first differ",
      "@param prefix the prefix to check",
      "@param key the key to check",
      "@return {@code true} if this is a valid prefix for the given key",
      "@param key the key to use in the search",
      "@return the {@link Entry} whose key is closest in a bitwise XOR metric\n  to the provided key",
      "@return the key that is closest in a bitwise XOR metric to the provided key",
      "@return the value whose key is closest in a bitwise XOR metric\nto the provided key",
      "@throws ClassCastException if provided key is of an incompatible type",
      "@param offsetInBits the prefix offset",
      "@param lengthInBits the number of significant prefix bits",
      "@return a {@link SortedMap} view of this {@link Trie} with all elements whose\n  key is prefixed by the search key",
      "@param start the start entry",
      "@return the {@link KeyAnalyzer} used by this {@link Trie}",
      "@param keyAnalyzer the {@link KeyAnalyzer} to use",
      "@return a new transformed sorted map",
      "@param value the value to search for",
      "@return true if the map contains the value",
      "@return the eldest key",
      "@return the most recently inserted key",
      "@param key the key to get after",
      "@return the next key",
      "@param key the key to get before",
      "@return the previous key"
   ],
   [
      "@param index the index to retrieve",
      "@return the key at the specified index",
      "@param entry the entry to add",
      "@param hashIndex the index into the data array to store at",
      "@param next the next entry in sequence",
      "@param hashCode the hash code to use",
      "@return the newly created entry",
      "@param entry the entry to remove",
      "@param hashIndex the index into the data structure",
      "@param previous the previous entry in the chain",
      "@param entry the entry to query, must not be null",
      "@return the <code>before</code> field of the entry",
      "@return the <code>after</code> field of the entry",
      "@param initialCapacity the initial capacity, must be a power of two",
      "@param threshold the threshold, must be sensible",
      "@param initialCapacity the initial capacity",
      "@param loadFactor the load factor",
      "@return the mapped value, null if no match",
      "@return the size",
      "@return true if the map is currently size zero",
      "@param key the key to search for",
      "@param key the key to add",
      "@param value the value to add",
      "@return the value previously mapped to this key, null if none",
      "@param map the map to add"
   ],
   [
      "@return a new AbstractHashedMap or subclass",
      "@param key the mapping to remove",
      "@return the value mapped to the removed key, null if key not in map",
      "@return the map iterator",
      "@return a shallow clone",
      "@return the hash code defined in the Map interface",
      "@return a string version of the map",
      "@return a new predicated map",
      "@param key the key to validate",
      "@param value the value to validate",
      "@throws IllegalArgumentException if invalid",
      "@return true if a value predicate is in use",
      "@return a new fixed size sorted map",
      "@return a new unmodifiable sorted map",
      "@return a new predicated sorted map",
      "@param defaultValue the default value to return when the key is not found",
      "@return a new defaulting map",
      "@param defaultValueTransformer transformer to use to generate missing values.",
      "@param defaultValueTransformer the value transformer to use",
      "@param key the key to get a hash code for",
      "@param key the key to get a hash code for, may be null",
      "@param value the value to get a hash code for, may be null",
      "@return the hash code, as per the MapEntry specification",
      "@param key1 the first key to compare passed in from outside",
      "@param key2 the second key extracted from the entry via <code>entry.key</code>"
   ],
   [
      "@return true if equal by identity",
      "@param value1 the first value to compare passed in from outside",
      "@param value2 the second value extracted from the entry via <code>getValue()</code>",
      "@param keyType the type of reference to use for keys;\n  must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}",
      "@param valueType the type of reference to use for values;\n  must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}",
      "@param purgeValues should the value be automatically purged when the\n  key is garbage collected",
      "@param capacity the initial capacity for the map",
      "@param loadFactor the load factor for the map",
      "@param value the value to check",
      "@throws UnsupportedOperationException if the map may not be changed by setValue",
      "@throws IllegalArgumentException if the specified value is invalid",
      "@throws ClassCastException if the class of the specified value is invalid",
      "@return a new fixed size map",
      "@return a new lazy sorted map",
      "@return a new ordered map",
      "@param key the key convert",
      "@return the converted key",
      "@param dataSize the size of the data to pick a bucket from",
      "@return the bucket index",
      "@return the entry, null if no match",
      "@param entry the entry to update",
      "@param newValue the new value to store",
      "@param entry the entry to update, not null",
      "@param hashIndex the index in the data array",
      "@param hashCode the hash code of the key to add"
   ],
   [
      "@param entry the entry to destroy",
      "@param newCapacity the new capacity of the array (a power of two, less or equal to max)",
      "@param proposedCapacity the proposed capacity",
      "@return the normalized new capacity",
      "@param newCapacity the new capacity",
      "@param factor the load factor",
      "@return the new resize threshold",
      "@return the <code>next</code> field of the entry",
      "@return the <code>hashCode</code> field of the entry",
      "@return the <code>key</code> field of the entry",
      "@return the <code>value</code> field of the entry",
      "@throws IOException if an error occurs while writing tothe stream",
      "@throws IOException if an error occurs while reading from the stream",
      "@throws ClassNotFoundException if an object read from the stream can not be loaded",
      "@throws InternalError if {@link AbstractMap#clone()} failed",
      "@return a new unmodifiable map",
      "@return Map.Entry<K, V>",
      "@param entrySet the entrySet to adapt",
      "@return a new list ordered map",
      "@return the first key currently in this map",
      "@return the last key currently in this map",
      "@param key the key to find previous for",
      "@return the next key, null if no match or at start",
      "@param index the index in the Map to start at.",
      "@param map the Map containing the entries to be added."
   ],
   [
      "@throws IndexOutOfBoundsException if the index is out of range [0, size]",
      "@return the fully modifiable collection view over the keys",
      "@return the unmodifiable list view over the keys",
      "@return the fully modifiable collection view over the values",
      "@return the partially modifiable list view over the values",
      "@return the fully modifiable set view over the entries",
      "@return the Map as a String",
      "@param key the key to find the index of",
      "@return the index, or -1 if not found",
      "@param index the index of the value to set",
      "@param value the new value to set",
      "@return the previous value at that index",
      "@param index the index at which the mapping should be inserted",
      "@param value the value",
      "@param index the index of the object to remove",
      "@return the removed value, or <code>null</code> if none existed",
      "@return The ordered list of keys.",
      "@return the value at the specified index",
      "@return the previous value corresponding the <code>key</code>,\n or <code>null</code> if none existed",
      "@return the old value",
      "@return 1 always",
      "@return the size of 1",
      "@param key the key to set, must be the key of the map",
      "@param value the value to set",
      "@throws IllegalArgumentException if the key does not match"
   ],
   [
      "@param map the map to add, must be size 0 or 1, and the key must match",
      "@param key the next key",
      "@return null always",
      "@param key the key to compare",
      "@param value the value to compare",
      "@param value the value to use",
      "@param keyValue the key value pair to use",
      "@param mapEntry the mapEntry to use",
      "@param map the map to copy, must be size 1",
      "@throws IllegalArgumentException if the size is not 1",
      "@return a new unmodifiable entry set",
      "@return the current size",
      "@return true if empty",
      "@return the associated value",
      "@return true if found",
      "@return the previous mapping for the key",
      "@param key the key to remove",
      "@return the previous value at this key",
      "@return the key set",
      "@return the values",
      "@return the entry set",
      "@param map the map of entries to add",
      "@param r the code to execute atomically",
      "@param numBuckets the number of buckets for this map",
      "@return a set view of this map's entries"
   ],
   [
      "@return a set view of this map's keys",
      "@return a set view of this map's values",
      "@param ref the reference to purge",
      "@throws IOException if an error occurs while writing to the stream",
      "@param type the type to check against.",
      "@return true if keyType has the specified type",
      "@param keyType the type of reference to use for keys;\n  must be {@link ReferenceStrength#HARD HARD},\n  {@link ReferenceStrength#SOFT SOFT},\n  {@link ReferenceStrength#WEAK WEAK}",
      "@param valueType the type of reference to use for values;\n  must be {@link ReferenceStrength#HARD},\n  {@link ReferenceStrength#SOFT SOFT},\n  {@link ReferenceStrength#WEAK WEAK}",
      "@return a new multi key map",
      "@param key1 the first key",
      "@param key2 the second key",
      "@return the value previously mapped to this combined key, null if none",
      "@param entry the entry to compare to",
      "@return true if the key matches",
      "@param key3 the third key",
      "@param key4 the fourth key",
      "@param key5 the fifth key",
      "@return true if any elements were removed",
      "@throws ClassCastException if the key is not a MultiKey",
      "@param mapToCopy to this map",
      "@throws ClassCastException if any key in mapToCopy is not a MultiKey",
      "@return a new lazy map",
      "@param timeToLive the constant amount of time an entry is available\n       before it expires. A negative value results in entries that NEVER\n       expire. A zero value results in entries that ALWAYS expire.",
      "@param now the time in milliseconds used to compare against the\n       expiration time.",
      "@param expirationTimeObject the expiration time value retrieved from\n       {@link #expirationMap}, can be null."
   ],
   [
      "@return <code>true</code> if <code>expirationTimeObject</code> is &ge; 0\n        and <code>expirationTimeObject</code> &lt; <code>now</code>.\n        <code>false</code> otherwise.",
      "@param expiringPolicy the policy used to determine expiration times of\n       entries as they are added.",
      "@param timeToLiveMillis the constant amount of time (in milliseconds) an\n       entry is available before it expires. A negative value results in\n       entries that NEVER expire. A zero value results in entries that\n       ALWAYS expire.",
      "@param map the map to wrap",
      "@return a new multi-value map",
      "@param collectionClass the type of the collection class",
      "@param map the MultiValuedMap to decorate, may not be null",
      "@return the {@code Set} of values removed, implementations should\n  return null for no mapping found, but may return an empty collection",
      "@throws IllegalArgumentException if either offset or max is negative",
      "@throws IndexOutOfBoundsException if start is less than zero or greater\n  than the length of the array",
      "@throws IllegalArgumentException if end is before start",
      "@throws IllegalArgumentException if the array is not an array or end is before start",
      "@throws IndexOutOfBoundsException if start is less than zero",
      "@throws IllegalArgumentException if max is negative",
      "@param iterator1 the first iterator to use, not null",
      "@param iterator2 the second iterator to use, not null",
      "@throws NullPointerException if iterators array is null or contains a null",
      "@param iterators the iterators to use, not null or empty or contain nulls",
      "@throws NullPointerException if iterators collection is null or contains a null",
      "@param iterator1 the first iterators to use, not null",
      "@param iterator2 the first iterators to use, not null",
      "@throws NullPointerException if iterators array is null or contains a null value",
      "@param transformer the transformer to use, see above, null uses no effect transformer",
      "@param iterator the iterator to use, not null",
      "@param transform the transform to use, not null"
   ],
   [
      "@param predicate the predicate to use as a filter, not null",
      "@param listIterator the list iterator to use, not null",
      "@param coll the collection to iterate over, not null",
      "@param list the list to iterate over, not null",
      "@param nodeList the node list to use, may not be null",
      "@param node the node to use, may not be null",
      "@param iterator the iterator to decorate, not null",
      "@param collectionFactory the collection factory (must return a Collection object).",
      "@param key the key to remove from",
      "@param value the value to remove",
      "@return {@code true} if the mapping was removed, {@code false} otherwise",
      "@param key the key to store against",
      "@param value the value to add to the collection at the key",
      "@return the value added if the map changed and null if the map did not change",
      "@param map the map to copy (either a normal or multi map)",
      "@return a collection view of the values contained in this map",
      "@return the collection mapped to the key, null if no mapping",
      "@param key the key to get size for",
      "@return the size of the collection at the key, zero if key not in map",
      "@return true if this map changed",
      "@param key the key to get an iterator for",
      "@return the iterator of the collection at the key, empty iterator if key not in map",
      "@return the iterator of all mappings in this map",
      "@return the total size of the map counting all values",
      "@param size the collection size that is about to be added"
   ],
   [
      "@return the new collection",
      "@param collectionFactory the collection factory which must return a Collection instance",
      "@param updateToMRU whether the key shall be updated to the\n  most recently used position",
      "@param entry the entry to reuse",
      "@param entry the entry to be removed",
      "@return <code>true</code> if the map is full",
      "@return the maximum number of elements the map can hold",
      "@return true if this map scans",
      "@param maxSize the maximum size of the map",
      "@param initialSize the initial size of the map",
      "@param scanUntilRemovable scan until a removeable entry is found, default false",
      "@return true if a value transformer is in use",
      "@param mutator the MapMutator to be used for mutation delegation",
      "@param map the Map to be added to the composite",
      "@throws IllegalArgumentException if there is a key collision and there is no\n        MapMutator set to handle it.",
      "@param map the Map to be removed from the composite",
      "@return The removed Map or <code>null</code> if map is not in the composite",
      "@throws UnsupportedOperationException if any of the composited Maps do not support clear()",
      "@param key key whose presence in this map is to be tested.",
      "@return {@code true} if this map contains a mapping for the specified\n        key.",
      "@throws ClassCastException if the key is of an inappropriate type for\n        this map (optional).",
      "@param value value whose presence in this map is to be tested.",
      "@return {@code true} if this map maps one or more keys to the\n        specified value.",
      "@throws ClassCastException if the value is of an inappropriate type for\n        this map (optional).",
      "@return a set view of the mappings contained in this map."
   ],
   [
      "@param key key whose associated value is to be returned.",
      "@return {@code true} if this map contains no key-value mappings.",
      "@param key key with which the specified value is to be associated.",
      "@param value value to be associated with the specified key.",
      "@return previous value associated with specified key, or {@code null}\n        if there was no mapping for key.  A {@code null} return can\n        also indicate that the map previously associated {@code null}\n        with the specified key, if the implementation supports\n        {@code null} values.",
      "@throws UnsupportedOperationException if no MapMutator has been specified",
      "@throws ClassCastException if the class of the specified key or value\n           prevents it from being stored in this map.",
      "@throws IllegalArgumentException if some aspect of this key or value\n           prevents it from being stored in this map.",
      "@throws NullPointerException this map does not permit {@code null}\n           keys or values, and the specified key or value is\n           {@code null}.",
      "@param map Mappings to be stored in this map.",
      "@throws UnsupportedOperationException if the {@code putAll} method is\n        not supported by this map.",
      "@throws ClassCastException if the class of a key or value in the\n        specified map prevents it from being stored in this map.",
      "@throws IllegalArgumentException some aspect of a key or value in the\n        specified map prevents it from being stored in this map.",
      "@return previous value associated with specified key, or {@code null}\n        if there was no mapping for key.",
      "@throws ClassCastException if the key is of an inappropriate type for\n        the composited map (optional).",
      "@throws UnsupportedOperationException if the {@code remove} method is\n        not supported by the composited map containing the key",
      "@return the number of key-value mappings in this map.",
      "@return a collection view of the values contained in this map.",
      "@return true if the maps are equal",
      "@param one the first Map to be composited",
      "@param two the second Map to be composited",
      "@throws IllegalArgumentException if there is a key collision",
      "@param mutator MapMutator to be used for mutation operations",
      "@param composite the Maps to be composited",
      "@param composite Maps to be composited"
   ],
   [
      "@param value the new value",
      "@return the previous value",
      "@param key the key for the entry, may be null",
      "@param value the value for the entry, may be null",
      "@return the individual keys",
      "@return the key at the index",
      "@return the size of the list of keys",
      "@param other the other object to compare to",
      "@return a debugging string",
      "@param keys the keys to calculate the hash code for",
      "@return the instance with recalculated hash code",
      "@param key the new key",
      "@return the old key",
      "@throws IllegalArgumentException if key is this object",
      "@return the old value of the value",
      "@throws IllegalArgumentException if value is this object",
      "@return a MapEntry instance",
      "@return true if equal key and value",
      "@return a String view of the entry",
      "@throws IllegalArgumentException if the value is set to this map entry",
      "@return entry as a string",
      "@param map the map",
      "@return a synchronized multiset backed by that multiset",
      "@return an unmodifiable view of that multiset",
      "@return a predicated multiset backed by the given multiset"
   ],
   [
      "@return <code>true</code> if the iterator has more elements",
      "@return the next key in the iteration",
      "@return the current key",
      "@throws IllegalStateException if <code>next()</code> has not yet been called",
      "@return the current value",
      "@throws UnsupportedOperationException if remove is not supported by the map",
      "@throws IllegalStateException if <code>remove()</code> has already been called\n since the last call to <code>next()</code>",
      "@throws UnsupportedOperationException if setValue is not supported by the map",
      "@throws IllegalStateException if <code>remove()</code> has been called since the\n last call to <code>next()</code>",
      "@return the wrapped map",
      "@return the {@code Collection} of values, will return an empty {@code Collection} for no mapping",
      "@return the <code>Collection</code> of values removed, will return an\n  empty, unmodifiable collection for no mapping found",
      "@return true if the mapping was removed, false otherwise",
      "@return true if the map changed as a result of this operation",
      "@return a bag view of the key mapping contained in this map",
      "@throws IOException any of the usual I/O related exceptions",
      "@throws ClassNotFoundException if the stream contains an object which class can not be loaded",
      "@throws ClassCastException if the stream does not contain the correct objects",
      "@param <K> the type of key elements",
      "@param <V> the type of value elements",
      "@return an unmodifiable MultiValuedMap",
      "@param initialSetCapacity the initial capacity used for value collections",
      "@param initialMapCapacity the initial hashmap capacity",
      "@param map a <code>MultiValuedMap</code> to copy into this map",
      "@param map a <code>Map</code> to copy into this map"
   ],
   [
      "@return a new transformed MultiValuedMap",
      "@return a new list",
      "@return the <code>Set</code> of values, will return an empty\n  <code>Set</code> for no mapping",
      "@return the <code>Set</code> of values removed, will return an empty,\n  unmodifiable set for no mapping found.",
      "@return the {@code List} of values, will return an empty {@link List} for no mapping",
      "@return the <code>List</code> of values removed, will return an empty,\n  unmodifiable list for no mapping found.",
      "@param initialListCapacity the initial capacity used for value collections",
      "@return the map to decorate",
      "@param <E> the type of the elements in the list",
      "@return a new lazy list",
      "@return the element at the given index",
      "@return the element at the specified index",
      "@return an iterator over the list",
      "@return the new iterator",
      "@param fromIndex the index to start from",
      "@param object the object to search",
      "@return the index of the object, -1 if not found",
      "@return true if the object is found",
      "@return the list as an array",
      "@param index the index to add before",
      "@param obj the element to add",
      "@param c the collection to be added to this list",
      "@return {@code true} if this list changed as a result of the call",
      "@throws NullPointerException {@inheritDoc}",
      "@param index the index to set"
   ],
   [
      "@param obj the object to store at the specified index",
      "@return the previous object at that index",
      "@param index the index to remove",
      "@param index the index to check",
      "@param startIndex the first allowed index",
      "@param endIndex the last allowed index",
      "@param coll the collection to copy",
      "@return a new {@link SetUniqueList}",
      "@return an unmodifiable set view",
      "@return true if object was added",
      "@param index the index to insert at",
      "@param coll the collection to add in iterator order",
      "@return true if this collection changed",
      "@param object the object to set",
      "@return the previous object",
      "@param list the {@link List} to populate the {@link Set}",
      "@return a new {@link Set} populated with all elements of the provided\n  {@link List}",
      "@return the decorated list",
      "@return the maximum cache size",
      "@param maximumCacheSize the new maximum cache size",
      "@return a node, or <code>null</code> if there are no nodes in the cache.",
      "@return true if the cache is full",
      "@param node the node to add to the cache",
      "@param value value of the new node",
      "@return the newly created node"
   ],
   [
      "@param node the node to remove",
      "@param maximumCacheSize the maximum cache size",
      "@return a new unmodifiable list",
      "@return a new fixed size list",
      "@return a new transformed list",
      "@return a new transformed List",
      "@return a new growth list",
      "@param index the index to add at",
      "@throws UnsupportedOperationException if the underlying list doesn't implement set",
      "@throws ClassCastException if the underlying list rejects the element",
      "@throws IllegalArgumentException if the underlying list rejects the element",
      "@param coll the collection to add at the specified index",
      "@return true if the list changed",
      "@param element the object to set at the specified index",
      "@return the object previously at that index",
      "@param initialSize the initial size of the ArrayList",
      "@throws IllegalArgumentException if initial size is invalid",
      "@param fromIndexInclusive the index to start from",
      "@param toIndexExclusive the index to end at",
      "@return the new sublist",
      "@param node node to update",
      "@param value new value of the node",
      "@return newly created node",
      "@return a new node containing the value",
      "@param node node to insert before"
   ],
   [
      "@param value value of the newly added node",
      "@throws NullPointerException if <code>node</code> is null",
      "@param node node to insert after",
      "@param nodeToInsert new node to insert",
      "@param insertBeforeNode node to insert before",
      "@throws NullPointerException if either node is null",
      "@param index the index, starting from 0",
      "@param endMarkerAllowed whether or not the end marker can be returned if\nstartIndex is set to the list's size",
      "@return the node at the given index",
      "@param subList the sublist to get an iterator for",
      "@return a new iterator on the given sublist",
      "@param fromIndex the index to start from, relative to the sublist",
      "@return a new list iterator on the given sublist",
      "@param outputStream the stream to write the object to",
      "@throws IOException if anything goes wrong",
      "@param inputStream the stream to read the object from",
      "@throws IOException if any error occurs while reading from the stream",
      "@throws ClassNotFoundException if a class read from the stream can not be loaded",
      "@return a new iterator that does <b>not</b> support concurrent modification",
      "@return a new cursor iterator",
      "@throws IndexOutOfBoundsException if the index is out of range\n     (index &lt; 0 || index &gt; size()).",
      "@param cursor the cursor to register",
      "@param cursor the cursor to deregister",
      "@param node the node that was changed",
      "@return the list iterator for the sublist"
   ],
   [
      "@param <T> the type of the elements in the list",
      "@return a new predicated list",
      "@throws IllegalArgumentException if the list contains invalid elements",
      "@return the decorated queue",
      "@param <E> the type of the elements in the queue",
      "@return a new transformed Queue",
      "@return an unmodifiable Queue",
      "@throws IOException if an I/O error occurs while writing to the output stream",
      "@throws IOException if an I/O error occurs while reading from the input stream",
      "@throws ClassNotFoundException if the class of a serialized object can not be found",
      "@return this queue's size",
      "@return true if this queue is empty",
      "@return always returns {@code false}",
      "@return {@code true} if the capacity limit has been reached, {@code false} otherwise",
      "@param element the element to add",
      "@param index the position of the element in the queue",
      "@return the element at position {@code index}",
      "@throws NoSuchElementException if the requested position is outside the range [0, size)",
      "@param index the index to increment",
      "@return the updated index",
      "@param index the index to decrement",
      "@return an iterator over this queue's elements",
      "@param size the size of the queue (cannot be changed)",
      "@return a new predicated queue",
      "@throws IllegalArgumentException if the queue contains invalid elements"
   ],
   [
      "@return the result of adding to the underlying queue",
      "@throws IllegalArgumentException if the Queue contains invalid elements",
      "@param singleton the singleton element",
      "@return a new FluentIterable containing the singleton",
      "@param elements the elements to be contained in the FluentIterable",
      "@return a new FluentIterable containing the provided elements",
      "@return a new FluentIterable wrapping the provided iterable",
      "@param elements the elements to append to the iterable",
      "@return a new iterable, combining this iterable with the elements",
      "@return a new iterable, combining this iterable with other",
      "@return a new iterable, collating this iterable with the other in natural order",
      "@param comparator the comparator to define an ordering, may be null,\n  in which case natural ordering will be used",
      "@return a new iterable with the same contents as this iterable",
      "@param predicate the predicate used to filter elements",
      "@return a new iterable, providing a filtered view of this iterable",
      "@param maxSize the maximum number of elements",
      "@return a new iterable, providing a bounded view of this iterable",
      "@return a new iterable, providing a looping view of this iterable",
      "@return a new iterable, providing a reversed view of this iterable",
      "@param elementsToSkip the number of elements to skip",
      "@return a new iterable, providing a view of this iterable by skipping\n  the first N elements",
      "@param transformer the transformer applied to each element",
      "@return a new iterable, providing a transformed view of this iterable",
      "@return a new iterable, providing a unique view of this iterable",
      "@return a new iterable, providing an unmodifiable view of this iterable"
   ],
   [
      "@return a new iterable, interleaving this iterable with others",
      "@return an Enumeration over the elements of this iterable",
      "@return true if all elements contained in this iterable match the predicate,\n  false otherwise",
      "@return true if at least one element contained in this iterable matches the predicate,\n  false otherwise",
      "@return true if this iterable does not contain any elements, false otherwise",
      "@return true if the object is contained in this iterable, false otherwise",
      "@param position the position of the element to return",
      "@return the element",
      "@return the size of this iterable",
      "@param collection the collection to add the elements",
      "@return an array of the iterable contents",
      "@throws ArrayStoreException if arrayClass is invalid",
      "@return a list of the iterable contents",
      "@param iterable the iterable to wrap",
      "@param constantToReturn the constant object to return each time in the transformer",
      "@return the transformer.",
      "@param transformers an array of transformers to chain",
      "@param <T> the input / output type",
      "@param trueTransformer the transformer called if the predicate is true",
      "@param falseTransformer the transformer called if the predicate is false",
      "@param predicates an array of predicates to check",
      "@param transformers an array of transformers to call",
      "@param predicatesAndTransformers a map of predicates to transformers",
      "@param objectsAndTransformers a map of objects to transformers",
      "@param <T> the output type"
   ],
   [
      "@param map the map to use to transform the objects",
      "@return the transformer, or {@link ConstantTransformer#nullTransformer()} if the\n  {@code map} is {@code null}",
      "@param value the value to compare against",
      "@return the <code>or</code> predicate",
      "@return the <code>either</code> predicate",
      "@return the <code>neither</code> predicate",
      "@return the <code>none</code> predicate",
      "@param predicate the predicate to not",
      "@return the transformer wrapping predicate",
      "@param transformer the transformer to call first",
      "@return the total size of the map",
      "@return {@code true} if this map contains no key-value mappings",
      "@return the {@code Collection} of values, implementations should\n  return an empty collection for no mapping",
      "@return true if the map changed as a result of this put operation, or false\n  if the map already contained the key-value mapping and the collection\n  type does not allow duplicate values, e.g. when using a Set",
      "@throws UnsupportedOperationException if the put operation is not supported by\n  this multi-valued map, e.g. if it is unmodifiable",
      "@throws NullPointerException if the key or value is null and null is invalid (optional)",
      "@throws IllegalArgumentException if some aspect of the specified key or value prevents\n  it from being stored in this multi-valued map",
      "@throws UnsupportedOperationException if the {@code putAll} operation is\n  not supported by this map",
      "@throws IllegalArgumentException if some property of a key or value in\n  the specified map prevents it from being stored in this map",
      "@param item the item to remove",
      "@return a set view of the mappings contained in this map",
      "@return a multiset view of the keys contained in this map",
      "@return a set view of the keys contained in this map",
      "@return a collection view of the values contained in this multi-valued map",
      "@return a map view of the mappings in this multi-valued map"
   ],
   [
      "@return an empty Set",
      "@return an empty sorted Set",
      "@param set the set, possibly <code>null</code>",
      "@return an empty set if the argument is <code>null</code>",
      "@param set1 the first set, may be null",
      "@param set2 the second set, may be null",
      "@param set the set to calculate the hash code for, may be null",
      "@return a new identity hash set",
      "@return a synchronized set backed by the given set",
      "@return an unmodifiable set backed by the given set",
      "@return a predicated set backed by the given set",
      "@return a transformed set backed by the given set",
      "@return an ordered set backed by the given set",
      "@return a predicated sorted set backed by the given sorted set",
      "@return a predicated navigable set backed by the given navigable set",
      "@param <E> the generic type that is able to represent the types contained\n  in both input sets.",
      "@return a view of the union of the two set",
      "@return a view of the relative complement of  of the two sets",
      "@return a view of the intersection of the two sets",
      "@return a view of the symmetric difference of the two sets",
      "@return Comparator<? super V>",
      "@param n the number of items down to go",
      "@return the n'th item on the stack, zero relative",
      "@param item the item to be added",
      "@param object the object to be searched for"
   ],
   [
      "@param initialSize the initial size to use",
      "@return the previous key in the iteration",
      "@return a new transformed set",
      "@return true if all of the contained sets are empty",
      "@return true if obj is contained in any of the contained sets",
      "@throws UnsupportedOperationException if SetMutator hasn't been set or add is unsupported",
      "@param obj object to be removed",
      "@return true if the object is removed, false otherwise",
      "@return true if the composite was modified",
      "@param set the set to add",
      "@throws IllegalArgumentException if a SetMutator is set, but fails to resolve a collision",
      "@throws UnsupportedOperationException if there is no SetMutator set",
      "@param set1 the first Set to be appended to the composite",
      "@param set2 the second Set to be appended to the composite",
      "@param sets the Sets to be appended to the composite",
      "@param set set to be removed",
      "@return A new HashSet containing all of the elements in this composite.\n  The new collection is <i>not</i> backed by this composite.",
      "@return Unmodifiable list of all sets in this composite.",
      "@return the set mutator",
      "@param set the initial set in the composite",
      "@param sets the initial sets in the composite",
      "@return a new transformed {@link NavigableSet}",
      "@return the decorated navigable set",
      "@return a new predicated navigable set.",
      "@throws IllegalArgumentException if the set contains invalid elements"
   ],
   [
      "@return the decorated set",
      "@return a new ordered set",
      "@return an unmodifiable list view",
      "@param index the position of the element in the ordered {@link Set}.",
      "@param object the element to search for",
      "@return the index of the first occurrence of the object, or {@code -1} if\n        this ordered set does not contain this object",
      "@param index the index at which the element is to be inserted",
      "@param object the element to be inserted",
      "@param index the position to insert the elements",
      "@param coll the collection containing the elements to be inserted",
      "@return {@code true} if this ordered set changed as a result of the call",
      "@param index the index of the element to be removed",
      "@return the element that has been remove from the ordered set",
      "@return a new unmodifiable set",
      "@param <V> the dummy value type in the map",
      "@return a new map backed set",
      "@param dummyValue the dummy value to use",
      "@return a new unmodifiable {@link SortedSet}",
      "@return a new predicated sorted set.",
      "@return the decorated sorted set",
      "@return a decorated set",
      "@return a new unmodifiable {@link NavigableSet}",
      "@return a new transformed {@link SortedSet}",
      "@param e the enumeration to get a value from",
      "@param <T> the type of object in the {@link Enumeration}"
   ],
   [
      "@return a list containing all elements of the given enumeration",
      "@param stringTokenizer the tokenizer to convert to a {@link List}&lt;{@link String}&gt;",
      "@return a list containing all tokens of the given StringTokenizer",
      "@param visitor the visitor to be accepted",
      "@param object the object of the first sequence that should be deleted",
      "@param skipped number of tokens skipped since the last call (i.e. number of\n  tokens that were in both sequences), this number should be strictly positive\n  except on the very first call where it can be zero (if the first object of\n  the two sequences are different)",
      "@param from sub-sequence of objects coming from the first sequence",
      "@param to sub-sequence of objects coming from the second sequence",
      "@param object the object of the second sequence that should be inserted",
      "@return the edit script resulting from the comparison of the two\n        sequences",
      "@param start the value of the start of the snake",
      "@param diag the value of the diagonal of the snake",
      "@param end1 the value of the end of the first sequence to be compared",
      "@param end2 the value of the end of the second sequence to be compared",
      "@return the snake built",
      "@param start1 the begin of the first sequence to be compared",
      "@param end1 the end of the first sequence to be compared",
      "@param start2 the begin of the second sequence to be compared",
      "@param end2 the end of the second sequence to be compared",
      "@return the middle snake",
      "@param script the edited script",
      "@param sequence1 first sequence to be compared",
      "@param sequence2 second sequence to be compared",
      "@param equator the equator to use for testing object equality",
      "@param object object to insert"
   ],
   [
      "@param object synchronization object detected",
      "@param object object to delete",
      "@param handler handler to call when synchronized sequences are found",
      "@param object the object belonging to both sequences (the object is a\n  reference to the instance in the first sequence which is known\n  to be equal to an instance in the second sequence)",
      "@return the object on which the command is applied",
      "@param object reference to the object associated with this command, this\n  refers to an element of one of the sequences being compared",
      "@param object object to insert (this object comes from the second sequence)",
      "@param object object to keep (this object comes from the first sequence)",
      "@param object object to delete (this object comes from the first sequence)",
      "@param command command to add",
      "@throws NullPointerException if enumeration is null",
      "@param enumeration the enumeration to use, may not be null",
      "@throws NullPointerException if enumeration or removeCollection is null",
      "@param removeCollection the collection to remove elements from, may not be null",
      "@param iterator the iterator to use, may not be null",
      "@throws NullPointerException if iterator parameter is null",
      "@throws NullPointerException if iterator parameter or arrayClass is null",
      "@throws IllegalArgumentException if the size is less than 1",
      "@return the last element in the iterator, or null if iterator is null or empty",
      "@param loadFactor the load factor, must be &gt; 0.0f and generally &lt; 1.0f",
      "@throws IllegalArgumentException if the load factor is less than or equal to zero",
      "@throws NullPointerException if values is null",
      "@throws NullPointerException if bag or transformer is null",
      "@throws NullPointerException if multiset or predicate is null",
      "@param transformer the transformer to call, not null"
   ],
   [
      "@throws NullPointerException if the underlying enumeration is null",
      "@throws NullPointerException if the enumeration is null",
      "@throws IllegalArgumentException if the size is &lt; 1",
      "@param coll the collection to copy into the queue, may not be null",
      "@throws NullPointerException if the given element is null",
      "@return true, always",
      "@throws NullPointerException if collection or predicate is null",
      "@param visitor the visitor that will visit all commands in turn",
      "@return length of the Longest Common Subsequence",
      "@return number of effective modifications",
      "@return an unmodifiable queue backed by that queue",
      "@return a predicated queue",
      "@return a transformed queue backed by the given queue",
      "@return the {@code Set} of values, implementations should return an\n  empty {@code Set} for no mapping",
      "@param <E> the type of the elements in the bag",
      "@return a new synchronized Bag",
      "@return the decorated bag",
      "@return the map being used by the Bag",
      "@return current size of the bag",
      "@return true if bag is empty",
      "@return true if the bag contains the given element",
      "@param other the bag to check against",
      "@return the iterator",
      "@return <code>true</code> if this call changed the bag",
      "@return true if the bag changed"
   ],
   [
      "@param coll the collection to use",
      "@return true if this call changed the collection",
      "@param other the bag to retain",
      "@return an array of all of this bag's elements",
      "@param <T> the type of the array elements",
      "@param array the array to populate",
      "@throws ArrayStoreException if the runtime type of the specified array is not\n  a supertype of the runtime type of the elements in this list",
      "@return the set of unique elements in this bag",
      "@param object the Bag to compare to",
      "@return the hash code of the Bag",
      "@return a debugging toString",
      "@param map the map to assign",
      "@return a Bag that complies to the Collection contract",
      "@throws ClassCastException if deserialised object has wrong type",
      "@return <code>true</code> if the Bag contains at least one of every object in the collection",
      "@param count the number of copies to add",
      "@return an unmodifiable Bag",
      "@return a new predicated SortedBag",
      "@throws IllegalArgumentException if the bag contains invalid elements",
      "@return an unmodifiable SortedBag",
      "@param coll a collection to copy into this bag",
      "@return a new transformed SortedBag",
      "@throws IllegalArgumentException if the object to be added does not implement\n{@link Comparable} and the {@link TreeBag} is using natural ordering",
      "@throws NullPointerException if the specified key is null and this bag uses\nnatural ordering, or its comparator does not permit null keys",
      "@param comparator the comparator to use"
   ],
   [
      "@param coll the collection to copy into the bag",
      "@return a new predicated Bag",
      "@return a new synchronized SortedBag",
      "@return a SortedBag that complies to the Collection contract",
      "@return a new transformed Bag",
      "@param coll a collection to copy into this multiset",
      "@return current size of the multiset",
      "@return true if the multiset contains the given element",
      "@return the set of unique elements in this multiset",
      "@return a view of the set of unique elements",
      "@return the uniqueSet iterator",
      "@return the set of entries in this multiset",
      "@return a view of the set of entries",
      "@return the number of unique elements",
      "@param <E> the type of the elements in the multiset",
      "@return a new predicated MultiSet",
      "@throws IllegalArgumentException if the multiset contains invalid elements",
      "@return the decorated multiset",
      "@return the map being used by the MultiSet",
      "@return true if multiset is empty",
      "@return an array of all of this multiset's elements",
      "@return an unmodifiable MultiSet",
      "@param multiset the multiset to decorate, may not be null",
      "@return a new synchronized MultiSet",
      "@return a synchronized bag backed by that bag"
   ],
   [
      "@return an unmodifiable view of that bag",
      "@return a predicated bag backed by the given bag",
      "@return a transformed bag backed by the given bag",
      "@param key the key used in the search",
      "@throws ClassCastException if the key or value is of an invalid type",
      "@throws NullPointerException if the key or value is null and null is invalid",
      "@return the number of key-collection mappings in this map",
      "@throws ClassCastException if the value is of an invalid type",
      "@return typically the value added if the map changed and null if the map did not change",
      "@throws IllegalArgumentException if the key or value is invalid",
      "@param iterator Iterator to add",
      "@throws IllegalStateException if I've already started iterating",
      "@return Iterator count",
      "@return true if IteratorChain cannot be modified, false if it can",
      "@return true if elements remain",
      "@return Object from the current Iterator",
      "@throws java.util.NoSuchElementException if all the Iterators are\nexhausted",
      "@throws UnsupportedOperationException if the remove operator is not\nsupported by the underlying Iterator",
      "@throws IllegalStateException if the next method has not yet been called,\nor the remove method has already been called after the last call to the\nnext method.",
      "@return {@link ResettableListIterator}<E>",
      "@return {@link ListIterator}<E>",
      "@return a new unmodifiable ordered map iterator",
      "@return the decorated iterator",
      "@return true if this iterator has remaining elements",
      "@return the next interleaved element"
   ],
   [
      "@throws NoSuchElementException if no child iterator has any more elements",
      "@throws IllegalStateException if there is no last returned element, or if\n  the last returned element has already been removed",
      "@param a the first child iterator",
      "@param b the second child iterator",
      "@param c the third child iterator",
      "@param iterators the array of iterators",
      "@return a new unmodifiable iterator",
      "@throws IllegalStateException if iteration has started",
      "@param index index of the Iterator to replace",
      "@param iterator Iterator to place at the given index",
      "@throws IndexOutOfBoundsException if index &lt; 0 or index &gt; size()",
      "@return the unmodifiable list of iterators added",
      "@return the {@link Comparator}",
      "@param comp the {@link Comparator} to set",
      "@return the next ordered element",
      "@throws IllegalStateException if there is no last returned element, or if\nthe last returned element has already been removed",
      "@return the index of the iterator that returned the last element",
      "@throws IllegalStateException if there is no last returned element",
      "@return {@code false} iff there was no value to set",
      "@throws IllegalStateException if iteration started",
      "@throws NullPointerException if no comparator is set",
      "@param initIterCapacity the initial capacity for the internal list of\n  child iterators",
      "@param a the first child ordered iterator",
      "@param b the second child ordered iterator",
      "@param iterators the collection of iterators"
   ],
   [
      "@throws ClassCastException if the iterators collection contains an\n  element that's not an {@link Iterator}",
      "@param iterator the iterator to use",
      "@return true if there is another element",
      "@return the next element in the iterator",
      "@return the index of the next element in the iterator",
      "@return true if there is a previous element",
      "@return the previous element in the iterator",
      "@return the index of the previous element in the iterator",
      "@throws UnsupportedOperationException if the list is unmodifiable",
      "@throws IllegalStateException if there is no element to remove",
      "@param obj the object to set",
      "@throws IllegalStateException if the iterator is not in a valid state for set",
      "@param list the list to create a reversed iterator for",
      "@return {@code true} if the iterator is within its bounds, {@code false} otherwise",
      "@param iterator the iterator to be decorated",
      "@param max the maximum number of elements of the decorated iterator to return",
      "@return the next object",
      "@throws java.util.NoSuchElementException if there are no more elements",
      "@return the iterator.",
      "@param source the object to transform",
      "@return true if there is a previous element to return",
      "@return the previous element",
      "@throws NoSuchElementException if there is no previous element",
      "@return the next element",
      "@throws NoSuchElementException if there is no next element"
   ],
   [
      "@return the index of the item to be retrieved next",
      "@param o the element to add",
      "@throws UnsupportedOperationException always thrown.",
      "@param o the element to set",
      "@throws IllegalStateException if {@link #next()} or {@link #previous()} has not been called\nbefore {@link #set(Object)}",
      "@param array the array to iterate over",
      "@throws IllegalArgumentException if <code>array</code> is not an array.",
      "@param startIndex the index to start iterating at",
      "@throws IndexOutOfBoundsException if the start index is out of bounds",
      "@param endIndex the index (exclusive) to finish iterating at",
      "@throws IndexOutOfBoundsException if the start or end index is out of bounds",
      "@throws IllegalArgumentException if end index is before the start",
      "@param count the number of time this method has been called (starts with 1)",
      "@return the next iterator, or null if there are no more.",
      "@return element from the current Iterator",
      "@throws java.util.NoSuchElementException if all the Iterators are exhausted",
      "@throws UnsupportedOperationException if the remove operator is not\n  supported by the underlying Iterator",
      "@throws IllegalStateException if the next method has not yet been called,\n  or the remove method has already been called after the last call to the next method.",
      "@return <code>true</code> if there are more elements",
      "@return the object after the last element returned",
      "@throws NoSuchElementException if there are no elements in the list",
      "@return the index of the element that would be returned if next() were called",
      "@return the object before the last element returned",
      "@return the index of the element that would be returned if previous() were called",
      "@throws UnsupportedOperationException if the remove method is\nnot supported by the iterator implementation of the underlying\nlist"
   ],
   [
      "@param obj the element to insert",
      "@throws UnsupportedOperationException if the add method is not\n supported by the iterator implementation of the underlying list",
      "@param obj the element with which to replace the last element returned",
      "@throws UnsupportedOperationException if the set method is not\n supported by the iterator implementation of the underlying list",
      "@return the current list size",
      "@param list the list to wrap",
      "@throws NullPointerException if the list it null",
      "@return a new peeking iterator",
      "@return the next element from the iterator",
      "@throws NoSuchElementException if the iterator is already exhausted according to {@link #hasNext()}",
      "@throws IllegalStateException if {@link #peek()} or {@link #element()} has been called\n  prior to the call to {@link #remove()}",
      "@param value the value to start from",
      "@param iterator the iterator to start from",
      "@return true if elements remain in the iteration",
      "@return the next element from the iteration",
      "@throws NoSuchElementException if all the Iterators are exhausted",
      "@throws UnsupportedOperationException if the remove operator is not supported by the underlying Iterator",
      "@throws IllegalStateException if the next method has not yet been called, or the remove method has\n  already been called after the last call to the next method.",
      "@param bound the index to check",
      "@param len the length of the array",
      "@param type the index type (for error messages)",
      "@return true if there is a next element to return",
      "@return the next element in the array",
      "@throws NoSuchElementException if all the elements in the array\n have already been returned",
      "@return the array this iterator iterates over."
   ],
   [
      "@return the start index",
      "@return the end index",
      "@param array the array to iterate over.",
      "@param startIndex the index to start iterating at.",
      "@param endIndex the index to finish iterating at.",
      "@throws IndexOutOfBoundsException if either index is invalid",
      "@return true if there are more permutations, otherwise false",
      "@return a list of the permutator's elements representing a permutation",
      "@throws NoSuchElementException if there are no more permutations",
      "@param coll the collection to generate permutations for",
      "@return true if the single object hasn't been returned yet",
      "@return true if the single object has been returned",
      "@return 0 or 1 depending on current state.",
      "@return 0 or -1 depending on current state.",
      "@return the single object",
      "@throws NoSuchElementException if the single object has already\n   been returned",
      "@throws NoSuchElementException if the single object has not already\n   been returned",
      "@throws IllegalStateException if the {@code next} or {@code previous}\n       method has not yet been called, or the {@code remove} method\n       has already been called after the last call to {@code next}\n       or {@code previous}.",
      "@throws IllegalStateException if {@code next} has not been called\n         or the object has been removed",
      "@param object the single object to return from the iterator",
      "@return {@link MapIterator}<K, V>",
      "@throws NoSuchElementException if all the elements in the array\n   have already been returned",
      "@return the array this iterator iterates over",
      "@param end the index (exclusive) to finish iterating at",
      "@return true if the underlying enumeration has more elements"
   ],
   [
      "@return the next object from the enumeration",
      "@throws IllegalStateException <code>next()</code> not called.",
      "@throws UnsupportedOperationException if no associated collection",
      "@return the underlying enumeration",
      "@param enumeration the new underlying enumeration",
      "@param enumeration the enumeration to use",
      "@param collection the collection to remove elements from",
      "@param iterator the iterator to use.",
      "@throws NoSuchElementException if there are no elements\n        at all.  Use {@link #hasNext} to avoid this error.",
      "@return the current collection size",
      "@param coll the collection to wrap",
      "@return true if the underlying iterator has more elements",
      "@return the next element from the underlying iterator.",
      "@throws java.util.NoSuchElementException if the underlying iterator has\nno more elements",
      "@return the underlying iterator",
      "@param iterator the new underlying iterator",
      "@throws IllegalStateException if the {@code next} method has not\n       yet been called, or the {@code remove} method has already\n       been called after the last call to the {@code next}\n       method.",
      "@throws UnsupportedOperationException if remove is not supported",
      "@throws UnsupportedOperationException if the underlying iterator is not of\ntype {@link ListIterator}",
      "@return true if there are more elements",
      "@return true if there are previous elements",
      "@throws NoSuchElementException if there are no more elements",
      "@return the index of the next element",
      "@throws NoSuchElementException if there are no previous elements",
      "@return the index of the previous element"
   ],
   [
      "@param iterator the iterator to wrap",
      "@return OrderedIterator<E>",
      "@param obj the object to set into the array",
      "@throws IllegalStateException if next() has not yet been called.",
      "@throws ClassCastException if the object type is unsuitable for the array",
      "@return a new unmodifiable list iterator",
      "@return {@link OrderedMapIterator}<K, V>",
      "@return a new unmodifiable map iterator",
      "@return ResettableIterator<E>",
      "@return Iterator<E>",
      "@return a string version of the iterator",
      "@param map the map to iterate over",
      "@param item the element to push back to the iterator",
      "@return true if there is another object that matches the predicate",
      "@return the next object which matches the given predicate",
      "@throws NoSuchElementException if there are no more elements that\n match the predicate",
      "@throws IllegalStateException if <code>hasNext()</code> has already\n been called.",
      "@return the predicate.",
      "@param predicate the transformer to use",
      "@param predicate the predicate to use.",
      "@return {@link IterableMap}",
      "@param <V> the element type",
      "@return {@link Map}",
      "@return true if the map is empty or null",
      "@return the Collection in the {@link MultiValuedMap}, or null if input map is null"
   ],
   [
      "@return the Collection in the {@link MultiValuedMap} as List, or null if input map is null",
      "@return the Collection in the {@link MultiValuedMap} as Set, or null if input map is null",
      "@return the Collection in the {@link MultiValuedMap} as Bag, or null if input map is null",
      "@param map the {@link MultiValuedMap} to decorate, must not be null",
      "@param map the {@link MultiValuedMap} to transform, must not be null, typically empty",
      "@param keyTransformer the transformer for the map keys, null means no transformation",
      "@param valueTransformer the transformer for the map values, null means no transformation",
      "@param iterator the first child iterator in the IteratorChain, not null",
      "@param first the first child iterator in the IteratorChain, not null",
      "@param second the second child iterator in the IteratorChain, not null",
      "@throws NullPointerException if iterators array is or contains null",
      "@param iteratorChain the array of iterators, not null",
      "@throws NullPointerException if iterators collection is or contains null",
      "@throws ClassCastException if iterators collection doesn't contain an\niterator",
      "@param iteratorChain the collection of iterators, not null",
      "@param closure the closure to execute, not null",
      "@param trie the trie to decorate, must not be null",
      "@param key the key to check, may not be null",
      "@throws NullPointerException if set or transformer is null",
      "@return true if input is null",
      "@param defaultList the returned values if list is {@code null}",
      "@throws NullPointerException if either list is null",
      "@throws NullPointerException if the input list is null",
      "@return whether the lists are equal by value comparison",
      "@param list the list to synchronize, must not be null"
   ],
   [
      "@param list the list to make unmodifiable, must not be null",
      "@throws NullPointerException if the List or Predicate is null",
      "@param list the list to predicate, must not be null",
      "@param predicate the predicate for the list, must not be null",
      "@throws NullPointerException if the List or Transformer is null",
      "@param transformer the transformer for the list, must not be null",
      "@throws NullPointerException if the List or Factory is null",
      "@param list the list to make lazy, must not be null",
      "@param factory the factory for creating new objects, must not be null",
      "@throws NullPointerException if the List is null",
      "@param list the list whose size to fix, must not be null",
      "@throws NullPointerException if either list is {@code null}",
      "@throws NullPointerException if either list or the equator is {@code null}",
      "@throws NullPointerException if either sequence is {@code null}",
      "@throws IllegalArgumentException if size is not strictly positive",
      "@param set the {@link Set} to be used as return type, must not be null",
      "@throws NullPointerException if either the iterator or predicate are null",
      "@throws NullPointerException if queue or transformer is null",
      "@throws NullPointerException if queue or predicate is null",
      "@param Queue the queue to decorate, must not be null",
      "@throws NullPointerException if {@code set} is null",
      "@throws NullPointerException if the key is {@code null} and this map\n           does not not permit {@code null} keys (optional).",
      "@throws NullPointerException if the value is {@code null} and this map\n           does not not permit {@code null} values (optional).",
      "@throws NullPointerException key is {@code null} and this map does not\n        not permit {@code null} keys (optional).",
      "@return the value to which this map maps the specified key, or\n        {@code null} if the map contains no mapping for this key."
   ],
   [
      "@throws NullPointerException the specified map is {@code null}, or if\n        this map does not permit {@code null} keys or values, and the\n        specified map contains {@code null} keys or values.",
      "@throws NullPointerException if the key is {@code null} and the composited map\n           does not not permit {@code null} keys (optional).",
      "@param defaultValue what to return if the value is null",
      "@throws NullPointerException if the bundle is null",
      "@param resourceBundle the resource bundle to convert, may not be null",
      "@param out the stream to print to, must not be null",
      "@param map the map to invert, may not be null",
      "@param map the map to add to, may not be null",
      "@param value the value, null converted to \"\"",
      "@param map the map to populate, must not be null",
      "@param array an array to populate from, null ignored",
      "@param map the map to synchronize, must not be null",
      "@param map the map to make unmodifiable, must not be null",
      "@throws NullPointerException if the Map is null",
      "@param map the map to predicate, must not be null",
      "@param keyPred the predicate for keys, null means no check",
      "@param valuePred the predicate for values, null means no check",
      "@param map the map to transform, must not be null, typically empty",
      "@param map the map whose size to fix, must not be null",
      "@throws NullPointerException if the Map or Factory is null",
      "@param map the map to make lazy, must not be null",
      "@throws NullPointerException if the Map or Transformer is null",
      "@param transformerFactory the factory for creating new objects, must not be null",
      "@param map the map to order, must not be null",
      "@param map the sorted map to make unmodifiable, must not be null"
   ],
   [
      "@throws NullPointerException if the SortedMap is null",
      "@throws NullPointerException if the SortedMap or Factory is null",
      "@throws NullPointerException if the map, elements or transformer are null",
      "@throws NullPointerException if the map, elements or transformers are null",
      "@throws NullPointerException if the map, collection or transformers are null",
      "@throws NullPointerException if sortedMap is null",
      "@param factory the factory to use, must not be null",
      "@return the value previously mapped to the key",
      "@param closure the closure to run each time in the transformer, not null",
      "@param predicate the predicate to run each time in the transformer, not null",
      "@param factory the factory to run each time in the transformer, not null",
      "@throws NullPointerException if the transformers array or any of the transformers is null",
      "@throws NullPointerException if the transformers collection or any of the transformers is null",
      "@throws NullPointerException if either the predicate or transformer is null",
      "@param defaultTransformer the default to call if no predicate matches, null means return null",
      "@throws NullPointerException if the collection or lock is null",
      "@param lock the lock object to use, must not be null",
      "@throws IllegalArgumentException if the maximum size is less than one",
      "@throws IllegalArgumentException if the initial size is larger than {@code maxSize}",
      "@throws IllegalArgumentException if the initial size is negative or larger than the maximum size",
      "@return {@code true}",
      "@param element the object to add at the specified index",
      "@param comp the comparator to use to sort; must not be null,\n  unless you'll be invoking {@link #setComparator(Comparator)} later on.",
      "@throws NullPointerException if the iterators collection is or contains null",
      "@param iterator the iterator to add to the collation, must not be null"
   ],
   [
      "@throws java.util.NoSuchElementException if this map is empty",
      "@throws NullPointerException if <code>nonNullComparator</code> is\n <code>null</code>",
      "@param nonNullComparator the comparator to use when comparing two\n non-<code>null</code> objects.  This argument cannot be\n <code>null</code>",
      "@param nonNullComparator the comparator to use when comparing two\n non-<code>null</code> objects. This argument cannot be\n <code>null</code>",
      "@param root the root object, null will result in an empty iterator",
      "@param transformer the transformer to use, null will use a no effect transformer",
      "@param rootIterator the root iterator, null will result in an empty iterator",
      "@throws NullPointerException if the transformers array is null",
      "@throws NullPointerException if any transformer in the array is null",
      "@throws NullPointerException if the transformers collection is null",
      "@throws NullPointerException if comparators array is null or contains a null",
      "@param comparators the comparators to use, not null or empty or containing nulls",
      "@throws NullPointerException if comparators collection is null or contains a null",
      "@throws NullPointerException if the Bag is null",
      "@param bag the bag to synchronize, must not be null",
      "@param bag the bag whose unmodifiable view is to be returned, must not be null",
      "@throws NullPointerException if the Bag or Predicate is null",
      "@throws NullPointerException if the SortedBag is null",
      "@throws NullPointerException if the SortedBag or Predicate is null",
      "@param bag the sorted bag to predicate, must not be null",
      "@throws MathIllegalArgumentException if the points are equal",
      "@throws NullArgumentException if original is null",
      "@throws MathIllegalArgumentException if the input array is null or the array\nindex parameters are not valid",
      "@throws NullArgumentException if either source or dest is null",
      "@throws NullArgumentException if {@code x} or {@code y} are {@code null}."
   ],
   [
      "@throws NoDataException if {@code x} or {@code y} are zero-length.",
      "@throws NumberIsTooLargeException if {@code exactPValue} is {@code true}\nand {@code x.length} > 30",
      "@throws NullArgumentException if the input collection is {@code null}",
      "@throws NumberIsTooSmallException if the size of {@code x} is smaller\nthan 2.",
      "@throws DimensionMismatchException if {@code x} and {@code y}\nhave different sizes.",
      "@throws NotStrictlyPositiveException if {@code maxIter <= 0}.",
      "@throws NullArgumentException if any argument is {@code null}.",
      "@throws NoDataException if any array has zero length.",
      "@throws DimensionMismatchException if the size difference between\n{@code a} and {@code c} is not equal to 1.",
      "@throws MathIllegalArgumentException if the array is null or the array index\n parameters are not valid",
      "@throws NullArgumentException if {@code c} is {@code null}.",
      "@throws NoDataException if {@code c} is empty.",
      "@throws NoDataException if {@code coefficients} is empty.",
      "@throws NullArgumentException if {@code coefficients} is {@code null}.",
      "@return the coefficients of the derivative or {@code null} if coefficients has length 1.",
      "@return vertices of the polygon, organized as oriented boundary\nloops with the open loops first (the returned value is guaranteed\nto be non-null)",
      "@return {@code false}",
      "@throws NullArgumentException if the list of chromosomes is {@code null}",
      "@throws NumberIsTooSmallException if {@code fuzziness <= 1.0}",
      "@param fuzziness the fuzziness factor, must be &gt; 1.0",
      "@throws MathIllegalArgumentException if the data points are null or the number\n    of clusters is larger than the number of data points",
      "@param bytes the non-null byte array in which to put the\nrandom bytes",
      "@throws NotStrictlyPositiveException if {@code n <= 0}.",
      "@param n the bound on the random number to be returned.  Must be\npositive.",
      "@throws NumberIsTooLargeException if {@code x0 > x1}.\n\nThe default implementation uses the identity\n{@code P(x0 < X <= x1) = P(X <= x1) - P(X <= x0)}"
   ],
   [
      "@throws NotStrictlyPositiveException if {@code initValue <= 0}.",
      "@throws NumberIsTooLargeException if {@code slope >= 0}.",
      "@throws NotStrictlyPositiveException if {@code numCall <= 0}.",
      "@throws NullArgumentException if the {@code valuesFileURL} has not been set",
      "@throws NullPointerException if the {@code valuesFileURL} has not been set.",
      "@throws NotPositiveException if {@code stepsize <= 0} (note that\n{@link NotPositiveException} extends {@link NumberIsTooSmallException})",
      "@throws NumberIsTooSmallException {@code nbPoint <= 1}",
      "@throws NumberIsTooLargeException {@code stepSize * (nbPoints - 1) >= tUpper - tLower}",
      "@throws NullArgumentException if {@code format} is {@code null}.",
      "@throws NonSquareMatrixException if the matrix is not square",
      "@throws NotPositiveException if {@code eps < 0.0} or {@code minPts < 0}",
      "@throws NullArgumentException if the data points are null",
      "@throws ZeroException if {@code n = 0}",
      "@throws NotStrictlyPositiveException if {@code max <= 0}.",
      "@param lower a value satisfying {@code cumulativeProbability(lower) < p}",
      "@return atan2(this, x)",
      "@throws NullArgumentException if {@code d} is {@code null}.",
      "@throws ZeroException if {@code d} is empty.",
      "@throws NullArgumentException if {@code v} is {@code null}.",
      "@throws NullArgumentException if {@code v1} or {@code v2} is\n{@code null}.",
      "@throws NumberIsTooSmallException if {@code end < start}.",
      "@throws NotStrictlyPositiveException if row or column dimension is not\npositive.",
      "@throws NullArgumentException if the array is {@code null}.",
      "@throws NoDataException if the array is empty.",
      "@throws NoDataException if array is empty."
   ],
   [
      "@throws NumberIsTooSmallException if {@code endRow < startRow} or\n{@code endColumn < startColumn}.",
      "@throws NullArgumentException if the arrays are {@code null}.",
      "@throws UnknownParameterException if the parameter is not supported",
      "@return updated high order derivatives",
      "@throws NotPositiveException if {@code n < 0}.",
      "@throws NumberIsTooLargeException if {@code k > n}.",
      "@throws MathArithmeticException if {@code n > 20}: The factorial value is too\nlarge to fit in a {@code long}.",
      "@throws NotPositiveException if {@code k < 0}.",
      "@throws IllegalArgumentException if n is not positive.",
      "@throws NullArgumentException if {@code steps} is {@code null}.",
      "@throws ZeroException if one of the steps is zero.",
      "@throws NotStrictlyPositiveException if {@code beta <= 0}",
      "@param beta scale parameter (must be positive)",
      "@throws NotStrictlyPositiveException if {@code numberOfElements <= 0}\nor {@code exponent <= 0}.",
      "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if {@code dimension <= 0} or {@code elements <= 0}.",
      "@throws NotPositiveException if {@code exponent < 0}.",
      "@throws NotPositiveException if {@code darkThreshold < 0}.",
      "@throws NullArgumentException if {@code manager} is {@code null}",
      "@throws org.apache.commons.math3.exception.NumberIsTooLargeException if {@code min >= max}.",
      "@return the value where the function is zero.",
      "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if {@code initValue <= 0}.",
      "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if {@code valueAtNumCall <= 0}.",
      "@throws org.apache.commons.math3.exception.NumberIsTooLargeException if {@code valueAtNumCall >= initValue}.",
      "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if {@code numCall <= 0}.",
      "@throws org.apache.commons.math3.exception.NumberIsTooLargeException if {@code slope >= 0}."
   ],
   [
      "@param n number to factors, must be &gt; 0",
      "@param a first number, must be &ge; 0",
      "@param b second number, must be &ge; 0",
      "@throws NotStrictlyPositiveException if minimal number of iterations\nis not strictly positive",
      "@throws NumberIsTooLargeException if maximal number of iterations\nis greater than {@link #ROMBERG_MAX_ITERATIONS_COUNT}",
      "@param maximalIterationCount maximum number of iterations\n(must be less than or equal to {@link #ROMBERG_MAX_ITERATIONS_COUNT})",
      "@throws NumberIsTooLargeException if maximal number of iterations\nis greater than {@link #SIMPSON_MAX_ITERATIONS_COUNT}",
      "@throws NumberIsTooSmallException if maximal number of iterations\nis lesser than or equal to the minimal number of iterations",
      "@param maximalIterationCount maximum number of iterations\n(must be less than or equal to {@link #SIMPSON_MAX_ITERATIONS_COUNT})",
      "@throws NotStrictlyPositiveException if {@code n <= 0}",
      "@throws NullArgumentException if {@code optimizer} or {@code generator}\nis {@code null}.",
      "@throws NotStrictlyPositiveException if {@code starts < 1}.",
      "@throws NotStrictlyPositiveException if {@code len <= 0}",
      "@throws NumberIsTooLargeException if {@code lower >= upper}",
      "@return a random integer greater than or equal to {@code lower}\nand less than or equal to {@code upper}",
      "@return a random long integer greater than or equal to {@code lower} and\nless than or equal to {@code upper}",
      "@throws NumberIsTooLargeException if {@code lower >= upper}.",
      "@return a random integer greater than or equal to {@code lower} and less\nthan or equal to {@code upper}.",
      "@return a random long integer greater than or equal to {@code lower} and\nless than or equal to {@code upper}.",
      "@throws NotStrictlyPositiveException if {@code mean <= 0}.",
      "@throws NotStrictlyPositiveException if {@code sigma <= 0}.",
      "@throws NotStrictlyPositiveException if {@code k <= 0}.",
      "@throws NumberIsTooLargeException if {@code k > c.size()}.",
      "@param s scale parameter (must be positive)",
      "@throws OutOfRangeException if bandwidth does not lie in the interval [0,1]."
   ],
   [
      "@throws NotPositiveException if {@code robustnessIters} is negative.",
      "@throws DimensionMismatchException if {@code xval} and {@code yval} have\ndifferent sizes.",
      "@throws NumberIsTooSmallException if the length of the arrays is &lt; 2",
      "@throws NullArgumentException if the arrays are <code>null</code>",
      "@throws NullArgumentException if <code>observed</code> is <code>null</code>",
      "@throws NumberIsTooSmallException if the length of <code>observed</code> is &lt; 2",
      "@throws NullArgumentException if <code>sampleStats</code> is <code>null</code>",
      "@throws NullArgumentException if the sample statistics are <code>null</code>",
      "@throws NullArgumentException if the sample array is <code>null</code>",
      "@throws NumberIsTooSmallException if the length of the array is &lt; 2",
      "@throws MathIllegalArgumentException if n is not greater than 1",
      "@throws NumberIsTooSmallException if maximal order is lower than 2",
      "@throws NumberIsTooSmallException if the size of {@code xvals} is smaller\n        than 5.",
      "@throws NullArgumentException if either of the arguments is null",
      "@throws ZeroException if the denominator is zero.",
      "@param num the numerator, must not be {@code null}.",
      "@param den the denominator, must not be {@code null}.",
      "@throws ArithmeticException if the denominator is <code>zero</code>.",
      "@throws NullArgumentException if the {@link BigInteger} is <code>null</code>.",
      "@param bg the {@link BigInteger} to add, must'nt be <code>null</code>.",
      "@throws NullArgumentException if the {@link BigFraction} is {@code null}.",
      "@param fraction the {@link BigFraction} to add, must not be <code>null</code>.",
      "@param object the object to compare to, must not be <code>null</code>.",
      "@throws NullArgumentException if the {@code BigInteger} is {@code null}",
      "@throws MathArithmeticException if the fraction to divide by is zero"
   ],
   [
      "@param bg the {@code BigInteger} to divide by, must not be {@code null}",
      "@throws NullArgumentException if the {@code fraction} is {@code null}.",
      "@param fraction Fraction to divide by, must not be {@code null}.",
      "@throws NullArgumentException if {@code bg} is {@code null}.",
      "@throws NullArgumentException if {@code fraction} is {@code null}.",
      "@param fraction Fraction to multiply by, must not be {@code null}.",
      "@throws NullArgumentException if the {@link BigInteger} is {@code null}.",
      "@param bg the {@link BigInteger} to subtract, cannot be {@code null}.",
      "@param fraction {@link BigFraction} to subtract, must not be {@code null}.",
      "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if {@code size <= 0}.",
      "@throws org.apache.commons.math3.exception.NotPositiveException if\n{@code darkThreshold < 0}.",
      "@throws NumberIsTooLargeException if {@code index >= parameters}.",
      "@throws DimensionMismatchException if the number of derivatives\nin the array is not equal to {@link #getOrder() order} + 1",
      "@throws NullArgumentException if one of the parameters is {@code null}",
      "@throws NumberIsTooSmallException if {@code x < -0.5}",
      "@throws NumberIsTooLargeException if {@code x > 1.5}",
      "@throws NumberIsTooSmallException if {@code x < -0.5}.",
      "@throws NumberIsTooLargeException if {@code x > 1.5}.",
      "@throws MathIllegalArgumentException if values is null",
      "@throws OutOfRangeException if {@code p <= 0} or {@code p > 1}.",
      "@throws NotStrictlyPositiveException if {@code len <= 0}.",
      "@throws NotStrictlyPositiveException if {@code shape <= 0} or\n{@code scale <= 0}.",
      "@throws NumberIsTooLargeException if {@code numberOfSuccesses > populationSize},\nor {@code sampleSize > populationSize}.",
      "@throws NotStrictlyPositiveException if {@code populationSize <= 0}.",
      "@throws NotPositiveException if {@code numberOfSuccesses < 0}."
   ],
   [
      "@throws NotStrictlyPositiveException if the number of successes is not positive",
      "@throws OutOfRangeException if the probability of success is not in the\nrange {@code [0, 1]}.",
      "@throws NotStrictlyPositiveException if {@code df <= 0}",
      "@throws NotStrictlyPositiveException if\n{@code numeratorDf <= 0} or {@code denominatorDf <= 0}.",
      "@param n1 first sample n",
      "@param n2 second sample n",
      "@return t test statistic",
      "@param m1 first sample mean",
      "@param m2 second sample mean",
      "@param v1 first sample variance",
      "@param v2 second sample variance",
      "@param m sample mean",
      "@param mu constant to test against",
      "@param v sample variance",
      "@param n sample n",
      "@return p-value",
      "@throws MaxCountExceededException if an error occurs computing the p-value",
      "@throws NotStrictlyPositiveException if the estimated degrees of freedom is not\nstrictly positive",
      "@param alpha significance level",
      "@throws OutOfRangeException if the significance level is out of bounds.",
      "@param data Sample data.",
      "@throws NullArgumentException if {@code data} is {@code null}.",
      "@throws NumberIsTooSmallException if there is not enough sample data.",
      "@param stat Statistical summary.",
      "@param observed array of observed frequency counts"
   ],
   [
      "@param expected array of expected frequency counts",
      "@return G-Test statistic",
      "@throws NotPositiveException if {@code observed} has negative entries",
      "@throws NotStrictlyPositiveException if {@code expected} has entries that\nare not strictly positive",
      "@throws DimensionMismatchException if the array lengths do not match or\nare less than 2.",
      "@throws MaxCountExceededException if an error occurs computing the\np-value.",
      "@throws NotStrictlyPositiveException {@code expected} has entries that are\nnot strictly positive",
      "@param alpha significance level of the test",
      "@return true iff null hypothesis can be rejected with confidence 1 -\nalpha",
      "@throws OutOfRangeException if alpha is not strictly greater than zero\nand less than or equal to 0.5",
      "@param k 2 Dimensional Matrix of long values (for ex. the counts of a\ntrials)",
      "@return Shannon Entropy of the given Matrix",
      "@param k Vector (for ex. Row Sums of a trials)",
      "@return Shannon Entropy of the given Vector",
      "@param observed1 array of observed frequency counts of the first data set",
      "@param observed2 array of observed frequency counts of the second data\nset",
      "@throws DimensionMismatchException the the lengths of the arrays do not\nmatch or their common length is less than 2",
      "@throws NotPositiveException if any entry in {@code observed1} or\n{@code observed2} is negative",
      "@throws ZeroException if either all counts of\n{@code observed1} or {@code observed2} are zero, or if the count\nat the same index is zero for both arrays.",
      "@param k11 number of times the two events occurred together (AB)",
      "@param k12 number of times the second event occurred WITHOUT the\nfirst event (notA,B)",
      "@param k21 number of times the first event occurred WITHOUT the\nsecond event (A, notB)",
      "@param k22 number of times something else occurred (i.e. was neither\nof these events (notA, notB)",
      "@return root log-likelihood ratio",
      "@throws NotPositiveException if any of the entries in {@code observed1} or\n{@code observed2} are negative"
   ],
   [
      "@throws ZeroException if either all counts of {@code observed1} or\n{@code observed2} are zero, or if the count at some index is\nzero for both arrays",
      "@throws DimensionMismatchException the the length of the arrays does not\nmatch",
      "@throws OutOfRangeException if {@code alpha} is not in the range\n(0, 0.5]",
      "@throws MaxCountExceededException if an error occurs performing the test",
      "@param x first sample",
      "@param y second sample",
      "@return concatenated array",
      "@param x the first sample",
      "@param y the second sample",
      "@return Mann-Whitney U statistic (maximum of U<sup>x</sup> and U<sup>y</sup>)",
      "@param Umin smallest Mann-Whitney U value",
      "@param n1 number of subjects in first sample",
      "@param n2 number of subjects in second sample",
      "@return two-sided asymptotic p-value",
      "@throws ConvergenceException if the p-value can not be computed\ndue to a convergence error",
      "@throws MaxCountExceededException if the maximum number of\niterations is exceeded",
      "@return asymptotic p-value",
      "@throws ConvergenceException if the p-value can not be computed due to a\nconvergence error",
      "@throws MaxCountExceededException if the maximum number of iterations\nis exceeded",
      "@param nanStrategy specifies the strategy that should be used for Double.NaN's",
      "@param tiesStrategy specifies the strategy that should be used for ties",
      "@throws DimensionMismatchException if {@code x} and {@code y} do not\nhave the same length.",
      "@return z = y - x",
      "@param z sample",
      "@return |z|"
   ],
   [
      "@throws NullArgumentException if {@code z} is {@code null}",
      "@throws NoDataException if {@code z} is zero-length.",
      "@return wilcoxonSignedRank statistic (the larger of W+ and W-)",
      "@param Wmax largest Wilcoxon signed rank value",
      "@param N number of subjects (corresponding to x.length)",
      "@return two-sided exact p-value",
      "@param Wmin smallest Wilcoxon signed rank value",
      "@param exactPValue if the exact p-value is wanted (only works for x.length <= 30,\n           if true and x.length > 30, this is ignored because\n           calculations may take too long)",
      "@throws ConvergenceException if the p-value can not be computed due to\na convergence error",
      "@param categoryData <code>Collection</code> of <code>double[]</code>\narrays each containing data for one category",
      "@return Fvalue",
      "@throws DimensionMismatchException if the length of the <code>categoryData</code>\narray is less than 2 or a contained <code>double[]</code> array does not have\nat least two values",
      "@return Pvalue",
      "@throws ConvergenceException if the p-value can not be computed due to a convergence error",
      "@throws MaxCountExceededException if the maximum number of iterations is exceeded",
      "@param categoryData <code>Collection</code> of {@link SummaryStatistics}\neach containing data for one category",
      "@param allowOneElementData if true, allow computation for one catagory\nonly or for one data element per category",
      "@throws DimensionMismatchException if the length of the <code>categoryData</code>\narray is less than 2 or a contained {@link SummaryStatistics} does not have\nat least two values",
      "@param categoryData <code>Collection</code> of <code>double[]</code> arrays each\n           containing data for one category",
      "@return computed AnovaStats",
      "@throws NullArgumentException if <code>categoryData</code> is <code>null</code>",
      "@throws DimensionMismatchException if the length of the <code>categoryData</code> array is less\n            than 2 or a contained <code>double[]</code> array does not\n            contain at least two values",
      "@return true if the null hypothesis can be rejected with\nconfidence 1 - alpha",
      "@throws OutOfRangeException if <code>alpha</code> is not in the range (0, 0.5]",
      "@throws DimensionMismatchException if <code>allowOneElementData</code> is false and the number of\ncategories is less than 2 or a contained SummaryStatistics does not contain\nat least two values"
   ],
   [
      "@return chiSquare test statistic",
      "@throws NotPositiveException if <code>observed</code> has negative entries",
      "@throws NotStrictlyPositiveException if <code>expected</code> has entries that are\nnot strictly positive",
      "@return true iff null hypothesis can be rejected with confidence\n1 - alpha",
      "@param counts array representation of 2-way table",
      "@throws DimensionMismatchException if the array is not rectangular",
      "@throws NotPositiveException if {@code counts} has negative entries",
      "@throws NotPositiveException if {@code counts} has any negative entries",
      "@param observed2 array of observed frequency counts of the second data set",
      "@throws DimensionMismatchException the the length of the arrays does not match",
      "@throws NotPositiveException if any entries in <code>observed1</code> or\n<code>observed2</code> are negative",
      "@throws ZeroException if either all counts of <code>observed1</code> or\n<code>observed2</code> are zero, or if the count at some index is zero\nfor both arrays",
      "@throws ZeroException if either all counts of <code>observed1</code> or\n<code>observed2</code> are zero, or if the count at the same index is zero\nfor both arrays",
      "@param in input 2-way table to check",
      "@throws NullArgumentException if the array is null",
      "@throws DimensionMismatchException if the array is not valid",
      "@throws NotPositiveException if the array contains any negative entries",
      "@param numberOfTrials number of trials performed",
      "@param numberOfSuccesses number of successes observed",
      "@param probability assumed probability of a single trial under the null hypothesis",
      "@param alternativeHypothesis type of hypothesis being evaluated (one- or two-sided)",
      "@return true if the null hypothesis can be rejected with confidence {@code 1 - alpha}",
      "@param distribution reference distribution",
      "@param data sample being being evaluated",
      "@param exact whether or not to force exact computation of the p-value"
   ],
   [
      "@return the p-value associated with the null hypothesis that {@code data} is a sample from\n        {@code distribution}",
      "@throws InsufficientDataException if {@code data} does not have length at least 2",
      "@param data sample being evaluated",
      "@return Kolmogorov-Smirnov statistic \\(D_n\\)",
      "@param x first sample dataset",
      "@param y second sample dataset",
      "@param strict whether or not the probability to compute is expressed as a strict inequality\n       (ignored for large samples)",
      "@return p-value associated with the null hypothesis that {@code x} and {@code y} represent\n        samples from the same distribution",
      "@throws InsufficientDataException if either {@code x} or {@code y} does not have length at\n        least 2",
      "@return test statistic \\(D_{n,m}\\) used to evaluate the null hypothesis that {@code x} and\n        {@code y} represent samples from the same underlying distribution",
      "@return test statistic \\(n m D_{n,m}\\) used to evaluate the null hypothesis that {@code x} and\n        {@code y} represent samples from the same underlying distribution",
      "@throws NullArgumentException if either {@code x} or {@code y} is null",
      "@return true iff the null hypothesis that {@code data} is a sample from {@code distribution}\n        can be rejected with confidence 1 - {@code alpha}",
      "@param iterations number of bootstrap resampling iterations",
      "@param strict whether or not the null hypothesis is expressed as a strict inequality",
      "@return estimated p-value",
      "@param d statistic",
      "@param n sample size",
      "@throws MathArithmeticException if algorithm fails to convert {@code h} to a\n        {@link org.apache.commons.math3.fraction.BigFraction} in expressing {@code d} as \\((k\n        - h) / m\\) for integer {@code k, m} and \\(0 \\le h < 1\\)",
      "@throws MathArithmeticException if the algorithm fails to convert {@code h} to a\n        {@link org.apache.commons.math3.fraction.BigFraction} in expressing {@code d} as \\((k\n        - h) / m\\) for integer {@code k, m} and \\(0 \\le h < 1\\)",
      "@param exact whether the probability should be calculated exact using\n       {@link org.apache.commons.math3.fraction.BigFraction} everywhere at the expense of\n       very slow execution time, or if {@code double} should be used convenient places to\n       gain speed. Almost never choose {@code true} in real applications unless you are very\n       sure; {@code true} is almost solely for verification purposes.",
      "@throws MathArithmeticException if algorithm fails to convert {@code h} to a\n        {@link org.apache.commons.math3.fraction.BigFraction} in expressing {@code d} as \\((k\n        - h) / m\\) for integer {@code k, m} and \\(0 \\le h < 1\\).",
      "@return the two-sided probability of \\(P(D_n < d)\\)",
      "@return \\(P(D_n < d)\\)",
      "@param d value of d-statistic (x in [2])"
   ],
   [
      "@return H matrix",
      "@throws NumberIsTooLargeException if fractional part is greater than 1",
      "@throws FractionConversionException if algorithm fails to convert {@code h} to a\n        {@link org.apache.commons.math3.fraction.BigFraction} in expressing {@code d} as \\((k\n        - h) / m\\) for integer {@code k, m} and \\(0 <= h < 1\\).",
      "@param array array to test",
      "@throws NullArgumentException if array is null",
      "@throws InsufficientDataException if array is too short",
      "@param t argument",
      "@param tolerance Cauchy criterion for partial sums",
      "@param maxIterations maximum number of partial sums to compute",
      "@return Kolmogorov sum evaluated at t",
      "@throws TooManyIterationsException if the series does not converge",
      "@param d a d-statistic in the range [0, 1]",
      "@param n first sample size",
      "@param m second sample size",
      "@param strict whether the returned value divided by (n*m) is allowed to be equal to d",
      "@return the integral d-statistic in the range [0, n*m]",
      "@param d D-statistic value",
      "@param strict whether or not the probability to compute is expressed as a strict inequality",
      "@return probability that a randomly selected m-n partition of m + n generates \\(D_{n,m}\\)\n        greater than (resp. greater than or equal to) {@code d}",
      "@return approximate probability that a randomly selected m-n partition of m + n generates\n        \\(D_{n,m}\\) greater than {@code d}",
      "@param b boolean array",
      "@param numberOfTrueValues number of {@code true} values the boolean array should finally have",
      "@param rng random data generator",
      "@param iterations number of random partitions to generate",
      "@return proportion of randomly generated m-n partitions of m + n that result in \\(D_{n,m}\\)\n        greater than (resp. greater than or equal to) {@code d}"
   ],
   [
      "@param d integral D-statistic",
      "@return proportion of randomly generated m-n partitions of m + n that result in \\(D_{n,m}\\)\n        greater than or equal to {@code d/(n*m))}",
      "@return true if x and y together contain ties",
      "@param data input/output data array - entries overwritten by the method",
      "@param dist probability distribution to sample for jitter values",
      "@throws NullPointerException if either of the parameters is null",
      "@param i first path parameter",
      "@param j second path paramter",
      "@param m first sample size",
      "@param n second sample size",
      "@param cmn integral D-statistic (see {@link #calculateIntegralD(double, int, int, boolean)})",
      "@param strict whether or not the null hypothesis uses strict inequality",
      "@return C(i,j) for given m, n, c",
      "@param j second path parameter",
      "@param cnm integral D-statistic (see {@link #calculateIntegralD(double, int, int, boolean)})",
      "@return number or paths to (i, j) from (0,0) representing D-values as large as c for given m, n",
      "@param rng random data generator used by {@link #monteCarloP(double, int, int, boolean, int)}",
      "@param values data array to store (may be null to remove stored data)",
      "@return copy of the stored data array (may be null)",
      "@return reference to the stored data array (may be null)",
      "@param values data array to store",
      "@param begin the index of the first element to include",
      "@param length the number of elements to include",
      "@return the value of the statistic applied to the stored data",
      "@param values the input array"
   ],
   [
      "@param begin index of the first array element to include",
      "@return true if the parameters are valid and designate a subarray of positive length",
      "@throws MathIllegalArgumentException if the indices are invalid or the array is null",
      "@param allowEmpty if <code>true</code> then zero length arrays are allowed",
      "@return true if the parameters are valid",
      "@param weights the weights array",
      "@param values the input array.",
      "@param weights the weights array.",
      "@param begin index of the first array element to include.",
      "@param length the number of elements to include.",
      "@param allowEmpty if {@code true} than allow zero length arrays to pass.",
      "@return {@code true} if the parameters are valid.",
      "@throws NullArgumentException if either of the arrays are null",
      "@throws MathIllegalArgumentException if the array indices are not valid,\nthe weights array contains NaN, infinite or negative elements, or there\nare no positive weights.",
      "@return Current values of statistics",
      "@return The number of available values",
      "@return The sum or <code>Double.NaN</code> if no values have been added",
      "@return The sum of squares",
      "@return the mean",
      "@return the standard deviation",
      "@return The quadratic mean or {@code Double.NaN} if no values\nhave been added.",
      "@return the variance",
      "@return the population variance",
      "@return the maximum",
      "@return the minimum"
   ],
   [
      "@return the geometric mean",
      "@return the sum of logs",
      "@return second central moment statistic",
      "@return String with line feeds displaying statistics",
      "@param object the object to test equality against.",
      "@return true if object equals this",
      "@return hash code",
      "@return the StorelessUnivariateStatistic implementing the sum",
      "@param sumImpl the StorelessUnivariateStatistic instance to use for\n       computing the Sum",
      "@throws MathIllegalStateException if data has already been added (i.e if n >0)",
      "@return the StorelessUnivariateStatistic implementing the sum of squares",
      "@param sumsqImpl the StorelessUnivariateStatistic instance to use for\n       computing the sum of squares",
      "@throws MathIllegalStateException if data has already been added (i.e if n > 0)",
      "@return the StorelessUnivariateStatistic implementing the minimum",
      "@param minImpl the StorelessUnivariateStatistic instance to use for\n       computing the minimum",
      "@return the StorelessUnivariateStatistic implementing the maximum",
      "@param maxImpl the StorelessUnivariateStatistic instance to use for\n       computing the maximum",
      "@return the StorelessUnivariateStatistic implementing the log sum",
      "@param sumLogImpl the StorelessUnivariateStatistic instance to use for\n       computing the log sum",
      "@return the StorelessUnivariateStatistic implementing the geometric mean",
      "@param geoMeanImpl the StorelessUnivariateStatistic instance to use for\n       computing the geometric mean",
      "@return the StorelessUnivariateStatistic implementing the mean",
      "@param meanImpl the StorelessUnivariateStatistic instance to use for\n       computing the mean",
      "@return the StorelessUnivariateStatistic implementing the variance",
      "@param varianceImpl the StorelessUnivariateStatistic instance to use for\n       computing the variance"
   ],
   [
      "@throws MathIllegalStateException if data has been added",
      "@param source SummaryStatistics to copy",
      "@param dest SummaryStatistics to copy to",
      "@param original the {@code SummaryStatistics} instance to copy",
      "@param v the value to be added",
      "@throws MathIllegalStateException if there are no elements stored",
      "@param v the value to replace the most recent stored value",
      "@return replaced value",
      "@return The mean or Double.NaN if no values have been added.",
      "@return The geometricMean, Double.NaN if no values have been added,\nor if any negative values have been added.",
      "@return The variance, Double.NaN if no values have been added\nor 0.0 for a single value set.",
      "@return The population variance, Double.NaN if no values have been added,\nor 0.0 for a single value set.",
      "@return The standard deviation, Double.NaN if no values have been added\nor 0.0 for a single value set.",
      "@return The skewness, Double.NaN if less than 3 values have been added.",
      "@return The kurtosis, Double.NaN if less than 4 values have been added.",
      "@return The max or Double.NaN if no values have been added.",
      "@return The min or Double.NaN if no values have been added.",
      "@return The sum or Double.NaN if no values have been added",
      "@return The sum of the squares or Double.NaN if no\nvalues have been added.",
      "@return The current window size or -1 if its Infinite.",
      "@param windowSize sets the size of the window.",
      "@return returns the current set of numbers in the order in which they\n        were added to this set",
      "@return returns the current set of\nnumbers sorted in ascending order",
      "@param index The Index of the element",
      "@return return the element at the specified index"
   ],
   [
      "@param p the requested percentile (scaled from 0 - 100)",
      "@return An estimate for the pth percentile of the stored data",
      "@throws MathIllegalStateException if percentile implementation has been\n overridden and the supplied implementation does not support setQuantile",
      "@throws MathIllegalArgumentException if p is not a valid quantile",
      "@param stat the statistic to apply",
      "@return the computed value of the statistic.",
      "@return the UnivariateStatistic implementing the mean",
      "@param meanImpl the UnivariateStatistic instance to use\nfor computing the mean",
      "@return the UnivariateStatistic implementing the geometric mean",
      "@param geometricMeanImpl the UnivariateStatistic instance to use\nfor computing the geometric mean",
      "@return the UnivariateStatistic implementing the kurtosis",
      "@param kurtosisImpl the UnivariateStatistic instance to use\nfor computing the kurtosis",
      "@return the UnivariateStatistic implementing the maximum",
      "@param maxImpl the UnivariateStatistic instance to use\nfor computing the maximum",
      "@return the UnivariateStatistic implementing the minimum",
      "@param minImpl the UnivariateStatistic instance to use\nfor computing the minimum",
      "@return the UnivariateStatistic implementing the percentile",
      "@param percentileImpl the percentileImpl to set",
      "@throws MathIllegalArgumentException if the supplied implementation does not\n provide a <code>setQuantile</code> method",
      "@return the UnivariateStatistic implementing the skewness",
      "@param skewnessImpl the UnivariateStatistic instance to use\nfor computing the skewness",
      "@return the UnivariateStatistic implementing the variance",
      "@param varianceImpl the UnivariateStatistic instance to use\nfor computing the variance",
      "@return the UnivariateStatistic implementing the sum of squares",
      "@param sumsqImpl the UnivariateStatistic instance to use\nfor computing the sum of squares"
   ],
   [
      "@return the UnivariateStatistic implementing the sum",
      "@param sumImpl the UnivariateStatistic instance to use\nfor computing the sum",
      "@return a copy of this",
      "@param source DescriptiveStatistics to copy",
      "@param dest DescriptiveStatistics to copy to",
      "@param window the window size.",
      "@param initialDoubleArray the initial double[].",
      "@param original DescriptiveStatistics instance to copy",
      "@param value the n-tuple to add",
      "@throws DimensionMismatchException if the length of the array\ndoes not match the one used at construction",
      "@return The dimension of the data",
      "@param stats univariate statistic array",
      "@return results array",
      "@return the array of component sums",
      "@return the array of component sums of squares",
      "@return the array of component log sums",
      "@return the array of component means",
      "@return the array of component standard deviations",
      "@return the covariance matrix",
      "@return the array of component maxima",
      "@return the array of component minima",
      "@return the array of component geometric means",
      "@param buffer buffer to fill",
      "@param data data array",
      "@param prefix text prefix"
   ],
   [
      "@param separator elements separator",
      "@param suffix text suffix",
      "@param newImpl new implementations for statistics",
      "@param oldImpl old implementations for statistics",
      "@throws DimensionMismatchException if the array dimension\ndoes not match the one used at construction",
      "@throws MathIllegalStateException if data has already been added\n(i.e. if n > 0)",
      "@param sumImpl the StorelessUnivariateStatistic instance to use\nfor computing the Sum",
      "@throws MathIllegalStateException if data has already been added\n (i.e if n > 0)",
      "@param sumsqImpl the StorelessUnivariateStatistic instance to use\nfor computing the sum of squares",
      "@param minImpl the StorelessUnivariateStatistic instance to use\nfor computing the minimum",
      "@param maxImpl the StorelessUnivariateStatistic instance to use\nfor computing the maximum",
      "@param sumLogImpl the StorelessUnivariateStatistic instance to use\nfor computing the log sum",
      "@param geoMeanImpl the StorelessUnivariateStatistic instance to use\nfor computing the geometric mean",
      "@param meanImpl the StorelessUnivariateStatistic instance to use\nfor computing the mean",
      "@throws MathIllegalStateException if n > 0.",
      "@param dimension dimension to check",
      "@throws DimensionMismatchException if dimension != k",
      "@param k dimension of the data",
      "@param isCovarianceBiasCorrected if true, the unbiased sample\ncovariance is computed, otherwise the biased population covariance\nis computed",
      "@param source SecondMoment to copy",
      "@param dest SecondMoment to copy to",
      "@param original the {@code SecondMoment} instance to copy",
      "@return the mean of the values or Double.NaN if length = 0",
      "@throws MathIllegalArgumentException if the parameters are not valid",
      "@param source Mean to copy"
   ],
   [
      "@param dest Mean to copy to",
      "@param m1 the moment",
      "@param original the {@code Mean} instance to copy",
      "@param source FourthMoment to copy",
      "@param dest FourthMoment to copy to",
      "@param original the {@code FourthMoment} instance to copy",
      "@return the variance of the values or Double.NaN if length = 0",
      "@return the weighted variance of the values or Double.NaN if length = 0",
      "@return the weighted variance of the values",
      "@param mean the precomputed mean value",
      "@return the variance of the values or Double.NaN if the array is empty",
      "@param mean the precomputed weighted mean value",
      "@return Returns the isBiasCorrected.",
      "@param source Variance to copy",
      "@param dest Variance to copy to",
      "@param m2 the SecondMoment (Third or Fourth moments work\nhere as well.)",
      "@param isBiasCorrected setting for bias correction - true means\nbias will be corrected and is equivalent to using the argumentless\nconstructor",
      "@param isBiasCorrected setting for bias correction - true means\nbias will be corrected",
      "@param original the {@code Variance} instance to copy",
      "@return the kurtosis of the values or Double.NaN if length is less than 4",
      "@param source Kurtosis to copy",
      "@param dest Kurtosis to copy to",
      "@param m4 external Moment",
      "@param original the {@code Kurtosis} instance to copy",
      "@param values input array containing the values"
   ],
   [
      "@param begin first array element to include",
      "@return the geometric mean or Double.NaN if length = 0 or\nany of the values are &lt;= 0.",
      "@param source GeometricMean to copy",
      "@param dest GeometricMean to copy to",
      "@throws MathIllegalStateException if data has been added to this statistic",
      "@param original the {@code GeometricMean} instance to copy",
      "@param sumOfLogs sum of logs instance to use for computation",
      "@return the standard deviation of the values or Double.NaN if length = 0",
      "@param isBiasCorrected The isBiasCorrected to set.",
      "@param source StandardDeviation to copy",
      "@param dest StandardDeviation to copy to",
      "@param m2 the external moment",
      "@param original the {@code StandardDeviation} instance to copy",
      "@param isBiasCorrected whether or not the variance computation will use\nthe bias-corrected formula",
      "@param v vector to add",
      "@throws DimensionMismatchException if the vector does not have the right dimension",
      "@return covariance matrix",
      "@return number of vectors in the sample",
      "@param dimension vectors dimension",
      "@param isBiasCorrected if true, computed the unbiased sample covariance,\notherwise computes the biased population covariance",
      "@param source ThirdMoment to copy",
      "@param dest ThirdMoment to copy to",
      "@param original the {@code ThirdMoment} instance to copy",
      "@param source SemiVariance to copy",
      "@param dest SemiVariance to copy to"
   ],
   [
      "@param start index of the first array element to include",
      "@return the SemiVariance",
      "@param direction the {@link Direction} of the semivariance",
      "@param cutoff the reference point",
      "@param corrected the BiasCorrection flag",
      "@return the value of biasCorrected.",
      "@param biasCorrected new biasCorrected property value",
      "@return the varianceDirection",
      "@param varianceDirection the direction of the semivariance",
      "@param biasCorrected setting for bias correction - true means\nbias will be corrected and is equivalent to using the argumentless\nconstructor",
      "@param direction setting for the direction of the SemiVariance\nto calculate",
      "@param corrected setting for bias correction - true means\nbias will be corrected and is equivalent to using the argumentless\nconstructor",
      "@param original the {@code SemiVariance} instance to copy",
      "@param source FirstMoment to copy",
      "@param dest FirstMoment to copy to",
      "@param original the {@code FirstMoment} instance to copy",
      "@return the skewness of the available values.",
      "@param begin the index of the first array element to include",
      "@return the skewness of the values or Double.NaN if length is less than\n3",
      "@param source Skewness to copy",
      "@param dest Skewness to copy to",
      "@param m3 external moment",
      "@param original the {@code Skewness} instance to copy",
      "@return mean vector",
      "@return Returns the max."
   ],
   [
      "@return Returns the mean.",
      "@return Returns the min.",
      "@return Returns the number of values.",
      "@return Returns the sum.",
      "@return Returns the standard deviation",
      "@return Returns the variance.",
      "@param mean the sample mean",
      "@param variance the sample variance",
      "@param n the number of observations in the sample",
      "@param max the maximum value",
      "@param min the minimum value",
      "@param sum the sum of the values",
      "@param d the new value.",
      "@param values array holding the new values to add",
      "@param start the array index of the first value to add",
      "@param length the number of elements to add",
      "@return value of the statistic, <code>Double.NaN</code> if it\nhas been cleared or just instantiated.",
      "@return the number of values.",
      "@return a copy of the statistic",
      "@return The covariance, null if no multivariate sample\nhave been added or a zeroed matrix for a single value set.",
      "@return Current values of aggregate statistics",
      "@return a {@code SummaryStatistics} whose data will be aggregated with\n     those of this {@code AggregateSummaryStatistics}.  The initial state\n     is a copy of the configured prototype statistics.",
      "@param statistics collection of SummaryStatistics to aggregate",
      "@return summary statistics for the combined dataset",
      "@param prototypeStatistics a {@code SummaryStatistics} serving as a\n     prototype both for the internal aggregate statistics and for\n     contributing statistics obtained via the\n     {@code createContributingStatistics()} method.  Being a prototype\n     means that other objects are initialized by copying this object's state.\n     If {@code null}, a new, default statistics object is used.  Any statistic\n     values in the prototype are propagated to contributing statistics\n     objects and (once) into these aggregate statistics."
   ],
   [
      "@param prototypeStatistics a {@code SummaryStatistics} serving as a\n     prototype both for the internal aggregate statistics and for\n     contributing statistics obtained via the\n     {@code createContributingStatistics()} method.  Being a prototype\n     means that other objects are initialized by copying this object's state.\n     If {@code null}, a new, default statistics object is used.  Any statistic\n     values in the prototype are propagated to contributing statistics\n     objects, but not into these aggregate statistics.",
      "@param initialStatistics a {@code SummaryStatistics} to serve as the\n     internal aggregate statistics object.  If {@code null}, a new, default\n     statistics object is used.",
      "@param values input array",
      "@param weights array of weights",
      "@return the value of the weighted statistic applied to the input array",
      "@throws MathIllegalArgumentException if either array is null, lengths\ndo not match, weights contain NaN, negative or infinite values, or\nweights does not include at least on positive value",
      "@return the value of the weighted statistic applied to the included array entries",
      "@throws MathIllegalArgumentException if either array is null, lengths\ndo not match, indices are invalid, weights contain NaN, negative or\ninfinite values, or weights does not include at least on positive value",
      "@param source SynchronizedSummaryStatistics to copy",
      "@param dest SynchronizedSummaryStatistics to copy to",
      "@param original the {@code SynchronizedSummaryStatistics} instance to copy",
      "@return the value of the statistic applied to the input array",
      "@return the value of the statistic applied to the included array entries",
      "@param p the percentile value to compute",
      "@param values input array of values",
      "@return the percentile value or Double.NaN if the array is empty",
      "@return the percentile value",
      "@param values array of input values",
      "@param p the percentile to compute",
      "@param begin the first (0-based) element to include in the computation",
      "@param length the number of array elements to include",
      "@throws MathIllegalArgumentException if the parameters are not valid or the\ninput array is null",
      "@param work data array",
      "@param begin index of the first element of the slice",
      "@param end index after the last element of the slice"
   ],
   [
      "@return the index of the median element chosen between the\nfirst, the middle and the last element of the array slice",
      "@return quantile set while construction or {@link #setQuantile(double)}",
      "@param p a value between 0 < p <= 100",
      "@param source Percentile to copy",
      "@param dest Percentile to copy to",
      "@throws MathUnsupportedOperationException always thrown since 3.4",
      "@param values the array of numbers",
      "@param begin index to start reading the array",
      "@param length the length of array to be read from the begin index",
      "@return work array sliced from values in the range [begin,begin+length)",
      "@throws MathIllegalArgumentException if values or indices are invalid",
      "@param begin start index of the array to include",
      "@param length number of elements to include from begin",
      "@return copy of a slice of the original array",
      "@param original the value to be replaced with",
      "@param replacement the value to be used for replacement",
      "@return the copy of sliced array with replaced values",
      "@param removedValue the value to be removed from the sliced array",
      "@return the copy of the sliced array after removing the removedValue",
      "@param values array containing the input numbers",
      "@return cached pivots or a newly created one",
      "@return the {@code estimationType} set",
      "@param newEstimationType estimation type for the new instance",
      "@return a new instance, with changed estimation type",
      "@return {@code NaN Handling} strategy set during construction"
   ],
   [
      "@param newNaNStrategy NaN strategy for the new instance",
      "@return a new instance, with changed NaN handling strategy",
      "@return the {@code kthSelector} set",
      "@return the pivoting strategy set",
      "@param newKthSelector KthSelector for the new instance",
      "@return a new instance, with changed KthSelector",
      "@param quantile the quantile",
      "@throws MathIllegalArgumentException if p is not greater than 0 and less\nthan or equal to 100",
      "@param original the {@code Percentile} instance to copy",
      "@param quantile the quantile to be computed",
      "@param estimationType one of the percentile {@link EstimationType  estimation types}",
      "@param nanStrategy one of {@link NaNStrategy} to handle with NaNs",
      "@param kthSelector a {@link KthSelector} to use for pivoting during search",
      "@throws MathIllegalArgumentException if p is not within (0,100]",
      "@return the maximum of the values or Double.NaN if length = 0",
      "@param source Max to copy",
      "@param dest Max to copy to",
      "@param original the {@code Max} instance to copy",
      "@param o object to compare",
      "@return true if {@code o} is a {@code PSquarePercentile} with\nequivalent internal state",
      "@param observation the observation currently being added.",
      "@return string representation of state data",
      "@return quantile estimated by {@link #getResult()}",
      "@return maximum in the data set added to this statistic",
      "@return minimum in the data set added to this statistic"
   ],
   [
      "@param initialFive list of initial five elements",
      "@param p the quantile desired",
      "@return an instance of PSquareMarkers",
      "@param p the percentile",
      "@return the minimum of the values or Double.NaN if length = 0",
      "@param source Min to copy",
      "@param dest Min to copy to",
      "@param original the {@code Min} instance to copy",
      "@param original the {@code Median} instance to copy",
      "@param kthSelector {@link KthSelector} to use for pivoting during search",
      "@throws NullArgumentException if type or NaNStrategy passed is null",
      "@param source SynchronizedDescriptiveStatistics to copy",
      "@param dest SynchronizedDescriptiveStatistics to copy to",
      "@param window the finite window size.",
      "@param original the {@code SynchronizedDescriptiveStatistics} instance to copy",
      "@param source SumOfSquares to copy",
      "@param dest SumOfSquares to copy to",
      "@param original the {@code SumOfSquares} instance to copy",
      "@return the product of the values or Double.NaN if length = 0",
      "@param source Product to copy",
      "@param dest Product to copy to",
      "@param original the {@code Product} instance to copy",
      "@return the sum of the values or Double.NaN if length = 0",
      "@param source Sum to copy",
      "@param dest Sum to copy to"
   ],
   [
      "@param original the {@code Sum} instance to copy",
      "@param source SumOfLogs to copy",
      "@param dest SumOfLogs to copy to",
      "@param original the {@code SumOfLogs} instance to copy",
      "@param values values to add",
      "@param values array holding values to add",
      "@param begin index of the first array element to add",
      "@param length number of array elements to add",
      "@param object object to test equality against.",
      "@return true if object returns the same value as this",
      "@param x independent variable value",
      "@param y dependent variable value",
      "@param reg model to append data from",
      "@param data array of observations to be added",
      "@throws ModelSpecificationException if the length of {@code data[i]} is not\ngreater than or equal to 2",
      "@param x the independent variables which form the design matrix",
      "@param y the dependent or response variable",
      "@throws NotStrictlyPositiveException if the number of {@code crossoverPoints} is not strictly positive",
      "@throws MathIllegalArgumentException iff one of the chromosomes is\n  not an instance of {@link AbstractListChromosome}",
      "@throws NotStrictlyPositiveException if {@code scale <= 0} or {@code shape <= 0}.",
      "@param isLast true if the step is the last one",
      "@param minimalStep minimal step (must be positive even for backward\nintegration), the last step can be smaller than this",
      "@param maximalStep maximal step (must be positive even for backward\nintegration)",
      "@param initialStepSize initial step size to use (must be positive even\nfor backward integration ; providing a negative value or a value\noutside of the min/max step interval will lead the integrator to\nignore the value and compute the initial step size by itself)",
      "@param newInitialStepBoundFactor Positive input variable used in\ndetermining the initial step bound. This bound is set to the\nproduct of initialStepBoundFactor and the euclidean norm of\n{@code diag * x} if non-zero, or else to {@code newInitialStepBoundFactor}\nitself. In most cases factor should lie in the interval\n{@code (0.1, 100.0)}. {@code 100} is a generally recommended value.\nof the matrix is reduced."
   ],
   [
      "@throws org.apache.commons.math3.exception.NullArgumentException if\n{@code f}, {@code goalType} or {@code startPoint} is {@code null}.",
      "@throws NumberIsTooSmallException if {@code numComponents < 2}.",
      "@throws NotStrictlyPositiveException if {@code abs <= 0}.",
      "@throws OutOfRangeException if the space dimension is outside the allowed range of [1, 1000]",
      "@throws NotPositiveException if index &lt; 0",
      "@throws NumberIsTooLargeException if {@code lo >= hi}.",
      "@throws OutOfRangeException if {@code init < lo} or {@code init > hi}.",
      "@return the sum of the squares of the values or 0 if length = 0",
      "@throws org.apache.commons.math3.exception.NullArgumentException if\nany argument is {@code null}.",
      "@throws NotPositiveException if the number of elements is not positive.",
      "@throws NumberIsTooSmallException if {@code end < start}",
      "@throws MathArithmeticException if the norm is zero.",
      "@throws MathArithmeticException if {@code this} or {@code v} is the null\nvector",
      "@throws DimensionMismatchException if the dimensions of {@code this} and\n{@code v} do not match",
      "@throws DimensionMismatchException if {@code v} is not the same size as\n{@code this} vector.",
      "@throws DimensionMismatchException if {@code y} is not the same size as\n{@code this} vector.",
      "@param initialStepBoundFactor Positive input variable used in\ndetermining the initial step bound. This bound is set to the\nproduct of initialStepBoundFactor and the euclidean norm of\n{@code diag * x} if non-zero, or else to {@code initialStepBoundFactor}\nitself. In most cases factor should lie in the interval\n{@code (0.1, 100.0)}. {@code 100} is a generally recommended value.",
      "@param starts Number of starts to perform. If {@code starts == 1},\nthe {@link #optimize(int,MultivariateFunction,GoalType,double[])\noptimize} will return the same solution as {@code optimizer} would.",
      "@return the tree node containing the smallest element in the tree\nor null if the tree is empty",
      "@return the tree node containing the largest element in the tree\nor null if the tree is empty",
      "@return the tree node containing the smallest element not smaller\nthan the reference object or null if either the tree is empty or\nall its elements are smaller than the reference object",
      "@return the tree node containing the largest element not larger\nthan the reference object (in which case the node is guaranteed\nnot to be empty) or null if either the tree is empty or all its\nelements are larger than the reference object",
      "@throws NotStrictlyPositiveException if {@code degreesOfFreedom <= 0}",
      "@return a convergence checker that delegates to {@code checker}.",
      "@return projected point"
   ],
   [
      "@return real value",
      "@param a right hand side parameter of the operator",
      "@return this+a",
      "@return this-a",
      "@return this&times;a",
      "@return this&divide;a",
      "@throws ModelSpecificationException if the length of {@code x} does not equal\nthe number of independent variables in the model",
      "@param x a series of observations on the independent variables",
      "@param y a series of observations on the dependent variable\nThe length of x and y must be the same",
      "@throws ModelSpecificationException if {@code x} is not rectangular, does not match\nthe length of {@code y} or does not contain sufficient data to estimate the model",
      "@param data array of observations to be removed",
      "@return n number of observations that have been added.",
      "@param x input <code>x</code> value",
      "@return the intercept of the regression line if the model includes an\nintercept; 0 otherwise",
      "@return true if the regression includes an intercept; false otherwise",
      "@return the slope of the regression line",
      "@return sum of squared errors associated with the regression model",
      "@return sum of squared deviations of y values",
      "@return sum of squared deviations of x values",
      "@return sum of cross products",
      "@return sum of squared deviations of predicted y values",
      "@return Pearson's r",
      "@return r-square",
      "@return standard error associated with intercept estimate",
      "@return standard error associated with slope estimate"
   ],
   [
      "@return half-width of 95% confidence interval for the slope estimate",
      "@throws OutOfRangeException if the confidence interval can not be computed.",
      "@param alpha the desired significance level",
      "@return significance level for slope/correlation",
      "@throws org.apache.commons.math3.exception.MaxCountExceededException if the significance level can not be computed.",
      "@param slope current slope",
      "@return the intercept of the regression line",
      "@param slope regression slope estimate",
      "@return RegressionResults acts as a container of regression output",
      "@throws ModelSpecificationException if the model is not correctly specified",
      "@throws NoDataException if there is not sufficient data in the model to\nestimate the regression parameters",
      "@param variablesToInclude an array of indices of regressors to include",
      "@throws OutOfRangeException if a requested variable is not present in model",
      "@param includeIntercept whether or not to include an intercept term in\nthe regression model",
      "@return true if constant exists, false otherwise",
      "@return Number of observations",
      "@return the X sample data.",
      "@return the Y sample data.",
      "@return true if the model has no intercept term; false otherwise",
      "@param data input data array",
      "@param nobs number of observations (rows)",
      "@param nvars number of independent variables (columns, not counting y)",
      "@throws DimensionMismatchException if the length of the data array is not equal\nto <code>nobs * (nvars + 1)</code>",
      "@param y the array representing the y sample",
      "@param x the rectangular array representing the x sample"
   ],
   [
      "@throws DimensionMismatchException if x is not rectangular",
      "@param x the [n,k] array representing the x data",
      "@param y the [n,1] array representing the y data",
      "@throws DimensionMismatchException if {@code x} and {@code y} do not\nhave the same length",
      "@throws MathIllegalArgumentException if the number of rows of {@code x}\nis not larger than the number of columns + 1",
      "@param x the [n,k] array representing the x sample",
      "@param covariance the [n,n] array representing the covariance matrix",
      "@throws DimensionMismatchException if the number of rows in x is not equal\nto the number of rows in covariance",
      "@throws NonSquareMatrixException if the covariance matrix is not square",
      "@return estimate of the error variance",
      "@return regression standard error",
      "@return beta",
      "@return beta variance",
      "@return Y variance",
      "@return error variance estimate",
      "@return The residuals [n,1] matrix",
      "@param y y values of the sample",
      "@param x x values of the sample",
      "@param covariance array representing the covariance matrix",
      "@param omega the [n,n] array representing the covariance",
      "@return inverse of the covariance",
      "@return The beta variance matrix",
      "@return error variance",
      "@param pattern message pattern describing the specification error.",
      "@param args arguments."
   ],
   [
      "@param index Index.",
      "@return the parameters estimated for regressor at index.",
      "@throws OutOfRangeException if {@code index} is not in the interval\n{@code [0, number of parameters)}.",
      "@return array of parameter estimates, null if no estimation occurred",
      "@return the standard errors associated with parameters estimated at index.",
      "@return an array standard errors associated with parameters estimates,\n null if no estimation occurred",
      "@param i {@code i}th regression parameter.",
      "@param j {@code j}th regression parameter.",
      "@return the covariance of the parameter estimates.",
      "@throws OutOfRangeException if {@code i} or {@code j} is not in the\ninterval {@code [0, number of parameters)}.",
      "@return number of regressors, -1 if not estimated",
      "@return Number of observations, -1 if an error condition prevents estimation",
      "@return r-square, a double in the interval [0, 1]",
      "@return adjusted R-Squared statistic",
      "@return true if the model has an intercept term",
      "@param i first variable index",
      "@param j second variable index",
      "@return the requested variance-covariance matrix entry",
      "@param parameters a double array with the regression slope estimates",
      "@param varcov the variance covariance matrix, stored either in a square matrix\nor as a compressed",
      "@param isSymmetricCompressed a flag which denotes that the variance covariance\nmatrix is in symmetric compressed format",
      "@param nobs the number of observations of the regression estimation",
      "@param rank the number of independent variables in the regression",
      "@param sumy the sum of the independent variable",
      "@param sumysq the sum of the squared independent variable"
   ],
   [
      "@param sse sum of squared errors",
      "@param containsConstant true model has constant,  false model does not have constant",
      "@param copyData if true a deep copy of all input data is made, if false only references\nare copied and the RegressionResults become mutable",
      "@return true regression has an intercept, false no intercept",
      "@return number of observations",
      "@param x the array with regressor values",
      "@param y the value of dependent variable given these regressors",
      "@param x observations on the regressors",
      "@param y observations on the regressand",
      "@param wi weight of the this observation (-1,1)",
      "@param yi observation on the regressand",
      "@param a - an addend",
      "@param b - an addend",
      "@return the sum of the a and b",
      "@param nreq how many of the regressors to include (either in canonical\norder, or in the current reordered state)",
      "@return an array with the estimated slope coefficients",
      "@throws ModelSpecificationException if {@code nreq} is less than 1\nor greater than the number of independent variables",
      "@return an array with the variance covariance of the included\nregressors in lower triangular form",
      "@param rinv the storage for the inverse of r",
      "@param in how many of the regressors to include (either in canonical\norder, or in the current reordered state)",
      "@return an array with the partial correlations of the remainder of\nregressors with each other and the regressand, in lower triangular form",
      "@param from initial position",
      "@param to destination",
      "@param list the regressors to move",
      "@param pos1 where the list will be placed"
   ],
   [
      "@return -1 error, 0 everything ok",
      "@param row_data returns the diagonal of the hat matrix for this observation",
      "@return the diagonal element of the hatmatrix",
      "@return int[] with the current order of the regressors",
      "@return RegressionResults the structure holding all regression results",
      "@throws ModelSpecificationException - thrown if number of observations is\nless than the number of variables",
      "@param numberOfRegressors many of the regressors to include (either in canonical\norder, or in the current reordered state)",
      "@throws ModelSpecificationException - thrown if number of observations is\nless than the number of variables or number of regressors requested\nis greater than the regressors in the model",
      "@param variablesToInclude array of variables to include in regression",
      "@throws ModelSpecificationException - thrown if number of observations is\nless than the number of variables, the number of regressors requested\nis greater than the regressors in the model or a regressor index in\nregressor array does not exist",
      "@param numberOfVariables number of regressors to expect, not including constant",
      "@param includeConstant include a constant automatically",
      "@param errorTolerance zero tolerance, how machine zero is determined",
      "@throws ModelSpecificationException if {@code numberOfVariables is less than 1}",
      "@param numberOfVariables maximum number of potential regressors",
      "@param y the [n,1] array representing the y sample",
      "@throws MathIllegalArgumentException if the x and y array data are not\n            compatible for the regression",
      "@return the hat matrix",
      "@throws NullPointerException unless method {@code newSampleData} has been\ncalled beforehand.",
      "@return SSTO - the total sum of squares",
      "@throws NullPointerException if the sample has not been set",
      "@return residual sum of squares",
      "@throws org.apache.commons.math3.linear.SingularMatrixException if the design matrix is singular",
      "@throws NullPointerException if the data for the model have not been loaded",
      "@return R-square statistic"
   ],
   [
      "@return The beta variance-covariance matrix",
      "@param threshold the singularity threshold",
      "@return The [k,1] array representing b",
      "@return The [k,k] array representing the variance of b",
      "@return The [n,1] array representing the residuals",
      "@return The double representing the variance of y",
      "@return standard errors of estimated regression parameters",
      "@return a string representation.",
      "@param v the value to add.",
      "@throws MathIllegalArgumentException if <code>v</code> is not comparable with previous entries",
      "@throws MathIllegalArgumentException if the table contains entries not\ncomparable to Long",
      "@throws MathIllegalArgumentException if the table contains entries not\ncomparable to Char",
      "@param increment the amount by which the value should be incremented",
      "@return values Iterator",
      "@return entry set Iterator",
      "@return the total frequency count.",
      "@param v the value to lookup.",
      "@return the frequency of v.",
      "@return the number of unique values that have been added to the frequency table.",
      "@param v the value to lookup",
      "@return the proportion of values equal to v",
      "@return the proportion of values less than or equal to v",
      "@return a list containing the value(s) which appear most often.",
      "@param other the other {@link Frequency} object to be merged",
      "@param others the other {@link Frequency} objects to be merged"
   ],
   [
      "@param comparator Comparator used to order values",
      "@param a the first vector",
      "@param b the second vector",
      "@return the distance between the two vectors",
      "@throws DimensionMismatchException if the array lengths differ.",
      "@return chosen cluster center",
      "@param center the point which is to be the center of this cluster",
      "@return maximum radius of the neighborhood",
      "@return minimum number of points needed for a cluster",
      "@param points the points to cluster",
      "@return the list of clusters",
      "@param cluster Cluster to expand",
      "@param point Point to add to cluster",
      "@param neighbors List of neighbors",
      "@param points the data set",
      "@param visited the set of already visited points",
      "@return the expanded cluster",
      "@param point the point to look for",
      "@param points possible neighbors",
      "@return the List of neighbors",
      "@param one first list",
      "@param two second list",
      "@return merged lists",
      "@param eps maximum radius of the neighborhood to be considered",
      "@param minPts minimum number of points needed for a cluster"
   ],
   [
      "@param measure the distance measure to use",
      "@param point point to add",
      "@return points contained in the cluster",
      "@return the embedded clusterer",
      "@return the number of trials",
      "@return the used {@link ClusterEvaluator}",
      "@return a list of clusters containing the points",
      "@throws ConvergenceException if an empty cluster is encountered and the\n  underlying {@link KMeansPlusPlusClusterer} has its\n  {@link KMeansPlusPlusClusterer.EmptyClusterStrategy} is set to {@code ERROR}.",
      "@param clusterer the k-means clusterer to use",
      "@param numTrials number of trial runs",
      "@param evaluator the cluster evaluator to use",
      "@return the point array",
      "@return the number of clusters",
      "@return the fuzziness factor",
      "@return the maximum number of iterations, or -1 if no maximum is set",
      "@return the convergence criteria",
      "@return the random generator",
      "@return the membership matrix",
      "@throws MathIllegalStateException if {@link #cluster(Collection)} has not been called before",
      "@return the list of data points, or {@code null} if {@link #cluster(Collection)} has\n  not been called before.",
      "@return the list of clusters, or {@code null} if {@link #cluster(Collection)} has\n  not been called before.",
      "@return the objective function evaluation as double value",
      "@param dataPoints the points to cluster",
      "@param matrix the membership matrix of the previous iteration",
      "@return the maximum membership matrix change"
   ],
   [
      "@param matrix the place to store the membership matrix",
      "@param k the number of clusters to split the data into",
      "@param maxIterations the maximum number of iterations to run the algorithm for.\n  If negative, no maximum will be used.",
      "@param epsilon the convergence criteria (default is 1e-3)",
      "@param random random generator to use for choosing initial centers",
      "@return the {@link EmptyClusterStrategy}",
      "@throws ConvergenceException if an empty cluster is encountered and the\n{@link #emptyStrategy} is set to {@code ERROR}",
      "@param clusters the {@link Cluster}s to add the points to",
      "@param points the points to add to the given {@link Cluster}s",
      "@param assignments points assignments to clusters",
      "@return the number of points assigned to different clusters as the iteration before",
      "@param points the points to choose the initial centers from",
      "@return the initial centers",
      "@param clusters the {@link Cluster}s to search",
      "@return a random point from the selected cluster",
      "@throws ConvergenceException if clusters are all empty",
      "@return point farthest to its cluster center",
      "@param point the point to find the nearest {@link Cluster} for",
      "@return the index of the nearest {@link Cluster} to the given point",
      "@param points the set of points",
      "@param dimension the point dimension",
      "@return the computed centroid for the set of points",
      "@param emptyStrategy strategy to use for handling empty clusters that\nmay appear during algorithm iterations",
      "@param clusters the clusters to evaluate",
      "@return the computed score"
   ],
   [
      "@param score1 the first score",
      "@param score2 the second score",
      "@return {@code true} if the first score is considered to be better, {@code false} otherwise",
      "@param p1 the first clusterable",
      "@param p2 the second clusterable",
      "@return the distance between the two clusterables",
      "@param cluster the cluster",
      "@return the computed centroid for the cluster,\nor {@code null} if the cluster does not contain any points",
      "@param points the set of {@link Clusterable} instances",
      "@return a {@link List} of clusters",
      "@throws ConvergenceException if the algorithm has not yet converged after\n  the maximum number of iterations has been exceeded",
      "@return the distance measure",
      "@param point the n-dimensional point in double space",
      "@param point the n-dimensional point in integer space",
      "@param net Network to be trained with the SOFM algorithm.",
      "@param featuresIterator Training data iterator.",
      "@param updateAction SOFM update procedure.",
      "@return the current number of calls.",
      "@param n Neuron to be updated.",
      "@param features Training data.",
      "@param learningRate Learning factor.",
      "@return {@code true} if the update succeeded, {@code true} if a\nconcurrent update has been detected.",
      "@param net Network.",
      "@param features Sample data.",
      "@param learningRate Current learning factor."
   ],
   [
      "@return the winning neuron.",
      "@param current Current values of the features.",
      "@param sample Training data.",
      "@return the new values for the features.",
      "@param distance Distance function.",
      "@param learningFactor Learning factor update function.",
      "@param neighbourhoodSize Neighbourhood size update function.",
      "@param numCall Current step of the training task.",
      "@return the value of the function at {@code numCall}.",
      "@param initValue Initial value, i.e. {@link #value(long) value(0)}.",
      "@param slope Value of the function derivative at {@code numCall}.",
      "@param numCall Inflexion point.",
      "@param valueAtNumCall Value of the function at {@code numCall}.",
      "@param numCall Argument for which the function returns\n{@code valueAtNumCall}.",
      "@param initValue Initial value, i.e.\n{@link NeighbourhoodSizeFunction#value(long) value(0)}.",
      "@return the neighbourhood size function.",
      "@param initValue Initial value, i.e.\n{@link LearningFactorFunction#value(long) value(0)}.",
      "@return the learning factor function.",
      "@param features Data.",
      "@param neurons List of neurons to scan. If the list is empty\n{@code null} will be returned.",
      "@param distance Distance function. The neuron's features are\npassed as the first argument to {@link DistanceMeasure#compute(double[],double[])}.",
      "@return the neuron whose features are closest to the given data.",
      "@throws org.apache.commons.math3.exception.DimensionMismatchException if the size of the input is not compatible with the neurons features\nsize.",
      "@return the two neurons whose features are closest to the given data.",
      "@param neurons List of neurons to scan. If it is empty, an empty array\nwill be returned."
   ],
   [
      "@return the neurons, sorted in increasing order of distance in data\nspace.",
      "@param map Network.",
      "@param distance Function to use for computing the average\ndistance from a neuron to its neighbours.",
      "@return the matrix of average distances.",
      "@param data Feature vectors.",
      "@param distance Function to use for determining the best matching unit.",
      "@return the number of hits for each neuron in the map.",
      "@param neurons List of neurons to scan.",
      "@return the error.",
      "@throws NoDataException if {@code data} is empty.",
      "@return a new instance with the same state as this instance.",
      "@param comparator {@link Comparator} used for sorting the neurons.",
      "@return a list of neurons, sorted in the order prescribed by the\ngiven {@code comparator}.",
      "@param features Initial values for the neuron's features.",
      "@return the neuron's identifier.",
      "@throws DimensionMismatchException if the length of {@code features}\nis different from the expected size (as set by the\n{@link #Network(long,int) constructor}).",
      "@param neuron Neuron to be removed from this network.",
      "@throws NoSuchElementException if {@code n} does not belong to\nthis network.",
      "@return the size of the features set.",
      "@param a Neuron.",
      "@param b Neuron.",
      "@throws NoSuchElementException if the neurons do not exist in the\nnetwork.",
      "@param linkSet Neuron identifier.",
      "@param id Neuron identifier.",
      "@param id Identifier."
   ],
   [
      "@return the neuron associated with the given {@code id}.",
      "@throws NoSuchElementException if the neuron does not exist in the\nnetwork.",
      "@param neurons Neurons for which to retrieve the neighbours.",
      "@return the list of neighbours.",
      "@param exclude Neurons to exclude from the returned list.\nCan be {@code null}.",
      "@param neuron Neuron for which to retrieve the neighbours.",
      "@return a value that will serve as a unique identifier.",
      "@param in Input stream.",
      "@return the proxy instance that will be actually serialized.",
      "@param nextId Next available identifier.",
      "@param featureSize Number of features.",
      "@param neuronList Neurons.",
      "@param neighbourIdList Links associated to each of the neurons in\n{@code neuronList}.",
      "@throws MathIllegalStateException if an inconsistency is detected\n(which probably means that the serialized form has been corrupted).",
      "@param initialIdentifier Identifier for the first neuron that\nwill be added to this network.",
      "@param featureSize Size of the neuron's features.",
      "@param min Lower bound of the range.",
      "@param max Upper bound of the range.",
      "@param rng Random number generator used to draw samples from a\nuniform distribution.",
      "@return an initializer such that the features will be initialized with\nvalues within the given range.",
      "@param f Function.",
      "@param init Initial value.",
      "@param inc Increment",
      "@return the initializer.",
      "@param random Random variable distribution."
   ],
   [
      "@param orig Original initializer.",
      "@return an initializer whose {@link FeatureInitializer#value() value}\nmethod will return {@code orig.value() + random.sample()}.",
      "@return the identifier.",
      "@return the number of features.",
      "@return a copy of the neuron's features.",
      "@param expect Current values of the features, as assumed by the caller.\nUpdate will never succeed if the contents of this array does not match\nthe values returned by {@link #getFeatures()}.",
      "@param update Features's new values.",
      "@return {@code true} if the update was successful, {@code false}\notherwise.",
      "@throws DimensionMismatchException if the length of {@code update} is\nnot the same as specified in the {@link #Neuron(long,double[])\nconstructor}.",
      "@return the number of update attempts.",
      "@return the number of successful updates.",
      "@param current Current values.",
      "@param expect Expected values.",
      "@throws DimensionMismatchException if the length of {@code expected}\nis not the same as specified in the {@link #Neuron(long,double[])\nconstructor}.",
      "@return {@code true} if the arrays contain the same values.",
      "@param identifier Identifier (assigned by the {@link Network}).",
      "@param features Initial values of the feature set.",
      "@return the initial value.",
      "@return the network.",
      "@return the number of neurons.",
      "@param i Neuron index.",
      "@return the features of the neuron at index {@code i}.",
      "@throws OutOfRangeException if {@code i} is out of range.",
      "@param wrap Whether to wrap the dimension (i.e the first and last\nneurons will be linked together).",
      "@param featuresList Arrays that will initialize the features sets of\nthe network's neurons."
   ],
   [
      "@throws NumberIsTooSmallException if {@code num < 2}.",
      "@param num Number of neurons.",
      "@param featureInit Arrays that will initialize the features sets of\nthe network's neurons.",
      "@return the number of rows.",
      "@return the number of column.",
      "@param i Row index.",
      "@param j Column index.",
      "@return the neuron at {@code (i, j)}.",
      "@throws OutOfRangeException if {@code i} or {@code j} is\nout of range.",
      "@param row Row index.",
      "@param col Column index.",
      "@param alongRowDir Direction along the given {@code row} (i.e. an\noffset will be added to the given <em>column</em> index.",
      "@param alongColDir Direction along the given {@code col} (i.e. an\noffset will be added to the given <em>row</em> index.",
      "@return the neuron at the requested location, or {@code null} if\nthe location is not on the map.",
      "@return an array of length 2 containing the indices of the requested\nlocation, or {@code null} if that location is not part of the map.",
      "@param wrapRowDim Whether to wrap the first dimension (i.e the first\nand last neurons will be linked together).",
      "@param wrapColDim Whether to wrap the second dimension (i.e the first\nand last neurons will be linked together).",
      "@param neighbourhoodType Neighbourhood type.",
      "@throws NumberIsTooSmallException if {@code numRows < 2} or\n{@code numCols < 2}.",
      "@param numRows Number of neurons in the first dimension.",
      "@param numCols Number of neurons in the second dimension.",
      "@param featureInit Array of functions that will initialize the\ncorresponding element of the features set of each newly created\nneuron. In particular, the size of this array defines the size of\nfeature set.",
      "@param net Underlying network.",
      "@param idGrid Neuron identifiers.",
      "@throws NumberIsTooSmallException if the size of the {@code map}\nis smaller than the number of {@link #SmoothedDataHistogram(int,DistanceMeasure)\nsmoothing bins}."
   ],
   [
      "@param smoothingBins Number of bins.",
      "@param distance Distance.",
      "@param map Map.",
      "@return an image representing the individual distances.",
      "@return an image representing the average distances.",
      "@param individualDistances If {@code true}, the 8 individual\ninter-units distances will be {@link #computeImage(NeuronSquareMesh2D)\ncomputed}.  They will be stored in additional pixels around each of\nthe original units of the 2D-map.  The additional pixels that lie\nalong a \"diagonal\" are shared by <em>two</em> pairs of units: their\nvalue will be set to the average distance between the units belonging\nto each of the pairs.  The value zero will be stored in the pixel\ncorresponding to the location of a unit of the 2D-map.\n<br>\nIf {@code false}, only the average distance between a unit and all its\nneighbours will be computed (and stored in the pixel corresponding to\nthat unit of the 2D-map).  In that case, the number of neighbours taken\ninto account depends on the network's\n{@link org.apache.commons.math3.ml.neuralnet.SquareNeighbourhood\nneighbourhood type}.",
      "@param data Data.",
      "@return a 2D-array (in row major order) representing the metrics.",
      "@return a 2D-array (in row major order) representing the property.",
      "@param n Neuron.",
      "@return the (row, column) coordinates of {@code n}, or {@code null}\nif no such neuron belongs to the {@link #LocationFinder(NeuronSquareMesh2D)\nmap used to build this instance}.",
      "@throws MathIllegalStateException if the network contains non-unique\nidentifiers.  This indicates an inconsistent state due to a bug in\nthe construction code of the underlying\n{@link org.apache.commons.math3.ml.neuralnet.Network network}.",
      "@param normalizeCount Whether to compute relative bin counts.\nIf {@code true}, the data count in each bin will be divided by the total\nnumber of samples.",
      "@param relativeCount Whether to compute relative bin counts.\nIf {@code true}, the data count in each bin will be divided by the total\nnumber of samples mapped to the neuron represented by that bin.",
      "@return absolute accuracy",
      "@return relative accuracy",
      "@return function accuracy",
      "@param maxEval Maximum number of evaluations.",
      "@param f Function to solve.",
      "@param min Lower bound for the interval.",
      "@param max Upper bound for the interval.",
      "@param allowedSolution The kind of solutions that the root-finding algorithm may\naccept as solutions.",
      "@return a value where the function is zero.",
      "@throws NoBracketingException if root cannot be bracketed",
      "@param startValue Start value to use."
   ],
   [
      "@param relativeAccuracy Relative accuracy.",
      "@param absoluteAccuracy Absolute accuracy.",
      "@param functionValueAccuracy Function value accuracy.",
      "@param maximalOrder maximal order.",
      "@param x Point at which the function value should be computed.",
      "@return the value.",
      "@throws IllegalArgumentException when the activated method itself can\nascertain that preconditions, specified in the API expressed at the\nlevel of the activated method, have been violated.  In the vast\nmajority of cases where Commons-Math throws IllegalArgumentException,\nit is the result of argument checking of actual parameters immediately\npassed to a method.",
      "@return number of decimal digits this class is going to represent",
      "@param factory factory linked to this instance",
      "@param x value to convert to an instance",
      "@param d instance to copy",
      "@param s string representation of the instance",
      "@param sign sign of the Dfp to create",
      "@param field field to which the Dfp must belong",
      "@param a string representation to split",
      "@return an array of two {@link Dfp} which sum is a",
      "@param a number to split",
      "@return two elements array containing the split number",
      "@param a first factor of the multiplication, in split form",
      "@param b second factor of the multiplication, in split form",
      "@return a &times; b, in split form",
      "@param a dividend, in split form",
      "@param b divisor, in split form",
      "@return a / b, in split form",
      "@param base number to raise"
   ],
   [
      "@param a power",
      "@return base<sup>a</sup>",
      "@param a power at which e should be raised",
      "@return e<sup>a</sup>",
      "@param a number from which logarithm is requested",
      "@return log(a)",
      "@param a number from which logarithm is requested, in split form",
      "@param x base to be raised",
      "@param y power to which base should be raised",
      "@return x<sup>y</sup>",
      "@param a number from which sine is desired, in split form",
      "@return sin(a)",
      "@param a number from which cosine is desired, in split form",
      "@return cos(a)",
      "@param a number from which sine is desired",
      "@param a number from which cosine is desired",
      "@param a number from which tangent is desired",
      "@return tan(a)",
      "@param a number from which arc-tangent is desired",
      "@return atan(a)",
      "@param a number from which arc-sine is desired",
      "@return asin(a)",
      "@param a number from which arc-cosine is desired",
      "@return acos(a)",
      "@return a new instance with a value of 0"
   ],
   [
      "@return a new instance with value x",
      "@return a new instance with the same value as d",
      "@return a new instance parsed from specified string",
      "@param sig sign of the Dfp to create",
      "@return a new instance with a non-finite value",
      "@return {@link org.apache.commons.math3.Field Field} (really a {@link DfpField}) to which the instance belongs",
      "@return number of radix digits",
      "@return a Dfp with value zero",
      "@return a Dfp with value one",
      "@return a Dfp with value two",
      "@param e desired exponent",
      "@return last digit destroyed by shifting right",
      "@param x number to check instance against",
      "@return true if instance is less than x and neither are NaN, false otherwise",
      "@return true if instance is greater than x and neither are NaN, false otherwise",
      "@return true if instance is not NaN and less than or equal to 0, false otherwise",
      "@return true if instance is not NaN and greater than or equal to 0, false otherwise",
      "@return absolute value of instance",
      "@return true if instance is infinite",
      "@return true if instance is not a number",
      "@return true if instance is equal to zero",
      "@param other object to check instance against",
      "@return true if instance is equal to x and neither are NaN, false otherwise",
      "@return a hash code value for this object",
      "@return true if instance is not equal to x and neither are NaN, false otherwise"
   ],
   [
      "@param a first instance in comparison",
      "@param b second instance in comparison",
      "@return -1 if a<b, 1 if a>b and 0 if a==b\n Note this method does not properly handle NaNs or numbers with different precision.",
      "@return rounded value",
      "@param d divisor",
      "@return this less n &times; d, where n is the integer closest to this/d",
      "@param rmode rounding mode to use",
      "@return truncated value",
      "@return converted number",
      "@return integer base 10000 logarithm",
      "@param e desired power",
      "@return 10000<sup>e</sup>",
      "@return integer base 10 logarithm",
      "@return 10<sup>e</sup>",
      "@param extra ???",
      "@return ???",
      "@param x number to add",
      "@return sum of this and x",
      "@return the opposite of this",
      "@param x number to subtract",
      "@return difference of this and a",
      "@param n ???",
      "@return the IEEE flag if an exception occurred",
      "@param x multiplicand",
      "@return product of this and x"
   ],
   [
      "@param divisor divisor",
      "@return quotient of this by divisor",
      "@return square root of the instance",
      "@return string representation of the instance",
      "@return string representation of the instance in scientific notation",
      "@return string representation of the instance in normal notation",
      "@param type the trap type",
      "@param what - name of routine trap occurred in",
      "@param oper - input operator to function",
      "@param result - the result computed prior to the trap",
      "@return The suggested return value from the trap handler",
      "@param type The exception type - e.g. FLAG_OVERFLOW",
      "@param what The name of the routine we were in e.g. divide()",
      "@param oper An operand to this function if any",
      "@param def The default return value if trap not enabled",
      "@param result The result that is specified to be delivered per\n                  IEEE 854, if any",
      "@return the value that should be return by the operation triggering the trap",
      "@return type of the number",
      "@param x number to get the value from",
      "@param y number to get the sign from",
      "@return a number with the value of x and the sign of y",
      "@param x direction where to look at",
      "@return closest number next to instance in the direction of x",
      "@return a double approximating the instance",
      "@return an array of two doubles which sum represent the instance"
   ],
   [
      "@param field field to which this instance belongs",
      "@param mode desired rounding mode\nNote that the rounding mode is common to all {@link Dfp} instances\nbelonging to the current {@link DfpField} in the system and will\naffect all future calculations.",
      "@return current rounding mode",
      "@return IEEE 854 status flags",
      "@param flags desired value for the flags",
      "@param bits bits to set",
      "@return a new {@link Dfp} with a value of 0",
      "@return a new {@link Dfp} with the same value as x",
      "@return a new {@link Dfp} with the same value as d",
      "@return a new {@link Dfp} parsed from specified string",
      "@return a new {@link Dfp} with a non-finite value",
      "@return a {@link Dfp} with value 0",
      "@return a {@link Dfp} with value 1",
      "@return a {@link Dfp} with value 2",
      "@return a {@link Dfp} with value &radic;2",
      "@return a {@link Dfp} with value &radic;2 split in two pieces",
      "@return a {@link Dfp} with value &radic;2 / 2",
      "@return a {@link Dfp} with value &radic;3",
      "@return a {@link Dfp} with value &radic;3 / 3",
      "@return a {@link Dfp} with value &pi;",
      "@return a {@link Dfp} with value &pi; split in two pieces",
      "@return a {@link Dfp} with value e",
      "@return a {@link Dfp} with value e split in two pieces",
      "@return a {@link Dfp} with value ln(2)",
      "@return a {@link Dfp} with value ln(2) split in two pieces"
   ],
   [
      "@return a {@link Dfp} with value ln(5)",
      "@return a {@link Dfp} with value ln(5) split in two pieces",
      "@return a {@link Dfp} with value ln(10)",
      "@param a string representation of the number to split",
      "@return an array of two {@link Dfp Dfp} instances which sum equals a",
      "@param highPrecisionDecimalDigits precision at which the string constants mus be computed",
      "@param one constant with value 1 at desired precision",
      "@param two constant with value 2 at desired precision",
      "@param three constant with value 3 at desired precision",
      "@return &pi;",
      "@param a number for which we want the exponential",
      "@param decimalDigits minimal number of decimal digits.",
      "@param decimalDigits minimal number of decimal digits",
      "@param computeConstants if true, the transcendental constants for the given precision\nmust be computed (setting this flag to false is RESERVED for the internal recursive call)",
      "@param random random generator",
      "@return the static random generator shared by GA implementation classes",
      "@param initial the initial, seed population.",
      "@param condition the stopping condition used to stop evolution.",
      "@return the population that satisfies the stopping condition.",
      "@param current the current population.",
      "@return the population for the next generation.",
      "@return crossover policy",
      "@return crossover rate",
      "@return mutation policy",
      "@return mutation rate"
   ],
   [
      "@return selection policy",
      "@return number of generations evolved",
      "@param crossoverPolicy The {@link CrossoverPolicy}",
      "@param crossoverRate The crossover rate as a percentage (0-1 inclusive)",
      "@param mutationPolicy The {@link MutationPolicy}",
      "@param mutationRate The mutation rate as a percentage (0-1 inclusive)",
      "@param selectionPolicy The {@link SelectionPolicy}",
      "@throws OutOfRangeException if the crossover or mutation rate is outside the [0, 1] range",
      "@param population the population from which the chromosomes are choosen.",
      "@return the selected chromosomes.",
      "@throws MathIllegalArgumentException if the population is not compatible with this {@link SelectionPolicy}",
      "@param chromosomes the list of chromosomes",
      "@throws NumberIsTooLargeException if the list of chromosomes exceeds the population limit",
      "@param chromosomeColl a {@link Collection} of chromosomes",
      "@throws NumberIsTooLargeException if the population would exceed the population limit when\nadding this chromosome",
      "@return the unmodifiable list of chromosomes",
      "@return the list of chromosomes",
      "@param chromosome the chromosome to add.",
      "@throws NumberIsTooLargeException if the population would exceed the {@code populationLimit} after\n  adding this chromosome",
      "@return the fittest chromosome.",
      "@return the maximum population size.",
      "@param populationLimit maximal population size.",
      "@throws NotPositiveException if the population limit is not a positive number (&lt; 1)",
      "@throws NumberIsTooSmallException if the new population size is smaller than the current number\n  of chromosomes in the population",
      "@return the current population size."
   ],
   [
      "@return chromosome iterator",
      "@param populationLimit maximal size of the population",
      "@param chromosomes list of chromosomes to be added to the population",
      "@param population ignored (no impact on result)",
      "@return <code>true</code> IFF the maximum number of generations has been exceeded",
      "@return the number of generations that have passed",
      "@param maxGenerations number of generations to evolve",
      "@param chromosomeRepresentation representation of the chromosome",
      "@throws InvalidRepresentationException iff the <code>representation</code> can not represent a valid chromosome",
      "@return the representation of the chromosome",
      "@return the length of the chromosome",
      "@param chromosomeRepresentation the inner array representation of the new chromosome.",
      "@return new instance extended from FixedLengthChromosome with the given arrayRepresentation",
      "@param representation inner representation of the chromosome",
      "@param copyList if {@code true}, the representation will be copied, otherwise it will be referenced.",
      "@param first first parent (p1)",
      "@param second second parent (p2)",
      "@return pair of two children (c1,c2)",
      "@throws DimensionMismatchException if the length of the two chromosomes is different",
      "@param first the first chromosome.",
      "@param second the second chromosome.",
      "@return the pair of new chromosomes that resulted from the crossover.",
      "@return the beginnings of the next generation.",
      "@param elitismRate how many best chromosomes will be directly transferred to the next generation [in %]",
      "@throws OutOfRangeException if the elitism rate is outside the [0, 1] range"
   ],
   [
      "@return the elitism rate",
      "@param chromosomes list of chromosomes in the population",
      "@return the fitness",
      "@param another another chromosome to compare",
      "@return <ul>\n  <li>-1 if <code>another</code> is better than <code>this</code></li>\n  <li>1 if <code>another</code> is worse than <code>this</code></li>\n  <li>0 if the two chromosomes have the same fitness</li>\n</ul>",
      "@param another chromosome to compare",
      "@return true if <code>another</code> is equivalent to this chromosome",
      "@param population Population to search",
      "@return Chromosome with the same representation, or <code>null</code> if no such chromosome exists.",
      "@param first the first chromosome",
      "@param second the second chromosome",
      "@return the pair of new chromosomes that resulted from the crossover",
      "@param pattern Message pattern.",
      "@param args Arguments.",
      "@param <S> generic type of the sequence values",
      "@param sequence the unpermuted sequence",
      "@param representation representation of the permutation ([0,1] vector)",
      "@param sortedRepr sorted <code>representation</code>",
      "@return list with the sequence values permuted according to the representation",
      "@throws DimensionMismatchException iff the length of the <code>sequence</code>,\n  <code>representation</code> or <code>sortedRepr</code> lists are not equal",
      "@return true iff chromosomes encode the same permutation",
      "@param l length of the permutation",
      "@return representation of a random permutation",
      "@return representation of an identity permutation",
      "@param <S> type of the data"
   ],
   [
      "@param data list of data determining the order",
      "@param comparator how the data will be compared",
      "@return list representation of the permutation corresponding to the parameters",
      "@param originalData the original, unpermuted data",
      "@param permutedData the data, somehow permuted",
      "@return representation of a permutation corresponding to the permutation\n  <code>originalData -> permutedData</code>",
      "@throws MathIllegalArgumentException iff the <code>permutedData</code> and\n  <code>originalData</code> lists contain different data",
      "@param l length of list to generate",
      "@return list of integers from 0 to l-1",
      "@param representation list of [0,1] values representing the permutation",
      "@param representation array of [0,1] values representing the permutation",
      "@param population the population to test.",
      "@return <code>true</code> if this stopping condition is met by the given population,\n  <code>false</code> otherwise.",
      "@param sequence the unpermuted (original) sequence of objects",
      "@return permutation of <code>sequence</code> represented by this permutation",
      "@return the first chromosome.",
      "@return the second chromosome.",
      "@param c1 the first chromosome.",
      "@param c2 the second chromosome.",
      "@param population the population from which the chromosomes are chosen.",
      "@throws MathIllegalArgumentException if the tournament arity is bigger than the population size",
      "@return the selected chromosome.",
      "@return arity of the tournament",
      "@param arity arity of the tournament",
      "@param arity how many chromosomes will be drawn to the tournament"
   ],
   [
      "@return the number of crossover points",
      "@return this - n &times; a where n is the closest integer to this/a\n(the even integer is chosen for n if this/a is halfway between two integers)",
      "@throws DimensionMismatchException if number of free parameters or orders are inconsistent",
      "@return abs(this)",
      "@return ceil(this)",
      "@return floor(this)",
      "@return a double number r such that r is an integer r - 0.5 &le; this &le; r + 0.5",
      "@return closest long to {@link #getReal()}",
      "@return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a",
      "@param sign the sign for the returned value",
      "@return the instance with the same sign as the {@code sign} argument",
      "@param n power of 2",
      "@return this &times; 2<sup>n</sup>",
      "@param y a value",
      "@return sqrt(<i>this</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)",
      "@return cubic root of the instance",
      "@param n order of the root",
      "@return n<sup>th</sup> root of the instance",
      "@param p power to apply",
      "@return this<sup>p</sup>",
      "@param n power to apply",
      "@return this<sup>n</sup>",
      "@param e exponent",
      "@return this<sup>e</sup>",
      "@return exponential of the instance"
   ],
   [
      "@return exponential minus one of the instance",
      "@return logarithm of the instance",
      "@return logarithm of one plus the instance",
      "@return cos(this)",
      "@return sin(this)",
      "@return tan(this)",
      "@return acos(this)",
      "@return asin(this)",
      "@return atan(this)",
      "@param x second argument of the arc tangent",
      "@return cosh(this)",
      "@return sinh(this)",
      "@return tanh(this)",
      "@return acosh(this)",
      "@return atanh(this)",
      "@param a Factors.",
      "@param b Factors.",
      "@return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.",
      "@throws DimensionMismatchException if arrays dimensions don't match",
      "@param a1 first factor of the first term",
      "@param b1 second factor of the first term",
      "@param a2 first factor of the second term",
      "@param b2 second factor of the second term",
      "@return a<sub>1</sub>&times;b<sub>1</sub> +\na<sub>2</sub>&times;b<sub>2</sub>",
      "@param a3 first factor of the third term"
   ],
   [
      "@param b3 second factor of the third term",
      "@return a<sub>1</sub>&times;b<sub>1</sub> +\na<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>",
      "@param a4 first factor of the third term",
      "@param b4 second factor of the third term",
      "@return a<sub>1</sub>&times;b<sub>1</sub> +\na<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\na<sub>4</sub>&times;b<sub>4</sub>",
      "@param n number to test.",
      "@return list of prime factors of n",
      "@throws NumberIsTooLargeException if the number of crossoverPoints is too large for the actual chromosomes",
      "@param crossoverPoints the number of crossover points",
      "@return the mixing ratio",
      "@param ratio the mixing ratio",
      "@throws OutOfRangeException if the mixing ratio is outside the [0, 1] range",
      "@param original the original chromosome.",
      "@return the mutated chromosome.",
      "@throws MathIllegalArgumentException if the given chromosome is not compatible with this {@link MutationPolicy}",
      "@return <code>true</code> IFF the maximum allowed time period has elapsed",
      "@param maxTime maximum number of seconds generations are allowed to evolve",
      "@param maxTime maximum time generations are allowed to evolve",
      "@param unit {@link TimeUnit} of the maxTime argument",
      "@return {@code true} if the starting index is chosen randomly, {@code false} otherwise",
      "@param randomStart whether the start index shall be chosen randomly or be set to 0",
      "@param length length of the array",
      "@return a random binary array of length <code>length</code>",
      "@param representation list of {0,1} values representing the chromosome",
      "@param representation array of {0,1} values representing the chromosome"
   ],
   [
      "@throws NumberIsTooLargeException if the population would exceed the population limit when adding\n  this chromosome",
      "@throws MathIllegalArgumentException if <code>original</code> is not a {@link RandomKey} instance",
      "@return fitness",
      "@throws MathIllegalArgumentException if the given chromosomes are not compatible with this {@link CrossoverPolicy}",
      "@return null vector of the vectorial space or origin point of the affine space",
      "@return L<sub>1</sub> norm for the vector",
      "@return Euclidean norm for the vector",
      "@return square of the Euclidean norm for the vector",
      "@return L<sub>&infin;</sub> norm for the vector",
      "@return a new vector",
      "@param factor scale factor to apply to v before adding it",
      "@param v vector to subtract",
      "@param factor scale factor to apply to v before subtracting it",
      "@return a new vector which is opposite to the instance",
      "@return a new normalized vector",
      "@param a scalar",
      "@return true if any coordinate of this vector is infinite and none are NaN;\nfalse otherwise",
      "@param v second vector",
      "@return the distance between the instance and p according to the L<sub>1</sub> norm",
      "@return the distance between the instance and p according to the L<sub>2</sub> norm",
      "@return the distance between the instance and p according to the L<sub>&infin;</sub> norm",
      "@return the square of the distance between the instance and p",
      "@return the dot product this.v",
      "@param format the custom format for components",
      "@return a string representation of this vector"
   ],
   [
      "@return available point/vector format locales.",
      "@return format prefix.",
      "@return format suffix.",
      "@return format separator.",
      "@return components format.",
      "@param vector the object to format.",
      "@return a formatted string.",
      "@param toAppendTo where the text is to be appended",
      "@param pos On input: an alignment field, if desired. On output: the\n           offsets of the alignment field",
      "@return the value passed in as toAppendTo.",
      "@param coordinates coordinates of the object to format.",
      "@param source the string to parse",
      "@return the parsed {@link Vector} object.",
      "@throws MathParseException if the beginning of the specified string\ncannot be parsed.",
      "@param pos input/output parsing parameter.",
      "@param dimension dimension of the space",
      "@return coordinates array.",
      "@param format the custom format for components.",
      "@param prefix prefix to use instead of the default \"{\"",
      "@param suffix suffix to use instead of the default \"}\"",
      "@param separator separator to use instead of the default \"; \"",
      "@return containing space",
      "@return true if any coordinate of this point is NaN; false otherwise",
      "@param p second point",
      "@return the distance between the instance and p"
   ],
   [
      "@param hyperplane splitting hyperplane",
      "@return an object containing both the part of the instance\non the plus side of the instance and the part of the\ninstance on the minus side of the instance",
      "@param hyperplane underlying hyperplane",
      "@param remainingRegion remaining region of the hyperplane",
      "@return the default 3D vector format.",
      "@param locale the specific locale used by the format.",
      "@return the 3D vector format specific to the given locale.",
      "@return the parsed {@link Vector3D} object.",
      "@param pos input/ouput parsing parameter.",
      "@return start point of the segment",
      "@return end point of the segment",
      "@return line containing the segment",
      "@param start start point of the segment",
      "@param end end point of the segment",
      "@param line line containing the segment",
      "@param polyhedronsSet polyhedrons set whose outline must be extracted",
      "@return an outline, as an array of loops.",
      "@param loop points array",
      "@param n number of points to consider in the array",
      "@param i index of the point to check (must be between 0 and n-1)",
      "@return true if the point is exactly between its neighbors",
      "@param u abscissa axis of the projection point",
      "@param v ordinate axis of the projection point",
      "@param xMin low bound along the x direction",
      "@param xMax high bound along the x direction"
   ],
   [
      "@param yMin low bound along the y direction",
      "@param yMax high bound along the y direction",
      "@param zMin low bound along the z direction",
      "@param zMax high bound along the z direction",
      "@param tolerance tolerance below which points are considered identical",
      "@return boundary tree",
      "@param vertices list of polyhedrons set vertices",
      "@param facets list of facets, as vertices indices in the vertices list",
      "@return boundary as a list of sub-hyperplanes",
      "@throws MathIllegalArgumentException if some basic sanity checks fail",
      "@return references array such that r[v][k] = f for some k if facet f contains vertex v",
      "@throws MathIllegalArgumentException if some facets have fewer than 3 vertices",
      "@param references facets references array",
      "@return indices of vertices that follow vertex v in some facet (the array\nmay contain extra entries at the end, set to negative indices)",
      "@throws MathIllegalArgumentException if the same vertex appears more than\nonce in the successors list (which means one facet orientation is wrong)",
      "@param point start point of the part of the line considered",
      "@param line line to consider (contains point)",
      "@return the first sub-hyperplane crossed by the line after the\ngiven point, or null if the line does not intersect any\nsub-hyperplane",
      "@param node current node",
      "@param point point to check",
      "@param node node containing the boundary facet to check",
      "@return the boundary facet this points belongs to (or null if it\ndoes not belong to any boundary facet)",
      "@param center rotation center",
      "@param rotation vectorial rotation operator",
      "@return a new instance representing the rotated region"
   ],
   [
      "@param translation translation to apply",
      "@return a new instance representing the translated region",
      "@param tree inside/outside BSP tree representing the region",
      "@param boundary collection of boundary elements, as a\ncollection of {@link SubHyperplane SubHyperplane} objects",
      "@return a string representation of the instance (in fact, its name)",
      "@return axis of the first rotation",
      "@return axis of the second rotation",
      "@param name name of the rotation order",
      "@param a1 axis of the first rotation",
      "@param a2 axis of the second rotation",
      "@param a3 axis of the third rotation",
      "@return abscissa of the vector",
      "@return ordinate of the vector",
      "@return height of the vector",
      "@return vector coordinates",
      "@return a constant vector",
      "@return azimuth (&alpha;) of the vector, between -&pi; and +&pi;",
      "@return elevation (&delta;) of the vector, between -&pi;/2 and +&pi;/2",
      "@throws MathArithmeticException if the norm is zero",
      "@return a new normalized vector orthogonal to the instance",
      "@param v1 first vector",
      "@param v2 second vector",
      "@param <T> the type of the field elements",
      "@return angular separation between v1 and v2",
      "@throws MathArithmeticException if either vector has a null norm"
   ],
   [
      "@return true if any coordinate of this vector is NaN; false otherwise",
      "@param other Object to test for equality to this",
      "@return true if two 3D vector objects are equal, false if\n        object is null, not an instance of Vector3D, or\n        not equal to this Vector3D instance",
      "@param v other vector",
      "@return the cross product this ^ v as a new Vector3D",
      "@return the dot product v1.v2",
      "@return the cross product v1 ^ v2 as a new Vector",
      "@return the distance between v1 and v2 according to the L<sub>1</sub> norm",
      "@return the distance between v1 and v2 according to the L<sub>2</sub> norm",
      "@return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm",
      "@return the square of the distance between v1 and v2",
      "@param x abscissa",
      "@param y ordinate",
      "@param z height",
      "@param v coordinates array",
      "@throws DimensionMismatchException if array does not have 3 elements",
      "@param alpha azimuth (&alpha;) around Z\n             (0 is +X, &pi;/2 is +Y, &pi; is -X and 3&pi;/2 is -Y)",
      "@param delta elevation (&delta;) above (XY) plane, from -&pi;/2 to +&pi;/2",
      "@param a scale factor",
      "@param u base (unscaled) vector",
      "@param a1 first scale factor",
      "@param u1 first base (unscaled) vector",
      "@param a2 second scale factor",
      "@param u2 second base (unscaled) vector",
      "@param a3 third scale factor"
   ],
   [
      "@param u3 third base (unscaled) vector",
      "@param a4 fourth scale factor",
      "@param u4 fourth base (unscaled) vector",
      "@param ort orthogonal rotation matrix",
      "@return quaternion corresponding to the matrix",
      "@return a new rotation whose effect is the reverse of the effect\nof the instance",
      "@return scalar coordinate of the quaternion",
      "@return first coordinate of the vectorial part of the quaternion",
      "@return second coordinate of the vectorial part of the quaternion",
      "@return third coordinate of the vectorial part of the quaternion",
      "@return normalized axis of the rotation",
      "@param convention convention to use for the semantics of the angle",
      "@return angle of the rotation (between 0 and &pi;)",
      "@param order rotation order to use",
      "@return an array of three angles, in the order specified by the set",
      "@throws CardanEulerSingularityException if the rotation is\nsingular with respect to the angles set specified",
      "@return the matrix corresponding to the instance",
      "@param u vector to apply the rotation to",
      "@return a new vector which is the image of u by the rotation",
      "@param in an array with three items which stores vector to rotate",
      "@param out an array with three items to put result to (it can be the same\narray as in)",
      "@param u vector to apply the inverse of the rotation to",
      "@return a new vector which such that u is its image by the rotation",
      "@param r rotation to apply the rotation to",
      "@return a new rotation which is the composition of r by the instance"
   ],
   [
      "@return a new rotation which is the composition of r by the instance\nusing vector operator convention",
      "@return a new rotation which is the composition of r by the inverse\nof the instance",
      "@return a new rotation which is the composition of r by the inverse\nof the instance using vector operator convention",
      "@param m initial matrix (not exactly orthogonal)",
      "@param threshold convergence threshold for the iterative\northogonality correction (convergence is reached when the\ndifference between two steps of the Frobenius norm of the\ncorrection is below this threshold)",
      "@return an orthogonal matrix close to m",
      "@throws NotARotationMatrixException if the matrix cannot be\northogonalized with the given threshold after 10 iterations",
      "@param r1 first rotation",
      "@param r2 second rotation",
      "@return <i>distance</i> between r1 and r2",
      "@param q0 scalar part of the quaternion",
      "@param q1 first coordinate of the vectorial part of the quaternion",
      "@param q2 second coordinate of the vectorial part of the quaternion",
      "@param q3 third coordinate of the vectorial part of the quaternion",
      "@param needsNormalization if true, the coordinates are considered\nnot to be normalized, a normalization preprocessing step is performed\nbefore using them",
      "@param axis axis around which to rotate",
      "@param angle rotation angle.",
      "@throws MathIllegalArgumentException if the axis norm is zero",
      "@param angle rotation angle",
      "@param m rotation matrix",
      "@throws NotARotationMatrixException if the matrix is not a 3X3\nmatrix, or if it cannot be transformed into an orthogonal matrix\nwith the given threshold, or if the determinant of the resulting\northogonal matrix is negative",
      "@param u1 first vector of the origin pair",
      "@param u2 second vector of the origin pair",
      "@param v1 desired image of u1 by the rotation",
      "@param v2 desired image of u2 by the rotation"
   ],
   [
      "@throws MathArithmeticException if the norm of one of the vectors is zero,\nor if one of the pair is degenerated (i.e. the vectors of the pair are collinear)",
      "@param u origin vector",
      "@param v desired image of u by the rotation",
      "@throws MathArithmeticException if the norm of one of the vectors is zero",
      "@param order order of rotations to use",
      "@param alpha1 angle of the first elementary rotation",
      "@param alpha2 angle of the second elementary rotation",
      "@param alpha3 angle of the third elementary rotation",
      "@param order order of rotations to compose, from left to right\n(i.e. we will use {@code r1.compose(r2.compose(r3, convention), convention)})",
      "@return the unique instance",
      "@return list of segments endpoints",
      "@param subLine other sub-line which may intersect instance",
      "@param includeEndPoints if true, endpoints are considered to belong to\ninstance (i.e. they are closed sets) and may be returned, otherwise endpoints\nare considered to not belong to instance (i.e. they are open sets) and intersection\noccurring on endpoints lead to null being returned",
      "@return the intersection point if there is one, null if the sub-lines don't intersect",
      "@param start start point",
      "@param end end point",
      "@return an interval set",
      "@param line underlying line",
      "@param remainingRegion remaining region of the line",
      "@param segment single segment forming the sub-line",
      "@throws MathIllegalArgumentException if the segment endpoints are equal",
      "@return Cartesian coordinates",
      "@return radius r",
      "@return azimuthal angle in x-y plane &theta;",
      "@return polar (co-latitude) angle &Phi;"
   ],
   [
      "@param sGradient gradient with respect to spherical coordinates\n{df/dr, df/d&theta;, df/d&Phi;}",
      "@return gradient with respect to Cartesian coordinates\n{df/dx, df/dy, df/dz}",
      "@param sHessian Hessian with respect to spherical coordinates\n{{d<sup>2</sup>f/dr<sup>2</sup>, d<sup>2</sup>f/drd&theta;, d<sup>2</sup>f/drd&Phi;},\n {d<sup>2</sup>f/drd&theta;, d<sup>2</sup>f/d&theta;<sup>2</sup>, d<sup>2</sup>f/d&theta;d&Phi;},\n {d<sup>2</sup>f/drd&Phi;, d<sup>2</sup>f/d&theta;d&Phi;, d<sup>2</sup>f/d&Phi;<sup>2</sup>}",
      "@return Hessian with respect to Cartesian coordinates\n{{d<sup>2</sup>f/dx<sup>2</sup>, d<sup>2</sup>f/dxdy, d<sup>2</sup>f/dxdz},\n {d<sup>2</sup>f/dxdy, d<sup>2</sup>f/dy<sup>2</sup>, d<sup>2</sup>f/dydz},\n {d<sup>2</sup>f/dxdz, d<sup>2</sup>f/dydz, d<sup>2</sup>f/dz<sup>2</sup>}}",
      "@return data transfer object that will be serialized",
      "@param v Cartesian coordinates",
      "@param r radius",
      "@param theta azimuthal angle in x-y plane",
      "@param phi polar (co-latitude) angle",
      "@param isCardan if true, the rotation is related to Cardan angles,\nif false it is related to EulerAngles",
      "@param specifier format specifier (to be translated)",
      "@param parts to insert in the format (no translation)",
      "@param a0 first array element",
      "@param a1 second array element",
      "@param a2 third array element",
      "@return new array",
      "@param out an array with three items to put result to",
      "@param r rotation to apply",
      "@param r1 rotation to apply",
      "@param rInner rotation to apply the rotation to",
      "@param rOuter rotation to apply the rotation to",
      "@return a new hyperplane, copy of the instance",
      "@param p point belonging to the plane",
      "@param normal normal direction to the plane",
      "@throws MathArithmeticException if the normal norm is too small"
   ],
   [
      "@param original plane to reset from",
      "@param normal normal direction to the plane (will be copied)",
      "@return the origin point of the plane frame (point closest to the\n3D-space origin)",
      "@return normalized normal vector",
      "@return normalized first canonical vector",
      "@return normalized second canonical vector",
      "@param vector n-dimension point of the space",
      "@return (n-1)-dimension point of the sub-space corresponding to\nthe specified space point",
      "@param vector (n-1)-dimension point of the sub-space",
      "@return n-dimension point of the space corresponding to the\nspecified sub-space point",
      "@param point point of the space (must be a {@link Vector3D\nVector3D} instance)",
      "@return in-plane point (really a {@link\norg.apache.commons.math3.geometry.euclidean.twod.Vector2D Vector2D} instance)",
      "@param point in-plane point (must be a {@link\norg.apache.commons.math3.geometry.euclidean.twod.Vector2D Vector2D} instance)",
      "@return 3D space point (really a {@link Vector3D Vector3D} instance)",
      "@param inPlane desired in-plane coordinates for the point in the\nplane",
      "@param offset desired offset for the point",
      "@return one point in the 3D-space, with given coordinates and offset\nrelative to the plane",
      "@param plane plane to which the instance is compared",
      "@return true if the planes are similar",
      "@return a new plane",
      "@param line line intersecting the instance",
      "@return intersection point between between the line and the\ninstance (null if the line is parallel to the instance)",
      "@param other other plane",
      "@return line at the intersection of the instance and the\nother plane (really a {@link Line Line} instance)",
      "@param plane1 first plane1"
   ],
   [
      "@param plane2 second plane2",
      "@param plane3 third plane2",
      "@return intersection point of three planes, null if some planes are parallel",
      "@return a region covering the whole hyperplane",
      "@return a region containing the instance (really a {@link\nPolyhedronsSet PolyhedronsSet} instance)",
      "@param p point to check",
      "@return true if p belongs to the plane",
      "@param plane plane to check",
      "@return offset of the plane",
      "@param vector vector to check",
      "@return offset of the vector",
      "@return offset of the point",
      "@param other other hyperplane to check against the instance",
      "@return true if the instance and the other hyperplane have\nthe same orientation",
      "@param p1 first point belonging to the plane",
      "@param p2 second point belonging to the plane",
      "@param p3 third point belonging to the plane",
      "@throws MathArithmeticException if the points do not constitute a plane",
      "@param plane plane to copy",
      "@param c1 first column",
      "@param c2 second column",
      "@param c3 third column",
      "@return value of the minor computed has an exact fraction",
      "@param p1 first point belonging to the line (this can be any point)",
      "@param p2 second point belonging to the line (this can be any point, different from p1)"
   ],
   [
      "@return tolerance below which points are considered identical",
      "@return a new instance, with reversed direction",
      "@return normalized direction vector",
      "@return line point closest to the origin",
      "@return abscissa of the point",
      "@param abscissa desired abscissa for the point",
      "@return one point belonging to the line, at specified abscissa",
      "@param line line to which instance should be compared",
      "@return true if the lines are similar",
      "@return true if p belongs to the line",
      "@param p to check",
      "@return distance between the instance and the point",
      "@param line line to check against the instance",
      "@return shortest distance between the instance and the line",
      "@return point of the instance closest to another line",
      "@param line other line",
      "@return intersection point of the instance and the other line\nor null if there are no intersection points",
      "@return a sub-line covering the whole line",
      "@param line line to copy",
      "@param lower lower bound of the interval, must be lesser or equal\nto {@code upper} (may be {@code Double.NEGATIVE_INFINITY})",
      "@param upper upper bound of the interval, must be greater or equal\nto {@code lower} (may be {@code Double.POSITIVE_INFINITY})",
      "@param tolerance tolerance below which points are considered identical.",
      "@return the built tree",
      "@return lowest value belonging to the instance\n({@code Double.NEGATIVE_INFINITY} if the instance doesn't\nhave any low bound, {@code Double.POSITIVE_INFINITY} if the\ninstance is empty)",
      "@return highest value belonging to the instance\n({@code Double.POSITIVE_INFINITY} if the instance doesn't\nhave any high bound, {@code Double.NEGATIVE_INFINITY} if the\ninstance is empty)"
   ],
   [
      "@param x abscissa of the point",
      "@return a new point for finite abscissa, null otherwise",
      "@return a new ordered list containing {@link Interval Interval}\nelements",
      "@param root tree root",
      "@return first leaf node",
      "@return smallest internal node,\nor null if there are no internal nodes (i.e. the set is either empty or covers the real line)",
      "@param node internal node to check",
      "@return true if the node corresponds to the start abscissa of an interval",
      "@return true if the node corresponds to the end abscissa of an interval",
      "@param node current internal node",
      "@return next internal node in ascending order, or null\nif this is the last internal node",
      "@return previous internal node in ascending order, or null\nif this is the first internal node",
      "@param node internal node at which the sub-tree starts",
      "@return leaf node just before the internal node",
      "@return leaf node just after the internal node",
      "@param node child node considered",
      "@return true is the node has a parent end is before it in ascending order",
      "@return true is the node has a parent end is after it in ascending order",
      "@return child node just before the internal node",
      "@return child node just after the internal node",
      "@return true if the oriented point is direct",
      "@return abscissa",
      "@param tree inside/outside BSP tree representing the intervals set",
      "@param boundary collection of boundary elements",
      "@return lower bound of the interval"
   ],
   [
      "@return upper bound of the interval",
      "@return size of the interval",
      "@return length of the interval",
      "@return barycenter of the interval",
      "@return midpoint of the interval",
      "@param tolerance tolerance below which points are considered to\nbelong to the boundary",
      "@return a code representing the point status: either {@link\nLocation#INSIDE}, {@link Location#OUTSIDE} or {@link Location#BOUNDARY}",
      "@param lower lower bound of the interval",
      "@param upper upper bound of the interval",
      "@return the instance itself",
      "@return a dummy sub hyperplane",
      "@return a region containing the instance (really an {@link\nIntervalsSet IntervalsSet} instance)",
      "@return the hyperplane location",
      "@return true if the plus side of the hyperplane is towards\nabscissae greater than hyperplane location",
      "@param location location of the hyperplane",
      "@param direct if true, the plus side of the hyperplane is towards\nabscissas greater than {@code location}",
      "@param tolerance tolerance below which points are considered to belong to the hyperplane",
      "@return nothing",
      "@throws NoSubSpaceException in all cases",
      "@return the default 1D vector format.",
      "@return the 1D vector format specific to the given locale.",
      "@param p1 first vector",
      "@param p2 second vector",
      "@return the distance between p1 and p2 according to the L<sub>2</sub> norm",
      "@return the distance between p1 and p2 according to the L<sub>&infin;</sub> norm"
   ],
   [
      "@return the square of the distance between p1 and p2",
      "@return true if two 1D vector objects are equal, false if\n        object is null, not an instance of Vector1D, or\n        not equal to this Vector1D instance",
      "@param factors the list where to add the factors.",
      "@return the part of n which remains to be factored, it is either a prime or a semi-prime",
      "@param maxFactor the upper bound of trial division: if it is reached, the method gives up and returns n.",
      "@return n or 1 if factorization is completed.",
      "@param n the number to factor",
      "@return the list of prime factors of n",
      "@param n number to test: an odd integer &ge; 3",
      "@return true if n is prime. false if n is definitely composite.",
      "@return the list of prime factors of n.",
      "@param n number to factor, must be semi-prime.",
      "@return a prime factor of n.",
      "@return gcd(a,b)",
      "@param y observed value of the point at x, after fitting we should\nhave f(x) as close as possible to this value",
      "@param weight weight of the observed point in the fit",
      "@param observed observed point to add",
      "@return observed points",
      "@param f parametric function to fit.",
      "@param initialGuess first guess of the function parameters.",
      "@return the fitted parameters.",
      "@throws org.apache.commons.math3.exception.DimensionMismatchException if the start point dimension is wrong.",
      "@param maxEval Maximum number of function evaluations.",
      "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the number of allowed evaluations is exceeded.",
      "@param optimizer Optimizer to use for the fitting."
   ],
   [
      "@return a curve fitter.",
      "@param newStart new start point (initial guess)",
      "@return a new instance.",
      "@param newMaxIter maximum number of iterations",
      "@param initialGuess Initial guess. If set to {@code null}, the initial guess\nwill be estimated using the {@link ParameterGuesser}.",
      "@param maxIter Maximum number of iterations of the optimization algorithm.",
      "@param f Function to fit.",
      "@param function Function to fit.",
      "@param initialGuess Initial guess. Cannot be {@code null}. Its length must\nbe consistent with the number of parameters of the {@code function} to fit.",
      "@param guess First guess for the coefficients. They must be sorted in\nincreasing order of the polynomial's degree.",
      "@param maxEval Maximum number of evaluations of the polynomial.",
      "@return the coefficients of the polynomial that best fits the observed points.",
      "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if\nthe number of evaluations exceeds {@code maxEval}.",
      "@throws org.apache.commons.math3.exception.ConvergenceException if the algorithm failed to converge.",
      "@param initialGuess First guess values in the following order:\n<ul>\n <li>Amplitude</li>\n <li>Angular frequency</li>\n <li>Phase</li>\n</ul>",
      "@return the parameters of the harmonic function that best fits the\nobserved points (in the same order as above).",
      "@return the parameters of the harmonic function that best fits the\nobserved points (see the other {@link #fit(double[]) fit} method.",
      "@throws NumberIsTooSmallException if the sample is too short for the\nthe first guess to be computed.",
      "@throws ZeroException if the first guess cannot be computed because\nthe abscissa range is zero.",
      "@return the weight of the measurement in the fitting process.",
      "@return the abscissa of the point.",
      "@return the observed value of the function at x.",
      "@param weight Weight of the measurement in the fitting process.",
      "@param x Abscissa of the measurement.",
      "@param y Ordinate of the measurement."
   ],
   [
      "@param params Input parameters.",
      "@return the validated values.",
      "@param newCostRelativeTolerance Desired relative error in the sum of squares.",
      "@param newParRelativeTolerance Desired relative error in the approximate solution\nparameters.",
      "@param newOrthoTolerance Desired max cosine on the orthogonality between\nthe function vector and the columns of the Jacobian.",
      "@param newQRRankingThreshold Desired threshold for QR ranking.\nIf the squared norm of a column vector is smaller or equal to this\nthreshold during QR decomposition, it is considered to be a zero vector\nand hence the rank of the matrix is reduced.",
      "@return the parameter's value.",
      "@param qy Array containing qTy.",
      "@param delta Upper bound on the euclidean norm of diagR * lmDir.",
      "@param diag Diagonal matrix.",
      "@param internalData Data (modified in-place in this method).",
      "@param solvedCols Number of solved point.",
      "@param work1 work array",
      "@param work2 work array",
      "@param work3 work array",
      "@param lmDir the \"returned\" LM direction will be stored in this array.",
      "@param lmPar the value of the LM parameter from the previous iteration.",
      "@return the new LM parameter",
      "@param qy array containing qTy",
      "@param diag diagonal matrix",
      "@param lmDiag diagonal elements associated with lmDir",
      "@param solvedCols Number of sloved point.",
      "@return the tolerance below which points are considered identical",
      "@return {@code true} if collinear points are added as hull vertices, or {@code false}\nif only extreme points are present.",
      "@param points the set of input points"
   ],
   [
      "@return the convex hull vertices in CCW winding",
      "@param includeCollinearPoints indicates if collinear points on the hull shall be\nadded as hull vertices",
      "@param points the original point set",
      "@return a reduced point set, useful as input for convex hull algorithms",
      "@param points the respective points with min/max x/y coordinate",
      "@return the quadrilateral",
      "@param point the point to check",
      "@param quadrilateralPoints the convex quadrilateral, represented by 4 points",
      "@return {@code true} if the point is inside the quadrilateral, {@code false} otherwise",
      "@param hullVertices the hull vertices",
      "@return {@code true} if the vertices form a convex hull, {@code false} otherwise",
      "@return the line segments of the convex hull",
      "@return the array of line segments",
      "@param vertices the vertices of the convex hull, must be ordered",
      "@throws MathIllegalArgumentException if the vertices do not form a convex hull",
      "@param point the current point",
      "@param hull the partial hull",
      "@param includeCollinearPoints whether collinear points shall be added as hull vertices",
      "@return the default 2D vector format.",
      "@return the 2D vector format specific to the given locale.",
      "@return boundary of the box",
      "@param hyperplaneThickness tolerance below which points are consider to\nbelong to the hyperplane (which is therefore more a slab)",
      "@param vertices vertices of the simple loop boundary",
      "@return the BSP tree of the input vertices",
      "@param node current tree node (it is a leaf node at the beginning\nof the call)"
   ],
   [
      "@param edges list of edges to insert in the cell defined by this node\n(excluding edges not belonging to the cell defined by this node)",
      "@param segments segments complete segments list",
      "@return number of connections performed",
      "@param segments segments list",
      "@return first segment that has not been processed yet\nor null if all segments have been processed",
      "@param defining segment used to define the loop",
      "@return loop containing the segment (may be null if the loop is a\ndegenerated infinitely thin 2 points loop",
      "@param loop segments loop to filter (will be modified in-place)",
      "@param hyperplaneThickness tolerance below which points are considered to\nbelong to the hyperplane (which is therefore more a slab)",
      "@param p1 first point of the line",
      "@param p2 second point of the line",
      "@return the cross-product",
      "@return true if two 2D vector objects are equal, false if\n        object is null, not an instance of Vector2D, or\n        not equal to this Vector2D instance",
      "@throws DimensionMismatchException if array does not have 2 elements",
      "@param bLoop boundary loop (will be reversed in place if needed)",
      "@throws MathIllegalArgumentException if an outline has crossing\nboundary loops or open boundary loops",
      "@param node boundary loop (will be reversed in place if needed)",
      "@throws MathIllegalArgumentException if an outline has boundary\nloops that cross each other",
      "@param clockwise if true, the loop should be set to clockwise\norientation",
      "@param loop boundary loop (will be reversed in place if needed)",
      "@throws MathIllegalArgumentException if an outline has an open boundary loop",
      "@param p1 first point",
      "@param p2 second point",
      "@param p point belonging to the line",
      "@param alpha angle of the line with respect to abscissa axis"
   ],
   [
      "@return a new line, with orientation opposite to the instance orientation",
      "@param other other line",
      "@return a region containing the instance (really a {@link\nPolygonsSet PolygonsSet} instance)",
      "@param line line to check",
      "@return offset of the line",
      "@return one point in the plane, with given abscissa and offset\nrelative to the line",
      "@param line other line to check",
      "@return true if the instance is parallel to the other line\n(they can have either the same or opposite orientations)",
      "@param p point by which the line should pass",
      "@return the angle of the line with respect to the abscissa axis",
      "@param angle new angle of the line with respect to the abscissa axis",
      "@return the offset of the origin",
      "@param offset offset of the origin",
      "@param transform affine transform to embed (must be inversible\notherwise the {@link\norg.apache.commons.math3.geometry.partitioning.Transform#apply(Hyperplane)\napply(Hyperplane)} method would work only for some lines, and\nfail for other ones)",
      "@return a new transform that can be applied to either {@link\nVector2D Vector2D}, {@link Line Line} or {@link\norg.apache.commons.math3.geometry.partitioning.SubHyperplane\nSubHyperplane} instances",
      "@throws MathIllegalArgumentException if the transform is non invertible",
      "@param cXX transform factor between input abscissa and output abscissa",
      "@param cYX transform factor between input abscissa and output ordinate",
      "@param cXY transform factor between input ordinate and output abscissa",
      "@param cYY transform factor between input ordinate and output ordinate",
      "@param cX1 transform addendum for output abscissa",
      "@param cY1 transform addendum for output ordinate",
      "@param angle angle of the line with respect to abscissa axis",
      "@param cos cosine of the angle",
      "@param sin sine of the angle"
   ],
   [
      "@param originOffset offset of the origin",
      "@return the convex hull",
      "@throws ConvergenceException if generator fails to generate a convex hull for\nthe given set of input points",
      "@return vertices of the convex hull",
      "@return the region enclosed by the convex hull",
      "@throws InsufficientDataException if the number of vertices is not enough to\nbuild a region in the respective space",
      "@param lower lower angular bound of the arc",
      "@param upper upper angular bound of the arc",
      "@param tolerance tolerance below which close sub-arcs are merged together",
      "@throws NumberIsTooLargeException if lower is greater than upper",
      "@throws InconsistentStateAt2PiWrapping if the tree leaf nodes are not\nconsistent across the \\( 0, 2 \\pi \\) crossing",
      "@return first leaf node (i.e. node corresponding to the region just after 0.0 radians)",
      "@return last leaf node (i.e. node corresponding to the region just before \\( 2 \\pi \\) radians)",
      "@return smallest internal node (i.e. first after 0.0 radians, in trigonometric direction),\nor null if there are no internal nodes (i.e. the set is either empty or covers the full circle)",
      "@return true if the node corresponds to the start angle of an arc",
      "@return true if the node corresponds to the end angle of an arc",
      "@return next internal node in trigonometric order, or null\nif this is the last internal node",
      "@return previous internal node in trigonometric order, or null\nif this is the first internal node",
      "@return true is the node has a parent end is before it in trigonometric order",
      "@return true is the node has a parent end is after it in trigonometric order",
      "@return true if the limit angle is direct",
      "@return limit angle",
      "@return a new ordered list containing {@link Arc Arc} elements",
      "@param arc arc to check instance against",
      "@return one of {@link Side#PLUS}, {@link Side#MINUS}, {@link Side#BOTH}\nor {@link Side#HYPER}"
   ],
   [
      "@param arc splitting arc",
      "@return an object containing both the part of the instance\non the plus side of the arc and the part of the\ninstance on the minus side of the arc",
      "@param tree BSP tree under construction",
      "@param alpha arc limit",
      "@param isStart if true, the limit is the start of an arc",
      "@param limits limit angles of the split part",
      "@return split part (may be null)",
      "@param lower lower bound of the arc",
      "@param upper upper bound of the arc",
      "@param tree inside/outside BSP tree representing the arcs set",
      "@return azimuthal angle \\( \\alpha \\)",
      "@return normalized vector",
      "@return the angular separation between p1 and p2",
      "@return true if two points on the 2-sphere objects are equal, false if\n        object is null, not an instance of S2Point, or\n        not equal to this S2Point instance",
      "@param alpha azimuthal angle \\( \\alpha \\)",
      "@param vector corresponding vector",
      "@return lower angular bound of the arc,\nalways between 0 and \\( 2 \\pi \\)",
      "@return upper angular bound of the arc,\nalways between {@link #getInf()} and {@link #getInf()} \\( + 2 \\pi \\)",
      "@return angular size of the arc",
      "@return barycenter of the arc",
      "@return tolerance below which angles are considered identical",
      "@param tolerance tolerance below which angles are considered identical",
      "@return true if the plus side of the hyperplane is towards\nangles greater than hyperplane location",
      "@return a new limit angle, with orientation opposite to the instance orientation",
      "@param direct if true, the plus side of the hyperplane is towards\nangles greater than {@code location}"
   ],
   [
      "@return vertex location",
      "@param circle circle to bind with this vertex",
      "@param vertex other vertex to check instance against",
      "@return circle bound with both the instance and another vertex, or null if the\ntwo vertices do not share a circle yet",
      "@param incoming incoming edge",
      "@return incoming edge",
      "@param outgoing outgoing edge",
      "@return outgoing edge",
      "@param location vertex location",
      "@param newPole circle pole",
      "@return a new circle, with orientation opposite to the instance orientation",
      "@param direction direction for which phase is requested",
      "@return phase angle of the direction around the circle",
      "@param alpha phase around the circle",
      "@return circle point on the sphere",
      "@return an arbitrary x axis on the circle",
      "@return an arbitrary y axis point on the circle",
      "@return pole of the circle",
      "@param other other circle",
      "@return arc of the instance that lies inside the other circle",
      "@return a region containing the instance (really a {@link\nSphericalPolygonsSet SphericalPolygonsSet} instance)",
      "@param direction direction to check",
      "@return offset of the direction",
      "@param rotation rotation to use",
      "@return a new transform that can be applied to either {@link\nPoint Point}, {@link Circle Line} or {@link\norg.apache.commons.math3.geometry.partitioning.SubHyperplane\nSubHyperplane} instances"
   ],
   [
      "@param pole circle pole",
      "@param first first point contained in the great circle",
      "@param second second point contained in the great circle",
      "@param x first axis in the equator plane",
      "@param y second axis in the equator plane",
      "@param circle circle to copy",
      "@param start start vertex of the convex cell boundary",
      "@return area",
      "@return barycenter",
      "@return points strictly inside convex cells",
      "@param tolerance below which points are consider to be identical",
      "@param center center of the polygon (the center is in the inside half)",
      "@param meridian point defining the reference meridian for first polygon vertex",
      "@param outsideRadius distance of the vertices to the center",
      "@param n number of sides of the polygon",
      "@return vertices array",
      "@throws MathIllegalStateException if the tolerance setting does not allow to build\na clean non-ambiguous boundary",
      "@return boundary of the polygon, organized as an unmodifiable list of loops start vertices.",
      "@return a spherical cap enclosing the polygon",
      "@return list of points known to be strictly in all inside convex cells",
      "@return list of points known to be strictly in all outside convex cells",
      "@param pole pole of the hemisphere (the pole is in the inside half)",
      "@return start vertex",
      "@return end vertex",
      "@return length of the arc (can be greater than \\( \\pi \\))"
   ],
   [
      "@return circle supporting this edge",
      "@param alpha angle along the edge, counted from {@link #getStart()}",
      "@return an intermediate point",
      "@param next edge following the instance",
      "@param splitCircle circle splitting the edge in several parts",
      "@param outsideList list where to put parts that are outside of the split circle",
      "@param insideList list where to put parts that are inside the split circle",
      "@param subStart start of the sub-edge",
      "@param subEnd end of the sub-edge",
      "@param subLength length of the sub-edge",
      "@param list list where to put the sub-edge",
      "@return end vertex of the edge ({@code subEnd} if the edge was long enough and really\nadded, {@code subStart} if the edge was too small and therefore ignored)",
      "@param start start vertex",
      "@param end end vertex",
      "@param length length of the arc (it can be greater than \\( \\pi \\))",
      "@param circle circle supporting the edge",
      "@param sub boundary facet",
      "@param reversed if true, the facet has the inside on its plus side",
      "@param node node to which the edge belongs",
      "@param previous edge to be continued",
      "@return other edge, starting where the previous one ends (they\nhave not been connected yet)",
      "@throws MathIllegalStateException if there is not a single other edge",
      "@return boundary edges",
      "@param theta azimuthal angle \\( \\theta \\) in the x-y plane",
      "@param phi polar angle \\( \\varphi \\)"
   ],
   [
      "@throws OutOfRangeException if \\( \\varphi \\) is not in the [\\( 0; \\pi \\)] range",
      "@return azimuthal angle \\( \\theta \\) in the x-y plane",
      "@return polar angle \\( \\varphi \\)",
      "@param vector 3D vector",
      "@param support support points (may be empty)",
      "@return ball whose boundary lies on the prescribed support points",
      "@return center of the ball",
      "@return radius of the ball (can be negative if the ball is empty)",
      "@return support points used to define the ball",
      "@return number of support points used to define the ball",
      "@param point point to test",
      "@return true if the point is within the ball or at boundary",
      "@param margin margin to consider",
      "@return true if the point is within the ball enlarged\nby the margin or at boundary",
      "@param center center of the ball",
      "@param radius radius of the ball",
      "@param support support points used to define the ball",
      "@param points points to be enclosed",
      "@return enclosing ball",
      "@param extreme subset of extreme points",
      "@param nbExtreme number of extreme points to consider",
      "@param support points that must belong to the ball support",
      "@return enclosing ball, for the extreme subset only",
      "@param ball current ball",
      "@return farthest point"
   ],
   [
      "@param generator generator for balls on support",
      "@param points points to enclose",
      "@param node current BSP tree node",
      "@param sub sub-hyperplane",
      "@return true if inside leaf nodes have been found on the plus side",
      "@return true if inside leaf nodes have been found on the minus side",
      "@param region region on which to operate",
      "@return original point",
      "@return projected point, or null if there are no boundary",
      "@return offset of the point with respect to the boundary it is projected on",
      "@param original original point",
      "@param projected projected point",
      "@param offset offset of the point with respect to the boundary it is projected on",
      "@return projection",
      "@param node internal node",
      "@return regions in the node sub-hyperplane",
      "@param sub sub-hyperplane defining the region",
      "@param list to fill up",
      "@param point projected point to check",
      "@param hyperplane hyperplane into which the point was projected",
      "@param part boundary part",
      "@return true if point lies on the boundary part",
      "@return projection to a singular point of boundary part (may be null)",
      "@param newTree inside/outside BSP tree representing the new region",
      "@return the built region"
   ],
   [
      "@return a new region, copy of the instance",
      "@return true if the instance is empty",
      "@param node root node of the sub-tree (<em>must</em> have {@link\nRegion Region} tree semantics, i.e. the leaf nodes must have\n{@code Boolean} attributes representing an inside/outside\nproperty)",
      "@return true if the sub-tree starting at the given node is empty",
      "@return true if the instance covers the full space",
      "@return true if the sub-tree starting at the given node covers the full space",
      "@param region region to check against the instance",
      "@return true if the instance contains the specified tree",
      "@return projection of the point on the boundary",
      "@param includeBoundaryAttributes if true, the boundary attributes\nat internal nodes are guaranteed to be included (they may be\nincluded even if the argument is false, if they have already been\ncomputed due to a previous call)",
      "@return underlying BSP tree",
      "@return the size of the boundary (this is 0 in 1D, a length in\n2D, an area in 3D ...)",
      "@return the size of the instance (this is a length in 1D, an area\nin 2D, a volume in 3D ...)",
      "@return an object representing the barycenter",
      "@param hyperplane reference hyperplane",
      "@return one of {@link Side#PLUS Side.PLUS}, {@link Side#MINUS\nSide.MINUS}, {@link Side#BOTH Side.BOTH} or {@link Side#HYPER\nSide.HYPER} (the latter result can occur only if the tree\ncontains only one cut hyperplane)",
      "@param sub sub-hyperplane traversing the region",
      "@return filtered sub-hyperplane",
      "@param point point to transform",
      "@return a new object representing the transformed point",
      "@param hyperplane hyperplane to transform",
      "@return a new object representing the transformed hyperplane",
      "@param sub sub-hyperplane to transform",
      "@param original hyperplane in which the sub-hyperplane is\ndefined (this is the original hyperplane, the transform has\n<em>not</em> been applied to it)",
      "@param transformed hyperplane in which the sub-hyperplane is\ndefined (this is the transformed hyperplane, the transform\n<em>has</em> been applied to it)"
   ],
   [
      "@return a new object representing the transformed sub-hyperplane",
      "@param node node to add",
      "@param iterator nodes iterator",
      "@return tolerance below which points are considered to belong to hyperplanes",
      "@param boundary collection of edges belonging to the cell defined\nby the node",
      "@return a code representing the point status: either {@link\nRegion.Location#INSIDE}, {@link Region.Location#OUTSIDE} or\n{@link Region.Location#BOUNDARY}",
      "@param node root node of the region",
      "@return a code representing the point status: either {@link\nRegion.Location#INSIDE INSIDE}, {@link Region.Location#OUTSIDE\nOUTSIDE} or {@link Region.Location#BOUNDARY BOUNDARY}",
      "@param size size of the instance",
      "@param barycenter barycenter of the instance",
      "@param transform transform to apply",
      "@return a new region, resulting from the application of the\ntransform to the instance",
      "@param map transformed nodes map",
      "@return a new tree",
      "@param hyperplanes array of bounding hyperplanes (if null, an\nempty region will be built)",
      "@param sub sub-hyperplane to characterize",
      "@param splitters nodes that did split the current one",
      "@param sub part of the cut sub-hyperplane known to touch an outside cell",
      "@param splitters sub-hyperplanes that did split the current one",
      "@param sub part of the cut sub-hyperplane known to touch an inside cell",
      "@return true if the cut sub-hyperplane touches outside cells",
      "@return parts of the cut sub-hyperplane known to touch outside cells\n(may be null or empty)",
      "@return nodes that were used to split the outside touching part",
      "@return true if the cut sub-hyperplane touches inside cells",
      "@return parts of the cut sub-hyperplane known to touch inside cells\n(may be null or empty)"
   ],
   [
      "@return nodes that were used to split the inside touching part",
      "@param hyper underlying hyperplane",
      "@param remaining remaining region of the hyperplane",
      "@return a new sub-hyperplane",
      "@return underlying hyperplane",
      "@return remaining region of the hyperplane",
      "@param transform D-dimension transform to apply",
      "@return the transformed instance",
      "@param transformed image of the instance hyperplane by the transform",
      "@param hyperplane hyperplane to insert, it will be chopped in\norder to fit in the cell defined by the parent nodes of the\ninstance",
      "@return true if a cut sub-hyperplane has been inserted (i.e. if\nthe cell now has two leaf child nodes)",
      "@return a new tree, copy of the instance",
      "@return cut sub-hyperplane, null if this is a leaf tree",
      "@return tree on the plus side of the cut hyperplane, null if this\nis a leaf tree",
      "@return tree on the minus side of the cut hyperplane, null if this\nis a leaf tree",
      "@return parent node, null if the node has no parents",
      "@param attribute attribute to associate with the node",
      "@return attribute associated with the node or null if no\nattribute has been explicitly set using the {@link #setAttribute\nsetAttribute} method",
      "@param visitor object visiting the tree nodes",
      "@param sub sub-hyperplane to fit",
      "@return a new sub-hyperplane, guaranteed to have no part outside\nof the instance cell",
      "@return the tree cell to which the point belongs",
      "@param tolerance tolerance below which points close to a cut hyperplane\nare considered to belong to the hyperplane itself",
      "@param maxOffset offset below which a cut sub-hyperplane is considered\nclose to the point (in absolute value)",
      "@return close cells (may be empty if all cut sub-hyperplanes are farther\nthan maxOffset from the point)"
   ],
   [
      "@param close list to fill",
      "@param tree other tree to merge with the instance (will be\n<em>unusable</em> after the operation, as well as the\ninstance itself)",
      "@param leafMerger object implementing the final merging phase\n(this is where the semantic of the operation occurs, generally\ndepending on the attribute of the leaf node)",
      "@return a new tree, result of <code>instance &lt;op&gt;\ntree</code>, this value can be ignored if parentTree is not null\nsince all connections have already been established",
      "@param parentTree parent tree to connect to (may be null)",
      "@param isPlusChild if true and if parentTree is not null, the\nresulting tree should be the plus child of its parent, ignored if\nparentTree is null",
      "@param sub partitioning sub-hyperplane, must be already clipped\nto the convex region represented by the instance, will be used as\nthe cut sub-hyperplane of the returned tree",
      "@return a tree having the specified sub-hyperplane as its cut\nsub-hyperplane, the two parts of the split instance as its two\nsub-trees and a null parent",
      "@param vanishingHandler handler to use for handling very rare corner\ncases of vanishing cut sub-hyperplanes in internal nodes during merging",
      "@param cellAttribute attribute to set for the leaf node\ncorresponding to the initial instance cell",
      "@param otherLeafsAttributes attribute to set for the other leaf\nnodes",
      "@param internalAttributes attribute to set for the internal nodes",
      "@return a new tree (the original tree is left untouched) containing\na single branch with the cell as a leaf node, and other leaf nodes\nas the remnants of the pruned branches",
      "@param hyperplane chopping hyperplane",
      "@param attribute attribute of the tree (may be null)",
      "@param cut cut sub-hyperplane for the tree",
      "@param plus plus side sub-tree",
      "@param minus minus side sub-tree",
      "@param attribute attribute associated with the node (may be null)",
      "@param hyperplanes collection of bounding hyperplanes",
      "@param region1 first region (will be unusable after the operation as\nparts of it will be reused in the new region)",
      "@param region2 second region (will be unusable after the operation as\nparts of it will be reused in the new region)",
      "@return a new region, result of {@code region1 union region2}",
      "@return a new region, result of {@code region1 intersection region2}",
      "@return a new region, result of {@code region1 xor region2}"
   ],
   [
      "@return a new region, result of {@code region1 minus region2}",
      "@param region region to complement, it will not modified, a new\nregion independent region will be built",
      "@return a new region, complement of the specified one",
      "@param node current node of the original tree",
      "@return new tree, complement of the node",
      "@return size of the boundary",
      "@param element element to insert (silently ignored if null)",
      "@param element element to delete (silently ignored if null)",
      "@return true if the element was deleted from the tree",
      "@return true if the tree is empty",
      "@return number of elements contained in the tree",
      "@param reference reference object (may not be in the tree)",
      "@param minOffset minimal scale of the offset to add to all\ncomponents (must be greater than the MSBs of all components)",
      "@param ot T-uple to compare instance with",
      "@return a negative integer if the instance is less than the\nobject, zero if they are equal, or a positive integer if the\ninstance is greater than the object",
      "@return array containing the T-uple components",
      "@param bits binary representation of the double",
      "@return sign bit (zero if positive, non zero if negative)",
      "@return exponent",
      "@return mantissa",
      "@param l long from which the most significant bit is requested",
      "@return scale of the most significant bit of {@code l},\nor 0 if {@code l} is zero",
      "@param l long from which the least significant bit is requested",
      "@return scale of the least significant bit of {@code l},\nor 63 if {@code l} is zero",
      "@param i index of the component"
   ],
   [
      "@param k scale of the requested bit",
      "@return the specified bit (either 0 or 1), after the offset has\nbeen added to the double",
      "@param components double components of the T-uple",
      "@param node BSP node guaranteed to have a non null cut sub-hyperplane",
      "@return desired visit order, must be one of\n{@link Order#PLUS_MINUS_SUB}, {@link Order#PLUS_SUB_MINUS},\n{@link Order#MINUS_PLUS_SUB}, {@link Order#MINUS_SUB_PLUS},\n{@link Order#SUB_PLUS_MINUS}, {@link Order#SUB_MINUS_PLUS}",
      "@param node leaf BSP node having a null sub-hyperplane",
      "@param point point to project",
      "@return tolerance below which points are considered to belong to the hyperplane",
      "@return a sub-hyperplane covering the whole hyperplane",
      "@return a region containing the instance",
      "@param point n-dimension point of the space",
      "@param point (n-1)-dimension point of the sub-space",
      "@return part of the node cut sub-hyperplane that belongs to the\nboundary and has the outside of the region on the plus side of\nits underlying hyperplane",
      "@return part of the node cut sub-hyperplane that belongs to the\nboundary and has the inside of the region on the plus side of\nits underlying hyperplane",
      "@return sub-hyperplanes that were used to split the boundary part",
      "@param plusOutside part of the node cut sub-hyperplane that\nbelongs to the boundary and has the outside of the region on\nthe plus side of its underlying hyperplane (may be null)",
      "@param plusInside part of the node cut sub-hyperplane that\nbelongs to the boundary and has the inside of the region on the\nplus side of its underlying hyperplane (may be null)",
      "@param splitters sub-hyperplanes that were used to\nsplit the boundary part (may be null)",
      "@return a new sub-hyperplane, copy of the instance",
      "@param hyperplane hyperplane to check instance against",
      "@return one of {@link Side#PLUS}, {@link Side#MINUS}, {@link Side#BOTH},\n{@link Side#HYPER}",
      "@return an object containing both the part of the instance\non the plus side of the hyperplane and the part of the\ninstance on the minus side of the hyperplane",
      "@param other other sub-hyperplane to union (<em>must</em> be in the\nsame hyperplane as the instance)",
      "@return a new sub-hyperplane, union of the instance and other",
      "@return dimension of the space"
   ],
   [
      "@return n-1 dimension sub-space of this space",
      "@throws MathUnsupportedOperationException for dimension-1 spaces\nwhich do not have sub-spaces",
      "@return additive identity of the field",
      "@return multiplicative identity of the field",
      "@return The {@code Class} object that represents the runtime\n        class of this object.",
      "@return the state transition matrix",
      "@return the control matrix",
      "@return the process noise matrix",
      "@return the initial state estimation vector",
      "@return the initial error covariance matrix",
      "@return the measurement matrix",
      "@return the measurement noise matrix",
      "@return the state dimension",
      "@return the measurement vector dimension",
      "@return the state estimation vector",
      "@return the error covariance matrix",
      "@param u the control vector",
      "@throws DimensionMismatchException if the dimension of the control vector does not fit",
      "@throws DimensionMismatchException if the dimension of the control vector does not match",
      "@param z the measurement vector",
      "@throws DimensionMismatchException if the dimension of the measurement vector does not fit",
      "@throws SingularMatrixException if the covariance matrix could not be inverted",
      "@param process the model defining the underlying process dynamics",
      "@param measurement the model defining the given measurement characteristics",
      "@throws NullArgumentException if any of the given inputs is null (except for the control matrix)"
   ],
   [
      "@throws NonSquareMatrixException if the transition matrix is non square",
      "@throws DimensionMismatchException if the column dimension of the transition matrix does not match the dimension of the\n            initial state estimation vector",
      "@throws MatrixDimensionMismatchException if the matrix dimensions do not fit together",
      "@param stateTransition the state transition matrix",
      "@param control the control matrix",
      "@param processNoise the process noise matrix",
      "@param initialStateEstimate the initial state estimate vector",
      "@param initialErrorCovariance the initial error covariance matrix",
      "@throws NoDataException if any row / column dimension of the input matrices is zero",
      "@throws DimensionMismatchException if any of the input matrices is non-rectangular",
      "@param measMatrix the measurement matrix",
      "@param measNoise the measurement noise matrix",
      "@throws NullArgumentException if any of the input matrices is {@code null}",
      "@return a random scalar with null mean and unit standard deviation",
      "@param generator underlying random generator to use",
      "@param seed the seed value",
      "@return the next pseudorandom, uniformly distributed <code>int</code>\n value from this random number generator's sequence",
      "@return a pseudorandom, uniformly distributed {@code int}\nvalue between 0 (inclusive) and n (exclusive).",
      "@return the next pseudorandom, uniformly distributed <code>long</code>\nvalue from this random number generator's sequence",
      "@return the next pseudorandom, uniformly distributed\n<code>boolean</code> value from this random number generator's\nsequence",
      "@return the next pseudorandom, uniformly distributed <code>float</code>\nvalue between <code>0.0</code> and <code>1.0</code> from this\nrandom number generator's sequence",
      "@return the next pseudorandom, uniformly distributed\n <code>double</code> value between <code>0.0</code> and\n <code>1.0</code> from this random number generator's sequence",
      "@return the next pseudorandom, Gaussian (\"normally\") distributed\n<code>double</code> value with mean <code>0.0</code> and\nstandard deviation <code>1.0</code> from this random number\n generator's sequence",
      "@param start First index into {@link #mem} array.",
      "@param seed Initial seed."
   ],
   [
      "@param seed Initial seed. If {@code null}, the seed will be related\nto the current time.",
      "@return underlying uncorrelated components generator",
      "@return rank of the square matrix.",
      "@return root of the square matrix",
      "@return a random vector as an array of double. The returned array\nis created at each call, the caller can do what it wants with it.",
      "@param mean Expected mean values for all components.",
      "@param covariance Covariance matrix.",
      "@param small Diagonal elements threshold under which  column are\nconsidered to be dependent on previous ones and are discarded",
      "@param generator underlying generator for uncorrelated normalized\ncomponents.",
      "@throws org.apache.commons.math3.linear.NonPositiveDefiniteMatrixException if the covariance matrix is not strictly positive definite.",
      "@throws DimensionMismatchException if the mean and covariance\narrays dimensions do not match.",
      "@param small Diagonal elements threshold under which  column are\nconsidered to be dependent on previous ones and are discarded.",
      "@param generator Underlying generator for uncorrelated normalized\ncomponents.",
      "@param seed the initial seed (32 bits integer)",
      "@param seed the initial seed (32 bits integers array), if null\nthe seed of the generator will be related to the current time",
      "@param seed the initial seed (64 bits integer)",
      "@param bits number of random bits to produce",
      "@return random bits generated",
      "@return a pseudorandom, uniformly distributed {@code long}\nvalue between 0 (inclusive) and n (exclusive).",
      "@param start Index at which to start inserting the generated bytes.",
      "@param len Number of bytes to insert.",
      "@param bytes Array in which to put the generated bytes. Cannot be {@code null}.",
      "@param rng Generator whose methods will be called through\ntheir corresponding overridden synchronized version.\nTo ensure thread-safety, the wrapped generator <em>must</em>\nnot be used directly.",
      "@return a random vector as a newly built array of double",
      "@param mean expected mean values for each component"
   ],
   [
      "@param standardDeviation standard deviation for each component",
      "@param generator underlying generator for uncorrelated normalized\ncomponents",
      "@param dimension dimension of the vectors to generate",
      "@return generated value",
      "@throws IOException in REPLAY_MODE if a file I/O error occurs",
      "@throws MathIllegalStateException if mode is not recognized",
      "@throws MathIllegalArgumentException if the underlying random generator thwrows one",
      "@param values array to be filled",
      "@param length length of output array",
      "@return array of generated values",
      "@throws IOException if an I/O error occurs reading the input file",
      "@throws ZeroException if URL contains no data",
      "@param binCount the number of bins used in computing the empirical\ndistribution",
      "@throws IOException if an error occurs reading the input file",
      "@return Value of property mode.",
      "@param mode New value of the data generation mode.",
      "@return Values file URL.",
      "@param url String representation for new valuesFileURL.",
      "@throws MalformedURLException if url is not well formed",
      "@param url URL of the values file.",
      "@return EmpircalDistribution built by {@link #computeDistribution()}",
      "@throws IOException if an error occurs opening the file",
      "@throws IOException if an error occurs closing the file",
      "@return Mean used in data generation.",
      "@param mu new Mean value."
   ],
   [
      "@return Standard deviation used when operating in {@link #GAUSSIAN_MODE}.",
      "@param sigma New standard deviation.",
      "@param seed Value with which to reseed the {@link RandomDataImpl}\nused to generate random data.",
      "@return next random value from the empirical distribution digest",
      "@throws MathIllegalStateException if digest has not been initialized",
      "@return next value from the replay file",
      "@throws IOException if there is a problem reading from the file",
      "@throws MathIllegalStateException if URL contains no data",
      "@throws NumberFormatException if an invalid numeric string is\n  encountered in the file",
      "@return random uniform value",
      "@return random exponential value",
      "@return random Gaussian value",
      "@param randomData the RandomDataImpl instance used to source random data",
      "@param generator source of random data",
      "@param i the dimension index",
      "@param j the digit index",
      "@param b the base for this dimension",
      "@param digit the j-th digit",
      "@return the scrambled digit",
      "@param index the index in the sequence to skip to",
      "@return the i-th point in the Halton sequence",
      "@return the index of the next point",
      "@param dimension the space dimension",
      "@param weights the weights used during scrambling, may be null in which case no scrambling will be performed",
      "@throws OutOfRangeException if the space dimension is outside the range [1, len], where\n  len refers to the length of the bases array"
   ],
   [
      "@param len the length of the string to be generated",
      "@return a random string of hex characters of length {@code len}",
      "@param lower lower bound for generated integer",
      "@param upper upper bound for generated integer",
      "@param lower lower bound for generated long integer",
      "@param upper upper bound for generated long integer",
      "@param mean the mean of the Poisson distribution",
      "@return a random value following the specified Poisson distribution",
      "@param mu the mean of the distribution",
      "@param sigma the standard deviation of the distribution",
      "@return a random value following the specified Gaussian distribution",
      "@param mean the mean of the distribution",
      "@return a random value following the specified exponential distribution",
      "@param lower the exclusive lower bound of the support",
      "@param upper the exclusive upper bound of the support",
      "@return a uniformly distributed random value between lower and upper\n(exclusive)",
      "@throws NotFiniteNumberException if one of the bounds is infinite",
      "@throws NotANumberException if one of the bounds is NaN",
      "@param lower the lower bound of the support",
      "@param lowerInclusive {@code true} if the lower bound is inclusive",
      "@return uniformly distributed random value in the {@code (lower, upper)}\ninterval, if {@code lowerInclusive} is {@code false}, or in the\n{@code [lower, upper)} interval, if {@code lowerInclusive} is\n{@code true}",
      "@param n the domain of the permutation",
      "@param k the size of the permutation",
      "@return a random {@code k}-permutation of {@code n}, as an array of\nintegers",
      "@param c the collection to be sampled"
   ],
   [
      "@param k the size of the sample",
      "@return a random sample of {@code k} elements from {@code c}",
      "@return a random vector as an array of double.",
      "@param len the desired string length.",
      "@return the random string.",
      "@param rng random generator to use",
      "@param shape the median of the Gamma distribution",
      "@param scale the scale parameter of the Gamma distribution",
      "@return random value sampled from the Gamma(shape, scale) distribution",
      "@param populationSize the population size of the Hypergeometric distribution",
      "@param numberOfSuccesses number of successes in the population of the Hypergeometric distribution",
      "@param sampleSize the sample size of the Hypergeometric distribution",
      "@return random value sampled from the Hypergeometric(numberOfSuccesses, sampleSize) distribution",
      "@param r the number of successes of the Pascal distribution",
      "@param p the probability of success of the Pascal distribution",
      "@return random value sampled from the Pascal(r, p) distribution",
      "@param df the degrees of freedom of the T distribution",
      "@return random value from the T(df) distribution",
      "@param shape the shape parameter of the Weibull distribution",
      "@param scale the scale parameter of the Weibull distribution",
      "@return random value sampled from the Weibull(shape, size) distribution",
      "@param numberOfElements the number of elements of the ZipfDistribution",
      "@param exponent the exponent of the ZipfDistribution",
      "@return random value sampled from the Zipf(numberOfElements, exponent) distribution",
      "@param alpha first distribution shape parameter"
   ],
   [
      "@param beta second distribution shape parameter",
      "@return random value sampled from the beta(alpha, beta) distribution",
      "@param numberOfTrials number of trials of the Binomial distribution",
      "@param probabilityOfSuccess probability of success of the Binomial distribution",
      "@return random value sampled from the Binomial(numberOfTrials, probabilityOfSuccess) distribution",
      "@param median the median of the Cauchy distribution",
      "@param scale the scale parameter of the Cauchy distribution",
      "@return random value sampled from the Cauchy(median, scale) distribution",
      "@param df the degrees of freedom of the ChiSquare distribution",
      "@return random value sampled from the ChiSquare(df) distribution",
      "@param numeratorDf the numerator degrees of freedom of the F distribution",
      "@param denominatorDf the denominator degrees of freedom of the F distribution",
      "@return random value sampled from the F(numeratorDf, denominatorDf) distribution",
      "@param seed the seed value to use",
      "@param algorithm the name of the PRNG algorithm",
      "@param provider the name of the provider",
      "@throws NoSuchAlgorithmException if the specified algorithm is not available",
      "@throws NoSuchProviderException if the specified provider is not installed",
      "@return the Random used to generate random data",
      "@return the SecureRandom used to generate secure random data, wrapped in a\n{@link RandomGenerator}.",
      "@param rand the source of (non-secure) random data\n(may be null, resulting in the default generator)",
      "@return the next pseudorandom, uniformly distributed {@code int}\n value from this random number generator's sequence",
      "@return the next pseudorandom, uniformly distributed {@code long}\nvalue from this random number generator's sequence",
      "@return the next pseudorandom, uniformly distributed\n{@code boolean} value from this random number generator's\nsequence",
      "@return the next pseudorandom, uniformly distributed {@code float}\nvalue between {@code 0.0} and {@code 1.0} from this\nrandom number generator's sequence"
   ],
   [
      "@return the next pseudorandom, uniformly distributed\n {@code double} value between {@code 0.0} and\n {@code 1.0} from this random number generator's sequence",
      "@return the next pseudorandom, Gaussian (\"normally\") distributed\n{@code double} value with mean {@code 0.0} and\nstandard deviation {@code 1.0} from this random number\n generator's sequence",
      "@param seed initial seed",
      "@return a random scalar with zero location and unit scale",
      "@param alpha Stability parameter. Must be in range (0, 2]",
      "@param beta Skewness parameter. Must be in range [-1, 1]",
      "@param work work array",
      "@param lmDir the \"returned\" LM direction is stored in this array",
      "@param jacobian Weighted Jacobian matrix at the current point.",
      "@return data used in other methods of this class.",
      "@throws ConvergenceException if the decomposition cannot be performed.",
      "@param y vector to multiply (will be overwritten with the result)",
      "@param internalData Data.",
      "@param initialStepBoundFactor initial step bound factor",
      "@param costRelativeTolerance cost relative tolerance",
      "@param parRelativeTolerance parameters relative tolerance",
      "@param orthoTolerance orthogonality tolerance",
      "@param qrRankingThreshold threshold in the QR decomposition. Columns with a 2\n                              norm less than this threshold are considered to be\n                              all 0s.",
      "@param tol the relative and absolute tolerance.",
      "@param relTol the relative tolerance.",
      "@param absTol the absolute tolerance.",
      "@param value the function value",
      "@param evaluations number of times the function was evaluated",
      "@param iterations number of iterations of the algorithm",
      "@param problem the delegate"
   ],
   [
      "@param unweighted the evalutation before weights are applied",
      "@param weightSqrt the matrix square root of the weight matrix",
      "@param leastSquaresProblem the problem definition, including model function and\n                           convergence criteria.",
      "@return The optimum.",
      "@param observationSize the number of observation. Needed for {@link\n                       #getRMS()}.",
      "@return the matrix {@link Decomposition} algoritm.",
      "@param newDecomposition the {@link Decomposition} algorithm to use.",
      "@param jacobian the m by n jacobian matrix, J. Input.",
      "@param residuals the m by 1 residual vector, r. Input.",
      "@return the n by n normal matrix and  the n by 1 J<sup>Tr vector.",
      "@param decomposition the {@link Decomposition} algorithm.",
      "@param model the model function. Produces the computed values.",
      "@param observed the observed (target) values",
      "@param start the initial guess.",
      "@param weight the weight matrix",
      "@param checker convergence checker",
      "@param maxEvaluations the maximum number of times to evaluate the model",
      "@param maxIterations the maximum number to times to iterate in the algorithm",
      "@param lazyEvaluation Whether the call to {@link Evaluation#evaluate(RealVector)}\nwill defer the evaluation until access to the value is requested.",
      "@param paramValidator Model parameters validator.",
      "@return the specified General Least Squares problem.",
      "@param jacobian the jacobian of the model with respect to the parameters",
      "@param problem the unweighted problem",
      "@param weights the matrix of weights",
      "@return a new {@link LeastSquaresProblem} with the weights applied. The original\n        {@code problem} is not modified."
   ],
   [
      "@param weights the diagonal of the weight matrix",
      "@param problem the problem to track.",
      "@param counter the counter to increment.",
      "@return a least squares problem that tracks evaluations",
      "@param checker the convergence checker to adapt.",
      "@param m Symmetric, positive-definite (weight) matrix.",
      "@return the square-root of the weight matrix.",
      "@param value the vector value function",
      "@param jacobian the Jacobian function",
      "@return a function that computes both at the same time",
      "@param params Point.",
      "@return the value at the given point.",
      "@return the Jacobian at the given point.",
      "@param point the abscissae",
      "@return the values and their Jacobian of this vector valued function.",
      "@return a new {@link LeastSquaresProblem}.",
      "@param newMaxEvaluations the maximum number of evaluations permitted.",
      "@return this",
      "@param newMaxIterations the maximum number of iterations permitted.",
      "@param newChecker the convergence checker.",
      "@param value the model function value",
      "@param jacobian the Jacobian of {@code value}",
      "@param randomGenerator wrapped RandomGenerator instance",
      "@return a Random instance wrapping the RandomGenerator",
      "@param randomGenerator the wrapped generator"
   ],
   [
      "@param rng JDK {@link Random} instance that will generate the\nthe random data.",
      "@return the given RNG, wrapped in a {@link RandomGenerator}.",
      "@param seed Original seed.",
      "@return the converted seed.",
      "@param seed the initial seed (32 bits integers array). If null\nthe seed of the generator will be the system time plus the system identity\nhash code of the instance.",
      "@param k number of bits in the pool (not necessarily a multiple of 32)",
      "@param m1 first parameter of the algorithm",
      "@param m2 second parameter of the algorithm",
      "@param m3 third parameter of the algorithm",
      "@return the delegate object.",
      "@param distribution Continuous distribution to generate a random value from",
      "@return a random value sampled from the given distribution",
      "@throws MathIllegalArgumentException if the underlynig distribution throws one",
      "@param distribution Integer distribution to generate a random value from",
      "@param in the input data array",
      "@param url url of the input file",
      "@throws IOException if an IO error occurs",
      "@param file the input file",
      "@param da object providing access to the data",
      "@param value the value whose bin we are trying to find",
      "@return the index of the bin containing the value",
      "@return the random value.",
      "@throws MathIllegalStateException if the distribution has not been loaded",
      "@return the sample statistics",
      "@throws IllegalStateException if the distribution has not been loaded"
   ],
   [
      "@return the number of bins.",
      "@return List of bin statistics.",
      "@return array of bin upper bounds",
      "@return array of upper bounds of subintervals used in data generation",
      "@throws NullPointerException unless a {@code load} method has been\ncalled beforehand.",
      "@return true if the distribution has been loaded",
      "@param seed random generator seed",
      "@param i the index of the bin",
      "@return the probability that selection begins in bin i",
      "@return the probability that selection begins in a bin below bin i.",
      "@param i index of the bin",
      "@return the difference in the within-bin kernel cdf between the\nupper and lower endpoints of bin i",
      "@param x the value to locate within a bin",
      "@return the within-bin kernel of the bin containing x",
      "@param binIndex maximum bin index",
      "@return sum of the probabilities of bins through binIndex",
      "@param bStats summary statistics for the bin",
      "@return within-bin kernel parameterized by bStats",
      "@param generator random data generator (may be null, resulting in default JDK generator)",
      "@param binCount number of bins",
      "@param randomData random data generator (may be null, resulting in default JDK generator)",
      "@param binCount number of bins. Must be strictly positive.",
      "@param randomData Random data generator.",
      "@throws NotStrictlyPositiveException if {@code binCount <= 0}.",
      "@param is the input stream to read the direction vector from"
   ],
   [
      "@return the last dimension that has been read from the input stream",
      "@throws IOException if the stream could not be read",
      "@throws MathParseException if the content could not be parsed successfully",
      "@param d the dimension, zero-based",
      "@param a the coefficients of the primitive polynomial",
      "@param m the initial direction numbers",
      "@return the i-th point in the Sobol sequence",
      "@param is the stream to read the direction vectors from",
      "@throws NotStrictlyPositiveException if the space dimension is &lt; 1",
      "@throws OutOfRangeException if the space dimension is outside the range [1, max], where\n  max refers to the maximum dimension found in the input stream",
      "@throws MathParseException if the content in the stream could not be parsed successfully",
      "@throws IOException if an error occurs while reading from the input stream",
      "@param seed the initial seed (32 bits integers array), if null\nthe seed of the generator will be the current system time plus the\nsystem identity hash code of this instance",
      "@param dimension Space dimension.",
      "@param rand RNG for the individual components of the vectors.",
      "@param a element to add",
      "@return a new element representing this + a",
      "@param a element to subtract",
      "@return a new element representing this - a",
      "@return the opposite of {@code this}.",
      "@param n Number of times {@code this} must be added to itself.",
      "@return A new element representing n &times; this.",
      "@param a element to multiply",
      "@return a new element representing this &times; a",
      "@param a element to divide by"
   ],
   [
      "@return a new element representing this &divide; a",
      "@throws MathArithmeticException if {@code a} is zero",
      "@return the inverse of {@code this}.",
      "@throws MathArithmeticException if {@code this} is zero",
      "@return {@link Field} to which the instance belongs",
      "@return available complex format locales.",
      "@param f BigFraction object to format",
      "@return A formatted BigFraction in proper form.",
      "@return the default complex format.",
      "@return the complex format specific to the given locale.",
      "@param BigFraction the object to format.",
      "@param obj the object to format.",
      "@throws MathIllegalArgumentException if <code>obj</code> is not a valid type.",
      "@return the parsed {@link BigFraction} object.",
      "@throws MathParseException if the beginning of the specified string\n           cannot be parsed.",
      "@return a parsed <code>BigInteger</code> or null if string does not\ncontain a BigInteger at the specified position",
      "@param format the custom format for both the numerator and denominator.",
      "@param numeratorFormat the custom format for the numerator.",
      "@param denominatorFormat the custom format for the denominator.",
      "@return the absolute value.",
      "@return -1 if this is less than {@code object}, +1 if this is greater\n        than {@code object}, 0 if they are equal.",
      "@return the fraction as a {@code double}",
      "@param other fraction to test for equality to this fraction",
      "@return true if two fractions are equal, false if object is\n        {@code null}, not an instance of {@link Fraction}, or not equal\n        to this fraction instance.",
      "@return the fraction as a {@code float}"
   ],
   [
      "@return the denominator.",
      "@return the numerator.",
      "@return the whole number fraction part",
      "@return the negation of this fraction.",
      "@return the reciprocal fraction",
      "@return a {@code Fraction} instance with the resulting values",
      "@throws MathArithmeticException if the resulting numerator or denominator exceeds\n {@code Integer.MAX_VALUE}",
      "@param i the {@code integer} to add.",
      "@return this + i",
      "@throws MathArithmeticException if the resulting numerator or denominator\n  cannot be represented in an {@code int}.",
      "@param i the {@code integer} to subtract.",
      "@return this - i",
      "@param fraction the fraction to subtract, must not be {@code null}",
      "@param isAdd true to add, false to subtract",
      "@throws NullArgumentException if the fraction is {@code null}",
      "@param i the {@code integer} to multiply by.",
      "@return this * i",
      "@param i the {@code integer} to divide by.",
      "@return the fraction percentage as a {@code double}.",
      "@param numerator the numerator, for example the three in 'three sevenths'",
      "@param denominator the denominator, for example the seven in 'three sevenths'",
      "@return a new fraction instance, with the numerator and denominator reduced",
      "@return a string representation of the fraction.",
      "@param value the double value to convert to a fraction.",
      "@throws FractionConversionException if the continued fraction failed to\n        converge."
   ],
   [
      "@param epsilon maximum error allowed.  The resulting fraction is within\n       {@code epsilon} of {@code value}, in absolute terms.",
      "@param maxIterations maximum number of convergents",
      "@param maxDenominator The maximum allowed value for denominator",
      "@throws FractionConversionException if the continued fraction failed to\n        converge",
      "@param maxDenominator maximum denominator value allowed.",
      "@param num the numerator.",
      "@param den the denominator.",
      "@param numerator the numerator, for example the three in 'three sevenths'.",
      "@param denominator the denominator, for example the seven in 'three sevenths'.",
      "@return a new fraction instance, with the numerator and denominator\n        reduced.",
      "@return the absolute value as a {@link BigFraction}.",
      "@return a <code>BigFraction</code> instance with the resulting values.",
      "@param l the {@code long} to add.",
      "@return a {@link BigFraction} instance with the resulting values.",
      "@return the fraction as a <code>BigDecimal</code>.",
      "@throws ArithmeticException if the exact quotient does not have a terminating decimal\n            expansion.",
      "@param roundingMode rounding mode to apply. see {@link BigDecimal} constants.",
      "@throws IllegalArgumentException if {@code roundingMode} does not represent a valid rounding\n            mode.",
      "@param scale scale of the <code>BigDecimal</code> quotient to be returned.\n           see {@link BigDecimal} for more information.",
      "@return a {@link BigFraction} instance with the resulting values",
      "@param i the {@code int} to divide by",
      "@param l the {@code long} to divide by",
      "@param other fraction to test for equality to this fraction, can be\n           <code>null</code>.",
      "@return true if two fractions are equal, false if object is\n        <code>null</code>, not an instance of {@link BigFraction}, or not\n        equal to this fraction instance.",
      "@return the fraction as a {@code float}."
   ],
   [
      "@return the denominator as a <code>BigInteger</code>.",
      "@return the denominator as a {@code int}.",
      "@return the denominator as a {@code long}.",
      "@return the numerator as a <code>BigInteger</code>.",
      "@return the numerator as a {@code int}.",
      "@return the numerator as a {@code long}.",
      "@return a hash code value for this object.",
      "@return the whole number fraction part.",
      "@param bg the {@code BigInteger} to multiply by.",
      "@return a {@code BigFraction} instance with the resulting values.",
      "@param i the {@code int} to multiply by.",
      "@param l the {@code long} to multiply by.",
      "@param exponent exponent to which this {@code BigFraction} is to be\n           raised.",
      "@return <tt>this<sup>exponent</sup></tt>.",
      "@param exponent exponent to which this <code>BigFraction</code> is to be raised.",
      "@return <tt>this<sup>exponent</sup></tt> as a <code>BigFraction</code>.",
      "@return the reciprocal fraction.",
      "@return the reduced <code>BigFraction</code>. It doesn't change anything if\n        the fraction can be reduced.",
      "@param l the {@code long} to subtract.",
      "@throws MathIllegalArgumentException if value is NaN or infinite",
      "@param epsilon maximum error allowed. The resulting fraction is within\n           <code>epsilon</code> of <code>value</code>, in absolute terms.",
      "@param maxIterations maximum number of convergents.",
      "@throws FractionConversionException if the continued fraction failed to converge.",
      "@param maxDenominator The maximum allowed value for denominator.",
      "@return the default number format."
   ],
   [
      "@return the default number format specific to the given locale.",
      "@return the denominator format.",
      "@return the numerator format.",
      "@param format the new denominator format value.",
      "@param format the new numerator format value.",
      "@param pos input/output parsing parameter.  On output, <code>pos</code>\n       holds the index of the next non-whitespace character.",
      "@return the first non-whitespace character.",
      "@param value the double value to format",
      "@param buffer StringBuffer to append to",
      "@param position On input: an alignment field, if desired. On output: the\n           offsets of the alignment field",
      "@return a reference to the appended buffer",
      "@param value the long value to format",
      "@param f Fraction object to format",
      "@return a formatted fraction in proper form.",
      "@param fraction the object to format.",
      "@throws FractionConversionException if the number cannot be converted to a fraction",
      "@return the parsed {@link Fraction} object.",
      "@return the whole format.",
      "@param format The new whole format value.",
      "@param format the custom format for the whole, numerator, and\n       denominator.",
      "@param wholeFormat the custom format for the whole.",
      "@param value double value to convert",
      "@param maxIterations maximal number of iterations allowed",
      "@param p current numerator",
      "@param q current denominator"
   ],
   [
      "@param wrong Value that is infinite or NaN.",
      "@param args Optional arguments.",
      "@param specific Specific context pattern.",
      "@return the lower end.",
      "@return the higher end.",
      "@return the value at the lower end.",
      "@return the value at the higher end.",
      "@param lo Lower end of the interval.",
      "@param hi Higher end of the interval.",
      "@param fLo Value at lower end of the interval.",
      "@param fHi Value at higher end of the interval.",
      "@param specific Contextual information on what caused the exception.",
      "@param args Additional arguments.",
      "@param pattern Message pattern providing the specific context of\nthe error.",
      "@param pattern Message pattern providing the specific context of the error.",
      "@param arguments Values for replacing the placeholders in {@code pattern}.",
      "@param max Maximum number of evaluations.",
      "@return a reference to the exception context.",
      "@return a reference to the exception to which the context relates",
      "@param arguments Values for replacing the placeholders in the message\npattern.",
      "@param key Context key (not null).",
      "@param value Context value.",
      "@param key Context key.",
      "@return the context value or {@code null} if the key does not exist.",
      "@return the set of keys."
   ],
   [
      "@return the message.",
      "@return the localized message.",
      "@param locale Locale in which the message should be translated.",
      "@param separator Separator inserted between the message parts.",
      "@param separator Message separator.",
      "@return a localized message string.",
      "@param out Stream.",
      "@throws IOException This should never happen.",
      "@param in Stream.",
      "@throws ClassNotFoundException This should never happen.",
      "@param obj Object that does not implement the {@code Serializable}\ninterface.",
      "@return a string that mentions which class could not be serialized.",
      "@param throwable the exception this context refers too",
      "@param array Array (possibly multidimensional).",
      "@return a list of all the {@code Object} instances contained in\n{@code array}.",
      "@param source source text",
      "@return the source string.",
      "@param locale locale into which to get the string.",
      "@return the localized string or the source string if no\nlocalized version is available.",
      "@param sourceFormat source English format to use when no\nlocalized version is available",
      "@return an array containing the wrong dimensions.",
      "@return an array containing the expected dimensions.",
      "@param index Dimension index.",
      "@return the wrong dimension stored at {@code index}.",
      "@return the expected dimension stored at {@code index}."
   ],
   [
      "@param wrong Wrong dimensions.",
      "@param expected Expected dimensions.",
      "@param specific Message pattern providing the specific context of\nthe error.",
      "@return the lower bound.",
      "@return the higher bound.",
      "@param wrong Requested value.",
      "@param lo Lower bound.",
      "@param hi Higher bound.",
      "@param specific Context information.",
      "@return {@code true} if the maximum is included in the allowed range.",
      "@return the maximum.",
      "@param wrong Value that is larger than the maximum.",
      "@param max Maximum.",
      "@param boundIsAllowed if true the maximum is included in the allowed range.",
      "@param pattern Message pattern explaining the cause of the error.",
      "@param cause Root cause.",
      "@param value Argument.",
      "@param specific Specific context where the error occurred.",
      "@return the order direction.",
      "@return {@code true} is the sequence should be strictly monotonic.",
      "@return the current index.",
      "@return the previous value.",
      "@param wrong Value that did not match the requirements.",
      "@param previous Previous value in the sequence.",
      "@param index Index of the value that did not match the requirements."
   ],
   [
      "@param direction Strictly positive for a sequence required to be\nincreasing, negative (or zero) for a decreasing sequence.",
      "@param strict Whether the sequence must be strictly increasing or\ndecreasing.",
      "@param arguments Arguments.",
      "@return the expected dimension.",
      "@param specific Specific context information pattern.",
      "@param wrong Wrong dimension.",
      "@param expected Expected dimension.",
      "@param wrong Bad string representation of the object.",
      "@param position Index, in the {@code wrong} string, that caused the\nparsing to fail.",
      "@param type Class of the object supposedly represented by the\n{@code wrong} string.",
      "@return the requested value.",
      "@param pattern Localizable pattern.",
      "@param wrong Wrong number.",
      "@return the maximum number of evaluations.",
      "@return {@code true} if the minimum is included in the allowed range.",
      "@return the minimum.",
      "@param wrong Value that is smaller than the minimum.",
      "@param min Minimum.",
      "@param boundIsAllowed Whether {@code min} is included in the allowed range.",
      "@param cause root cause",
      "@param f the real data array to be transformed (signal)",
      "@param type the type of transform (forward, inverse) to be performed",
      "@return the real transformed array (spectrum)",
      "@throws MathIllegalArgumentException if the array cannot be transformed\n  with the given type (this may be for example due to array size, which is\n  constrained in some transforms)",
      "@param f the function to be sampled and transformed"
   ],
   [
      "@param min the (inclusive) lower bound for the interval",
      "@param max the (exclusive) upper bound for the interval",
      "@param n the number of sample points",
      "@return the real transformed array",
      "@throws NonMonotonicSequenceException if the lower bound is greater than, or equal to the upper bound",
      "@throws MathIllegalArgumentException if the sample cannot be transformed\n  with the given type (this may be for example due to sample size, which is\n  constrained in some transforms)",
      "@throws MathIllegalArgumentException if the length of the data array is\n  not a power of two, or the first element of the data array is not zero",
      "@throws org.apache.commons.math3.exception.NonMonotonicSequenceException if the lower bound is greater than, or equal to the upper bound",
      "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if the number of sample points is negative",
      "@throws MathIllegalArgumentException if the number of sample points is not a power of two",
      "@param f the real data array to be transformed",
      "@param normalization the type of normalization to be applied to the transformed data",
      "@param a the first array to be shuffled",
      "@param b the second array to be shuffled",
      "@param dataRI the unscaled transformed data",
      "@param normalization the normalization to be applied",
      "@param type the type of transform (forward, inverse) which resulted in the specified data",
      "@param dataRI the two dimensional array of real and imaginary parts of the data",
      "@param normalization the normalization to be applied to the transformed data",
      "@throws DimensionMismatchException if the number of rows of the specified\n  array is not two, or the array is not rectangular",
      "@throws MathIllegalArgumentException if the number of data points is not\n  a power of two",
      "@return the complex transformed array",
      "@throws MathIllegalArgumentException if the length of the data array is not a power of two",
      "@throws org.apache.commons.math3.exception.NumberIsTooLargeException if the lower bound is greater than, or equal to the upper bound",
      "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if the number of sample points {@code n} is negative"
   ],
   [
      "@throws MathIllegalArgumentException if the number of sample points\n  {@code n} is not a power of two",
      "@param f the complex data array to be transformed",
      "@param mdca Multi-Dimensional Complex Array, i.e. {@code Complex[][][][]}",
      "@return transform of {@code mdca} as a Multi-Dimensional Complex Array, i.e. {@code Complex[][][][]}",
      "@throws IllegalArgumentException if any dimension is not a power of two",
      "@param mdcm input matrix",
      "@param d index of the dimension to process",
      "@param subVector recursion subvector",
      "@param normalization the type of normalization to be applied to the\ntransformed data",
      "@throws MathIllegalArgumentException if the length of the data array is\nnot a power of two plus one",
      "@throws MathIllegalArgumentException if the number of sample points is\nnot a power of two plus one",
      "@param f the real array to be scaled",
      "@param d the real scaling coefficient",
      "@return a reference to the scaled array",
      "@param f the complex array to be scaled",
      "@param dataC the array of {@link Complex} data to be transformed",
      "@return a two dimensional array filled with the real and imaginary parts\n  of the specified complex input",
      "@param dataRI the array of real and imaginary parts to be transformed",
      "@return an array of {@link Complex} with specified real and imaginary parts.",
      "@param n the {@code int} whose base-2 logarithm is to be evaluated",
      "@return the base-2 logarithm of {@code n}",
      "@throws MathIllegalArgumentException if {@code n} is not a power of two",
      "@throws MathIllegalArgumentException if the length of the data array is\nnot a power of two",
      "@param f the integer data array to be transformed (signal)",
      "@return the integer transformed array (spectrum)"
   ],
   [
      "@param x the real data array to be transformed",
      "@return the real transformed array, {@code y}",
      "@param x the integer data array to be transformed",
      "@return the integer transformed array, {@code y}",
      "@param newModel the model function value and Jacobian",
      "@param newTarget the observed data.",
      "@param newStart the initial guess.",
      "@param newWeight the weight matrix",
      "@param newValue Whether to perform lazy evaluation.",
      "@return this object.",
      "@param newValidator Parameter validator.",
      "@return the initial guess values.",
      "@return the number of scalar observations",
      "@return the number of scalar parameters",
      "@param point the parameter values.",
      "@return the model's value and derivative at the given point.",
      "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximal number of evaluations (of the model vector function) is\n         exceeded.",
      "@param x Abscissa of the point.",
      "@param y Observed value  at {@code x}. After fitting we should\nhave {@code f(x)} as close as possible to this value.",
      "@param weight Weight of the observed point.",
      "@param observed Observed point to add.",
      "@return the observed points, in the order they were added to this\ncontainer.",
      "@param initialGuess First guess values in the following order:\n<ul>\n <li>Norm</li>\n <li>Mean</li>\n <li>Sigma</li>\n</ul>",
      "@return the parameters of the Gaussian function that best fits the\nobserved points (in the same order as above).",
      "@param points Observations."
   ],
   [
      "@return the optimizer to use for fitting the curve to the\ngiven {@code points}.",
      "@param points Sample points.",
      "@return the least squares problem to use for fitting the curve to the\ngiven {@code points}.",
      "@param degree Degree of the polynomial to be fitted.",
      "@param initialGuess Initial guess.",
      "@throws MathInternalError if {@code initialGuess} is {@code null}.",
      "@param x the point for which the function value should be computed",
      "@param f List of functions.",
      "@return the composite function.",
      "@return a function that computes the sum of the functions.",
      "@return a function that computes the product of the functions.",
      "@param combiner Combiner function.",
      "@param g Function.",
      "@param initialValue Initial value.",
      "@return a collector function.",
      "@param f Binary function.",
      "@param fixed value to which the first argument of {@code f} is set.",
      "@return the unary function h(x) = f(fixed, x)",
      "@param fixed value to which the second argument of {@code f} is set.",
      "@return the unary function h(x) = f(x, fixed)",
      "@param f Function to be sampled",
      "@param min Lower bound of the interval (included).",
      "@param max Upper bound of the interval (excluded).",
      "@param n Number of sample points.",
      "@return the array of samples."
   ],
   [
      "@param f function to convert",
      "@return converted function",
      "@return the derivative function",
      "@param n Number of steps.",
      "@return the value of n-th stage integral.",
      "@throws TooManyEvaluationsException if the maximum number of evaluations\nis exceeded.",
      "@param n Number of integration points.",
      "@param relativeAccuracy Relative accuracy of the result.",
      "@param absoluteAccuracy Absolute accuracy of the result.",
      "@param minimalIterationCount Minimum number of iterations.",
      "@param maximalIterationCount Maximum number of iterations.",
      "@param n number of steps",
      "@return the value of n-th stage integral",
      "@param n number of points desired (must be between 2 and 5 inclusive)",
      "@param relativeAccuracy relative accuracy of the result",
      "@param absoluteAccuracy absolute accuracy of the result",
      "@param minimalIterationCount minimum number of iterations",
      "@param maximalIterationCount maximum number of iterations",
      "@throws MathIllegalArgumentException if number of points is out of [2; 5]",
      "@param n the stage of 1/2 refinement. Must be larger than 0.",
      "@param previousStageResult Result from the previous call to the\n{@code stage} method.",
      "@param min Lower bound of the integration interval.",
      "@param diffMaxMin Difference between the lower bound and upper bound\nof the integration interval.",
      "@throws TooManyEvaluationsException if the maximal number of evaluations\nis exceeded.",
      "@param numberOfPoints Number of integration points."
   ],
   [
      "@return a copy of the integration rule.",
      "@throws DimensionMismatchException if the elements of the rule pair do not\nhave the same length.",
      "@param numberOfPoints Order of the rule to be retrieved.",
      "@return the points and weights corresponding to the given order.",
      "@param rule Rule to be stored.",
      "@throws DimensionMismatchException if the elements of the pair do not\nhave the same length.",
      "@param numberOfPoints Order of the rule to be computed.",
      "@return the computed rule.",
      "@param <T> Type of the number used to represent the points and\nweights of the quadrature rules.",
      "@param rule Points and weights.",
      "@return points and weights as {@code double}s.",
      "@param numberOfPoints Order of the integration rule.",
      "@return a Gauss-Legendre integrator.",
      "@param lowerBound Lower bound of the integration interval.",
      "@param upperBound Upper bound of the integration interval.",
      "@return a Gauss-Hermite integrator.",
      "@param factory Integration rule factory.",
      "@return the integration nodes and weights.",
      "@throws NotStrictlyPositiveException if number of points is not positive",
      "@param rule Original points and weights.",
      "@param a Lower bound of the integration interval.",
      "@param b Lower bound of the integration interval.",
      "@return the points and weights adapted to the new interval.",
      "@param mContext Precision setting for computing the quadrature rules.",
      "@param points Integration points."
   ],
   [
      "@param weights Weights of the corresponding integration nodes.",
      "@throws NonMonotonicSequenceException if the {@code points} are not\nsorted in increasing order.",
      "@throws DimensionMismatchException if points and weights don't have the same length",
      "@param pointsAndWeights Integration points and corresponding weights.",
      "@param f Function to integrate.",
      "@return the integral of the weighted function.",
      "@return the order of the integration rule (the number of integration\npoints).",
      "@param index index of the integration point",
      "@return the integration point.",
      "@return the weight.",
      "@throws MaxCountExceededException if the number of iterations\nexceeds the allowed maximum number",
      "@return the upper bound.",
      "@param point Point at which the objective function must be evaluated.",
      "@return the objective function value at specified point.",
      "@throws TooManyEvaluationsException if the maximal number of function\nevaluations is exceeded.",
      "@param f the integrand function",
      "@param lower the min bound for the interval",
      "@param upper the upper bound for the interval",
      "@return the root.",
      "@throws MaxCountExceededException if the maximum iteration count is exceeded\nor the integrator detects convergence problems otherwise",
      "@return the accuracy",
      "@return the actual min limit",
      "@return the actual upper limit",
      "@param min the lower bound for the interval",
      "@param max the upper bound for the interval"
   ],
   [
      "@return the value of integral",
      "@throws TooManyEvaluationsException if the maximum number of function\nevaluations is exceeded",
      "@return number of function evaluations",
      "@return number of iterations",
      "@param baseIntegrator integrator holding integration parameters",
      "@param n the stage of 1/2 refinement, n = 0 is no refinement",
      "@param x Abscissa for which the function value should be computed.",
      "@param y Ordinate for which the function value should be computed.",
      "@throws TooManyEvaluationsException if the maximal number of evaluations is exceeded.",
      "@param absoluteAccuracy Maximum absolute error.",
      "@param relativeAccuracy Maximum relative error.",
      "@param functionValueAccuracy Maximum function value error.",
      "@return the objective function value and derivative at specified point.",
      "@return the maximum number of function evaluations.",
      "@return the number of evaluations of the objective function.",
      "@return the absolute accuracy.",
      "@return the relative accuracy.",
      "@return the function value accuracy.",
      "@throws MathIllegalArgumentException if the arguments do not satisfy the requirements specified by the solver.",
      "@throws TooManyEvaluationsException if\nthe allowed number of evaluations is exceeded.",
      "@throws org.apache.commons.math3.exception.MathIllegalArgumentException if the arguments do not satisfy the requirements specified by the solver.",
      "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if\nthe allowed number of evaluations is exceeded.",
      "@param function Function.",
      "@param x0 Lower bound for the interval.",
      "@param x1 Upper bound for the interval."
   ],
   [
      "@throws NoBracketingException if the function has the same sign at the\nendpoints.",
      "@param absoluteAccuracy Accuracy to be used by the solver.",
      "@param maxEval maximal number of new evaluations of the function\n(evaluations already done for finding the root should have already been subtracted\nfrom this number)",
      "@param f function to solve",
      "@param bracketing bracketing solver to use for shifting the root",
      "@param baseRoot original root found by a previous non-bracketing solver",
      "@param min minimal bound of the search interval",
      "@param max maximal bound of the search interval",
      "@param allowedSolution the kind of solutions that the root-finding algorithm may\naccept as solutions.",
      "@return a root approximation, on the specified side of the exact root",
      "@param initial Initial midpoint of interval being expanded to\nbracket a root.",
      "@param lowerBound Lower bound (a is never lower than this value)",
      "@param upperBound Upper bound (b never is greater than this\nvalue).",
      "@return a two-element array holding a and b.",
      "@throws NoBracketingException if a root cannot be bracketted.",
      "@throws NotStrictlyPositiveException if {@code maximumIterations <= 0}.",
      "@param lowerBound Lower bound (a is never lower than this value).",
      "@param maximumIterations Maximum number of iterations to perform",
      "@return a two element array holding a and b.",
      "@throws NoBracketingException if the algorithm fails to find a and b\nsatisfying the desired conditions.",
      "@param function function to check",
      "@param r multiplicative factor used to compute bounds sequence",
      "@return a two element array holding the bracketing values.",
      "@throws NoBracketingException if function cannot be bracketed in the search interval",
      "@param a first value."
   ],
   [
      "@param b second value.",
      "@return the midpoint.",
      "@param lower Lower endpoint.",
      "@param upper Upper endpoint.",
      "@return {@code true} if the function values have opposite signs at the\ngiven points.",
      "@param start First number.",
      "@param mid Second number.",
      "@param end Third number.",
      "@return {@code true} if the arguments form an increasing sequence.",
      "@param initial Initial value.",
      "@return maximal order",
      "@return the maximal number of function evaluations.",
      "@param targetY target value for y",
      "@param x reference points abscissas for interpolation,\nnote that this array <em>is</em> modified during computation",
      "@param y reference points ordinates for interpolation",
      "@param start start index of the points to consider (inclusive)",
      "@param end end index of the points to consider (exclusive)",
      "@return guessed root (will be a NaN if two points share the same y)",
      "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximum evaluation count is exceeded.",
      "@throws ConvergenceException if the algorithm failed due to finite\nprecision.",
      "@param method <em>Secant</em>-based root-finding method to use.",
      "@param method <em>Secant</em>-based root-finding method to use",
      "@param absoluteAccuracy absolute accuracy",
      "@param relativeAccuracy relative accuracy",
      "@return the coefficients of the polynomial function."
   ],
   [
      "@param fMin function value at the lower bound.",
      "@param fMax function value at the upper bound.",
      "@return the point at which the function value is zero.",
      "@throws TooManyEvaluationsException if the allowed number of calls to\nthe function to be solved has been exhausted.",
      "@return the lower end of the search interval.",
      "@return the higher end of the search interval.",
      "@return the initial guess.",
      "@throws NoBracketingException if the initial search interval does not bracket\na root and the solver requires it.",
      "@throws NullArgumentException if the function has not been set.",
      "@throws NoBracketingException if the function has the same sign at\nthe endpoints.",
      "@throws TooManyEvaluationsException when the allowed number of function\nevaluations has been exhausted.",
      "@throws NoDataException if {@code xval} or {@code yval} has zero size.",
      "@param starts Number of starts to perform. If {@code starts == 1},\nthe {@link #optimize(OptimizationData[]) optimize} will return the\nsame solution as the given {@code optimizer} would return.",
      "@throws NonSquareMatrixException if the matrix is not square.",
      "@throws NotStrictlyPositiveException if the number of sample points is negative",
      "@param minStep minimal step (must be positive even for backward\nintegration), the last step can be smaller than this",
      "@param maxStep maximal step (must be positive even for backward\nintegration)",
      "@throws NullArgumentException if Object <code>o</code> is {@code null}.",
      "@throws MathIllegalArgumentException if {@code min > max} or the endpoints do not\nsatisfy the requirements specified by the integrator",
      "@throws NullArgumentException if {@code f} is {@code null}.",
      "@throws NullArgumentException if {@code function} is {@code null}.",
      "@param q additive offset used to compute bounds sequence (must be strictly positive)",
      "@throws NumberIsTooLargeException if {@code lower >= initial} or\n{@code initial >= upper}.",
      "@param nans code of the value, must be one of {@link Dfp#INFINITE},\n{@link Dfp#SNAN},  {@link Dfp#QNAN}",
      "@return exp(a)"
   ],
   [
      "@throws NonSquareMatrixException if matrix is not square",
      "@throws IllegalArgumentException if one of the steps is zero.",
      "@throws DimensionMismatchException if the arrays length is less than 2",
      "@throws NullArgumentException if f is null",
      "@param forward true if integration goes forward",
      "@return the product of the values or 1 if length = 0",
      "@throws NotStrictlyPositiveException if {@code numberOfPoints < 1}.",
      "@throws MathArithmeticException if the denominator is {@code zero}",
      "@param fraction the fraction to add, must not be {@code null}",
      "@param fraction the fraction to multiply by, must not be {@code null}",
      "@throws IllegalArgumentException if the fraction is {@code null}",
      "@param fraction the fraction to divide by, must not be {@code null}",
      "@throws MathIllegalArgumentException if p is not a valid quantile value\n(p must be greater than 0 and less than or equal to 100)",
      "@throws MathIllegalArgumentException if <code>values</code> is null\n    or p is invalid",
      "@throws NullArgumentException when newEstimationType is null",
      "@throws NullArgumentException when newNaNStrategy is null",
      "@throws NullArgumentException when newKthSelector is null",
      "@throws NonSquareMatrixException if matrix is not square.",
      "@param base Base of the logarithm, must be greater than 0.",
      "@param x Argument, must be greater than 0.",
      "@return a if a is lesser or equal to b, b otherwise",
      "@return b if a is lesser or equal to b, a otherwise",
      "@throws MathArithmeticException if b == 0",
      "@return the sum of the natural logs of the values or 0 if\nlength = 0",
      "@param lo Lower bound of the search interval."
   ],
   [
      "@param hi Higher bound of the search interval.",
      "@param fLo Function value at the lower bound of the search interval.",
      "@param fHi Function value at the higher bound of the search interval.",
      "@param coefficients Polynomial coefficients.",
      "@param initial Start value.",
      "@return the full set of complex roots of the polynomial",
      "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximum number of evaluations is exceeded when solving for one of the roots",
      "@param coefficients polynomial coefficients",
      "@param initial start value",
      "@param maxEval maximum number of evaluations",
      "@return a complex root of the polynomial",
      "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximum number of evaluations is exceeded.",
      "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximum number of evaluations is exceeded",
      "@return A value where the function is zero.",
      "@param x Domain values where the function changes value.",
      "@param y Values of the function.",
      "@throws NonMonotonicSequenceException if the {@code x} array is not sorted in strictly increasing order.",
      "@param xMinusMean {@code x - mean}.",
      "@param norm Normalization factor.",
      "@param i2s2 Inverse of twice the square of the standard deviation.",
      "@return the value of the Gaussian at {@code x}.",
      "@param mean Mean.",
      "@param sigma Standard deviation.",
      "@param c Constant.",
      "@param x Value at which to compute the logit."
   ],
   [
      "@return the value of the logit function at {@code x}.",
      "@throws OutOfRangeException if {@code x < lo} or {@code x > hi}.",
      "@throws OutOfRangeException if parameter is outside of function domain",
      "@param lo Lower bound of the function domain.",
      "@param hi Higher bound of the function domain.",
      "@param p Power.",
      "@param mMinusX {@code m - x}.",
      "@param k {@code k}.",
      "@param b {@code b}.",
      "@param q {@code q}.",
      "@param a {@code a}.",
      "@param oneOverN {@code 1 / n}.",
      "@return the value of the function.",
      "@param k If {@code b > 0}, value of the function for x going towards +&infin;.\nIf {@code b < 0}, value of the function for x going towards -&infin;.",
      "@param m Abscissa of maximum growth.",
      "@param b Growth rate.",
      "@param q Parameter that affects the position of the curve along the\nordinate axis.",
      "@param a If {@code b > 0}, value of the function for x going towards -&infin;.\nIf {@code b < 0}, value of the function for x going towards +&infin;.",
      "@param n Parameter that affects near which asymptote the maximum\ngrowth occurs.",
      "@param x Value at which to compute the sigmoid.",
      "@param lo Lower asymptote.",
      "@param hi Higher asymptote.",
      "@return the value of the sigmoid function at {@code x}.",
      "@param normalized If {@code true}, the function is\n<code> sin(&pi;x) / &pi;x</code>, otherwise {@code sin(x) / x}.",
      "@param xTimesOmegaPlusPhase {@code omega * x + phase}."
   ],
   [
      "@param amplitude Amplitude.",
      "@return the value of the harmonic oscillator function at {@code x}.",
      "@param omega Angular frequency.",
      "@param phase Phase.",
      "@param point Point at which the function must be evaluated.",
      "@return the function value for the given point.",
      "@throws org.apache.commons.math3.exception.DimensionMismatchException if the parameter's dimension is wrong for the function being evaluated.",
      "@throws org.apache.commons.math3.exception.MathIllegalArgumentException when the activated method itself can ascertain that preconditions,\nspecified in the API expressed at the level of the activated method,\nhave been violated.  In the vast majority of cases where Commons Math\nthrows this exception, it is the result of argument checking of actual\nparameters immediately passed to a method.",
      "@param k index of the coordinate with respect to which the partial\nderivative is computed",
      "@return the partial derivative function with respect to k<sup>th</sup> point coordinate",
      "@return the gradient function",
      "@throws IllegalArgumentException when the activated method itself can\nascertain that a precondition, specified in the API expressed at the\nlevel of the activated method, has been violated.\nWhen Commons Math throws an {@code IllegalArgumentException}, it is\nusually the consequence of checking the actual parameters passed to\nthe method.",
      "@param x x-coordinate for which the function value should be computed.",
      "@param y y-coordinate for which the function value should be computed.",
      "@param z z-coordinate for which the function value should be computed.",
      "@param point point at which the function must be evaluated",
      "@return function value for the given point",
      "@throws IllegalArgumentException if point's dimension is wrong",
      "@param x Point for which the function value should be computed.",
      "@param parameters Function parameters.",
      "@throws MathIllegalArgumentException if {@code x} does not\nsatisfy the function's constraints (argument out of bound, or unsupported\nderivative order for example)",
      "@param parameters number of free parameters",
      "@param order derivation order",
      "@return cached rules set",
      "@throws NumberIsTooLargeException if order is too large"
   ],
   [
      "@param valueCompiler compiler for the value part",
      "@return sizes array",
      "@param derivativeCompiler compiler for the derivative part",
      "@return derivatives indirection array",
      "@return lower derivatives indirection array",
      "@param lowerIndirection lower derivatives indirection array",
      "@return multiplication indirection array",
      "@param sizes sizes array",
      "@param derivativesIndirection derivatives indirection array",
      "@param orders derivation orders with respect to each parameter",
      "@return index of the partial derivative",
      "@throws DimensionMismatchException if the numbers of parameters does not\nmatch the instance",
      "@throws NumberIsTooLargeException if sum of derivation orders is larger\nthan the instance limits",
      "@param orders derivation orders with respect to each parameter\n(the lenght of this array must match the number of parameters)",
      "@param index index of a partial derivative in source derivative structure",
      "@param srcP number of free parameters in source derivative structure",
      "@param srcDerivativesIndirection derivatives indirection array for the source\nderivative structure",
      "@param destP number of free parameters in destination derivative structure",
      "@param destO derivation order in destination derivative structure",
      "@param destSizes sizes array for the destination derivative structure",
      "@return index of the partial derivative with the <em>same</em> characteristics\nin destination derivative structure",
      "@param index of the partial derivative",
      "@return orders derivation orders with respect to each parameter",
      "@return number of free parameters",
      "@return derivation order"
   ],
   [
      "@return array size required for holding partial derivatives data",
      "@param c1 first base (unscaled) component",
      "@param offset1 offset of first operand in its array",
      "@param c2 second base (unscaled) component",
      "@param offset2 offset of second operand in its array",
      "@param result array where result must be stored (it may be\none of the input arrays)",
      "@param resultOffset offset of the result in its array",
      "@param c3 third base (unscaled) component",
      "@param offset3 offset of third operand in its array",
      "@param c4 fourth base (unscaled) component",
      "@param offset4 offset of fourth operand in its array",
      "@param lhs array holding left hand side of addition",
      "@param lhsOffset offset of the left hand side in its array",
      "@param rhs array right hand side of addition",
      "@param rhsOffset offset of the right hand side in its array",
      "@param lhs array holding left hand side of subtraction",
      "@param rhs array right hand side of subtraction",
      "@param lhs array holding left hand side of multiplication",
      "@param rhs array right hand side of multiplication",
      "@param result array where result must be stored (for\nmultiplication the result array <em>cannot</em> be one of\nthe input arrays)",
      "@param lhs array holding left hand side of division",
      "@param rhs array right hand side of division",
      "@param result array where result must be stored (for\ndivision the result array <em>cannot</em> be one of\nthe input arrays)",
      "@param lhs array holding left hand side of remainder",
      "@param rhs array right hand side of remainder"
   ],
   [
      "@param a number to exponentiate",
      "@param operand array holding the power",
      "@param operandOffset offset of the power in its array",
      "@param result array where result must be stored (for\npower the result array <em>cannot</em> be the input\narray)",
      "@param operand array holding the operand",
      "@param operandOffset offset of the operand in its array",
      "@param x array holding the base",
      "@param xOffset offset of the base in its array",
      "@param y array holding the exponent",
      "@param yOffset offset of the exponent in its array",
      "@param result array where result must be stored (for\nn<sup>th</sup> root the result array <em>cannot</em> be the input\narray)",
      "@param result array where result must be stored (for\nexponential the result array <em>cannot</em> be the input\narray)",
      "@param result array where result must be stored (for\nlogarithm the result array <em>cannot</em> be the input\narray)",
      "@param result array where result must be stored (for\nshifted logarithm the result array <em>cannot</em> be the input array)",
      "@param result array where result must be stored (for\nbase 10 logarithm the result array <em>cannot</em> be the input array)",
      "@param result array where result must be stored (for\ncosine the result array <em>cannot</em> be the input\narray)",
      "@param result array where result must be stored (for\nsine the result array <em>cannot</em> be the input\narray)",
      "@param result array where result must be stored (for\ntangent the result array <em>cannot</em> be the input\narray)",
      "@param result array where result must be stored (for\narc cosine the result array <em>cannot</em> be the input\narray)",
      "@param result array where result must be stored (for\narc sine the result array <em>cannot</em> be the input\narray)",
      "@param result array where result must be stored (for\narc tangent the result array <em>cannot</em> be the input\narray)",
      "@param y array holding the first operand",
      "@param yOffset offset of the first operand in its array",
      "@param x array holding the second operand",
      "@param xOffset offset of the second operand in its array"
   ],
   [
      "@param result array where result must be stored (for\ntwo arguments arc tangent the result array <em>cannot</em>\nbe the input array)",
      "@param result array where result must be stored (for\nhyperbolic cosine the result array <em>cannot</em> be the input\narray)",
      "@param result array where result must be stored (for\nhyperbolic sine the result array <em>cannot</em> be the input\narray)",
      "@param result array where result must be stored (for\nhyperbolic tangent the result array <em>cannot</em> be the input\narray)",
      "@param result array where result must be stored (for\ninverse hyperbolic cosine the result array <em>cannot</em> be the input\narray)",
      "@param result array where result must be stored (for\ninverse hyperbolic sine the result array <em>cannot</em> be the input\narray)",
      "@param result array where result must be stored (for\ninverse hyperbolic tangent the result array <em>cannot</em> be the input\narray)",
      "@param f array of value and derivatives of the function at\nthe current point (i.e. at {@code operand[operandOffset]}).",
      "@param result array where result must be stored (for\ncomposition the result array <em>cannot</em> be the input\narray)",
      "@param ds array holding the derivative structure",
      "@param dsOffset offset of the derivative structure in its array",
      "@param delta parameters offsets (&Delta;x, &Delta;y, ...)",
      "@return value of the Taylor expansion at x + &Delta;x, y + &Delta;y, ...",
      "@throws MathArithmeticException if factorials becomes too large",
      "@param compiler other compiler to check against instance",
      "@param value value of the constant",
      "@return a new instance",
      "@param idx index of the variable",
      "@param value value of the variable",
      "@return number of variables",
      "@param index index to differentiate with.",
      "@return derivative with respect to a particular index variable",
      "@return value of the function.",
      "@param a instance to add",
      "@param a instance to multiply"
   ],
   [
      "@param x a value",
      "@return sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)",
      "@param x power to apply",
      "@return a<sup>x</sup>",
      "@return base 10 logarithm of the instance",
      "@param y first argument of the arc tangent",
      "@return atan2(y, x)",
      "@return instance converted into degrees",
      "@return instance converted into radians",
      "@param f0 value of the function at (i.e. f({@link #getValue()}))",
      "@param f1 first derivative of the function at\nthe current point (i.e. f'({@link #getValue()}))",
      "@return f(this)",
      "@return true if two sparse gradients are equal",
      "@param value value of the function",
      "@param derivatives derivatives map, a deep copy will be performed,\nso the map given here will remain safe from changes in the new instance,\nmay be null to create an empty derivatives map, i.e. a constant value",
      "@param scale scaling factor to apply to all derivatives",
      "@param function function to differentiate",
      "@return differential function",
      "@throws MathIllegalArgumentException if {@code point} does not\nsatisfy the function's constraints (wrong dimension, argument out of bound,\nor unsupported derivative order for example)",
      "@param f underlying vector-valued function",
      "@param f underlying real-valued function",
      "@param c value of the constant",
      "@return a constant compatible with instance order and number of parameters",
      "@return value part of the derivative structure",
      "@param orders derivation orders with respect to each variable (if all orders are 0,\nthe value is returned)"
   ],
   [
      "@return partial derivative",
      "@throws DimensionMismatchException if the numbers of variables does not\nmatch the instance",
      "@return a fresh copy of partial derivatives, in an array sorted according to\n{@link DSCompiler#getPartialDerivativeIndex(int...)}",
      "@throws DimensionMismatchException if number of free parameters\nor orders do not match",
      "@return exponent for instance in IEEE754 representation, without bias",
      "@param f array of value and derivatives of the function at\nthe current point (i.e. [f({@link #getValue()}),\nf'({@link #getValue()}), f''({@link #getValue()})...]).",
      "@return true if two derivative structures are equal",
      "@param compiler compiler to use for computation",
      "@param index index of the variable (from 0 to {@code parameters - 1})",
      "@param ds1 first base (unscaled) derivative structure",
      "@param ds2 second base (unscaled) derivative structure",
      "@param ds3 third base (unscaled) derivative structure",
      "@param ds4 fourth base (unscaled) derivative structure",
      "@param derivatives derivatives sorted according to\n{@link DSCompiler#getPartialDerivativeIndex(int...)}",
      "@throws DimensionMismatchException if derivatives array does not match the\n{@link DSCompiler#getSize() size} expected by the compiler",
      "@param ds instance to copy",
      "@return number of points to use",
      "@return step size",
      "@param t evaluation abscissa value and derivatives",
      "@param t0 first sample point abscissa",
      "@param y function values sample {@code y[i] = f(t[i]) = f(t0 + i * stepSize)}",
      "@return value and derivatives at {@code t}",
      "@throws NumberIsTooLargeException if the requested derivation order\nis larger or equal to the number of points",
      "@param nbPoints number of points to use",
      "@param stepSize step size (gap between each point)"
   ],
   [
      "@param tLower lower bound for independent variable (may be {@code Double.NEGATIVE_INFINITY}\nif there are no lower bounds)",
      "@param tUpper upper bound for independent variable (may be {@code Double.POSITIVE_INFINITY}\nif there are no upper bounds)",
      "@param t function input value",
      "@return function result",
      "@throws DimensionMismatchException if t is inconsistent with the\nfunction's free parameters or order",
      "@return the jacobian function",
      "@param z Point at which the function value is to be computed.",
      "@return the function value.",
      "@return the degree of the polynomial",
      "@return a fresh copy of coefficients in Newton form formula",
      "@return a fresh copy of the centers array.",
      "@return a fresh copy of the coefficients array.",
      "@param a Coefficients in Newton form formula.",
      "@param c Centers.",
      "@param a the coefficients in Newton form formula",
      "@param c the centers",
      "@throws DimensionMismatchException if {@code x} and {@code y} have\ndifferent lengths.",
      "@throws org.apache.commons.math3.exception.NonMonotonicSequenceException if {@code x} is not sorted in strictly increasing order.",
      "@return a fresh copy of the interpolating points array",
      "@return a fresh copy of the interpolating values array",
      "@return a fresh copy of the coefficients array",
      "@param x Interpolating points array.",
      "@param y Interpolating values array.",
      "@throws NonMonotonicSequenceException if {@code x} is not sorted in strictly increasing order.",
      "@throws NumberIsTooSmallException if the size of {@code x} is less\nthan 2."
   ],
   [
      "@param abort Whether to throw an exception if {@code x} is not sorted.",
      "@throws DimensionMismatchException if the array lengths are different.",
      "@throws org.apache.commons.math3.exception.NonMonotonicSequenceException if {@code x} is not sorted in strictly increasing order and {@code abort}\nis {@code true}.",
      "@return {@code false} if the {@code x} is not sorted in increasing order,\n{@code true} otherwise.",
      "@param x interpolating points",
      "@param y function values at interpolating points",
      "@throws NonMonotonicSequenceException if two abscissae have the same value.",
      "@param v Point for which the function value should be computed.",
      "@throws OutOfRangeException if {@code v} is outside of the domain of the\nspline function (smaller than the smallest knot point or larger than the\nlargest knot point).",
      "@return the derivative function.",
      "@return the number of spline segments.",
      "@return the interpolating polynomials.",
      "@return the knot points.",
      "@param x Point.",
      "@return {@code true} if {@code x} is a valid point.",
      "@param knots Spline segment interval delimiters.",
      "@param polynomials Polynomial functions that make up the spline.",
      "@throws NumberIsTooSmallException if knots has length less than 2.",
      "@throws DimensionMismatchException if {@code polynomials.length != knots.length - 1}.",
      "@throws NonMonotonicSequenceException if the {@code knots} array is not strictly increasing.",
      "@param degree degree of the polynomial",
      "@return Chebyshev polynomial of specified degree",
      "@return Hermite polynomial of specified degree",
      "@return Laguerre polynomial of specified degree",
      "@return Legendre polynomial of specified degree"
   ],
   [
      "@param v first exponent",
      "@param w second exponent",
      "@return Jacobi polynomial of specified degree",
      "@param coefficients Coefficients of the original polynomial.",
      "@param shift Shift value.",
      "@return the coefficients \\(b_i\\) of the shifted\npolynomial.",
      "@param coefficients list where the computed coefficients are stored",
      "@param generator recurrence coefficients generator",
      "@return coefficients array",
      "@param degree maximal degree",
      "@param maxDegree current maximal degree",
      "@param coefficients list where the computed coefficients should be appended",
      "@param x Argument for which the function value should be computed.",
      "@return the value of the polynomial at the given point.",
      "@return the degree of the polynomial.",
      "@param coefficients Coefficients of the polynomial to evaluate.",
      "@param argument Input value.",
      "@return the value of the polynomial.",
      "@param p Polynomial to add.",
      "@return a new polynomial which is the sum of the instance and {@code p}.",
      "@param p Polynomial to subtract.",
      "@return a new polynomial which is the instance minus {@code p}.",
      "@return a new polynomial with all coefficients negated",
      "@param p Polynomial to multiply by.",
      "@return a new polynomial equal to this times {@code p}"
   ],
   [
      "@param coefficients Coefficients of the polynomial to differentiate.",
      "@return the derivative polynomial.",
      "@return a string representation of the polynomial.",
      "@param coeff Coefficient.",
      "@return a string representation of {@code coeff}.",
      "@param c Polynomial coefficients.",
      "@param x First coordinate.",
      "@param y Second coordinate.",
      "@return {@code true} if (x, y) is a valid point.",
      "@param x x-coordinate.",
      "@param y y-coordinate.",
      "@return the value at point (x, y) of the first partial derivative with\nrespect to x.",
      "@throws OutOfRangeException if {@code x} (resp. {@code y}) is outside\nthe range defined by the boundary values of {@code xval} (resp.\n{@code yval}).",
      "@throws NullPointerException if the internal data were not initialized\n(cf. {@link #BicubicSplineInterpolatingFunction(double[],double[],double[][],\n            double[][],double[][],double[][],boolean) constructor}).",
      "@return the value at point (x, y) of the first partial derivative with\nrespect to y.",
      "@return the value at point (x, y) of the second partial derivative with\nrespect to x.",
      "@return the value at point (x, y) of the second partial derivative with\nrespect to y.",
      "@return the value at point (x, y) of the second partial cross-derivative.",
      "@param which First index in {@link #partialDerivatives}.",
      "@return the value at point (x, y) of the selected partial derivative.",
      "@param c Coordinate.",
      "@param val Coordinate samples.",
      "@return the index in {@code val} corresponding to the interval\ncontaining {@code c}.",
      "@throws OutOfRangeException if {@code c} is out of the\nrange defined by the boundary values of {@code val}.",
      "@param beta List of function values and function partial derivatives\nvalues."
   ],
   [
      "@return the spline coefficients.",
      "@param x Sample values of the x-coordinate, in increasing order.",
      "@param y Sample values of the y-coordinate, in increasing order.",
      "@param f Values of the function on every grid point.",
      "@param dFdX Values of the partial derivative of function with respect\nto x on every grid point.",
      "@param dFdY Values of the partial derivative of function with respect\nto y on every grid point.",
      "@param d2FdXdY Values of the cross partial derivative of function on\nevery grid point.",
      "@throws DimensionMismatchException if the various arrays do not contain\nthe expected number of elements.",
      "@throws NonMonotonicSequenceException if {@code x} or {@code y} are\nnot strictly increasing.",
      "@param initializeDerivatives Whether to initialize the internal data\nneeded for calling any of the methods that compute the partial derivatives\nthis function.",
      "@param pX Powers of the x-coordinate.",
      "@param pY Powers of the y-coordinate.",
      "@param coeff Spline coefficients.",
      "@return the interpolated value.",
      "@return the partial derivative wrt {@code x}.",
      "@return the partial derivative wrt {@code y}.",
      "@return the second partial derivative wrt {@code x}.",
      "@return the second partial derivative wrt {@code y}.",
      "@return the second partial cross-derivative.",
      "@param xval the arguments for the interpolation points",
      "@param yval the values for the interpolation points",
      "@return A cubic spline built upon a loess fit to the data at the original abscissae",
      "@throws NonMonotonicSequenceException if {@code xval} not sorted in\nstrictly increasing order.",
      "@throws NotFiniteNumberException if any of the arguments and values are\nnot finite real numbers.",
      "@throws NumberIsTooSmallException if the bandwidth is too small to\naccomodate the size of the input data (i.e. the bandwidth must be\nlarger than 2/n)."
   ],
   [
      "@param xval Arguments for the interpolation points.",
      "@param yval Values for the interpolation points.",
      "@param weights point weights: coefficients by which the robustness weight\nof a point is multiplied.",
      "@return the values of the loess fit at corresponding original abscissae.",
      "@throws NotFiniteNumberException if any of the arguments and values are\n     not finite real numbers.",
      "@return values of the loess fit at corresponding original abscissae",
      "@param xval Arguments array.",
      "@param weights Weights array.",
      "@param i Index around which the new interval should be computed.",
      "@param bandwidthInterval a two-element array {left, right} such that:\n{@code (left==0 or xval[i] - xval[left-1] > xval[right] - xval[i])}\nand\n{@code (right==xval.length-1 or xval[right+1] - xval[i] > xval[i] - xval[left])}.\nThe array will be updated.",
      "@param i Index from which to start search.",
      "@return the smallest compliant index.",
      "@param x Argument.",
      "@return <code>(1 - |x|<sup>3</sup>)<sup>3</sup></code> for |x| &lt; 1, 0 otherwise.",
      "@param values Values array.",
      "@throws org.apache.commons.math3.exception.NotFiniteNumberException if one of the values is not a finite real number.",
      "@param bandwidth when computing the loess fit at\na particular point, this fraction of source points closest\nto the current point is taken into account for computing\na least-squares regression.\nA sensible value is usually 0.25 to 0.5, the default value is\n{@link #DEFAULT_BANDWIDTH}.",
      "@param robustnessIters This many robustness iterations are done.\nA sensible value is usually 0 (just the initial fit without any\nrobustness iterations) to 4, the default value is\n{@link #DEFAULT_ROBUSTNESS_ITERS}.",
      "@param accuracy If the median residual at a certain robustness iteration\nis less than this amount, no more iterations are done.",
      "@return a function which interpolates the dataset.",
      "@throws NonMonotonicSequenceException if {@code x} is not sorted in\nstrictly increasing order.",
      "@return a fresh copy of the divided difference array.",
      "@param x abscissa of the sample point",
      "@param value value and derivatives of the sample point\n(if only one row is passed, it is the value, if two rows are\npassed the first one is the value and the second the derivative\nand so on)",
      "@throws ZeroException if the abscissa difference between added point\nand a previous point is zero (i.e. the two points are at same abscissa)"
   ],
   [
      "@throws MathArithmeticException if the number of derivatives is larger\nthan 20, which prevents computation of a factorial",
      "@return interpolation polynomials array",
      "@throws NoDataException if sample is empty",
      "@param x interpolation abscissa",
      "@return interpolated value",
      "@throws NoDataException if interpolation cannot be performed\nbecause sample is empty",
      "@param c polynomials coefficients",
      "@return polynomial",
      "@throws OutOfRangeException if any of the variables is outside its interpolation range.",
      "@param z Third coordinate.",
      "@return {@code true} if (x, y, z) is a valid point.",
      "@return the index in {@code val} corresponding to the interval containing {@code c}, or {@code -1}\n  if {@code c} is out of the range defined by the end values of {@code val}.",
      "@param beta List of function values and function partial derivatives values.",
      "@param z Sample values of the y-coordinate, in increasing order.",
      "@param dFdX Values of the partial derivative of function with respect to x on every grid point.",
      "@param dFdY Values of the partial derivative of function with respect to y on every grid point.",
      "@param dFdZ Values of the partial derivative of function with respect to z on every grid point.",
      "@param d2FdXdY Values of the cross partial derivative of function on every grid point.",
      "@param d2FdXdZ Values of the cross partial derivative of function on every grid point.",
      "@param d2FdYdZ Values of the cross partial derivative of function on every grid point.",
      "@param d3FdXdYdZ Values of the cross partial derivative of function on every grid point.",
      "@throws NoDataException if any of the arrays has zero length.",
      "@throws DimensionMismatchException if the various arrays do not contain the expected number of elements.",
      "@throws NonMonotonicSequenceException if {@code x}, {@code y} or {@code z} are not strictly increasing.",
      "@param x x-coordinate of the interpolation point."
   ],
   [
      "@param y y-coordinate of the interpolation point.",
      "@param z z-coordinate of the interpolation point.",
      "@throws OutOfRangeException if {@code x}, {@code y} or\n{@code z} are not in the interval {@code [0, 1]}.",
      "@param aV List of spline coefficients.",
      "@param xval All the x-coordinates of the interpolation points, sorted\nin increasing order.",
      "@param yval All the y-coordinates of the interpolation points, sorted\nin increasing order.",
      "@param zval All the z-coordinates of the interpolation points, sorted\nin increasing order.",
      "@param fval the values of the interpolation points on all the grid knots:\n{@code fval[i][j][k] = f(xval[i], yval[j], zval[k])}.",
      "@return a function that interpolates the data set.",
      "@throws DimensionMismatchException if the array lengths are inconsistent.",
      "@throws NonMonotonicSequenceException if arrays are not sorted",
      "@throws NumberIsTooSmallException if the number of points is too small for\nthe order of the interpolation",
      "@param x Interpolating points.",
      "@param y Interpolating values.",
      "@return a function which interpolates the data set",
      "@throws NumberIsTooSmallException if the number of points is less than 2.",
      "@throws NonMonotonicSequenceException if two abscissae have the same\nvalue.",
      "@throws DimensionMismatchException if the space dimension of the\ngiven samples does not match the space dimension of the microsphere.",
      "@param elements Number of surface elements of the microsphere.",
      "@param exponent Exponent used in the power law that computes the",
      "@param maxDarkFraction Maximum fraction of the facets that can be dark.\nIf the fraction of \"non-illuminated\" facets is larger, no estimation\nof the value will be performed, and the {@code background} value will\nbe returned instead.",
      "@param darkThreshold Value of the illumination below which a facet is\nconsidered dark.",
      "@param background Value returned when the {@code maxDarkFraction}\nthreshold is exceeded.",
      "@param sharedSphere Whether the sphere can be shared among the\ninterpolating function instances.  If {@code true}, the instances\nwill share the same data, and thus will <em>not</em> be thread-safe.",
      "@param noInterpolationTolerance When the distance between an\ninterpolated point and one of the sample points is less than this\nvalue, no interpolation will be performed (the value of the sample\nwill be returned)."
   ],
   [
      "@throws org.apache.commons.math3.exception.OutOfRangeException if\n{@code maxDarkFraction} does not belong to the interval {@code [0, 1]}.",
      "@param microsphere Microsphere.",
      "@param exponent Exponent used in the power law that computes the\nweights (distance dimming factor) of the sample data.",
      "@param xvals the arguments for the interpolation points",
      "@param yvals the values for the interpolation points",
      "@throws DimensionMismatchException if {@code xvals} and {@code yvals} have\n        different sizes.",
      "@throws NonMonotonicSequenceException if {@code xvals} is not sorted in\n        strict increasing order.",
      "@param xvals x values to calculate the numerical derivative with",
      "@param yvals y values to calculate the numerical derivative with",
      "@param indexOfDifferentiation index of the elemnt we are calculating the derivative around",
      "@param indexOfFirstSample index of the first element to sample for the three point method",
      "@param indexOfSecondsample index of the second element to sample for the three point method",
      "@param indexOfThirdSample index of the third element to sample for the three point method",
      "@return the derivative",
      "@param xvals x values for interpolation",
      "@param yvals y values for interpolation",
      "@param firstDerivatives first derivative values of the function",
      "@return polynomial that fits the function",
      "@param xval the arguments for the interpolation points.\n{@code xval[i][0]} is the first component of interpolation point\n{@code i}, {@code xval[i][1]} is the second component, and so on\nuntil {@code xval[i][d-1]}, the last component of that interpolation\npoint (where {@code d} is thus the dimension of the space).",
      "@throws MathIllegalArgumentException if the arguments violate assumptions\nmade by the interpolation algorithm.",
      "@throws DimensionMismatchException when the array dimensions are not consistent.",
      "@param i Index.",
      "@param max Upper limit of the array.",
      "@return the next index.",
      "@return the previous index."
   ],
   [
      "@param initializeDerivatives Whether to initialize the internal data\nneeded for calling any of the methods that compute the partial derivatives\nof the {@link BicubicSplineInterpolatingFunction function} returned from\nthe call to {@link #interpolate(double[],double[],double[][]) interpolate}.",
      "@throws DimensionMismatchException if derivative structures are inconsistent",
      "@param order maximum derivation order",
      "@return interpolated value and derivatives (value in row 0,\n1<sup>st</sup> derivative in row 1, ... n<sup>th</sup> derivative in row n)",
      "@return a copy of this instance.",
      "@return the number of space dimensions.",
      "@return the number of surface elements of the microspshere.",
      "@param point Interpolation point.",
      "@param samplePoints Sampling data points.",
      "@param sampleValues Sampling data values at the corresponding\n{@code samplePoints}.",
      "@param exponent Exponent used in the power law that computes\nthe weights (distance dimming factor) of the sample data.",
      "@param noInterpolationTolerance When the distance between the\n{@code point} and one of the {@code samplePoints} is less than\nthis value, no interpolation will be performed, and the value\nof the sample will just be returned.",
      "@return the estimated value at the given {@code point}.",
      "@param normal Facet's normal vector.",
      "@param copy Whether to copy the given array.",
      "@throws DimensionMismatchException if the length of {@code n}\ndoes not match the space dimension.",
      "@throws MaxCountExceededException if the method has been called\nmore times than the size of the sphere.",
      "@return the value estimated from the current illumination of the\nmicrosphere.",
      "@param sampleDirection Vector whose origin is at the interpolation\npoint and tail is at the sample location.",
      "@param sampleValue Data value of the sample.",
      "@param weight Weight.",
      "@param dimension Dimension of the data space.",
      "@param size Number of surface elements of the sphere.",
      "@throws OutOfRangeException if {@code maxDarkFraction} does not\nbelong to the interval {@code [0, 1]}.",
      "@param rand Unit vector generator for creating the microsphere."
   ],
   [
      "@param darkThreshold Value of the illumination below which a facet\nis considered dark.",
      "@throws DimensionMismatchException if the size of the generated\nvectors does not match the dimension set in the constructor.",
      "@param other Instance to copy.",
      "@param x the arguments for the interpolation points",
      "@param y the values for the interpolation points",
      "@throws NonMonotonicSequenceException if {@code x} is not sorted in\nstrict increasing order.",
      "@param fval The values of the interpolation points on all the grid knots:\n{@code fval[i][j] = f(xval[i], yval[j])}.",
      "@throws NonMonotonicSequenceException if the array is not sorted.",
      "@throws NumberIsTooSmallException if the number of extension points\nis larger than the size of {@code xval}.",
      "@param interpolator Interpolator.",
      "@param period Period.",
      "@param extend Number of points to be appended at the beginning and\nend of the sample arrays in order to avoid interpolation failure at\nthe (periodic) boundaries of the orginal interval. The value is the\nnumber of sample points which the original {@code interpolator} needs\non each side of the interpolated point.",
      "@throws MathIllegalArgumentException if the arguments violate assumptions made by the interpolation\nalgorithm.",
      "@throws DimensionMismatchException if arrays lengthes do not match",
      "@param degree Degree of the polynomial fitting functions.",
      "@param xDegree Degree of the polynomial fitting functions along the\nx-dimension.",
      "@param yDegree Degree of the polynomial fitting functions along the\ny-dimension.",
      "@param biasCorrected true means covariances are bias-corrected",
      "@throws NullArgumentException when pivotingStrategy is null",
      "@throws NoDataException if there an array has zero-length.",
      "@throws NullArgumentException if an argument is {@code null}.",
      "@throws NumberIsTooSmallException if the provided time is &lt; 0",
      "@return true if n is prime. (All numbers &lt; 2 return false).",
      "@throws MathIllegalArgumentException if n &lt; 0.",
      "@param n a positive number."
   ],
   [
      "@return the smallest prime greater than or equal to n.",
      "@throws MathIllegalArgumentException if n &lt; 2.",
      "@param n number to factorize: must be &ge; 2",
      "@throws NumberIsTooSmallException if the size of {@code x} is smaller\nthan 3.",
      "@throws NotStrictlyPositiveException if {@code scale <= 0}.",
      "@throws NotPositiveException if {@code numberOfTrials} or {@code numberOfSuccesses} is negative",
      "@throws OutOfRangeException if {@code probability} is not between 0 and 1",
      "@throws MathIllegalArgumentException if {@code numberOfTrials} &lt; {@code numberOfSuccesses} or\nif {@code alternateHypothesis} is null.",
      "@throws NullArgumentException if {@code imaginaryFormat} is {@code null}.",
      "@throws NullArgumentException if {@code realFormat} is {@code null}.",
      "@throws NullArgumentException if {@code imaginaryCharacter} is\n{@code null}.",
      "@throws NotStrictlyPositiveException if\n{@code numeratorDegreesOfFreedom <= 0} or\n{@code denominatorDegreesOfFreedom <= 0}.",
      "@throws NotStrictlyPositiveException if {@code numeratorDegreesOfFreedom <= 0} or\n{@code denominatorDegreesOfFreedom <= 0}.",
      "@throws NotStrictlyPositiveException if the row or column dimension is\nnot positive.",
      "@throws NoDataException if {@code d} row or column dimension is zero.",
      "@throws MathIllegalArgumentException if the array is null",
      "@throws MathIllegalArgumentException if the array is null or the index",
      "@return the sum of the values or 0 if length = 0",
      "@param theta normalized interpolation abscissa within the step\n(theta is zero at the previous time step and one at the current time step)",
      "@return the sum {@code x+y}",
      "@return the sum {@code a+b}",
      "@return the product {@code x * y}.",
      "@return the product {@code a * b}.",
      "@return the difference {@code x - y}.",
      "@return the difference {@code a - b}."
   ],
   [
      "@throws NotPositiveException if {@code e < 0}.",
      "@param e Exponent (must be positive or zero).",
      "@param i Index",
      "@param max Upper limit of the array",
      "@return the next index",
      "@return the previous index",
      "@param offset how far back from found value to offset for querying",
      "@param count total number of elements forward from beginning that will be\n       queried",
      "@return the index in {@code val} corresponding to the interval containing\n        {@code c}.",
      "@throws OutOfRangeException if {@code c} is out of the range defined by\n        the boundary values of {@code val}.",
      "@param f Values of the function on every grid point. the expected number\n       of elements.",
      "@throws NonMonotonicSequenceException if {@code x} or {@code y} are not\n        strictly increasing.",
      "@throws DimensionMismatchException if the length of x and y don't match the row, column\n        height of f",
      "@throws DimensionMismatchException if point dimension does not math sample",
      "@param v Vector.",
      "@param w Vector.",
      "@return the cosine of the angle between {@code v} and {@code w}.",
      "@param xval Arguments for the interpolation points.\n{@code xval[i][0]} is the first component of interpolation point\n{@code i}, {@code xval[i][1]} is the second component, and so on\nuntil {@code xval[i][d-1]}, the last component of that interpolation\npoint (where {@code dimension} is thus the dimension of the sampled\nspace).",
      "@param brightnessExponent Brightness dimming factor.",
      "@param microsphereElements Number of surface elements of the\nmicrosphere.",
      "@throws DimensionMismatchException if the lengths of {@code yval} and\n{@code xval} (equal to {@code n}, the number of interpolation points)\ndo not match, or the the arrays {@code xval[0]} ... {@code xval[n]},\nhave lengths different from {@code dimension}.",
      "@param x the first number",
      "@param y the second number",
      "@param eps the amount of error to allow when checking for equality",
      "@return <ul><li>0 if  {@link #equals(double, double, double) equals(x, y, eps)}</li>\n      <li>&lt; 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x &lt; y</li>\n      <li>> 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x > y or\n      either argument is NaN</li></ul>"
   ],
   [
      "@param x first value",
      "@param y second value",
      "@param maxUlps {@code (maxUlps - 1)} is the number of floating point\nvalues between {@code x} and {@code y}.",
      "@return <ul><li>0 if  {@link #equals(double, double, int) equals(x, y, maxUlps)}</li>\n      <li>&lt; 0 if !{@link #equals(double, double, int) equals(x, y, maxUlps)} &amp;&amp; x &lt; y</li>\n      <li>&gt; 0 if !{@link #equals(double, double, int) equals(x, y, maxUlps)} &amp;&amp; x > y\n      or either argument is NaN</li></ul>",
      "@return {@code true} if the values are equal.",
      "@return {@code true} if the values are equal or both are NaN.",
      "@param eps the amount of absolute error to allow.",
      "@return {@code true} if the values are equal or within range of each other.",
      "@return {@code true} if the values are equal or within range of each other,\nor both are NaN.",
      "@return {@code true} if there are fewer than {@code maxUlps} floating\npoint values between {@code x} and {@code y}.",
      "@return {@code true} if both arguments are NaN or if there are less than\n{@code maxUlps} floating point values between {@code x} and {@code y}.",
      "@param x First value.",
      "@param y Second value.",
      "@param eps Amount of allowed absolute error.",
      "@return {@code true} if the values are two adjacent floating point\nnumbers or they are within range of each other.",
      "@param eps Amount of allowed relative error.",
      "@param x Value to round.",
      "@param scale Number of digits to the right of the decimal point.",
      "@return the rounded value.",
      "@param roundingMethod Rounding method as defined in {@link BigDecimal}.",
      "@throws ArithmeticException if {@code roundingMethod == ROUND_UNNECESSARY}\nand the specified scaling operation would require rounding.",
      "@throws IllegalArgumentException if {@code roundingMethod} does not\nrepresent a valid rounding mode.",
      "@throws MathArithmeticException if an exact operation is required but result is not exact",
      "@throws MathIllegalArgumentException if {@code roundingMethod} is not a valid rounding method.",
      "@param unscaled Value to round."
   ],
   [
      "@param sign Sign of the original, scaled value.",
      "@param roundingMethod Rounding method, as defined in {@link BigDecimal}.",
      "@param x Value.",
      "@param originalDelta Offset value.",
      "@return the number of dimensions.",
      "@param index Index in unidimensional counter.",
      "@return the multidimensional counts.",
      "@param c Indices in multidimensional counter.",
      "@return the index within the unidimensionl counter.",
      "@throws DimensionMismatchException if the size of {@code c}\ndoes not match the size of the array given in the constructor.",
      "@throws OutOfRangeException if a value of {@code c} is not in\nthe range of the corresponding dimension, as defined in the\n{@link MultidimensionalCounter#MultidimensionalCounter(int...) constructor}.",
      "@return the total size of the unidimensional counter.",
      "@return the sizes of the multidimensional counter in each dimension.",
      "@param size Counter sizes (number of slots in each dimension).",
      "@throws NotStrictlyPositiveException if one of the sizes is\nnegative or zero.",
      "@return number of elements",
      "@param index index to fetch a value from",
      "@return value stored at the specified index",
      "@param index index to store a value in",
      "@param value value to store at the specified index",
      "@param value to be added to end of array",
      "@param values to be added to end of array",
      "@param value the value to be added to the array",
      "@return the value which has been discarded or \"pushed\" out of the array\n        by this rolling insert",
      "@return all elements added to the array"
   ],
   [
      "@param max Upper limit of the counter.",
      "@return the counter upper limit.",
      "@return the current count.",
      "@return {@code false} if the next call to {@link #incrementCount(int)\nincrementCount} will trigger a {@code MaxCountExceededException},\n{@code true} otherwise.",
      "@param value Number of increments.",
      "@throws MaxCountExceededException at counter exhaustion.",
      "@throws MaxCountExceededException at counter exhaustion, unless a\ncustom {@link MaxCountExceededCallback callback} has been set at\nconstruction.",
      "@param incrementor wrapped {@link IntegerSequence.Incrementor}",
      "@return an incrementor wrapping an {@link IntegerSequence.Incrementor}",
      "@param max Maximal count.",
      "@param cb Function to be called when the maximal count has been reached.",
      "@param expectedSize expected size of the map",
      "@return capacity to use for the specified size",
      "@param i input value",
      "@return smallest power of two greater than the input value",
      "@param key key associated with the data",
      "@return data associated with the key",
      "@param key key to check",
      "@return true if a value is associated with key",
      "@return iterator over the map elements",
      "@param hash initial hash",
      "@return perturbed hash",
      "@param key key to lookup",
      "@return index at which key should be inserted",
      "@param keys keys table"
   ],
   [
      "@param states states table",
      "@param mask bit mask for hash values",
      "@param perturb perturbed hash",
      "@param j previous probe",
      "@return next probe",
      "@param index initial index",
      "@return changed index",
      "@return number of elements stored in the map",
      "@param key key to which the value is associated",
      "@return removed value",
      "@param index index to check",
      "@return true if an element is associated with key at index",
      "@param index index of the element to remove",
      "@param key key to which value is associated",
      "@param value value to put in the map",
      "@return previous value associated with the key",
      "@return true if  tables should grow",
      "@param key key to hash",
      "@return hash value of the key",
      "@param stream input stream",
      "@throws IOException if object cannot be read",
      "@throws ClassNotFoundException if the class corresponding\nto the serialized object cannot be found",
      "@param missingEntries value to return when a missing entry is fetched",
      "@param expectedSize expected number of elements in the map",
      "@param source map to copy"
   ],
   [
      "@param length size of the array to build",
      "@return a new array",
      "@param field field to which the elements belong",
      "@param arr Array to scale.",
      "@param val Scalar.",
      "@return scaled copy of array with each entry multiplied by val.",
      "@param arr Array to scale",
      "@param val Scalar",
      "@param a First term of the addition.",
      "@param b Second term of the addition.",
      "@return a new array {@code r} where {@code r[i] = a[i] + b[i]}.",
      "@param a First term.",
      "@param b Element to be subtracted.",
      "@param a First factor of the multiplication.",
      "@param b Second factor of the multiplication.",
      "@return a new array {@code r} where {@code r[i] = a[i] * b[i]}.",
      "@param a Numerator of the division.",
      "@param b Denominator of the division.",
      "@return a new array {@code r} where {@code r[i] = a[i] / b[i]}.",
      "@param p1 the first point",
      "@param p2 the second point",
      "@return the L<sub>1</sub> distance between the two points",
      "@return the L<sub>2</sub> distance between the two points",
      "@param v1 Cartesian coordinates of the first vector.",
      "@param v2 Cartesian coordinates of the second vector."
   ],
   [
      "@return the cosine of the angle between the vectors.",
      "@return the L<sub>&infin;</sub> distance between the two points",
      "@param <T> the type of the elements in the specified array",
      "@param val Values.",
      "@param dir Ordering direction.",
      "@param strict Whether the order should be strict.",
      "@return {@code true} if sorted, {@code false} otherwise.",
      "@param a Array.",
      "@param b Array.",
      "@param abort Whether to throw an exception if the check fails.",
      "@return {@code true} if the arrays have the same length.",
      "@throws DimensionMismatchException if the lengths differ.",
      "@return {@code true} if the array is sorted.",
      "@throws NonMonotonicSequenceException if the array is not sorted\nand {@code abort} is {@code true}.",
      "@param in array to be tested",
      "@throws DimensionMismatchException if input array is not rectangular",
      "@param in Array to be tested",
      "@throws NotStrictlyPositiveException if any entries of the array are not\nstrictly positive.",
      "@param in Array to be tested.",
      "@throws NotANumberException if an entry is {@code NaN}.",
      "@param v Vector of doubles.",
      "@return the 2-norm of the vector.",
      "@param x Array to be sorted and used as a pattern for permutation\nof the other arrays.",
      "@param yList Set of arrays whose permutations of entries will follow\nthose performed on {@code x}.",
      "@throws DimensionMismatchException if any {@code y} is not the same\nsize as {@code x}."
   ],
   [
      "@param dir Order direction.",
      "@param source Array to be copied.",
      "@return the copied array.",
      "@param len Number of entries to copy. If smaller then the source\nlength, the copy will be truncated, if larger it will padded with\nzeroes.",
      "@param from Initial index of the range to be copied, inclusive.",
      "@param to Final index of the range to be copied, exclusive. (This index may lie outside the array.)",
      "@param x first array",
      "@param y second array",
      "@return true if the values are both null or have same dimension\nand equal elements.",
      "@return true if the values are both null or have same dimension and\nequal elements",
      "@param x First array.",
      "@param y Second array.",
      "@return {@code true} if the values are both {@code null} or have same\ndimension and equal elements.",
      "@param values Input array to be normalized",
      "@param normalizedSum Target sum for the normalized array",
      "@return the normalized array.",
      "@throws MathArithmeticException if the input array contains infinite\nelements or sums to zero.",
      "@throws MathIllegalArgumentException if the target sum is infinite or {@code NaN}.",
      "@param field field to which array elements belong",
      "@param length of the array",
      "@param rows number of rows in the array",
      "@param columns number of columns (may be negative to build partial\narrays in the same way <code>new Field[rows][]</code> works)",
      "@param x First sequence.\nTypically, this sequence will represent an input signal to a system.",
      "@param h Second sequence.\nTypically, this sequence will represent the impulse response of the system.",
      "@return the convolution of {@code x} and {@code h}.\nThis array's length will be {@code x.length + h.length - 1}."
   ],
   [
      "@param list Array whose entries will be shuffled (in-place).",
      "@param start Index at which shuffling begins.",
      "@param pos Shuffling is performed for index positions between\n{@code start} and either the end (if {@link Position#TAIL})\nor the beginning (if {@link Position#HEAD}) of the array.",
      "@param rng Random number generator.",
      "@param n Natural number.",
      "@return an array whose entries are the numbers 0, 1, ..., {@code n}-1.\nIf {@code n == 0}, the returned array is empty.",
      "@param size Natural number.",
      "@param start Natural number.",
      "@param stride Natural number.",
      "@return an array whose entries are the numbers\n{@code start, start + stride, ..., start + (size - 1) * stride}.\nIf {@code size == 0}, the returned array is empty.",
      "@param x list of double[] arrays to concatenate",
      "@return a new array consisting of the entries of the argument arrays",
      "@param data array to scan",
      "@return descending list of values included in the input array",
      "@return the key (first element of the pair).",
      "@return the value (second element of the pair).",
      "@return the first element of the pair.",
      "@return the second element of the pair.",
      "@param o Object.",
      "@return {@code true} if the given object is also a map entry and\nthe two entries represent the same mapping.",
      "@return the hash code value.",
      "@param k First element of the pair.",
      "@param v Second element of the pair.",
      "@return a new {@code Pair} containing {@code k} and {@code v}.",
      "@param k Key (first element of the pair)."
   ],
   [
      "@param v Value (second element of the pair).",
      "@param entry Entry to copy.",
      "@param SINE_TABLE_A table of the most significant part of the sines",
      "@param SINE_TABLE_B table of the least significant part of the sines",
      "@param COSINE_TABLE_A table of the most significant part of the cosines",
      "@param COSINE_TABLE_B table of the most significant part of the cosines",
      "@param SINE_TABLE_LEN length of the tables",
      "@param TANGENT_TABLE_A table of the most significant part of the tangents",
      "@param TANGENT_TABLE_B table of the most significant part of the tangents",
      "@param x number from which cosine is requested",
      "@param result placeholder where to put the result in extended precision\n(may be null)",
      "@return cos(x)",
      "@param x number from which sine is requested",
      "@return sin(x)",
      "@param x argument of exponential",
      "@param result placeholder where to place exp(x) split in two terms\n for extra precision (i.e. exp(x) = result[0] + result[1]",
      "@return exp(x)",
      "@param d number to split",
      "@param split placeholder where to place the result",
      "@param a input/out array containing the split, changed\non output",
      "@param a first term of multiplication",
      "@param b second term of multiplication",
      "@param ans placeholder where to put the result",
      "@param a first term of addition",
      "@param b second term of addition"
   ],
   [
      "@param in initial number, in split form",
      "@param result placeholder where to put the result",
      "@param a first term of the multiplication",
      "@param b second term of the multiplication",
      "@param p integer whose exponential is requested",
      "@param result placeholder where to put the result in extended precision",
      "@return exp(p) in standard precision (equal to result[0] + result[1])",
      "@param xi number from which log is requested",
      "@return log(xi)",
      "@param out text output stream where output should be printed",
      "@param name array name",
      "@param expectedLen expected length of the array",
      "@param array2d array data",
      "@param array array data",
      "@param d double number to format",
      "@return formatted number",
      "@param expectedLen expected length",
      "@param actual actual length",
      "@throws DimensionMismatchException if the two lengths are not equal",
      "@param d the value to split",
      "@return the high order part of the mantissa",
      "@param a number on which evaluation is done",
      "@return square root of a",
      "@param x number on which evaluation is done",
      "@return hyperbolic cosine of x"
   ],
   [
      "@return hyperbolic sine of x",
      "@return hyperbolic tangent of x",
      "@return inverse hyperbolic cosine of a",
      "@return inverse hyperbolic sine of a",
      "@return inverse hyperbolic tangent of a",
      "@param a number to which neighbor should be computed",
      "@return neighbor of a towards positive infinity",
      "@return neighbor of a towards negative infinity",
      "@return a random number between 0.0 and 1.0",
      "@param x a double",
      "@return double e<sup>x</sup>",
      "@param x original argument of the exponential function",
      "@param extra extra bits of precision on input (To Be Confirmed)",
      "@param hiPrec extra bits of precision on output (To Be Confirmed)",
      "@param x number to compute shifted exponential",
      "@return exp(x) - 1",
      "@param hiPrecOut receive high precision result for -1.0 < x < 1.0",
      "@return log(x)",
      "@param x original argument of the natural logarithm function",
      "@param x Number.",
      "@return {@code log(1 + x)}.",
      "@param x a number",
      "@return log10(x)",
      "@return the value of the logarithm, i.e. the number {@code y} such that\n<code>base<sup>y</sup> = x</code>.",
      "@param y a double"
   ],
   [
      "@return double",
      "@param d Number to raise.",
      "@param e Exponent.",
      "@return d<sup>e</sup>",
      "@param x a number smaller than 1/16",
      "@return sin(x) - x",
      "@return cos(x) - 1",
      "@param xa number from which sine is requested",
      "@param xb extra bits for x (may be 0.0)",
      "@return sin(xa + xb)",
      "@param xa number from which cosine is requested",
      "@return cos(xa + xb)",
      "@param cotanFlag if true, compute the cotangent instead of the tangent",
      "@return tan(xa+xb) (or cotangent, depending on cotanFlag)",
      "@param x number to reduce",
      "@return tan(x)",
      "@return atan(x)",
      "@param xa number from which arctangent is requested",
      "@param leftPlane if true, result angle must be put in the left half plane",
      "@return atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true)",
      "@return phase angle of point (x,y) between {@code -PI} and {@code PI}",
      "@return arc sine of x",
      "@return arc cosine of x",
      "@return cubic root of x",
      "@param x angle in degrees"
   ],
   [
      "@return x converted into radians",
      "@param x angle in radians",
      "@return x converted into degrees",
      "@param x number from which absolute value is requested",
      "@return abs(x)",
      "@param x number from which ulp is requested",
      "@return ulp(x)",
      "@param d number to multiply",
      "@return d &times; 2<sup>n</sup>",
      "@param f number to multiply",
      "@return f &times; 2<sup>n</sup>",
      "@param d base number",
      "@param direction (the only important thing is whether\n{@code direction} is greater or smaller than {@code d})",
      "@return the next machine representable number in the specified direction",
      "@param f base number",
      "@param direction (the only important thing is whether\n{@code direction} is greater or smaller than {@code f})",
      "@param x number from which floor is requested",
      "@return a double number f such that f is an integer f <= x < f + 1.0",
      "@param x number from which ceil is requested",
      "@return a double number c such that c is an integer c - 1.0 < x <= c",
      "@param x number from which nearest whole number is requested",
      "@return a double number r such that r is an integer r - 0.5 <= x <= r + 0.5",
      "@param x number from which closest long is requested",
      "@return closest long to x",
      "@param x number from which closest int is requested"
   ],
   [
      "@return closest int to x",
      "@param a first value",
      "@param b second value",
      "@param dividend the number to be divided",
      "@param divisor the number by which to divide",
      "@return the remainder, rounded",
      "@param n number to convert to int",
      "@return integer with same valie as n if no overflows occur",
      "@throws MathArithmeticException if n cannot fit into an int",
      "@param n number to increment",
      "@return n+1 if no overflows occur",
      "@throws MathArithmeticException if an overflow occurs",
      "@param n number to decrement",
      "@return n-1 if no overflows occur",
      "@param a first number to add",
      "@param b second number to add",
      "@return a+b if no overflows occur",
      "@param a first number",
      "@param b second number to subtract from a",
      "@return a-b if no overflows occur",
      "@param a first number to multiply",
      "@param b second number to multiply",
      "@return a*b if no overflows occur",
      "@param a dividend",
      "@param b divisor"
   ],
   [
      "@return q such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0",
      "@return r such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0",
      "@param magnitude the value to return",
      "@return the magnitude with the same sign as the {@code sign} argument",
      "@param d number from which exponent is requested",
      "@return exponent for d in IEEE754 representation, without bias",
      "@param f number from which exponent is requested",
      "@param a unused",
      "@param value Value to be added to end of array.",
      "@param values Values to be added to end of array.",
      "@param value Value to be added to the array.",
      "@return the value which has been discarded or \"pushed\" out of the array\nby this rolling insert.",
      "@param value New value to substitute for the most recently added value",
      "@return the value that has been replaced in the array.",
      "@throws MathIllegalStateException if the array is empty",
      "@param expansion factor to be checked",
      "@param contraction criteria to be checked",
      "@throws MathIllegalArgumentException if the contractionCriteria is less than\nthe expansionCriteria.",
      "@param contraction Criterion to be checked.",
      "@param expansion Factor to be checked.",
      "@param i the number of elements to discard from the front of the array",
      "@param i the number of elements to discard from the end of the array",
      "@param i the number of elements to discard from the front/end of the array",
      "@param front true if elements are to be discarded from the front\nof the array, false if elements are to be discarded from the end\nof the array",
      "@throws MathIllegalArgumentException if i is greater than numElements."
   ],
   [
      "@param size Size of the new internal storage array.",
      "@return the contraction criteria used to reclaim memory.",
      "@return the contraction criterion used to reclaim memory.",
      "@return the double array.",
      "@return the expansion factor of this expandable double array",
      "@return the expansion mode.",
      "@return the length of the internal storage array.",
      "@return the length of the internal array.",
      "@return the number of elements.",
      "@return the internal storage array used by this object",
      "@return the internal storage array used by this object.",
      "@return the start index.",
      "@param contractionCriteria contraction criteria",
      "@throws MathIllegalArgumentException if the contractionCriteria is less than\n        the expansionCriteria.",
      "@param f Function to be applied on this array.",
      "@return the result.",
      "@param expansionFactor the new expansion factor value.",
      "@param expansionMode The expansionMode to set.",
      "@throws MathIllegalArgumentException if the specified mode value is not valid.",
      "@param expansionMode Expansion mode to use for resizing the array.",
      "@param initialCapacity of the array",
      "@param i a new number of elements",
      "@return true if array satisfies the contraction criteria",
      "@return the starting index.",
      "@param source ResizableDoubleArray to copy"
   ],
   [
      "@param dest ResizableArray to replace with a copy of the source array",
      "@return a new ResizableDoubleArray with the same data and configuration\nproperties as this",
      "@param object object to be compared for equality with this",
      "@return true iff object is a ResizableDoubleArray with the same data and\nproperties as this",
      "@return the hash code representing this {@code ResizableDoubleArray}.",
      "@param initialCapacity Initial size of the internal storage array.",
      "@param initialArray initial array",
      "@param expansionFactor The array will be expanded based on this\nparameter.",
      "@throws MathIllegalArgumentException if parameters are not valid.",
      "@param initialCapacity Initial size of the internal storage array..",
      "@param contractionCriteria Contraction criteria.",
      "@param contractionCriterion Contraction criterion.",
      "@throws MathIllegalArgumentException if the parameters are not valid.",
      "@param initialCapacity the initial size of the internal storage array",
      "@param expansionFactor the array will be expanded based on this\n                       parameter",
      "@param contractionCriteria the contraction Criteria",
      "@param expansionMode the expansion mode",
      "@throws MathIllegalArgumentException if parameters are not valid",
      "@param contractionCriterion Contraction criteria.",
      "@param expansionMode Expansion mode.",
      "@param data Initial contents of the array.",
      "@param original array to copy",
      "@return the unique instance of this class",
      "@return the size of the universe.",
      "@return the size of the subsets to be enumerated."
   ],
   [
      "@return a lexicographic comparator.",
      "@param n Size of the set from which subsets are selected.",
      "@param k Size of the subsets to be enumerated.",
      "@param iterationOrder Specifies the {@link #iterator() iteration order}.",
      "@throws org.apache.commons.math3.exception.NotPositiveException if {@code n < 0}.",
      "@throws org.apache.commons.math3.exception.NumberIsTooLargeException if {@code k > n}.",
      "@param value the value to be hashed",
      "@param x Value",
      "@param y Value",
      "@return {@code new Double(x).equals(new Double(y))}",
      "@param value the value to be hashed (may be null)",
      "@param a angle to normalize",
      "@param center center of the desired 2&pi; interval for the result",
      "@param e1 first element",
      "@param e2 second element",
      "@param a Value to reduce.",
      "@param offset Value that will be mapped to {@code 0}.",
      "@return the value, within the interval {@code [0 |period|)},\nthat corresponds to {@code a}.",
      "@param magnitude Magnitude of the returned value.",
      "@param sign Sign of the returned value.",
      "@throws MathArithmeticException if {@code magnitude == Byte.MIN_VALUE}\nand {@code sign >= 0}.",
      "@throws MathArithmeticException if {@code magnitude == Short.MIN_VALUE}\nand {@code sign >= 0}.",
      "@throws MathArithmeticException if {@code magnitude == Integer.MIN_VALUE}\nand {@code sign >= 0}.",
      "@throws MathArithmeticException if {@code magnitude == Long.MIN_VALUE}\nand {@code sign >= 0}.",
      "@throws NotFiniteNumberException if {@code x} is not a\nfinite real number."
   ],
   [
      "@param val Arguments.",
      "@throws NotFiniteNumberException if any values of the array is not a\nfinite real number.",
      "@param o Object to be checked.",
      "@param args Arguments to replace the placeholders in {@code pattern}.",
      "@param o the Object to be transformed.",
      "@return the double value of the Object.",
      "@throws MathIllegalArgumentException if the Object can not be transformed into a Double.",
      "@param n the coefficient index to retrieve.",
      "@param x the evaluation point.",
      "@return the n-th a coefficient.",
      "@return the n-th b coefficient.",
      "@return the value of the continued fraction evaluated at x.",
      "@throws ConvergenceException if the algorithm fails to converge.",
      "@param epsilon maximum error allowed.",
      "@throws MaxCountExceededException if maximal number of iterations is reached",
      "@return The index corresponding to a random uniformly selected\nvalue between first and the last indices of the array slice",
      "@throws MathIllegalArgumentException when indices exceeds range",
      "@param random random generator to use for selecting pivot",
      "@param listener A {@code IterationListener} object.",
      "@param e The {@link IterationEvent} object.",
      "@return the number of iterations.",
      "@return the maximum number of iterations.",
      "@throws MaxCountExceededException if the maximum number of iterations is\nreached.",
      "@param listener The {@link IterationListener} to be removed.",
      "@param maxIterations the maximum number of iterations"
   ],
   [
      "@param callBack the function to be called when the maximum number of\niterations has been reached",
      "@throws org.apache.commons.math3.exception.NullArgumentException if {@code callBack} is {@code null}",
      "@param value the special value to parse.",
      "@return the special number.",
      "@param format the number format used to parse normal, numeric values.",
      "@return the parsed number.",
      "@param expected expected string",
      "@return true if the expected string was there",
      "@param value the double to format.",
      "@param format the format used.",
      "@return pivoting strategy",
      "@param work work array to use to find out the K<sup>th</sup> value",
      "@param pivotsHeap cached pivots heap that can be used for efficient estimation",
      "@param k the index whose value in the array is of interest",
      "@return K<sup>th</sup> value",
      "@param begin index of the first element of the slice of work array",
      "@param end index after the last element of the slice of work array",
      "@param pivot initial index of the pivot",
      "@return index of the pivot after partition",
      "@param pivotingStrategy pivoting strategy to use",
      "@return the number of iterations performed",
      "@param source the iterative algorithm on which the event initially\noccurred",
      "@param iterations the number of iterations performed at the time\n{@code this} event is created",
      "@param key Class to check",
      "@return true|false"
   ],
   [
      "@param value NumberTransformer to check",
      "@param key The Class of the object",
      "@return the mapped NumberTransformer or null.",
      "@param key The Class",
      "@param transformer The NumberTransformer",
      "@return the replaced transformer if one is present",
      "@return the removed transformer if one is present or\nnull if none was present.",
      "@return Set of Classes",
      "@return Set of NumberTransformers",
      "@throws MathIllegalArgumentException if the Object can not be\ntransformed into a Double.",
      "@param start First value of the range.",
      "@param end Last value of the range.",
      "@return a range.",
      "@param max Last value of the range that satisfies the above\nconstruction rule.",
      "@param step Increment.",
      "@throws DimensionMismatchException iff the length of <code>originalData</code>\n  and <code>permutedData</code> lists are not equal",
      "@throws MathIllegalArgumentException if values is null or the indices\nare not valid",
      "@throws MathIllegalArgumentException if the stored data array is null",
      "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if {@code sampleSize} is not positive.",
      "@throws NullArgumentException if prototypeStatistics is null",
      "@throws NotStrictlyPositiveException if {@code elements <= 0}.",
      "@throws OutOfRangeException if the space dimension is outside the allowed range of [1, 40]",
      "@throws NullArgumentException if base is null",
      "@throws DimensionMismatchException if weights is non-null and the length of the input arrays differ",
      "@param bases the base number for each dimension, entries should be (pairwise) prime, may not be null"
   ],
   [
      "@throws NullArgumentException if x is null",
      "@throws OutOfRangeException if p is not greater than 0 and less\nthan or equal to 100",
      "@throws NullArgumentException if either of the input arrays is {@code null}.",
      "@throws NotStrictlyPositiveException if {@code valueAtNumCall <= 0}.",
      "@throws NumberIsTooLargeException if {@code valueAtNumCall >= initValue}.",
      "@throws NotStrictlyPositiveException if {@code dimension <= 0}\nor {@code size <= 0}.",
      "@param alpha First shape parameter (must be positive).",
      "@param beta Second shape parameter (must be positive).",
      "@throws NumberIsTooSmallException if order is 1 or less",
      "@throws IllegalArgumentException if order is 1 or less",
      "@param v Vector to subtract from {@code this}.",
      "@throws NotStrictlyPositiveException if {@code n < 1}.",
      "@throws NotStrictlyPositiveException if minimal number of iterations\nis not strictly positive.",
      "@throws NumberIsTooSmallException if maximal number of iterations\nis smaller than or equal to the minimal number of iterations.",
      "@throws NotStrictlyPositiveException if minimal number of iterations\nor number of points are not strictly positive.",
      "@throws NotStrictlyPositiveException if {@code sd <= 0}.",
      "@throws NumberIsTooSmallException if number of steps is smaller than 2",
      "@return a clone of the data array.",
      "@param n the size of the set",
      "@param k the size of the subsets to be counted",
      "@return {@code n choose k}",
      "@throws MathArithmeticException if the result is too large to be\nrepresented by a long integer.",
      "@param n argument",
      "@return {@code n!}",
      "@throws MathArithmeticException if the result is too large to be represented\nby a {@code long}."
   ],
   [
      "@param n Argument.",
      "@param k the number of non-empty subsets",
      "@return {@code S(n,k)}",
      "@throws MathArithmeticException if some overflow happens, typically for n exceeding 25 and\nk between 20 and n-2 (S(n,n-1) is handled specifically and does not overflow)",
      "@return an {@link Iterator iterator} over the k-sets in n.",
      "@param n Size of the set.",
      "@param k Size of the subsets to be counted.",
      "@return the index of the pivot element chosen between the\nfirst and the last element of the array slice",
      "@return The index corresponding to a simple average of\nthe first and the last element indices of the array slice",
      "@return {@code true} if {@code this} number is infinite",
      "@return {@code true} if {@code this} is {@code NaN}",
      "@param x the primitive {@code double} value of the object to be created",
      "@param o the object that gets transformed.",
      "@return a double primitive representation of the Object o.",
      "@throws MathIllegalArgumentException if Object <code>o</code>\ncannot successfully be transformed",
      "@return the rounding mode.",
      "@param roundingMode rounding mode for decimal divisions",
      "@return the scale",
      "@param scale scale for division operations",
      "@return double value corresponding to the instance",
      "@return BigDecimal value corresponding to the instance",
      "@param val value of the instance",
      "@param unscaledVal unscaled value",
      "@param scale scale to use",
      "@param mc to used"
   ],
   [
      "@param mc context to use",
      "@param in character representation of the value",
      "@param offset offset of the first character to analyze",
      "@param len length of the array slice to analyze",
      "@param val character representation of the value",
      "@param x an addend",
      "@param y an addend",
      "@throws MathArithmeticException if the result can not be represented\nas an {@code int}.",
      "@param a an addend",
      "@param b an addend",
      "@throws MathArithmeticException if the result can not be represented as an long",
      "@param p Number.",
      "@param q Number.",
      "@return the greatest common divisor (never negative).",
      "@throws MathArithmeticException if the result cannot be represented as\na non-negative {@code int} value.",
      "@param a Positive number.",
      "@param b Positive number.",
      "@return the greatest common divisor.",
      "@return the greatest common divisor, never negative.",
      "@throws MathArithmeticException if the result cannot be represented as\na non-negative {@code long} value.",
      "@param a Number.",
      "@param b Number.",
      "@return the least common multiple, never negative.",
      "@throws MathArithmeticException if the result cannot be represented\nas a non-negative {@code long} value.",
      "@param x Factor."
   ],
   [
      "@param y Factor.",
      "@throws MathArithmeticException if the result can not be\nrepresented as an {@code int}.",
      "@param a Factor.",
      "@param b Factor.",
      "@throws MathArithmeticException if the result can not be represented\nas a {@code long}.",
      "@param x Minuend.",
      "@param y Subtrahend.",
      "@param a Value.",
      "@param b Value.",
      "@throws MathArithmeticException if the result can not be represented as a\n{@code long}.",
      "@param k Number to raise.",
      "@return \\( k^e \\)",
      "@throws MathArithmeticException if the result would overflow.",
      "@return k<sup>e</sup>",
      "@param a Addend.",
      "@param b Addend.",
      "@param pattern Pattern to use for any thrown exception.",
      "@return the sum {@code a + b}.",
      "@throws MathArithmeticException if the result cannot be represented\nas a {@code long}.",
      "@param n the number to test",
      "@return true if the argument is a power of two",
      "@return The index corresponding to a pivot chosen between the\nfirst, middle and the last indices of the array slice",
      "@param c Complex object to format.",
      "@return A formatted number in the form \"Re(c) + Im(c)i\".",
      "@param c Double object to format."
   ],
   [
      "@return A formatted number.",
      "@param complex the object to format.",
      "@param absIm Absolute value of the imaginary part of a complex number.",
      "@param toAppendTo where the text is to be appended.",
      "@param pos On input: an alignment field, if desired. On output: the\noffsets of the alignment field.",
      "@throws MathIllegalArgumentException is {@code obj} is not a valid type.",
      "@return the imaginaryCharacter.",
      "@return the imaginaryFormat.",
      "@param imaginaryCharacter Imaginary character.",
      "@throws NoDataException if {@code imaginaryCharacter} is an\nempty string.",
      "@return the realFormat.",
      "@param source the string to parse.",
      "@return the parsed {@link Complex} object.",
      "@param format the custom format for both real and imaginary parts.",
      "@param realFormat the custom format for the real part.",
      "@param imaginaryFormat the custom format for the imaginary part.",
      "@param imaginaryCharacter The custom imaginary character.",
      "@return {@code true} if the roots of unity are stored in\ncounter-clockwise order",
      "@throws MathIllegalStateException if no roots of unity have been computed\nyet",
      "@param n the (signed) number of roots of unity to be computed",
      "@param k index of the {@code n}-th root of unity",
      "@return real part of the {@code k}-th {@code n}-th root of unity",
      "@throws MathIllegalStateException if no roots of unity have been\ncomputed yet",
      "@throws MathIllegalArgumentException if {@code k} is out of range",
      "@return imaginary part of the {@code k}-th {@code n}-th root of unity"
   ],
   [
      "@throws OutOfRangeException if {@code k} is out of range",
      "@return the number of roots of unity currently stored",
      "@return the conjugate quaternion",
      "@param q1 First quaternion.",
      "@param q2 Second quaternion.",
      "@return the product {@code q1} and {@code q2}, in that order.",
      "@param q Quaternion.",
      "@return the product of this instance with {@code q}, in that order.",
      "@param q1 Quaternion.",
      "@param q2 Quaternion.",
      "@return the sum of {@code q1} and {@code q2}.",
      "@return the sum of this instance and {@code q}",
      "@param q1 First Quaternion.",
      "@return the difference between {@code q1} and {@code q2}.",
      "@return the difference between this instance and {@code q}.",
      "@return the dot product of {@code q1} and {@code q2}.",
      "@return the dot product of this instance and {@code q}.",
      "@return the norm.",
      "@return a normalized quaternion.",
      "@throws ZeroException if the norm of the quaternion is zero.",
      "@param q Quaternion with which to compare the current quaternion.",
      "@param eps Tolerance.",
      "@return {@code true} if the each of the components are equal\nwithin the allowed absolute error.",
      "@param eps Tolerance (absolute error).",
      "@return {@code true} if the scalar part of the quaternion is zero."
   ],
   [
      "@return the unit quaternion with positive scalar part.",
      "@return the inverse.",
      "@throws ZeroException if the norm (squared) of the quaternion is zero.",
      "@return the scalar part.",
      "@return the first component of the vector part.",
      "@return the second component of the vector part.",
      "@return the third component of the vector part.",
      "@return the vector part.",
      "@param alpha Scalar factor.",
      "@return a scaled quaternion.",
      "@param a Scalar component.",
      "@param b First vector component.",
      "@param c Second vector component.",
      "@param d Third vector component.",
      "@param scalar Scalar part of the quaternion.",
      "@param v Components of the vector part of the quaternion.",
      "@param v Components of the vector part of the pure quaternion.",
      "@param addend Value to be added to this {@code Complex}.",
      "@return {@code this + addend}.",
      "@return the conjugate of this Complex object.",
      "@param divisor Value by which this {@code Complex} is to be divided.",
      "@return {@code this / divisor}.",
      "@param other Object to test for equality with this instance.",
      "@return {@code true} if the objects are equal, {@code false} if object\nis {@code null}, not an instance of {@code Complex}, or not equal to\nthis instance.",
      "@param maxUlps {@code (maxUlps - 1)} is the number of floating point\nvalues between the real (resp. imaginary) parts of {@code x} and\n{@code y}."
   ],
   [
      "@return {@code true} if there are fewer than {@code maxUlps} floating\npoint values between the real (resp. imaginary) parts of {@code x}\nand {@code y}.",
      "@return the imaginary part.",
      "@return the real part.",
      "@return true if either or both parts of this complex number is\n{@code NaN}; false otherwise.",
      "@return true if one or both parts of this complex number are infinite\nand neither part is {@code NaN}.",
      "@param factor value to be multiplied by this {@code Complex}.",
      "@return {@code this * factor}.",
      "@return {@code -this}.",
      "@param subtrahend value to be subtracted from this {@code Complex}.",
      "@return {@code this - subtrahend}.",
      "@return the inverse cosine of this complex number.",
      "@return the inverse sine of this complex number.",
      "@return the inverse tangent of this complex number",
      "@return the cosine of this complex number.",
      "@return the hyperbolic cosine of this complex number.",
      "@return <code><i>e</i><sup>this</sup></code>.",
      "@return the value <code>ln &nbsp; this</code>, the natural logarithm\nof {@code this}.",
      "@param x exponent to which this {@code Complex} is to be raised.",
      "@return <code> this<sup>x</sup></code>.",
      "@return <code>this<sup>x</sup></code>.",
      "@return the sine of this complex number.",
      "@return the hyperbolic sine of {@code this}.",
      "@return the square root of {@code this}.",
      "@return the square root of <code>1 - this<sup>2</sup></code>.",
      "@return the tangent of {@code this}."
   ],
   [
      "@return the hyperbolic tangent of {@code this}.",
      "@return the argument of {@code this}.",
      "@param n Degree of root.",
      "@return a List of all {@code n}-th roots of {@code this}.",
      "@param realPart Real part.",
      "@param imaginaryPart Imaginary part.",
      "@return a new complex number instance.",
      "@return a Complex instance.",
      "@return A Complex instance with all fields resolved.",
      "@param real Real part.",
      "@param imaginary Imaginary part.",
      "@param r the modulus of the complex number to create",
      "@param theta the argument of the complex number to create",
      "@return <code>r&middot;e<sup>i&middot;theta</sup></code>",
      "@param real Array of numbers to be converted to their {@code Complex}\nequivalent.",
      "@return an array of {@code Complex} objects.",
      "@param function vectorial residuals function to wrap",
      "@param observations observations to be compared to objective function to compute residuals",
      "@param weights weights to apply to the residuals",
      "@throws DimensionMismatchException if the observations vector and the weights\nvector dimensions do not match (objective function dimension is checked only when\nthe {@link #value(double[])} method is called)",
      "@param scale scaling matrix",
      "@throws DimensionMismatchException if the observations vector and the scale\nmatrix dimensions do not match (objective function dimension is checked only when\nthe {@link #value(double[])} method is called)",
      "@param f Objective function.",
      "@param goalType Type of optimization goal: either\n{@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}.",
      "@param startPoint Start point for optimization."
   ],
   [
      "@param lowerBound Lower bound for each of the parameters.",
      "@param upperBound Upper bound for each of the parameters.",
      "@return the point/value pair giving the optimal value for objective\nfunction.",
      "@throws org.apache.commons.math3.exception.DimensionMismatchException if the array sizes are wrong.",
      "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximal number of evaluations is exceeded.",
      "@throws org.apache.commons.math3.exception.NumberIsTooSmallException if any\nof the initial values is less than its lower bound.",
      "@throws org.apache.commons.math3.exception.NumberIsTooLargeException if any\nof the initial values is greater than its upper bound.",
      "@return a copy of the stored point.",
      "@return a reference to the internal array storing the point.",
      "@param point Point coordinates. This instance will store\na copy of the array, not the array passed as argument.",
      "@param value Value of the objective function at the point.",
      "@param point Point coordinates.",
      "@param copyArray if {@code true}, the input array will be copied,\notherwise it will be referenced.",
      "@param iteration Index of current iteration",
      "@param previous Best point in the previous iteration.",
      "@param current Best point in the current iteration.",
      "@return {@code true} if the algorithm has converged.",
      "@param relativeThreshold relative tolerance threshold",
      "@param absoluteThreshold absolute tolerance threshold",
      "@param maxIter Maximum iteration count.",
      "@param optimizer optimizer to use for the fitting",
      "@param degree Maximal degree of the polynomial.",
      "@return weight of the measurement in the fitting process",
      "@return observed value of the function at x",
      "@param weight weight of the measurement in the fitting process"
   ],
   [
      "@param x abscissa of the measurement",
      "@param y ordinate of the measurement",
      "@return the relative threshold.",
      "@return the absolute threshold.",
      "@return the dimension of the simplex.",
      "@return the size of the simplex.",
      "@param evaluationFunction Evaluation function.",
      "@param comparator Comparator to use to sort simplex vertices from best\nto worst.",
      "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the algorithm fails to converge.",
      "@param startPoint First point of the simplex.",
      "@throws DimensionMismatchException if the start point does not match\nsimplex dimension.",
      "@param comparator Comparator to use to sort simplex vertices from best to worst.",
      "@param pointValuePair Point to insert.",
      "@param comparator Comparator to use for sorting the simplex vertices\nfrom best to worst.",
      "@return all the simplex points.",
      "@param index Location.",
      "@return the point at location {@code index}.",
      "@param point New value.",
      "@param points New Points.",
      "@param n Dimension of the hypercube.",
      "@param sideLength Length of the sides of the hypercube.",
      "@return the steps.",
      "@param n Dimension of the simplex.",
      "@param steps Steps along the canonical axes representing box edges. They\nmay be negative but not zero.",
      "@param referenceSimplex Reference simplex."
   ],
   [
      "@throws NotStrictlyPositiveException if the reference simplex does not\ncontain at least one point.",
      "@throws DimensionMismatchException if there is a dimension mismatch\nin the reference simplex.",
      "@throws IllegalArgumentException if one of its vertices is duplicated.",
      "@param simplex Simplex.",
      "@param maxEval Allowed number of evaluations of the objective function.",
      "@param goalType Optimization type.",
      "@param optData Optimization data. The following data will be looked for:\n<ul>\n <li>{@link org.apache.commons.math3.optimization.InitialGuess InitialGuess}</li>\n <li>{@link AbstractSimplex}</li>\n</ul>",
      "@param optData Optimization data. The following data will be looked for:\n<ul>\n <li>{@link AbstractSimplex}</li>\n</ul>",
      "@param checker Convergence checker.",
      "@param rel Relative threshold.",
      "@param abs Absolute threshold.",
      "@param lowerBound Lower bounds.",
      "@param upperBound Upper bounds.",
      "@return the value of the objective at the optimum.",
      "@param lowerBound Lower bounds (constraints) of the objective variables.",
      "@param upperBound Upperer bounds (constraints) of the objective variables.",
      "@param numberOfInterpolationPoints Number of interpolation conditions.\nFor a problem of dimension {@code n}, its value must be in the interval\n{@code [n+2, (n+1)(n+2)/2]}.\nChoices that exceed {@code 2n+1} are not recommended.",
      "@param initialTrustRegionRadius Initial trust region radius.",
      "@param stoppingTrustRegionRadius Stopping trust region radius.",
      "@param sideLength Length of the sides of the default (hypercube)\nsimplex. See {@link AbstractSimplex#AbstractSimplex(int,double)}.",
      "@param n Dimension of the simplex. See\n{@link AbstractSimplex#AbstractSimplex(int,double)}.",
      "@param rho Reflection coefficient.",
      "@param khi Expansion coefficient.",
      "@param gamma Contraction coefficient.",
      "@param sigma Shrinkage coefficient."
   ],
   [
      "@param n Dimension of the simplex. See\n{@link AbstractSimplex#AbstractSimplex(int)}.",
      "@param steps Steps along the canonical axes representing box edges.\nThey may be negative but not zero. See",
      "@param steps Steps along the canonical axes representing box edges.\nThey may be negative but not zero. See\n{@link AbstractSimplex#AbstractSimplex(double[])}.",
      "@param referenceSimplex Reference simplex. See\n{@link AbstractSimplex#AbstractSimplex(double[][])}.",
      "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if the reference simplex does not contain at least one point.",
      "@throws org.apache.commons.math3.exception.DimensionMismatchException if there is a dimension mismatch in the reference simplex.",
      "@param point unbounded value",
      "@return bounded value",
      "@param point bounded value",
      "@return unbounded value",
      "@return underlying function value",
      "@param bounded bounded function",
      "@param lower lower bounds for each element of the input parameters array\n(some elements may be set to {@code Double.NEGATIVE_INFINITY} for\nunbounded values)",
      "@param upper upper bounds for each element of the input parameters array\n(some elements may be set to {@code Double.POSITIVE_INFINITY} for\nunbounded values)",
      "@throws DimensionMismatchException if lower and upper bounds are not\nconsistent, either according to dimension or to values",
      "@return the objective function value at the specified point.",
      "@throws TooManyEvaluationsException if the maximal number of evaluations is\nexceeded.",
      "@param optData Optimization data. The following data will be looked for:\n<ul>\n <li>{@link Target}</li>\n <li>{@link Weight}</li>\n <li>{@link InitialGuess}</li>\n</ul>",
      "@return the point/value pair giving the optimal value of the objective\nfunction.",
      "@throws TooManyEvaluationsException if the maximal number of\nevaluations is exceeded.",
      "@throws DimensionMismatchException if the initial guess, target, and weight\narguments have inconsistent dimensions.",
      "@param t Target value for the objective functions at optimum.",
      "@param w Weights for the least squares cost computation.",
      "@return the weight matrix.",
      "@return the target values."
   ],
   [
      "@return the objective vector function.",
      "@return the point/value pair giving the optimal value for the\nobjective function.",
      "@return a reference to the {@link #target array}.",
      "@return a reference to the {@link #weight array}.",
      "@throws DimensionMismatchException if {@link #target} and\n{@link #weightMatrix} have inconsistent dimensions.",
      "@return History of sigma values.",
      "@return History of mean matrix.",
      "@return History of fitness values.",
      "@return History of D matrix.",
      "@param optData Optimization data. The following data will be looked for:\n<ul>\n <li>{@link org.apache.commons.math3.optimization.InitialGuess InitialGuess}</li>\n <li>{@link Sigma}</li>\n <li>{@link PopulationSize}</li>\n</ul>",
      "@param optData Optimization data. The following data will be looked for:\n<ul>\n <li>{@link Sigma}</li>\n <li>{@link PopulationSize}</li>\n</ul>",
      "@param guess Initial guess for the arguments of the fitness function.",
      "@param zmean Weighted row matrix of the gaussian random numbers generating\nthe current offspring.",
      "@param xold xmean matrix of the previous generation.",
      "@return hsig flag indicating a small correction.",
      "@param hsig Flag indicating a small correction.",
      "@param bestArz Fitness-sorted matrix of the gaussian random values of the\ncurrent offspring.",
      "@param bestArx Fitness-sorted matrix of the argument vectors producing the\ncurrent offspring.",
      "@param arz Unsorted matrix containing the gaussian random values of the\ncurrent offspring.",
      "@param arindex Indices indicating the fitness-order of the current offspring.",
      "@param negccov Negative covariance factor.",
      "@param vals History queue.",
      "@param val Current best fitness value.",
      "@param doubles Array of values to be sorted.",
      "@return a sorted array of indices pointing into doubles."
   ],
   [
      "@param m Input matrix",
      "@return Matrix representing the element-wise logarithm of m.",
      "@param m Input matrix.",
      "@return Matrix representing the element-wise square root of m.",
      "@return Matrix representing the element-wise square of m.",
      "@param m Input matrix 1.",
      "@param n Input matrix 2.",
      "@return the matrix where the elements of m and n are element-wise multiplied.",
      "@return Matrix where the elements of m and n are element-wise divided.",
      "@param cols Columns to select.",
      "@return Matrix representing the selected columns.",
      "@param k Diagonal position.",
      "@return Upper triangular part of matrix.",
      "@return Row matrix representing the sums of the rows.",
      "@return the diagonal n-by-n matrix if m is a column matrix or the column\nmatrix representing the diagonal if m is a n-by-n matrix.",
      "@param m1 Source matrix.",
      "@param col1 Source column.",
      "@param m2 Target matrix.",
      "@param col2 Target column.",
      "@param n Number of rows.",
      "@param m Number of columns.",
      "@return n-by-m matrix filled with 1.",
      "@return n-by-m matrix of 0 values out of diagonal, and 1 values on\nthe diagonal.",
      "@return n-by-m matrix of zero values.",
      "@param mat Input matrix."
   ],
   [
      "@param n Number of row replicates.",
      "@param m Number of column replicates.",
      "@return a matrix which replicates the input matrix in both directions.",
      "@param start Start value.",
      "@param end End value.",
      "@param step Step size.",
      "@return a sequence as column matrix.",
      "@return the maximum of the matrix element values.",
      "@return the minimum of the matrix element values.",
      "@param m Input array.",
      "@return the maximum of the array values.",
      "@return the minimum of the array values.",
      "@param indices Input index array.",
      "@return the inverse of the mapping defined by indices.",
      "@return the indices in inverse order (last is first).",
      "@param size Length of random array.",
      "@return an array of Gaussian random numbers.",
      "@param size Number of rows.",
      "@param popSize Population size.",
      "@return a 2-dimensional matrix of Gaussian random numbers.",
      "@param lambda Population size.",
      "@param inputSigma Initial standard deviations to sample new points\naround the initial guess.",
      "@param maxIterations Maximal number of iterations.",
      "@param stopFitness Whether to stop if objective function value is smaller than\n{@code stopFitness}.",
      "@param isActiveCMA Chooses the covariance matrix update method."
   ],
   [
      "@param diagonalOnly Number of initial iterations, where the covariance matrix\nremains diagonal.",
      "@param checkFeasableCount Determines how often new random objective variables are\ngenerated in case they are out of bounds.",
      "@param random Random generator.",
      "@param generateStatistics Whether statistic data is collected.",
      "@param point unbounded point",
      "@return either underlying function value or penalty function value",
      "@param offset base offset of the penalty function",
      "@param scale scale of the penalty function",
      "@throws DimensionMismatchException if lower bounds, upper bounds and\nscales are not consistent, either according to dimension or to bounadary\nvalues",
      "@param optData Optimization data. The following data will be looked for:\n<ul>\n <li>{@link InitialGuess}</li>\n <li>{@link SimpleBounds}</li>\n</ul>",
      "@return the optimization type.",
      "@return the lower bounds.",
      "@return the upper bounds.",
      "@return the point/value pair giving the optimal value of the\nobjective function.",
      "@param p Point used in the line search.",
      "@param d Direction used in the line search.",
      "@param optimum Optimum found by the line search.",
      "@return a 2-element array containing the new point (at index 0) and\nthe new direction (at index 1).",
      "@throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}.",
      "@param rel Relative threshold for this optimizer.",
      "@param abs Absolute threshold for this optimizer.",
      "@param lineRel Relative threshold for the internal line search optimizer.",
      "@param lineAbs Absolute threshold for the internal line search optimizer.",
      "@param original Original simplex (to be preserved).",
      "@param coeff Linear coefficient."
   ],
   [
      "@param comparator Comparator to use to sort simplex vertices from best\nto poorest.",
      "@return the best point in the transformed simplex.",
      "@param startPoint Initial guess.",
      "@param point current point at which the search direction was computed",
      "@param r raw search direction (i.e. opposite of the gradient)",
      "@return approximation of H<sup>-1</sup>r where H is the objective function hessian",
      "@param delta upper bound on the euclidean norm of diagR * lmDir",
      "@throws ConvergenceException if the decomposition cannot be performed",
      "@param costRelativeTolerance Desired relative error in the sum of\nsquares.",
      "@param parRelativeTolerance Desired relative error in the approximate\nsolution parameters.",
      "@param orthoTolerance Desired max cosine on the orthogonality between\nthe function vector and the columns of the Jacobian.",
      "@param threshold Desired threshold for QR ranking. If the squared norm\nof a column vector is smaller or equal to this threshold during QR\ndecomposition, it is considered to be a zero vector and hence the rank\nof the matrix is reduced.",
      "@return the number of evaluations of the Jacobian function.",
      "@throws DimensionMismatchException if the Jacobian dimension does not\nmatch problem dimension.",
      "@param params Model parameters at which to compute the Jacobian.",
      "@return the weighted Jacobian: W<sup>1/2</sup> J.",
      "@throws DimensionMismatchException if the dimension does not match the\nproblem dimension.",
      "@param residuals Residuals.",
      "@return the cost.",
      "@return RMS value",
      "@return chi-square value",
      "@param cost Cost value.",
      "@return the covariance matrix.",
      "@throws org.apache.commons.math3.linear.SingularMatrixException if the covariance matrix cannot be computed (singular problem).",
      "@param threshold Singularity threshold."
   ],
   [
      "@param params Model parameters.",
      "@return an estimate of the standard deviation of the optimized parameters",
      "@throws org.apache.commons.math3.linear.SingularMatrixException if the covariance matrix cannot be computed.",
      "@throws NumberIsTooSmallException if the number of degrees of freedom is not\npositive, i.e. the number of measurements is less or equal to the number of\nparameters.",
      "@param covarianceSingularityThreshold Singularity threshold (see\n{@link #computeCovariances(double[],double) computeCovariances}).",
      "@param target Target value for the objective functions at optimum.",
      "@param weights Weights for the least squares cost computation.",
      "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if\nthe maximal number of evaluations is exceeded.",
      "@throws DimensionMismatchException if the target, and weight arguments\nhave inconsistent dimensions.",
      "@param objectiveValue Value of the the objective function. This is\nthe value returned from a call to\n{@link #computeObjectiveValue(double[]) computeObjectiveValue}\n(whose array argument contains the model parameters).",
      "@return the residuals.",
      "@throws DimensionMismatchException if {@code params} has a wrong\nlength.",
      "@param evaluationPoint Point at which the gradient must be evaluated.",
      "@return the gradient at the specified point.",
      "@param useLU If {@code true}, the normal equations will be solved\nusing LU decomposition, otherwise they will be solved using QR\ndecomposition.",
      "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the allowed number of evaluations is exceeded.",
      "@param initialStep initial step used to bracket the optimum in line search,\nif a non-positive value is used, the initial step is reset to its\ndefault value of 1.0",
      "@param f function whose root must be bracketed.",
      "@param a lower bound of the interval.",
      "@param h initial step to try.",
      "@return b such that f(a) and f(b) have opposite signs.",
      "@throws MathIllegalStateException if no bracket can be found.",
      "@param updateFormula formula to use for updating the &beta; parameter,\nmust be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link\nConjugateGradientFormula#POLAK_RIBIERE}.",
      "@param lineSearchSolver Solver to use during line search.",
      "@param preconditioner Preconditioner."
   ],
   [
      "@return array containing the optima",
      "@throws MathIllegalStateException if {@link\n#optimize(int,MultivariateVectorFunction,double[],double[],double[]) optimize} has not been\ncalled.",
      "@param weights Weights for the least-squares cost computation.",
      "@param optimizer Single-start optimizer to wrap.",
      "@param generator Random vector generator to use for restarts.",
      "@return {@code true} if the variables are restricted to non-negative values.",
      "@throws MaxCountExceededException if the maximal number of iterations is exceeded",
      "@return the point/value pair giving the optimal value for objective function",
      "@throws MathIllegalStateException if no solution fulfilling the constraints\ncan be found in the allowed number of iterations",
      "@return coefficients of the constraint (left hand side)",
      "@return relationship between left and right hand sides",
      "@return value of the constraint (right hand side)",
      "@param oos stream where object should be written",
      "@throws IOException if object cannot be written to stream",
      "@param ois stream from which the object should be read",
      "@throws ClassNotFoundException if a class in the stream cannot be found",
      "@throws IOException if object cannot be read from the stream",
      "@param coefficients The coefficients of the constraint (left hand side)",
      "@param relationship The type of (in)equality used in the constraint",
      "@param value The value of the constraint (right hand side)",
      "@param lhsCoefficients The coefficients of the linear expression on the left hand side of the constraint",
      "@param lhsConstant The constant term of the linear expression on the left hand side of the constraint",
      "@param rhsCoefficients The coefficients of the linear expression on the right hand side of the constraint",
      "@param rhsConstant The constant term of the linear expression on the right hand side of the constraint",
      "@param tableau simple tableau for the problem"
   ],
   [
      "@return column with the most negative coefficient",
      "@param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}",
      "@return row with the minimum ratio",
      "@throws MaxCountExceededException if the maximal iteration count has been exceeded",
      "@throws UnboundedSolutionException if the model is found not to have a bounded solution",
      "@throws NoFeasibleSolutionException if there is no feasible solution",
      "@param epsilon the amount of error to accept for algorithm convergence",
      "@param maxUlps amount of error to accept in floating point comparisons",
      "@param maxIterations maximal number of function calls",
      "@return maximal number of iterations",
      "@param f linear objective function",
      "@param constraints linear constraints",
      "@param goalType type of optimization goal: either {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}",
      "@param restrictToNonNegative whether to restrict the variables to non-negative values",
      "@return point/value pair giving the optimal value for objective function",
      "@throws MathIllegalStateException if no solution fulfilling the constraints\n  can be found in the allowed number of iterations",
      "@param maximize if true, goal is to maximize the objective function",
      "@return created tableau",
      "@param originalConstraints original (not normalized) constraints",
      "@return new versions of the constraints",
      "@param constraint reference constraint",
      "@return new equation",
      "@return 2 for Phase 1.  1 for Phase 2.",
      "@param relationship relationship to count",
      "@return number of constraint with the specified relationship"
   ],
   [
      "@param coefficients coefficients to sum",
      "@return the -1 times the sum of all coefficients in the given array.",
      "@param col index of the column to check",
      "@return the row that the variable is basic in.  null if the column is not basic",
      "@param src the source array",
      "@param dest the destination array",
      "@return whether the model has been solved",
      "@return current solution",
      "@param dividendRow index of the row",
      "@param divisor value of the divisor",
      "@param minuendRow row index",
      "@param subtrahendRow row index",
      "@param multiple multiplication factor",
      "@return width of the tableau",
      "@return height of the tableau",
      "@param row row index",
      "@param column column index",
      "@return entry at (row, column)",
      "@param value for the entry",
      "@return offset of the first slack variable",
      "@return offset of the first artificial variable",
      "@return offset of the right hand side",
      "@return number of decision variables",
      "@return original number of decision variables",
      "@return number of slack variables"
   ],
   [
      "@return number of artificial variables",
      "@return tableau data",
      "@param biasCorrected The isBiasCorrected to set.",
      "@throws NumberIsTooLargeException if maximal number of iterations\nis greater than {@link #MIDPOINT_MAX_ITERATIONS_COUNT}",
      "@param maximalIterationCount maximum number of iterations\n(must be less than or equal to {@link #MIDPOINT_MAX_ITERATIONS_COUNT}",
      "@throws NotStrictlyPositiveException if {@code p <= 0}.",
      "@param nans code of the value, must be one of {@link #INFINITE},\n{@link #SNAN},  {@link #QNAN}",
      "@throws NullArgumentException if the measurement vector is {@code null}",
      "@throws MathIllegalArgumentException if the array is null or the array index\nparameters are not valid",
      "@throws MathIllegalArgumentException if <code>values</code> is null\nor p is invalid",
      "@throws NumberIsTooSmallException if the arrays length is less than 2.",
      "@throws OutOfRangeException if {@code start < 0} or {@code start >= bytes.length}.",
      "@throws OutOfRangeException if {@code len < 0} or {@code len > bytes.length - start}.",
      "@return a new convex region, or null if the collection is empty",
      "@return the probability that a random variable with this\ndistribution takes a value less than or equal to {@code x}",
      "@throws NumberIsTooLargeException if {@code x0 > x1}",
      "@throws OutOfRangeException if {@code p < 0} or {@code p > 1}",
      "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if {@code sampleSize} is not positive",
      "@throws MathIllegalArgumentException if {@code r} is negative.",
      "@throws org.apache.commons.math3.exception.OutOfRangeException if {@code initValue <= 0} or {@code initValue > 1}.",
      "@throws NotPositiveException if {@code trials < 0}.",
      "@throws OutOfRangeException if {@code p < 0} or {@code p > 1}.",
      "@throws NullArgumentException if f is null.",
      "@throws NullArgumentException if {@code data} is null",
      "@param epsilon amount of error to accept when checking for optimality"
   ],
   [
      "@return coefficients of the linear equation being optimized",
      "@return constant of the linear equation being optimized",
      "@param point point at which linear equation must be evaluated",
      "@return value of the linear equation at the current point",
      "@param coefficients The coefficients for the linear equation being optimized",
      "@param constantTerm The constant term of the linear equation",
      "@return relationship obtained when multiplying all coefficients by -1",
      "@param stringValue display string for the relationship",
      "@param lB Lower bounds.",
      "@param uB Upper bounds.",
      "@return a copy of the stored value of the objective function.",
      "@return a reference to the internal array storing the value of\nthe objective function.",
      "@param copyArray if {@code true}, the input arrays will be copied,\notherwise they will be referenced.",
      "@param starts Number of starts to perform (including the\nfirst one), multi-start is disabled if value is less than or\nequal to 1.",
      "@return {@code true} if the arguments satify the convergence criterion.",
      "@param relativeThreshold Relative tolerance threshold.",
      "@param absoluteThreshold Absolute tolerance threshold.",
      "@return the object used to check for convergence.",
      "@param a Point and value.",
      "@param b Point and value.",
      "@param isMinim {@code true} if the selected point must be the one with\nthe lowest value.",
      "@return the best point, or {@code null} if {@code a} and {@code b} are\nboth {@code null}. When {@code a} and {@code b} have the same function\nvalue, {@code a} is returned.",
      "@param checker Additional, user-defined, convergence checking\nprocedure.",
      "@return an array containing the optima.",
      "@throws MathIllegalStateException if {@link\n#optimize(int,UnivariateFunction,GoalType,double,double) optimize}\nhas not been called."
   ],
   [
      "@param goal Goal type.",
      "@param starts Number of starts to perform. If {@code starts == 1},\nthe {@code optimize} methods will return the same solution as\n{@code optimizer} would.",
      "@param generator Random generator to use for restarts.",
      "@param f Function to optimize.",
      "@return a (point, value) pair where the function is optimum.",
      "@throws org.apache.commons.math3.exception.ConvergenceException if the optimizer detects a convergence problem.",
      "@throws org.apache.commons.math3.exception.ConvergenceException if the\noptimizer detects a convergence problem.",
      "@return the optimum and its corresponding function value.",
      "@param checker Convergence checking procedure.",
      "@return the point.",
      "@return the stored value of the objective function.",
      "@param point Point.",
      "@param value Value of an objective function at the point",
      "@param func Function whose optimum should be bracketed.",
      "@param goal {@link GoalType Goal type}.",
      "@param xA Initial point.",
      "@param xB Initial point.",
      "@return the number of evalutations.",
      "@return the lower bound of the bracket.",
      "@return function value at {@link #getLo()}",
      "@return the higher bound of the bracket.",
      "@return function value at {@link #getHi()}",
      "@return a point in the middle of the bracket.",
      "@return function value at {@link #getMid()}",
      "@return {@code f(x)}"
   ],
   [
      "@param growLimit Expanding factor.",
      "@param maxEvaluations Maximum number of evaluations allowed for finding\na bracketing interval.",
      "@param iteration Current iteration.",
      "@return {@code true} if the algorithm is considered to have converged.",
      "@throws MathIllegalStateException if {@link\n#optimize(int,MultivariateFunction,GoalType,double[]) optimize}\nhas not been called.",
      "@param observations Target values.",
      "@param weight List of the values of the diagonal.",
      "@param weight Weight matrix.",
      "@throws NonSquareMatrixException if the argument is not\na square matrix.",
      "@param weight Weights for the least squares cost computation.",
      "@return the row index of the entry.",
      "@return the column index of the entry.",
      "@return the relative symmetry threshold.",
      "@param column Column index.",
      "@param threshold Relative symmetry threshold.",
      "@param dimension the size of the vector",
      "@param start the index of the first entry to be visited",
      "@param end the index of the last entry to be visited (inclusive)",
      "@param index the index of the entry being visited",
      "@param value the value of the entry being visited",
      "@return the value returned after visiting all entries",
      "@return type of field elements of the vector",
      "@return vector copy",
      "@param v vector to be added",
      "@return {@code this + v}"
   ],
   [
      "@throws DimensionMismatchException if {@code v} is not the same size as {@code this}",
      "@param v vector to be subtracted",
      "@return {@code this - v}",
      "@param d value to be added to each entry",
      "@return {@code this + d}",
      "@param d value to be subtracted to each entry",
      "@return {@code this - d}",
      "@param d value to multiply all entries by",
      "@return {@code this * d}",
      "@param d value to divide all entries by",
      "@return {@code this / d}",
      "@throws MathArithmeticException if {@code d} is zero.",
      "@return a vector containing the result of applying the function to each entry.",
      "@throws MathArithmeticException if one of the entries is zero.",
      "@param v vector by which instance elements must be multiplied",
      "@return a vector containing {@code this[i] * v[i]} for all {@code i}",
      "@param v vector by which instance elements must be divided",
      "@return a vector containing {@code this[i] / v[i]} for all {@code i}",
      "@throws MathArithmeticException if one entry of {@code v} is zero.",
      "@return T array of entries",
      "@param v vector with which dot product should be computed",
      "@return the scalar dot product of {@code this} and {@code v}",
      "@param v vector onto which {@code this} must be projected",
      "@return projection of {@code this} onto {@code v}",
      "@throws MathArithmeticException if {@code v} is the null vector."
   ],
   [
      "@param v vector with which outer product should be computed",
      "@return the matrix outer product between instance and v",
      "@param index Index location of entry to be fetched.",
      "@return the vector entry at {@code index}.",
      "@throws OutOfRangeException if the index is not valid.",
      "@param index element index.",
      "@param value new value for the element.",
      "@return size",
      "@param v vector to append to this one.",
      "@param d T to append.",
      "@param index index of first element.",
      "@param n number of elements to be retrieved.",
      "@return a vector containing n elements.",
      "@throws NotPositiveException if the number of elements if not positive.",
      "@param index index of first element to be set.",
      "@param v vector containing the values to set.",
      "@param value single value to set for all elements",
      "@return array containing a copy of vector elements",
      "@return true if the matrix is square (rowDimension = columnDimension)",
      "@return rowDimension",
      "@return columnDimension",
      "@param wrong Row dimension.",
      "@param expected Column dimension.",
      "@return the U matrix",
      "@return the U matrix (or null if decomposed matrix is singular)"
   ],
   [
      "@return the &Sigma; matrix",
      "@return the diagonal elements of the &Sigma; matrix",
      "@return the V matrix (or null if decomposed matrix is singular)",
      "@param minSingularValue value below which singular values are ignored\n(a 0 or negative value implies all singular value will be used)",
      "@throws IllegalArgumentException if minSingularValue is larger than\nthe largest singular value, meaning all singular values are ignored",
      "@return norm",
      "@return condition number of the matrix",
      "@return the inverse of the condition number.",
      "@return effective numerical matrix rank",
      "@return a solver",
      "@param matrix Matrix to decompose.",
      "@return the V matrix.",
      "@return the D matrix.",
      "@return the transpose of the V matrix.",
      "@return {@code true} if the eigen values are complex, {@code false} otherwise",
      "@return a copy of the real parts of the eigenvalues of the original matrix.",
      "@param i index of the eigenvalue (counting from 0)",
      "@return real part of the i<sup>th</sup> eigenvalue of the original\nmatrix.",
      "@return a copy of the imaginary parts of the eigenvalues of the original\nmatrix.",
      "@param i Index of the eigenvalue (counting from 0).",
      "@return the imaginary part of the i<sup>th</sup> eigenvalue of the original\nmatrix.",
      "@param i Index of the eigenvector (counting from 0).",
      "@return a copy of the i<sup>th</sup> eigenvector of the original matrix.",
      "@return the determinant of the matrix.",
      "@return the square-root of the matrix."
   ],
   [
      "@throws MathUnsupportedOperationException if the matrix is not\nsymmetric or not positive definite.",
      "@throws MathUnsupportedOperationException if the decomposition resulted in\ncomplex eigenvalues",
      "@param matrix Matrix to transform.",
      "@param householderMatrix Householder matrix of the transformation\nto tridiagonal form.",
      "@return the {@link SchurTransformer Shur transform} for this matrix",
      "@param xr real part of the first number",
      "@param xi imaginary part of the first number",
      "@param yr real part of the second number",
      "@param yi imaginary part of the second number",
      "@return result of the complex division",
      "@param schur the schur transformation of the matrix",
      "@throws MathArithmeticException if the Schur form has a norm of zero",
      "@throws MaxCountExceededException if the algorithm fails to converge.",
      "@throws MathArithmeticException if the decomposition of a general matrix\nresults in a matrix with zero norm",
      "@param splitTolerance Dummy parameter (present for backward\ncompatibility only).",
      "@param main Main diagonal of the symmetric tridiagonal form.",
      "@param secondary Secondary of the tridiagonal form.",
      "@param rows number of rows of the matrix",
      "@param columns number of columns of the matrix",
      "@param startRow Initial row index",
      "@param endRow Final row index (inclusive)",
      "@param startColumn Initial column index",
      "@param endColumn Final column index (inclusive)",
      "@param row row index of the entry",
      "@param column column index of the entry"
   ],
   [
      "@param value current value of the entry",
      "@return the new value to be set for the entry",
      "@return the value that the <code>walkInXxxOrder</code> must return",
      "@return the L matrix (or null if decomposed matrix is singular)",
      "@return the P rows permutation matrix (or null if decomposed matrix is singular)",
      "@return the pivot permutation vector",
      "@return determinant of the matrix",
      "@param matrix The matrix to decompose.",
      "@return the row index.",
      "@return the column index.",
      "@return the absolute positivity threshold.",
      "@param wrong Value that fails the positivity check.",
      "@param index Row (and column) index.",
      "@param threshold Absolute positivity threshold.",
      "@return available real vector format locales.",
      "@return format separator for rows.",
      "@return format separator between components.",
      "@return the default real vector format.",
      "@return the real vector format specific to the given locale.",
      "@param m RealMatrix object to format.",
      "@return a formatted matrix.",
      "@param matrix the object to format.",
      "@param source String to parse.",
      "@return the parsed {@link RealMatrix} object.",
      "@param rowPrefix row prefix to use instead of the default \"{\""
   ],
   [
      "@param rowSuffix row suffix to use instead of the default \"}\"",
      "@param rowSeparator tow separator to use instead of the default \";\"",
      "@param columnSeparator column separator to use instead of the default \", \"",
      "@return RealMatrix with specified dimensions",
      "@param field field to which the matrix elements belong",
      "@return FieldMatrix with specified dimensions",
      "@param data input array",
      "@return RealMatrix containing the values of the array",
      "@throws org.apache.commons.math3.exception.DimensionMismatchException if {@code data} is not rectangular (not all rows have the same length).",
      "@throws NoDataException if a row or column is empty.",
      "@throws DimensionMismatchException if {@code data} is not rectangular.",
      "@return a matrix containing the values of the array.",
      "@param dimension dimension of identity matrix to generate",
      "@return identity matrix",
      "@param diagonal diagonal elements of the matrix (the array elements\nwill be copied)",
      "@return diagonal matrix",
      "@param data the input data",
      "@return a data.length RealVector",
      "@return a data.length FieldVector",
      "@throws ZeroException if {@code data} has 0 elements",
      "@param rowData the input row data",
      "@return a 1 x rowData.length RealMatrix",
      "@return a 1 x rowData.length FieldMatrix",
      "@param columnData the input column data",
      "@return a columnData x 1 RealMatrix"
   ],
   [
      "@return a columnData x 1 FieldMatrix",
      "@param matrix Matrix to check.",
      "@param relativeTolerance Tolerance of the symmetry check.",
      "@param raiseException If {@code true}, an exception will be raised if\nthe matrix is not symmetric.",
      "@return {@code true} if {@code matrix} is symmetric.",
      "@throws NonSymmetricMatrixException if the matrix is not symmetric.",
      "@param eps Relative tolerance.",
      "@param m Matrix.",
      "@param row Row index to check.",
      "@param column Column index to check.",
      "@throws OutOfRangeException if {@code row} or {@code column} is not\na valid index.",
      "@throws OutOfRangeException if {@code row} is not a valid index.",
      "@throws OutOfRangeException if {@code column} is not a valid index.",
      "@param startRow Initial row index.",
      "@param endRow Final row index.",
      "@param startColumn Initial column index.",
      "@param endColumn Final column index.",
      "@throws OutOfRangeException if the indices are invalid.",
      "@param selectedRows Array of row indices.",
      "@param selectedColumns Array of column indices.",
      "@throws NoDataException if the row or column selections are empty (zero\nlength).",
      "@throws OutOfRangeException if row or column selections are not valid.",
      "@param left Left hand side matrix.",
      "@param right Right hand side matrix.",
      "@throws MatrixDimensionMismatchException if the matrices are not addition\ncompatible."
   ],
   [
      "@throws DimensionMismatchException if matrices are not multiplication\ncompatible.",
      "@param m Matrix to convert.",
      "@return the converted matrix.",
      "@param vector real vector to serialize",
      "@param oos stream where the real vector should be written",
      "@param instance instance in which the field must be set up",
      "@param fieldName name of the field within the class (may be private and final)",
      "@param ois stream from which the real vector should be read",
      "@param matrix real matrix to serialize",
      "@param oos stream where the real matrix should be written",
      "@param ois stream from which the real matrix should be read",
      "@param rm RealMatrix which is lower triangular",
      "@param b RealVector this is overwritten",
      "@throws DimensionMismatchException if the matrix and vector are not\nconformable",
      "@throws MathArithmeticException if the absolute value of one of the diagonal\ncoefficient of {@code rm} is lower than {@link Precision#SAFE_MIN}",
      "@param rm RealMatrix which is upper triangular",
      "@param m Matrix whose inverse must be computed.",
      "@param splitIndex Index that determines the \"split\" line and\ncolumn.\nThe element corresponding to this index will part of the\nupper-left sub-matrix.",
      "@return the inverse of {@code m}.",
      "@param matrix Matrix whose inverse shall be computed",
      "@return the inverse of {@code matrix}",
      "@throws SingularMatrixException if m is singular",
      "@param threshold Singularity threshold",
      "@return the inverse of {@code m}",
      "@throws SingularMatrixException if matrix is singular"
   ],
   [
      "@return the entries of this instance.",
      "@param value Value to test",
      "@return {@code true} if this value is within epsilon to zero,\n{@code false} otherwise.",
      "@param v Vector to add.",
      "@return the sum of {@code this} and {@code v}.",
      "@throws DimensionMismatchException if the dimensions do not match.",
      "@param v vector to append",
      "@return The result of appending {@code v} to self",
      "@return the dot product of this vector with {@code v}.",
      "@param v Vector to compute distance to.",
      "@return the distance from {@code this} and {@code v}.",
      "@param v Vector to which distance is requested.",
      "@return distance between this vector and {@code v}.",
      "@param v Vector to compute distance from.",
      "@return the LInfDistance.",
      "@return the difference of {@code this} and {@code v}.",
      "@return the percentage of none zero elements as a decimal percent.",
      "@param dimension Size of the vector.",
      "@param epsilon Tolerance below which a value considered zero.",
      "@param v Original vector.",
      "@param resize Amount to add.",
      "@param expectedSize The expected number of non-zero entries.",
      "@param expectedSize Expected number of non-zero entries.",
      "@param epsilon Tolerance below which a value is considered zero.",
      "@param values Set of values to create from."
   ],
   [
      "@param values The set of values to create from",
      "@param v Instance to copy from.",
      "@param zero additive identity of the field",
      "@return the new value of the entry being visited",
      "@return the Q matrix",
      "@return the T matrix",
      "@return the main diagonal elements of the B matrix",
      "@return the main diagonal elements of the T matrix",
      "@return the secondary diagonal elements of the T matrix",
      "@param matrix Symmetrical matrix to transform.",
      "@return the number of columns.",
      "@return a string representation for this matrix",
      "@return hashcode for matrix",
      "@param rowDimension the number of rows in the new matrix",
      "@param columnDimension the number of columns in the new matrix",
      "@param m Matrix to be added.",
      "@return {@code this + m}.",
      "@throws MatrixDimensionMismatchException if {@code m} is not the same\nsize as {@code this}.",
      "@param m Matrix to be subtracted.",
      "@return {@code this - m}",
      "@param m matrix to postmultiply by",
      "@return {@code this * m}",
      "@throws DimensionMismatchException if\n{@code columnDimension(this) != rowDimension(m)}",
      "@return 2-dimensional array of entries.",
      "@return a copy of the underlying data array."
   ],
   [
      "@param in Data to copy.",
      "@throws NoDataException if the input array is empty.",
      "@throws DimensionMismatchException if the input array is not rectangular.",
      "@throws NullArgumentException if the input array is {@code null}.",
      "@param rowDimension Number of rows in the new matrix.",
      "@param columnDimension Number of columns in the new matrix.",
      "@param d Data for the new matrix.",
      "@throws DimensionMismatchException if {@code d} is not rectangular.",
      "@param d Data for new matrix.",
      "@param v Column vector holding data for new matrix.",
      "@param <T> Type of the field elements.",
      "@param rawData Data array in raw layout.",
      "@return a new data array containing the same entries but in blocks layout",
      "@throws DimensionMismatchException if {@code rawData} is not rectangular\n (not all rows have the same length).",
      "@param field Field to which the elements belong.",
      "@param rows Number of rows in the new matrix.",
      "@param columns Number of columns in the new matrix.",
      "@return a new data array in blocks layout.",
      "@param m matrix to be added",
      "@return {@code this + m}",
      "@throws MatrixDimensionMismatchException if {@code m} is not the same\nsize as {@code this}",
      "@param m matrix to be subtracted",
      "@throws DimensionMismatchException if the matrices are not compatible.",
      "@param srcBlock source block",
      "@param srcWidth source block width ({@link #BLOCK_SIZE} or smaller)"
   ],
   [
      "@param srcStartRow start row in the source block",
      "@param srcEndRow end row (exclusive) in the source block",
      "@param srcStartColumn start column in the source block",
      "@param srcEndColumn end column (exclusive) in the source block",
      "@param dstBlock destination block",
      "@param dstWidth destination block width ({@link #BLOCK_SIZE} or smaller)",
      "@param dstStartRow start row in the destination block",
      "@param dstStartColumn start column in the destination block",
      "@param row the row to be set",
      "@param matrix row matrix (must have one row and the same number of columns\nas the instance)",
      "@throws MatrixDimensionMismatchException if the matrix dimensions do\nnot match one instance row.",
      "@throws OutOfRangeException if the specified row index is invalid.",
      "@param column Column to be set.",
      "@param matrix Column matrix (must have one column and the same number of rows\nas the instance).",
      "@throws MatrixDimensionMismatchException if the matrix dimensions do\nnot match one instance column.",
      "@throws OutOfRangeException if the specified column index is invalid.",
      "@param blockRow row index (in block sense) of the block",
      "@return height (number of rows) of the block",
      "@param blockColumn column index (in block sense) of the block",
      "@return width (number of columns) of the block",
      "@param rawData Data for the new matrix, in raw layout.",
      "@throws DimensionMismatchException if the {@code blockData} shape is\ninconsistent with block layout.",
      "@param rows the number of rows in the new matrix",
      "@param columns the number of columns in the new matrix",
      "@param blockData data for new matrix"
   ],
   [
      "@param copyArray if true, the input array will be copied, otherwise\nit will be referenced",
      "@return {@code this} + m.",
      "@throws MatrixDimensionMismatchException if {@code m} is not the same\nsize as this matrix.",
      "@param m Matrix to postmultiply by.",
      "@return {@code this} * m.",
      "@throws DimensionMismatchException if the number of columns of this\nmatrix is not equal to the number of rows of {@code m}.",
      "@return the 2-dimensional array of entries.",
      "@throws NoDataException if there are not at least one row and one column.",
      "@param copyArray Whether to copy or reference the input array.",
      "@return the type of field elements of the matrix.",
      "@return a new matrix of the same type as the instance",
      "@return a copy of this matrix.",
      "@return {@code this} + {@code m}.",
      "@throws MatrixDimensionMismatchException if {@code m} is not the same\nsize as {@code this} matrix.",
      "@return {@code this} - {@code m}.",
      "@param d Value to be added to each entry.",
      "@return {@code d} + {@code this}.",
      "@param d Value to multiply all entries by.",
      "@return {@code d} * {@code this}.",
      "@return {@code this} * {@code m}.",
      "@throws DimensionMismatchException if the number of columns of\n{@code this} matrix is not equal to the number of rows of matrix\n{@code m}.",
      "@param m Matrix to premultiply by.",
      "@return {@code m} * {@code this}.",
      "@throws DimensionMismatchException if the number of columns of {@code m}\ndiffers from the number of rows of {@code this} matrix.",
      "@param p raise this to power p"
   ],
   [
      "@return this^p",
      "@return a 2-dimensional array of entries.",
      "@return the matrix containing the data of the specified rows and columns.",
      "@throws NumberIsTooSmallException is {@code endRow < startRow} of\n{@code endColumn < startColumn}.",
      "@throws OutOfRangeException if the indices are not valid.",
      "@return the matrix containing the data in the\nspecified rows and columns.",
      "@param endRow Final row index (inclusive).",
      "@param endColumn Final column index (inclusive).",
      "@param destination The array where the submatrix data should be copied\n(if larger than rows/columns counts, only the upper-left part will be modified).",
      "@throws MatrixDimensionMismatchException if the dimensions of\n{@code destination} are not large enough to hold the submatrix.",
      "@param destination Arrays where the submatrix data should be copied\n(if larger than rows/columns counts, only the upper-left part will be used)",
      "@throws MatrixDimensionMismatchException if the dimensions of\n{@code destination} do not match those of {@code this}.",
      "@param subMatrix Array containing the submatrix replacement data.",
      "@param row Row coordinate of the top-left element to be replaced.",
      "@param column Column coordinate of the top-left element to be replaced.",
      "@throws OutOfRangeException if {@code subMatrix} does not fit into this\nmatrix from element in {@code (row, column)}.",
      "@throws NoDataException if a row or column of {@code subMatrix} is empty.",
      "@throws DimensionMismatchException if {@code subMatrix} is not\nrectangular (not all rows have the same length).",
      "@param row Row to be fetched.",
      "@return a row matrix.",
      "@param row Row to be set.",
      "@param matrix Row matrix (must have one row and the same number\nof columns as the instance).",
      "@throws MatrixDimensionMismatchException if the matrix dimensions do not match one instance row.",
      "@param column Column to be fetched.",
      "@return a column matrix."
   ],
   [
      "@param matrix column matrix (must have one column and the same\nnumber of rows as the instance).",
      "@param row Row to be fetched",
      "@return a row vector.",
      "@param vector row vector (must have the same number of columns\nas the instance).",
      "@throws MatrixDimensionMismatchException if the vector dimension does not\nmatch one instance row.",
      "@return a column vector.",
      "@param vector Column vector (must have the same number of rows\nas the instance).",
      "@throws MatrixDimensionMismatchException if the vector dimension does not\nmatch one instance column.",
      "@return array of entries in the row.",
      "@throws OutOfRangeException if the specified row index is not valid.",
      "@param array Row matrix (must have the same number of columns as\nthe instance).",
      "@throws MatrixDimensionMismatchException if the array size does not match\none instance row.",
      "@param column the column to be fetched",
      "@return array of entries in the column",
      "@throws OutOfRangeException if the specified column index is not valid.",
      "@param column the column to be set",
      "@param array column array (must have the same number of rows as the instance)",
      "@throws MatrixDimensionMismatchException if the array size does not match\none instance column.",
      "@param row row location of entry to be fetched",
      "@param column column location of entry to be fetched",
      "@return matrix entry in row,column",
      "@throws OutOfRangeException if the row or column index is not valid.",
      "@param row row location of entry to be set",
      "@param column column location of entry to be set",
      "@param value matrix entry to be set in row,column"
   ],
   [
      "@param row Row location of entry to be set.",
      "@param column Column location of entry to be set.",
      "@param increment Value to add to the current matrix entry in\n{@code (row, column)}.",
      "@param factor Multiplication factor for the current matrix entry\nin {@code (row,column)}",
      "@return transpose matrix",
      "@return trace",
      "@param v the vector to operate on",
      "@return {@code this * v}",
      "@throws DimensionMismatchException if the number of columns of\n{@code this} matrix is not equal to the size of the vector {@code v}.",
      "@param v the row vector to premultiply by",
      "@return {@code v * this}",
      "@throws DimensionMismatchException if the number of rows of {@code this}\nmatrix is not equal to the size of the vector {@code v}",
      "@param visitor visitor used to process all matrix entries",
      "@return the value returned by {@link FieldMatrixChangingVisitor#end()} at the end\nof the walk",
      "@return the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end\nof the walk",
      "@param endColumn Final column index",
      "@param a the linear operator A of the system",
      "@param b the right-hand side vector",
      "@param x0 the initial guess of the solution",
      "@throws NonSquareOperatorException if {@code a} is not square",
      "@throws DimensionMismatchException if {@code b} or {@code x0} have\ndimensions inconsistent with {@code a}",
      "@return the manager",
      "@return a new vector containing the solution",
      "@throws DimensionMismatchException if {@code b} has dimensions\ninconsistent with {@code a}",
      "@throws MaxCountExceededException at exhaustion of the iteration count,\nunless a custom\n{@link org.apache.commons.math3.util.Incrementor.MaxCountExceededCallback callback}\nhas been set at construction of the {@link IterationManager}"
   ],
   [
      "@param x0 initial guess of the solution",
      "@return a reference to {@code x0} (shallow copy) updated with the\nsolution",
      "@param manager the custom iteration manager",
      "@return the array of entries.",
      "@param v Vector to append to this one.",
      "@return a new vector.",
      "@param index Index of first element to be set.",
      "@param v Vector containing the values to set.",
      "@throws OutOfRangeException if the index is inconsistent with the vector\nsize.",
      "@param v Vector to compare instance with.",
      "@throws DimensionMismatchException if the vectors do not\nhave the same dimension.",
      "@param n Expected dimension.",
      "@throws DimensionMismatchException if the dimension is\ninconsistent with vector size.",
      "@return {@code true} if any coordinate of this vector is {@code NaN},\n{@code false} otherwise.",
      "@return {@code true} if any coordinate of this vector is infinite and\nnone are {@code NaN}, {@code false} otherwise.",
      "@param size Size of the vector.",
      "@param size Size of the vector",
      "@param preset All entries will be set with this value.",
      "@param d Array.",
      "@param d Data for the new vector.",
      "@param pos Position of first entry.",
      "@param size Number of entries to copy.",
      "@throws NumberIsTooLargeException if the size of {@code d} is less\nthan {@code pos + size}.",
      "@param d Array of {@code Double}s.",
      "@param v vector to copy."
   ],
   [
      "@param v Vector to copy.",
      "@param deep If {@code true} perform a deep copy, otherwise perform a\nshallow copy.",
      "@param v1 First vector (will be put in front of the new vector).",
      "@param v2 Second vector (will be put at back of the new vector).",
      "@param v1 first vector (will be put in front of the new vector)",
      "@param v2 second vector (will be put at back of the new vector)",
      "@return the expected row dimension.",
      "@return the wrong column dimension.",
      "@return the expected column dimension.",
      "@param wrongRowDim Wrong row dimension.",
      "@param wrongColDim Wrong column dimension.",
      "@param expectedRowDim Expected row dimension.",
      "@param expectedColDim Expected column dimension.",
      "@throws DimensionMismatchException if {@code v} is not the same size as\n{@code this}",
      "@return array of entries",
      "@throws OutOfRangeException if the index is invalid.",
      "@param v vector to compare instance with",
      "@throws DimensionMismatchException if the vectors do not\nhave the same dimensions",
      "@throws DimensionMismatchException if the dimension is not equal to the\nsize of {@code this} vector.",
      "@param visitor the visitor to be used to process the entries of this\nvector",
      "@return the value returned by {@link FieldVectorPreservingVisitor#end()}\nat the end of the walk",
      "@param visitor visitor to be used to process the entries of this vector",
      "@param visitor the visitor to be used to process and modify the entries\nof this vector",
      "@return the value returned by {@link FieldVectorChangingVisitor#end()}\nat the end of the walk",
      "@throws NumberIsTooLargeException if {@code a >= b} or if {@code c > b}."
   ],
   [
      "@throws NumberIsTooSmallException if {@code c < a}.",
      "@throws NullArgumentException if {@code addend} is {@code null}.",
      "@throws NullArgumentException if {@code divisor} is {@code null}.",
      "@param x First value (cannot be {@code null}).",
      "@param y Second value (cannot be {@code null}).",
      "@throws NullArgumentException if {@code factor} is {@code null}.",
      "@throws NullArgumentException if {@code subtrahend} is {@code null}.",
      "@throws NullArgumentException if x is {@code null}.",
      "@throws NotPositiveException if {@code n <= 0}.",
      "@throws NullArgumentException if values is null",
      "@throws NullArgumentException if d is null",
      "@throws NullArgumentException if value is null",
      "@throws MathArithmeticException if the norm of the instance is null",
      "@throws NotStrictlyPositiveException if row or column dimension is not positive.",
      "@throws NoDataException if v is empty",
      "@throws NotPositiveException if degree is not positive",
      "@throws NotPositiveException if degrees are not positive",
      "@throws MathIllegalArgumentException if the array length is less than 2",
      "@throws NullArgumentException if generator is null",
      "@throws OutOfRangeException if {@code alpha <= 0} or {@code alpha > 2}\nor {@code beta < -1} or {@code beta > 1}",
      "@return for convenience, return {@code this}",
      "@throws NullArgumentException if {@code d} is {@code null}",
      "@throws MathIllegalArgumentException if {@code min >= max}.",
      "@param code code of the value, must be one of {@link #INFINITE},\n{@link #SNAN},  {@link #QNAN}",
      "@throws MathIllegalArgumentException if the array is null or the indices are not valid"
   ],
   [
      "@throws MathIllegalArgumentException if <code>original</code> is not an instance of {@link BinaryChromosome}.",
      "@throws MathIllegalArgumentException if the chromosomes are not an instance of {@link AbstractListChromosome}",
      "@param other Object to test for equality.",
      "@return {@code true} if two vector objects are equal, {@code false}\notherwise.",
      "@param index Index to check.",
      "@param start the index of the first entry of the subvector",
      "@param end the index of the last entry of the subvector (inclusive)",
      "@throws OutOfRangeException if {@code start} of {@code end} are not valid",
      "@param copyArray If {@code true}, the input array will be copied,\notherwise it will be referenced.",
      "@param pos Position of the first entry.",
      "@param deep If {@code true} perform a deep copy, otherwise perform\na shallow copy",
      "@throws ZeroException if both arrays are empty.",
      "@param b right-hand side of the equation A &times; X = B",
      "@return a vector X that minimizes the two norm of A &times; X - B",
      "@throws org.apache.commons.math3.exception.DimensionMismatchException if the matrices dimensions do not match.",
      "@throws SingularMatrixException if the decomposed matrix is singular.",
      "@return a matrix X that minimizes the two norm of A &times; X - B",
      "@return true if the decomposed matrix is non-singular.",
      "@return pseudo-inverse matrix (which is the inverse, if it exists),\nif the decomposition can pseudo-invert the decomposed matrix",
      "@throws SingularMatrixException if the decomposed matrix is singular and the decomposition\ncan not compute a pseudo-inverse",
      "@param singularityThreshold threshold (based on partial row norm)\nunder which a matrix is considered singular",
      "@return {@code true} if the tests are to be performed",
      "@throws NonPositiveDefiniteOperatorException if {@code a} or {@code m} is\nnot positive definite",
      "@param delta the &delta; parameter for the default stopping criterion",
      "@param check {@code true} if positive definiteness of both matrix and\npreconditioner should be checked"
   ],
   [
      "@throws NumberIsTooLargeException if the total number of entries of the\nmatrix is larger than {@code Integer.MAX_VALUE}.",
      "@throws NumberIsTooLargeException if {@code m} is an\n{@code OpenMapRealMatrix}, and the total number of entries of the product\nis larger than {@code Integer.MAX_VALUE}.",
      "@throws DimensionMismatchException if the number of rows of {@code m}\ndiffer from the number of columns of {@code this} matrix.",
      "@throws NumberIsTooLargeException if the total number of entries of the\nproduct is larger than {@code Integer.MAX_VALUE}.",
      "@param row row index of the matrix element",
      "@param column column index of the matrix element",
      "@return key within the map to access the matrix element",
      "@param rowDimension Number of rows of the matrix.",
      "@param columnDimension Number of columns of the matrix.",
      "@param matrix matrix to copy.",
      "@return the B matrix",
      "@return the V matrix",
      "@return the secondary diagonal elements of the B matrix",
      "@return true if the matrix is transformed to upper bi-diagonal",
      "@param matrix the matrix to transform.",
      "@return the L matrix",
      "@return the transpose of the matrix L of the decomposition",
      "@param matrix the matrix to decompose",
      "@throws NonPositiveDefiniteMatrixException if the matrix is not\nstrictly positive definite.",
      "@param relativeSymmetryThreshold threshold above which off-diagonal\nelements are considered too different and matrix not symmetric",
      "@param absolutePositivityThreshold threshold below which diagonal\nelements are considered null and matrix not positive definite",
      "@return true if the decomposed matrix is non-singular",
      "@return inverse matrix",
      "@return the value returned by\n{@link RealVector#walkInDefaultOrder(RealVectorPreservingVisitor)},\n{@link RealVector#walkInDefaultOrder(RealVectorPreservingVisitor, int, int)},\n{@link RealVector#walkInOptimizedOrder(RealVectorPreservingVisitor)}\nor\n{@link RealVector#walkInOptimizedOrder(RealVectorPreservingVisitor, int, int)}",
      "@return a new data array containing the same entries but in blocks layout."
   ],
   [
      "@throws DimensionMismatchException if {@code rawData} is not rectangular.",
      "@return {@code this} - m.",
      "@throws MatrixDimensionMismatchException if {@code m} is not the\nsame size as this matrix.",
      "@param matrix column matrix (must have one column and the same number of rows\nas the instance)",
      "@param rawData data for new matrix, in raw layout",
      "@throws DimensionMismatchException if the shape of {@code blockData} is\ninconsistent with block layout.",
      "@param copyArray Whether the input array will be copied or referenced.",
      "@param row Row index of the matrix element.",
      "@param column Column index of the matrix element.",
      "@return the key within the map to access the matrix element.",
      "@return the size of this vector.",
      "@param index Index location of entry to be set.",
      "@param increment Value to add to the vector entry.",
      "@param d double to append.",
      "@throws DimensionMismatchException if the dimension is\ninconsistent with the vector size.",
      "@throws OutOfRangeException if {@code index} is not valid.",
      "@param v Vector to be added.",
      "@return {@code this} + {@code v}.",
      "@param v Vector to be subtracted.",
      "@return {@code this} - {@code v}.",
      "@return {@code this} + {@code d}.",
      "@return {@code this}.",
      "@return a vector copy.",
      "@param v Vector with which dot product should be computed",
      "@return the scalar dot product between this instance and {@code v}."
   ],
   [
      "@return the cosine of the angle between this vector and {@code v}.",
      "@param v Vector by which instance elements must be divided.",
      "@return a vector containing this[i] / v[i] for all i.",
      "@param v Vector by which instance elements must be multiplied",
      "@return a vector containing this[i] * v[i] for all i.",
      "@return the distance between two vectors.",
      "@return the index of the minimum entry or -1 if vector length is 0\nor all entries are {@code NaN}.",
      "@return the value of the minimum entry or {@code NaN} if all\nentries are {@code NaN}.",
      "@return the index of the maximum entry or -1 if vector length is 0\nor all entries are {@code NaN}",
      "@return the value of the maximum entry or {@code NaN} if all\nentries are {@code NaN}.",
      "@param d Multiplication factor.",
      "@return {@code this} * {@code d}.",
      "@param d Value to be subtracted.",
      "@return {@code this} - {@code d}.",
      "@param d Value to divide by.",
      "@return {@code this} / {@code d}.",
      "@param v Vector with which outer product should be computed.",
      "@return the matrix outer product between this instance and {@code v}.",
      "@param v vector onto which instance must be projected.",
      "@return projection of the instance onto {@code v}.",
      "@param value Single value to set for all elements.",
      "@return an array containing a copy of the vector elements.",
      "@return a unit vector pointing in direction of this vector.",
      "@return a sparse iterator.",
      "@return a dense iterator."
   ],
   [
      "@param function Function to apply to each entry.",
      "@return a reference to this vector.",
      "@param a Coefficient of {@code this}.",
      "@param b Coefficient of {@code y}.",
      "@param y Vector with which {@code this} is linearly combined.",
      "@return a vector containing {@code a * this[i] + b * y[i]} for all\n{@code i}.",
      "@param a Weight of {@code this}.",
      "@param b Weight of {@code y}.",
      "@return {@code this}, with components equal to\n{@code a * this[i] + b * y[i]} for all {@code i}.",
      "@return the value returned by {@link RealVectorPreservingVisitor#end()}\nat the end of the walk",
      "@return the value returned by {@link RealVectorChangingVisitor#end()}\nat the end of the walk",
      "@return {@code true} if two vector objects are equal, {@code false} if\n{@code other} is null, not an instance of {@code RealVector}, or\nnot equal to this {@code RealVector} instance.",
      "@throws MathUnsupportedOperationException if this method is not\noverridden.",
      "@param v Vector for which an unmodifiable view is to be returned.",
      "@return an unmodifiable view of {@code v}.",
      "@param m the preconditioner, M (can be {@code null})",
      "@throws NonSquareOperatorException if {@code a} or {@code m} is not\nsquare",
      "@throws DimensionMismatchException if {@code m}, {@code b} or\n{@code x0} have dimensions inconsistent with {@code a}",
      "@throws DimensionMismatchException if {@code m} or {@code b} have\ndimensions inconsistent with {@code a}",
      "@param matrix transposed matrix",
      "@param minor minor index",
      "@return the R matrix",
      "@return the transpose of the Q matrix, Q<sup>T</sup>",
      "@return a matrix containing the Householder reflector vectors",
      "@throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n{@code true}, and {@code a} or {@code m} is not self-adjoint"
   ],
   [
      "@throws NonPositiveDefiniteOperatorException if {@code m} is not\npositive definite",
      "@throws IllConditionedOperatorException if {@code a} is ill-conditioned",
      "@param goodb usually {@code false}, except if {@code x} is expected to\ncontain a large multiple of {@code b}",
      "@param shift the amount to be subtracted to all diagonal elements of A",
      "@return a reference to {@code x} (shallow copy)",
      "@throws NonSquareOperatorException if {@code a} or {@code m} is not square",
      "@throws DimensionMismatchException if {@code m} or {@code b} have dimensions\ninconsistent with {@code a}",
      "@param x not meaningful in this implementation; should not be considered\nas an initial guess (<a href=\"#initguess\">more</a>)",
      "@throws NonPositiveDefiniteOperatorException if {@code m} is not positive\ndefinite",
      "@throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n{@code true}, and {@code a} is not self-adjoint",
      "@return a reference to {@code x}",
      "@param x the vector to be updated with the solution; {@code x} should\nnot be considered as an initial guess (<a href=\"#initguess\">more</a>)",
      "@return a reference to {@code x} (shallow copy).",
      "@throws DimensionMismatchException if {@code m}, {@code b} or {@code x}\nhave dimensions inconsistent with {@code a}.",
      "@param check {@code true} if self-adjointedness of both matrix and\npreconditioner should be checked",
      "@return the entries of this instance",
      "@return {@code this + v}.",
      "@throws DimensionMismatchException if {@code v} is not the same size as\n{@code this}.",
      "@param v Original vector",
      "@param v Instance to copy.",
      "@param v RealVector object to format.",
      "@return a formatted vector.",
      "@return the parsed {@link RealVector} object.",
      "@param cond An estimate of the condition number of the offending linear\noperator.",
      "@return {@code true} if {@code r != null}"
   ],
   [
      "@param source the iterative solver which fired this event",
      "@param x the current estimate of the solution",
      "@param r the current estimate of the residual (can be {@code null})",
      "@param rnorm the norm of the current estimate of the residual",
      "@return the right-hand side vector, b",
      "@return the norm of the residual, ||r||",
      "@return the updated residual, r",
      "@return the solution, x",
      "@return {@code false} if {@link #getResidual()} throws a\n{@link MathUnsupportedOperationException}",
      "@throws DimensionMismatchException if the requested dimensions are not equal.",
      "@return 1-dimensional array of entries.",
      "@throws NumberIsTooLargeException if {@code row != column} and value is non-zero.",
      "@throws NumberIsTooLargeException if {@code row != column} and increment is non-zero.",
      "@param value value to check",
      "@throws NumberIsTooLargeException if value is not zero",
      "@throws SingularMatrixException if the matrix is singular",
      "@return {@code true} if the matrix is singular, {@code false} otherwise",
      "@param dimension Number of rows and columns in the new matrix.",
      "@return the P matrix",
      "@return the transpose of the P matrix",
      "@return the H matrix",
      "@param matrix matrix to transform",
      "@return r of the square matrix.",
      "@param matrix Symmetric positive semidefinite matrix.",
      "@throws NonPositiveDefiniteMatrixException if the matrix is not\npositive semidefinite."
   ],
   [
      "@param small Diagonal elements threshold under which columns are\nconsidered to be dependent on previous ones and are discarded.",
      "@param a the linear operator for which the preconditioner should be built",
      "@return the diagonal preconditioner made of the inverse of the diagonal\ncoefficients of the specified linear operator",
      "@return the square root of {@code this} preconditioner",
      "@param diag the diagonal coefficients of the linear operator to be\npreconditioned",
      "@param deep {@code true} if a deep copy of the above array should be\nperformed",
      "@return the number of rows of the underlying matrix",
      "@return the number of columns of the underlying matrix",
      "@param x the vector to operate on",
      "@return the product of {@code this} instance with {@code x}",
      "@throws DimensionMismatchException if the column dimension does not match\nthe size of {@code x}",
      "@return the product of the transpose of {@code this} instance with\n{@code x}",
      "@throws org.apache.commons.math3.exception.DimensionMismatchException if the row dimension does not match the size of {@code x}",
      "@throws UnsupportedOperationException if this operation is not supported\nby {@code this} operator",
      "@param qrt transposed matrix",
      "@return a permutation matrix.",
      "@param dropThreshold threshold triggering rank computation",
      "@param d Data array.",
      "@return the field to which the array elements belong.",
      "@param <T> Type of the field elements",
      "@param rows number of rows",
      "@throws NoDataException if the arrays have zero length.",
      "@param m Matrix to check.",
      "@throws MatrixDimensionMismatchException if the matrix is not\naddition-compatible with instance.",
      "@throws MatrixDimensionMismatchException if the matrix is not\nsubtraction-compatible with instance."
   ],
   [
      "@throws DimensionMismatchException if the matrix is not\nmultiplication-compatible with instance.",
      "@return matrix copy",
      "@return {@code d + this}",
      "@return {@code d * this}",
      "@param m matrix to premultiply by",
      "@return {@code m * this}",
      "@throws DimensionMismatchException if\n{@code rowDimension(this) != columnDimension(m)}",
      "@param p raise {@code this} to power {@code p}",
      "@return {@code this^p}",
      "@return 2-dimensional array of entries",
      "@return The subMatrix containing the data of the\nspecified rows and columns.",
      "@return The subMatrix containing the data in the specified rows and\ncolumns",
      "@throws NullArgumentException if the row or column selections are\n{@code null}",
      "@param destination The arrays where the submatrix data should be copied\n(if larger than rows/columns counts, only the upper-left part will be\nused)",
      "@throws MatrixDimensionMismatchException if the destination array is too\nsmall.",
      "@param subMatrix array containing the submatrix replacement data",
      "@param row row coordinate of the top, left element to be replaced",
      "@param column column coordinate of the top, left element to be replaced",
      "@throws OutOfRangeException if {@code subMatrix} does not fit into\nthis matrix from element in {@code (row, column)}.",
      "@throws DimensionMismatchException if {@code subMatrix} is not rectangular\n(not all rows have the same length) or empty.",
      "@return row Matrix.",
      "@param matrix Row matrix to be copied (must have one row and the same\nnumber of columns as the instance).",
      "@throws MatrixDimensionMismatchException if the row dimension of the\n{@code matrix} is not {@code 1}, or the column dimensions of {@code this}\nand {@code matrix} do not match.",
      "@return column Matrix.",
      "@param matrix Column matrix to be copied (must have one column and the\nsame number of rows as the instance)."
   ],
   [
      "@throws MatrixDimensionMismatchException if the column dimension of the\n{@code matrix} is not {@code 1}, or the row dimensions of {@code this}\nand {@code matrix} do not match.",
      "@param vector row vector to be copied (must have the same number of\ncolumn as the instance).",
      "@throws MatrixDimensionMismatchException if the {@code vector} dimension\ndoes not match the column dimension of {@code this} matrix.",
      "@throws OutOfRangeException if the specified column index is invalid",
      "@param vector column vector to be copied (must have the same number of\nrows as the instance).",
      "@throws MatrixDimensionMismatchException if the {@code vector} dimension\ndoes not match the row dimension of {@code this} matrix.",
      "@return the array of entries in the row.",
      "@param array Row matrix to be copied (must have the same number of\ncolumns as the instance)",
      "@throws MatrixDimensionMismatchException if the {@code array} length does\nnot match the column dimension of {@code this} matrix.",
      "@return the array of entries in the column.",
      "@param array Column array to be copied (must have the same number of\nrows as the instance).",
      "@throws MatrixDimensionMismatchException if the {@code array} length does\nnot match the row dimension of {@code this} matrix.",
      "@param row Row index of entry to be fetched.",
      "@param column Column index of entry to be fetched.",
      "@return the matrix entry at {@code (row, column)}.",
      "@param row Row index of entry to be set.",
      "@param column Column index of entry to be set.",
      "@param value the new value of the entry.",
      "@throws OutOfRangeException if the row or column index is not valid",
      "@param row Row index of the entry to be modified.",
      "@param column Column index of the entry to be modified.",
      "@param increment value to add to the matrix entry.",
      "@param factor Multiplication factor for the matrix entry.",
      "@return the trace.",
      "@throws DimensionMismatchException if the length of {@code v} does not\nmatch the column dimension of {@code this}."
   ],
   [
      "@throws DimensionMismatchException if the dimension of {@code v} does not\nmatch the column dimension of {@code this}.",
      "@throws DimensionMismatchException if the length of {@code v} does not\nmatch the row dimension of {@code this}.",
      "@throws DimensionMismatchException if the dimension of {@code v} does not\nmatch the row dimension of {@code this}.",
      "@return the value returned by {@link RealMatrixChangingVisitor#end()} at the end\nof the walk",
      "@return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\nof the walk",
      "@throws MaxCountExceededException if the transformation does not converge",
      "@return the L1 norm of matrix T",
      "@param startIdx the starting index for the search",
      "@param norm the L1 norm of the matrix",
      "@return the index of the first small sub-diagonal element",
      "@param l the index of the small sub-diagonal element",
      "@param idx the current eigenvalue index",
      "@param iteration the current iteration",
      "@param shift holder for shift information",
      "@param il the index of the small sub-diagonal element",
      "@param iu the current eigenvalue index",
      "@param shift shift information holder",
      "@param hVec the initial houseHolder vector",
      "@return the start index for the QR step",
      "@param im the start index for the QR step",
      "@return the value returned by\n{@link RealVector#walkInDefaultOrder(RealVectorChangingVisitor)},\n{@link RealVector#walkInDefaultOrder(RealVectorChangingVisitor, int, int)},\n{@link RealVector#walkInOptimizedOrder(RealVectorChangingVisitor)}\nor\n{@link RealVector#walkInOptimizedOrder(RealVectorChangingVisitor, int, int)}",
      "@return the median for this distribution.",
      "@return the scale parameter for this distribution.",
      "@return mean (always Double.NaN)",
      "@return variance (always Double.NaN)"
   ],
   [
      "@return lower bound of the support (always Double.NEGATIVE_INFINITY)",
      "@return upper bound of the support (always Double.POSITIVE_INFINITY)",
      "@param median Median for this distribution.",
      "@param scale Scale parameter for this distribution.",
      "@param inverseCumAccuracy Maximum absolute error in inverse\ncumulative probability estimates\n(defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).",
      "@return the location parameter.",
      "@return the scale parameter.",
      "@param mu location parameter",
      "@param rng Random number generator",
      "@param x0 Lower bound (excluded).",
      "@param x1 Upper bound (included).",
      "@return the probability that a random variable with this distribution\ntakes a value between {@code x0} and {@code x1}, excluding the lower\nand including the upper endpoint.",
      "@return the maximum absolute error in inverse cumulative probability estimates",
      "@return zero.",
      "@param x the point at which the PDF is evaluated",
      "@return the logarithm of the value of the probability density function at point {@code x}",
      "@param n Population size.",
      "@param m Number of successes in the population.",
      "@param k Sample size.",
      "@return a two element array containing the lower and upper bounds of the\nhypergeometric distribution.",
      "@return the lowest domain value of the hypergeometric distribution.",
      "@return the number of successes.",
      "@return the population size.",
      "@return the sample size.",
      "@return the highest domain value of the hypergeometric distribution."
   ],
   [
      "@param x Value at which the CDF is evaluated.",
      "@return the upper tail CDF for this distribution.",
      "@param x0 Inclusive lower bound.",
      "@param x1 Inclusive upper bound.",
      "@param dx Direction of summation (1 indicates summing from x0 to x1, and\n0 indicates summing from x1 to x0).",
      "@return {@code P(x0 <= X <= x1)}.",
      "@return the variance of this distribution",
      "@return lower bound of the support",
      "@return upper bound of the support",
      "@param populationSize Population size.",
      "@param numberOfSuccesses Number of successes in the population.",
      "@param sampleSize Sample size.",
      "@return the degrees of freedom.",
      "@return lower bound of the support (always\n{@code Double.NEGATIVE_INFINITY})",
      "@return upper bound of the support (always\n{@code Double.POSITIVE_INFINITY})",
      "@param degreesOfFreedom Degrees of freedom.",
      "@param inverseCumAccuracy the maximum absolute error in inverse\ncumulative probability estimates\n(defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).",
      "@return {@code 2 * k}, where {@code k} is the number of degrees of freedom.",
      "@return {@code Double.POSITIVE_INFINITY}.",
      "@param inverseCumAccuracy the maximum absolute error in inverse\ncumulative probability estimates (defaults to\n{@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).",
      "@return the mode {@code c} of this distribution",
      "@param a Lower limit of this distribution (inclusive).",
      "@param b Upper limit of this distribution (inclusive).",
      "@param c Mode of this distribution.",
      "@param initialMixture Model containing initial values of weights and\n           multivariate normals"
   ],
   [
      "@param maxIterations Maximum iterations allowed for fit",
      "@param threshold Convergence threshold computed as difference in\n            logLikelihoods between successive iterations",
      "@throws SingularMatrixException if any component's covariance matrix is\n            singular during fitting",
      "@throws NotStrictlyPositiveException if numComponents is less than one\n            or threshold is less than Double.MIN_VALUE",
      "@throws DimensionMismatchException if initialMixture mean vector and data\n            number of columns are not equal",
      "@throws NotStrictlyPositiveException if numComponents is less than one or\n            threshold is less than Double.MIN_VALUE",
      "@param data Data to estimate distribution",
      "@param numComponents Number of components for estimated mixture",
      "@return Multivariate normal mixture model estimated from the data",
      "@throws NumberIsTooLargeException if {@code numComponents} is greater\nthan the number of data rows.",
      "@throws NotStrictlyPositiveException if data has less than 2 rows",
      "@throws DimensionMismatchException if rows of data have different numbers\n            of columns",
      "@return Log likelihood of data or zero of no data has been fit",
      "@throws NumberIsTooLargeException if the lower bound {@code min} is\ngreater than, or equal to the upper bound {@code max}.",
      "@throws NotStrictlyPositiveException if the number of sample points\n{@code n} is negative.",
      "@throws DimensionMismatchException if the array length is not 3.",
      "@return {@code true} if the norm is 1 within the given tolerance,\n{@code false} otherwise",
      "@throws MathIllegalArgumentException if the variablesToInclude array is null or zero length",
      "@param noIntercept true means the model is to be estimated without an intercept term",
      "@throws NullArgumentException if the data array is null",
      "@throws InsufficientDataException if <code>nobs</code> is less than\n<code>nvars + 1</code>",
      "@throws NullArgumentException if y is null",
      "@throws NoDataException if y is empty",
      "@throws NoDataException if x is empty",
      "@throws NullArgumentException if {@code x} or {@code y} is null"
   ],
   [
      "@throws NoDataException if {@code x} or {@code y} are zero-length",
      "@throws NotStrictlyPositiveException if row or column dimension is not positive",
      "@throws NullArgumentException if any of the input arrays is {@code null}",
      "@throws NotStrictlyPositiveException if {@code numberOfTrials <= 0}.",
      "@throws NumberIsTooLargeException if {@code numberOfSuccesses > numberOfTrials}.",
      "@param numberOfTrials number of trials (must be positive)",
      "@param confidenceLevel confidence level (must be strictly between 0 and 1)",
      "@throws MathArithmeticException if vector norm is zero",
      "@throws MathIllegalArgumentException if the data points are null or the number\n  of clusters is larger than the number of data points",
      "@throws NumberIsTooSmallException if {@code mu < 0.5}",
      "@throws NotStrictlyPositiveException if {@code omega <= 0}",
      "@param omega scale parameter (must be positive)",
      "@throws DimensionMismatchException the the length of the arrays does not\nmatch or their common length is less than 2",
      "@return a-2k&pi; with integer k and center-&pi; &lt;= a-2k&pi; &lt;= center+&pi;",
      "@return max(a1, e2)",
      "@return min(a1, e2)",
      "@return a value with magnitude equal to {@code magnitude} and with the\nsame sign as the {@code sign} argument.",
      "@throws NullArgumentException if {@code o} is {@code null}.",
      "@throws NotPositiveException if {@code p < 0}",
      "@throws NoDataException if {@code subMatrix} is empty.",
      "@throws NullArgumentException if {@code subMatrix} is {@code null}.",
      "@throws NotStrictlyPositiveException if {@code shape <= 0}.",
      "@throws NullArgumentException if in is null",
      "@throws NullArgumentException if url is null",
      "@throws NullArgumentException if file is null"
   ],
   [
      "@throws NullArgumentException if the {@code coefficients} is\n{@code null}.",
      "@throws NoDataException if the {@code coefficients} array is empty.",
      "@throws NullArgumentException if the {@code coefficients} is\n{@code null}",
      "@throws NoDataException if the {@code coefficients} array is empty",
      "@return fitted model or {@code null} if no fit has been performed yet.",
      "@param data Data to use in fitting procedure",
      "@throws NotStrictlyPositiveException if data has no rows",
      "@throws NumberIsTooSmallException if the number of columns in the data is\n            less than 2",
      "@return the first shape parameter.",
      "@return the second shape parameter.",
      "@return the solver absolute accuracy.",
      "@return lower bound of the support (always 0)",
      "@return upper bound of the support (always 1)",
      "@param inverseCumAccuracy Maximum absolute error in inverse\ncumulative probability estimates (defaults to\n{@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).",
      "@param x the point at which the PMF is evaluated",
      "@return the value of the probability mass function at point {@code x}",
      "@return the value of the probability density function at point {@code x}",
      "@param x the point at which the CDF is evaluated",
      "@param x0 the exclusive lower bound",
      "@param x1 the inclusive upper bound",
      "@return the probability that a random variable with this distribution\ntakes a value between {@code x0} and {@code x1},\nexcluding the lower and including the upper endpoint",
      "@param p the cumulative probability",
      "@return the smallest {@code p}-quantile of this distribution\n(largest 0-quantile for {@code p = 0})",
      "@return the mean or {@code Double.NaN} if it is not defined",
      "@return the variance (possibly {@code Double.POSITIVE_INFINITY} as\nfor certain cases in {@link TDistribution}) or {@code Double.NaN} if it\nis not defined"
   ],
   [
      "@return lower bound of the support (might be\n{@code Double.NEGATIVE_INFINITY})",
      "@return upper bound of the support (might be\n{@code Double.POSITIVE_INFINITY})",
      "@return true if the lower bound of support is finite and the density\nfunction returns a non-NaN, non-infinite value there",
      "@return true if the upper bound of support is finite and the density\nfunction returns a non-NaN, non-infinite value there",
      "@return whether the support is connected or not",
      "@param seed the new seed",
      "@return a random value.",
      "@param sampleSize the number of random values to generate",
      "@return an array representing the random sample",
      "@return the mean for this distribution.",
      "@return the standard deviation for this distribution.",
      "@param mean Mean for this distribution.",
      "@param sd Standard deviation for this distribution.",
      "@param inverseCumAccuracy Inverse cumulative probability accuracy.",
      "@param z the value.",
      "@return the Striling's series error.",
      "@param x the x value.",
      "@param mu the average.",
      "@return a part of the deviance.",
      "@param x the value at which the probability is evaluated.",
      "@param n the number of trials.",
      "@param p the probability of success.",
      "@param q the probability of failure (1 - p).",
      "@return log(p(x)).",
      "@param weights Weights of each component."
   ],
   [
      "@param means Mean vector for each component.",
      "@param covariances Covariance matrix for each component.",
      "@return the list of components.",
      "@param components List of (weight, distribution) pairs from which to sample.",
      "@param components Distributions from which to sample.",
      "@throws NotPositiveException if any of the weights is negative.",
      "@throws DimensionMismatchException if not all components have the same\nnumber of variables.",
      "@param lower Lower bound of this distribution (inclusive).",
      "@param upper Upper bound of this distribution (exclusive).",
      "@return the number of elements",
      "@return the exponent",
      "@return the mean of this distribution",
      "@param n Term in the series to calculate (must be larger than 1)",
      "@param m Exponent (special case {@code m = 1} is the harmonic series).",
      "@return the n<sup>th</sup> generalized harmonic number.",
      "@return lower bound of the support (always 1)",
      "@param numberOfElements Number of elements.",
      "@param exponent Exponent.",
      "@return the number of trials.",
      "@return the probability of success.",
      "@return lower bound of the support (0 or the number of trials)",
      "@return upper bound of the support (number of trials or 0)",
      "@param trials Number of trials.",
      "@param p Probability of success.",
      "@param singletons values"
   ],
   [
      "@param probabilities probabilities",
      "@return list of value/probability pairs",
      "@return {@code sum(singletons[i] * probabilities[i])}",
      "@return {@code sum((singletons[i] - mean) ^ 2 * probabilities[i])}",
      "@return the lowest value with non-zero probability.",
      "@return the highest value with non-zero probability.",
      "@param singletons array of random variable values.",
      "@param probabilities array of probabilities.",
      "@throws DimensionMismatchException if\n{@code singletons.length != probabilities.length}",
      "@throws NotPositiveException if any of the probabilities are negative.",
      "@throws NotFiniteNumberException if any of the probabilities are infinite.",
      "@throws NotANumberException if any of the probabilities are NaN.",
      "@throws MathArithmeticException all of the probabilities are 0.",
      "@param rng random number generator.",
      "@param rng random number generator used for sampling",
      "@param data input dataset",
      "@return the value of the probability mass function at {@code x}",
      "@return the probability that a random variable with this distribution\nwill take a value between {@code x0} and {@code x1},\nexcluding the lower and including the upper endpoint",
      "@return the variance (possibly {@code Double.POSITIVE_INFINITY} or\n{@code Double.NaN} if it is not defined)",
      "@return lower bound of the support ({@code Integer.MIN_VALUE}\nfor negative infinity)",
      "@return upper bound of the support ({@code Integer.MAX_VALUE}\nfor positive infinity)",
      "@return a random value",
      "@return the shape parameter, {@code alpha}.",
      "@return the scale parameter, {@code beta}.",
      "@param alpha Shape parameter."
   ],
   [
      "@param beta Scale parameter.",
      "@param x Point at which the PDF is evaluated.",
      "@return the value of the probability density function at point {@code x}.",
      "@param seed Seed with which to initialize the random number generator.",
      "@return the number of variables.",
      "@return a random value vector.",
      "@param sampleSize the number of random vectors to generate.",
      "@return an array representing the random samples.",
      "@return the shape parameter.",
      "@param mu shape parameter",
      "@param inverseAbsoluteAccuracy the maximum absolute error in inverse\ncumulative probability estimates (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).",
      "@return the probability mass function.",
      "@param sampleSize the number of random values to generate.",
      "@return an array representing the random sample.",
      "@param array the array to populate.",
      "@param pmf probability mass function enumerated as a list of <T, probability>\npairs.",
      "@param seed (ignored)",
      "@param value the constant value of this distribution",
      "@return the mean vector.",
      "@return the standard deviations.",
      "@param values Values at which to compute density.",
      "@return the multiplication factor of density calculations.",
      "@param means Vector of means.",
      "@param covariances Covariance matrix.",
      "@throws DimensionMismatchException if the arrays length are\ninconsistent."
   ],
   [
      "@throws SingularMatrixException if the eigenvalue decomposition cannot\nbe performed on the provided covariance matrix.",
      "@throws NonPositiveDefiniteMatrixException if any of the eigenvalues is\nnegative.",
      "@param rng Random Number Generator.",
      "@return the mean.",
      "@param mean mean of this distribution.",
      "@param mean Mean of this distribution.",
      "@param lower Lower bound (inclusive) of this distribution.",
      "@param upper Upper bound (inclusive) of this distribution.",
      "@return the scale parameter",
      "@return the shape parameter",
      "@param scale the scale parameter of this distribution",
      "@param shape the shape parameter of this distribution",
      "@param scale Scale parameter of this distribution.",
      "@param shape Shape parameter of this distribution.",
      "@return upper bound of the support (always {@code Integer.MAX_VALUE}\nfor positive infinity)",
      "@param r Number of successes.",
      "@return upper bound of the support (always {@code Double.POSITIVE_INFINITY})",
      "@return the numerator degrees of freedom.",
      "@return the denominator degrees of freedom.",
      "@param numeratorDegreesOfFreedom Numerator degrees of freedom.",
      "@param denominatorDegreesOfFreedom Denominator degrees of freedom.",
      "@param inverseCumAccuracy the maximum absolute error in inverse\ncumulative probability estimates.",
      "@return upper bound of the support (always Integer.MAX_VALUE)",
      "@param p probability of success.",
      "@param n Number of dimensions."
   ],
   [
      "@param upper a value satisfying {@code p <= cumulativeProbability(upper)}",
      "@return the smallest {@code p}-quantile of this distribution",
      "@param argument input value",
      "@return the cumulative probability",
      "@throws MathInternalError if the cumulative probability is {@code NaN}",
      "@return the logarithm of the value of the probability mass function at {@code x}",
      "@return the mean for the distribution.",
      "@param x Upper bound, inclusive.",
      "@return the distribution function value calculated using a normal\napproximation.",
      "@return upper bound of the support (always {@code Integer.MAX_VALUE} for\npositive infinity)",
      "@param meanPoisson Mean of the Poisson distribution.",
      "@return the next sample.",
      "@param p the Poisson mean",
      "@param p Poisson mean.",
      "@param epsilon Convergence criterion for cumulative probabilities.",
      "@param maxIterations the maximum number of iterations for cumulative\nprobabilities.",
      "@param maxIterations Maximum number of iterations for cumulative\nprobabilities.",
      "@return the two-sided probability of {@code P(D_n < d)}",
      "@throws MathArithmeticException if algorithm fails to convert {@code h}\nto a {@link org.apache.commons.math3.fraction.BigFraction} in expressing\n{@code d} as {@code (k - h) / m} for integer {@code k, m} and\n{@code 0 <= h < 1}.",
      "@param exact whether the probability should be calculated exact using\n{@link org.apache.commons.math3.fraction.BigFraction} everywhere at the\nexpense of very slow execution time, or if {@code double} should be used\nconvenient places to gain speed. Almost never choose {@code true} in real\napplications unless you are very sure; {@code true} is almost solely for\nverification purposes.",
      "@throws FractionConversionException if algorithm fails to convert\n{@code h} to a {@link org.apache.commons.math3.fraction.BigFraction} in\nexpressing {@code d} as {@code (k - h) / m} for integer {@code k, m} and\n{@code 0 <= h < 1}.",
      "@param n Number of observations",
      "@return the component distributions and associated weights.",
      "@return {@inheritDoc}",
      "@param shape the shape parameter"
   ],
   [
      "@param scale the scale parameter",
      "@return scale parameter of the distribution",
      "@return location parameter of the distribution",
      "@param c scale parameter",
      "@param rng random generator to be used for sampling",
      "@param mu location",
      "@return the allowed number of evaluations.",
      "@return a new instance suitable for allowing {@link Integer#MAX_VALUE}\nevaluations.",
      "@param max Allowed number of iterations.",
      "@return the constraints.",
      "@param constraints Constraints.",
      "@return the coefficients of the constraint (left hand side).",
      "@return the relationship between left and right hand sides.",
      "@return the value of the constraint (right hand side).",
      "@param optData Optimization data. In addition to those documented in\n{@link LinearOptimizer#optimize(OptimizationData...)\nLinearOptimizer}, this method will register the following data:\n<ul>\n <li>{@link SolutionCallback}</li>\n <li>{@link PivotSelectionRule}</li>\n</ul>",
      "@throws TooManyIterationsException if the maximal number of iterations is exceeded.",
      "@param optData Optimization data.\nIn addition to those documented in\n{@link LinearOptimizer#parseOptimizationData(OptimizationData[])\nLinearOptimizer}, this method will register the following data:\n<ul>\n <li>{@link SolutionCallback}</li>\n <li>{@link PivotSelectionRule}</li>\n</ul>",
      "@param tableau Simple tableau for the problem.",
      "@return the column with the most negative coefficient.",
      "@param tableau simplex tableau for the problem",
      "@param col the column to test",
      "@return {@code true} if the pivot column is valid, {@code false} otherwise",
      "@param tableau Simplex tableau for the problem.",
      "@param col Column to test the ratio of (see {@link #getPivotColumn(SimplexTableau)}).",
      "@return the row with the minimum ratio."
   ],
   [
      "@throws TooManyIterationsException if the allowed number of iterations has been exhausted.",
      "@throws UnboundedSolutionException if the model is found not to have a bounded solution.",
      "@throws NoFeasibleSolutionException if there is no feasible solution?",
      "@param epsilon Amount of error to accept for algorithm convergence.",
      "@param maxUlps Amount of error to accept in floating point comparisons.",
      "@param cutOff Values smaller than the cutOff are treated as zero.",
      "@param optData Optimization data. In addition to those documented in\n{@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])\nMultivariateOptimizer}, this method will register the following data:\n<ul>\n <li>{@link LinearObjectiveFunction}</li>\n <li>{@link LinearConstraintSet}</li>\n <li>{@link NonNegativeConstraint}</li>\n</ul>",
      "@throws TooManyIterationsException if the maximal number of\niterations is exceeded.",
      "@param optData Optimization data.\nThe following data will be looked for:\n<ul>\n <li>{@link LinearObjectiveFunction}</li>\n <li>{@link LinearConstraintSet}</li>\n <li>{@link NonNegativeConstraint}</li>\n</ul>",
      "@param row the index of the row to check",
      "@return the variable that is basic for this row.",
      "@param startColumn the column to start",
      "@param col index of the column",
      "@return the row that the variable is basic in, or {@code null} if the variable is not basic.",
      "@param pivotCol the pivot column",
      "@param pivotRow the pivot row",
      "@param dividendRowIndex index of the row",
      "@param minuendRowIndex row index",
      "@param subtrahendRowIndex row index",
      "@param multiplier multiplication factor",
      "@param row the row index",
      "@return the reference to the underlying row data",
      "@param f Linear objective function.",
      "@param constraints Linear constraints.",
      "@param goalType Optimization goal: either {@link GoalType#MAXIMIZE}\nor {@link GoalType#MINIMIZE}."
   ],
   [
      "@param restrictToNonNegative Whether to restrict the variables to non-negative values.",
      "@param epsilon Amount of error to accept when checking for optimality.",
      "@param tableau the simplex tableau containing a feasible solution",
      "@return the best solution found so far by the optimizer, or {@code null} if\nno feasible solution could be found",
      "@return {@code true} if the solution is optimal, {@code false} otherwise",
      "@return coefficients of the linear equation being optimized.",
      "@return constant of the linear equation being optimized.",
      "@param point Point at which linear equation must be evaluated.",
      "@return the value of the linear equation at the current point.",
      "@param coefficients Coefficients for the linear equation being optimized.",
      "@param constantTerm Constant term of the linear equation.",
      "@return {@code true} if all the variables must be positive.",
      "@param restricted If {@code true}, all the variables must be positive.",
      "@return the opposite relationship.",
      "@param stringValue Display string for the relationship.",
      "@param maxEvaluations the number of allowed model function evaluations.",
      "@param maxIterations the number of allowed iterations.",
      "@param checker the convergence checker.",
      "@param dim Number of parameters.",
      "@return a new instance suitable for passing to an optimizer that\nrequires bounds specification.",
      "@return the maximal number of iterations.",
      "@param optData Optimization data.\nThis method will register the following data:\n<ul>\n <li>{@link MaxEval}</li>\n <li>{@link MaxIter}</li>\n</ul>",
      "@return a point/value pair that satisfies the convergence criteria.",
      "@throws TooManyEvaluationsException if the allowed evaluations\nhave been exhausted.",
      "@throws TooManyIterationsException if the allowed iterations\nhave been exhausted."
   ],
   [
      "@param optData Optimization data.\nThe following data will be looked for:\n<ul>\n <li>{@link MaxEval}</li>\n <li>{@link MaxIter}</li>\n</ul>",
      "@param maxEval Maximum number of objective function evaluations.",
      "@param maxIter Maximum number of algorithm iterations.",
      "@return an array containing the optima sorted from best to worst.",
      "@throws MathIllegalStateException if {@code optData} does not contain an\ninstance of {@link MaxEval} or {@link InitialGuess}.",
      "@param optimum Result of an optimization run.",
      "@throws MathIllegalStateException if {@link #optimize(OptimizationData[])\noptimize} has not been called.",
      "@throws MathIllegalStateException if {@code optData} does not contain an\ninstance of {@link MaxEval} or {@link SearchInterval}.",
      "@return the objective function.",
      "@param f Function to be optimized.",
      "@return the start value.",
      "@param hi Upper bound.",
      "@param init Start value.",
      "@param optData Optimization data. In addition to those documented in\n{@link BaseOptimizer#parseOptimizationData(OptimizationData[])\nBaseOptimizer}, this method will register the following data:\n<ul>\n <li>{@link GoalType}</li>\n <li>{@link SearchInterval}</li>\n <li>{@link UnivariateObjectiveFunction}</li>\n</ul>",
      "@param optData Optimization data.\nThe following data will be looked for:\n<ul>\n <li>{@link GoalType}</li>\n <li>{@link SearchInterval}</li>\n <li>{@link UnivariateObjectiveFunction}</li>\n</ul>",
      "@param x Point at which the objective function must be evaluated.",
      "@param optData Optimization data. In addition to those documented in\n{@link BaseOptimizer#parseOptimizationData(OptimizationData[]) BaseOptimizer},\nthis method will register the following data:\n<ul>\n <li>{@link InitialGuess}</li>\n <li>{@link SimpleBounds}</li>\n</ul>",
      "@return the initial guess, or {@code null} if not set.",
      "@return the lower bounds, or {@code null} if not set.",
      "@return the upper bounds, or {@code null} if not set.",
      "@return a counter for the evaluations.",
      "@param max Allowed number of evalutations.",
      "@throws MathUnsupportedOperationException if bounds were passed to the\n{@link #optimize(OptimizationData[]) optimize} method.",
      "@param updateFormula formula to use for updating the &beta; parameter,\nmust be one of {@link Formula#FLETCHER_REEVES} or\n{@link Formula#POLAK_RIBIERE}.",
      "@param relativeTolerance Relative threshold for line search."
   ],
   [
      "@param absoluteTolerance Absolute threshold for line search.",
      "@param initialBracketingRange Extent of the initial interval used to\nfind an interval that brackets the optimum in order to perform the\nline search.",
      "@param params Point at which the gradient must be evaluated.",
      "@param optData Optimization data. In addition to those documented in\n{@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])\nMultivariateOptimizer}, this method will register the following data:\n<ul>\n <li>{@link ObjectiveFunctionGradient}</li>\n</ul>",
      "@throws TooManyEvaluationsException if the maximal number of\nevaluations (of the objective function) is exceeded.",
      "@param optData Optimization data.\nThe following data will be looked for:\n<ul>\n <li>{@link ObjectiveFunctionGradient}</li>\n</ul>",
      "@param point Unbounded values.",
      "@return the bounded values.",
      "@param point Bounded values.",
      "@return the unbounded values.",
      "@param startPoint Starting point.",
      "@param direction Search direction.",
      "@return the optimum.",
      "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the number of evaluations is exceeded.",
      "@param optimizer Optimizer on behalf of which the line search\nbe performed.\nIts {@link MultivariateOptimizer#computeObjectiveValue(double[])\ncomputeObjectiveValue} method will be called by the\n{@link #search(double[],double[]) search} method.",
      "@param relativeTolerance Search will stop when the function relative\ndifference between successive iterations is below this value.",
      "@param absoluteTolerance Search will stop when the function absolute\ndifference between successive iterations is below this value.",
      "@param initialBracketingRange Extent of the initial interval used to\nfind an interval that brackets the optimum.\nIf the optimized function varies a lot in the vicinity of the optimum,\nit may be necessary to provide a value lower than the distance between\nsuccessive local minima.",
      "@param optData Optimization data. In addition to those documented in\n{@link BaseMultivariateOptimizer#parseOptimizationData(OptimizationData[])\nBaseMultivariateOptimizer}, this method will register the following data:\n<ul>\n <li>{@link ObjectiveFunction}</li>\n <li>{@link GoalType}</li>\n</ul>",
      "@param optData Optimization data.\nThe following data will be looked for:\n<ul>\n <li>{@link ObjectiveFunction}</li>\n <li>{@link GoalType}</li>\n</ul>",
      "@param params Point at which the objective function must be evaluated.",
      "@param optData Optimization data. In addition to those documented in\n{@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])\nMultivariateOptimizer}, this method will register the following data:\n<ul>\n <li>{@link AbstractSimplex}</li>\n</ul>",
      "@param optData Optimization data.\nThe following data will be looked for:\n<ul>\n <li>{@link AbstractSimplex}</li>\n</ul>",
      "@throws NullArgumentException if no initial simplex was passed to the\n{@link #optimize(OptimizationData[]) optimize} method.",
      "@param optData Optimization data. In addition to those documented in\n{@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])\nMultivariateOptimizer}, this method will register the following data:\n<ul>\n <li>{@link Sigma}</li>\n <li>{@link PopulationSize}</li>\n</ul>"
   ],
   [
      "@param vpPairs Array of valuePenaltyPairs to get range from.",
      "@return a double equal to maximum value minus minimum value.",
      "@throws MathIllegalArgumentException if window size is less than 1 but\nnot equal to {@link #INFINITE_WINDOW}",
      "@throws NullArgumentException if either {@code data} or {@code data[0]}\nis {@code null}.",
      "@throws IllegalArgumentException if dimension is not positive",
      "@throws NoDataException if {@code rowData} is empty.",
      "@throws NullArgumentException if {@code rowData} is {@code null}.",
      "@throws NoDataException if {@code columnData} is empty.",
      "@throws NullArgumentException if {@code columnData} is {@code null}.",
      "@throws NullArgumentException if {@code selectedRows} or\n{@code selectedColumns} are {@code null}.",
      "@throws NonSquareMatrixException if the matrix {@code rm} is not square",
      "@throws NonSquareMatrixException if the matrix {@code rm} is not\nsquare",
      "@throws NonSquareMatrixException if {@code m} is not square.",
      "@throws NullArgumentException if {@code matrix} is {@code null}",
      "@param start Initial guess for the parameters.  Cannot be {@code null}.\nIts length must be consistent with the number of parameters of the\nfunction to fit.",
      "@throws NoDataException if an array has zero-length.",
      "@throws NullArgumentException if the arguments are {@code null}.",
      "@throws NullArgumentException if {@code a} is {@code null}.",
      "@throws UnknownParameterException if parameter is not supported",
      "@throws NonSquareMatrixException if {@code this matrix} is not square",
      "@throws NoDataException if {@code selectedRows} or\n{@code selectedColumns} is empty",
      "@throws NullArgumentException if {@code selectedRows} or\n{@code selectedColumns} is {@code null}.",
      "@throws NullArgumentException if orginal is null",
      "@return a number {@code delta} so that {@code x + delta} and {@code x}\ndiffer by a representable floating number.",
      "@param starts Number of starts to perform. If {@code starts == 1},\nthe {@link #optimize(int,MultivariateVectorFunction,double[],double[],double[])\noptimize} will return the same solution as {@code optimizer} would."
   ],
   [
      "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if row or column dimension is not positive.",
      "@throws OutOfRangeException if {@code index} is not between\n{@code 0} and the value returned by {@link #getSize()} (excluded).",
      "@return predicted <code>y</code> value",
      "@return a comparator for sorting the optima.",
      "@param starts Number of starts to perform.\nIf {@code starts == 1}, the result will be same as if {@code optimizer}\nis called directly.",
      "@return the objective function gradient.",
      "@param g Gradient of the function to be optimized.",
      "@return the model function.",
      "@param m Model function to be optimized.",
      "@return the RMS value.",
      "@param optData Optimization data. In addition to those documented in\n{@link JacobianMultivariateVectorOptimizer#parseOptimizationData(OptimizationData[])\nJacobianMultivariateVectorOptimizer}, this method will register the following data:\n<ul>\n <li>{@link org.apache.commons.math3.optim.nonlinear.vector.Weight}</li>\n</ul>",
      "@param optData Optimization data. The following data will be looked for:\n<ul>\n <li>{@link Weight}</li>\n</ul>",
      "@return the model function Jacobian.",
      "@param j Jacobian of the model function to be optimized.",
      "@param params Point at which the Jacobian must be evaluated.",
      "@return the Jacobian at the specified point.",
      "@param optData Optimization data. In addition to those documented in\n{@link MultivariateVectorOptimizer#optimize(OptimizationData...)}\nMultivariateOptimizer}, this method will register the following data:\n<ul>\n <li>{@link ModelFunctionJacobian}</li>\n</ul>",
      "@param optData Optimization data.\nThe following data will be looked for:\n<ul>\n <li>{@link ModelFunctionJacobian}</li>\n</ul>",
      "@throws TooManyEvaluationsException if the maximal number of evaluations\n(of the model vector function) is exceeded.",
      "@param optData Optimization data. In addition to those documented in\n{@link BaseMultivariateOptimizer#parseOptimizationData(OptimizationData[])\nBaseMultivariateOptimizer}, this method will register the following data:\n<ul>\n <li>{@link Target}</li>\n <li>{@link Weight}</li>\n <li>{@link ModelFunction}</li>\n</ul>",
      "@return the length of the target vector.",
      "@param optData Optimization data. The following data will be looked for:\n<ul>\n <li>{@link Target}</li>\n <li>{@link Weight}</li>\n <li>{@link ModelFunction}</li>\n</ul>",
      "@param x the value.",
      "@return the error function erf(x)",
      "@throws org.apache.commons.math3.exception.MaxCountExceededException if the algorithm fails to converge."
   ],
   [
      "@param x the value",
      "@return the complementary error function erfc(x)",
      "@param x1 the first value",
      "@param x2 the second value",
      "@return erf(x2) - erf(x1)",
      "@return t such that x = erf(t)",
      "@return t such that x = erfc(t)",
      "@param x Argument",
      "@return Value of the Bessel function at x",
      "@throws MathIllegalArgumentException if {@code x} is too large relative to {@code order}",
      "@throws ConvergenceException if the algorithm fails to converge",
      "@param order Order of the Bessel function",
      "@return Value of the Bessel function of the first kind, \\(J_{order}(x)\\)",
      "@param x non-negative real argument for which J's are to be calculated",
      "@param alpha fractional part of order for which J's or exponentially\nscaled J's (\\(J\\cdot e^{x}\\)) are to be calculated. 0 <= alpha < 1.0.",
      "@param nb integer number of functions to be calculated, nb > 0. The first\nfunction calculated is of order alpha, and the last is of order\nnb - 1 + alpha.",
      "@return BesselJResult a vector of the functions\n\\(J_{alpha}(x)\\) through \\(J_{nb-1+alpha}(x)\\), or the corresponding exponentially\nscaled functions and an integer output variable indicating possible errors",
      "@param order order of the function computed when using {@link #value(double)}.",
      "@return the value of {@code log(Gamma(x))}, {@code Double.NaN} if\n{@code x <= 0.0}.",
      "@param a Parameter.",
      "@return the regularized gamma function P(a, x).",
      "@param a the a parameter.",
      "@param epsilon When the absolute value of the nth item in the\nseries is less than epsilon the approximation ceases to calculate\nfurther elements in the series.",
      "@param maxIterations Maximum number of \"iterations\" to complete.",
      "@return the regularized gamma function P(a, x)"
   ],
   [
      "@return the regularized gamma function Q(a, x)",
      "@return digamma(x) to within 10-8 relative or absolute error whichever is smaller.",
      "@return trigamma(x) to within 10-8 relative or absolute error whichever is smaller",
      "@return The Lanczos approximation.",
      "@return The value of {@code 1.0 / Gamma(1.0 + x) - 1.0}.",
      "@return The value of {@code log(Gamma(1 + x))}.",
      "@return the value of {@code Gamma(x)}.",
      "@param a Parameter {@code a}.",
      "@param b Parameter {@code b}.",
      "@return the regularized beta function I(x, a, b).",
      "@return the regularized beta function I(x, a, b)",
      "@param epsilon This parameter is ignored.",
      "@param maxIterations This parameter is ignored.",
      "@return log(B(a, b)).",
      "@param a First argument.",
      "@param b Second argument.",
      "@return the value of {@code log(Gamma(a + b))}.",
      "@throws OutOfRangeException if {@code a} or {@code b} is lower than\n{@code 1.0} or greater than {@code 2.0}.",
      "@return the value of {@code log(Gamma(b) / Gamma(a + b))}.",
      "@throws NumberIsTooSmallException if {@code a < 0.0} or {@code b < 10.0}.",
      "@return the value of {@code Delta(b) - Delta(a + b)}",
      "@throws OutOfRangeException if {@code a < 0} or {@code a > b}",
      "@throws NumberIsTooSmallException if {@code b < 10}",
      "@param p First argument.",
      "@param q Second argument."
   ],
   [
      "@return the value of {@code Delta(p) + Delta(q) - Delta(p + q)}.",
      "@throws NumberIsTooSmallException if {@code p < 10.0} or {@code q < 10.0}.",
      "@return the value of {@code log(Beta(p, q))}, {@code NaN} if\n{@code p <= 0} or {@code q <= 0}.",
      "@param field field to which elements belong",
      "@param original original array (may be null)",
      "@return copied array or null if original array was null",
      "@return time",
      "@return main state dimension",
      "@return main state at time",
      "@return number of secondary states.",
      "@param index index of the secondary set as returned\nby {@link FieldExpandableODE#addSecondaryEquations(FieldSecondaryEquations)}\n(beware index 0 corresponds to main state, additional states start at 1)",
      "@return secondary state dimension",
      "@return secondary state at time",
      "@param time time",
      "@param state state at time",
      "@param secondaryState state at time (may be null)",
      "@return derivative of the main state at time",
      "@return derivative of the secondary state at time",
      "@param derivative derivative of the state at time",
      "@param secondaryDerivative derivative of the state at time (may be null)",
      "@return dimension of the problem",
      "@param t0 value of the independent <I>time</I> variable at integration start",
      "@param y0 array containing the value of the state vector at integration start",
      "@param finalTime target time for the integration",
      "@param t current value of the independent <I>time</I> variable"
   ],
   [
      "@param y array containing the current value of the state vector",
      "@return time derivative of the state vector",
      "@return starter integrator",
      "@param starterIntegrator starter integrator",
      "@param equations complete set of differential equations to integrate",
      "@param initialState initial state (time, primary and secondary state vectors)",
      "@param t target time for the integration\n(can be set to a value smaller than <code>t0</code> for backward integration)",
      "@throws DimensionMismatchException if arrays dimension do not match equations settings",
      "@throws NumberIsTooSmallException if integration step is too small",
      "@throws MaxCountExceededException if the number of functions evaluations is exceeded",
      "@throws NoBracketingException if the location of an event cannot be bracketed",
      "@param h step size to use for scaling",
      "@param t first steps times",
      "@param y first steps states",
      "@param yDot first steps derivatives",
      "@return Nordieck vector at first step (h<sup>2</sup>/2 y''<sub>n</sub>,\nh<sup>3</sup>/6 y'''<sub>n</sub> ... h<sup>k</sup>/k! y<sup>(k)</sup><sub>n</sub>)",
      "@return minimal reduction factor",
      "@param minReduction minimal reduction factor",
      "@return maximal growth factor",
      "@param maxGrowth maximal growth factor",
      "@return safety factor",
      "@param safety safety factor",
      "@return number of steps of the multistep method (excluding the one being computed)",
      "@param newStepSize new step size to use in the scaled and Nordsieck arrays",
      "@param error normalized error of the current step"
   ],
   [
      "@return grow/shrink factor for next step",
      "@param field field to which the time and state vector elements belong",
      "@param name name of the method",
      "@param nSteps number of steps of the multistep method\n(excluding the one being computed)",
      "@param order order of the method",
      "@param scalAbsoluteTolerance allowed absolute error",
      "@param scalRelativeTolerance allowed relative error",
      "@param vecAbsoluteTolerance allowed absolute error",
      "@param vecRelativeTolerance allowed relative error",
      "@return name of the method",
      "@param handler handler for the accepted steps",
      "@return an unmodifiable collection of the added events handlers",
      "@param handler event handler",
      "@param maxCheckInterval maximal time interval between switching\nfunction checks (this interval prevents missing sign changes in\ncase the integration steps becomes very large)",
      "@param convergence convergence threshold in the event time search",
      "@param maxIterationCount upper limit of the iteration count in\nthe event time search",
      "@param solver The root-finding algorithm to use to detect the state\nevents.",
      "@return current value of the step start time t<sub>i</sub>",
      "@return current signed value of the stepsize",
      "@param maxEvaluations maximal number of function evaluations (negative\nvalues are silently converted to maximal integer value, thus representing\nalmost unlimited evaluations)",
      "@return maximal number of functions evaluations",
      "@return number of evaluations of the differential equations function",
      "@return parameterName parameter name",
      "@return hP parameter step",
      "@param hParam parameter step"
   ],
   [
      "@param parameterName parameter name",
      "@param hP parameter step",
      "@param model model to add at the end of the instance",
      "@throws MathIllegalArgumentException if the model to append is not\ncompatible with the instance (dimension of the state vector,\npropagation direction, hole between the dates)",
      "@throws DimensionMismatchException if the dimensions of the states or\nthe number of secondary states do not match",
      "@throws MaxCountExceededException if the number of functions evaluations is exceeded\nduring step finalization",
      "@param d1 first dimension",
      "@param d2 second dimansion",
      "@throws DimensionMismatchException if dimensions do not match",
      "@param interpolator interpolator for the last accepted step.",
      "@return initial integration time",
      "@return final integration time",
      "@param time time of the interpolated point",
      "@return state at interpolated time",
      "@param time point to locate",
      "@param interval step interval",
      "@return -1 if the double is before the interval, 0 if it is in\nthe interval, and +1 if it is after the interval, according to\nthe interval direction",
      "@param yDot placeholder array where to put the time derivative of the state vector",
      "@param equations second order equations set to convert",
      "@param y array containing the current value of the main state vector",
      "@param yDot array containing the current value of the time derivative\nof the main state vector",
      "@param paramName name of the parameter to consider",
      "@param dFdP placeholder array where to put the Jacobian matrix of the\nODE with respect to the parameter",
      "@throws DimensionMismatchException if arrays dimensions do not match equations settings",
      "@param equations differential equations to integrate"
   ],
   [
      "@param t0 initial time",
      "@param y0 initial value of the state vector at t0",
      "@param yDot0 initial value of the first derivative of the state\nvector at t0",
      "@param t target time for the integration\n(can be set to a value smaller thant <code>t0</code> for backward integration)",
      "@param y placeholder where to put the state vector at each\nsuccessful step (and hence at the end of integration), can be the\nsame object as y0",
      "@param yDot placeholder where to put the first derivative of\nthe state vector at time t, can be the same object as yDot0",
      "@throws MathIllegalStateException if the integrator cannot perform integration",
      "@throws MathIllegalArgumentException if integration parameters are wrong (typically\ntoo small integration span)",
      "@return field to which state vector elements belong",
      "@param eqn equations to integrate",
      "@param t0 start value of the independent <i>time</i> variable",
      "@param y0 array containing the start value of the state vector",
      "@param t target time for the integration",
      "@return initial state with derivatives added",
      "@return differential equations to integrate",
      "@return evaluations counter",
      "@return state completed with derivatives",
      "@throws NullPointerException if the ODE equations have not been set (i.e. if this method\nis called outside of a call to {@link #integrate(FieldExpandableODE, FieldODEState,\nRealFieldElement) integrate}",
      "@param stateInitialized new value for the flag",
      "@param interpolator step interpolator",
      "@param tEnd final integration time",
      "@return state at end of step",
      "@throws MaxCountExceededException if the interpolator throws one because\nthe number of functions evaluations is exceeded",
      "@param eqn set of differential equations",
      "@throws NumberIsTooSmallException if integration span is too small"
   ],
   [
      "@throws DimensionMismatchException if adaptive step size integrators\ntolerance arrays dimensions are not compatible with equations settings",
      "@return true if a reset occurred while last step was accepted",
      "@param stepSize step size to set",
      "@return current step size",
      "@param stepStart step start",
      "@return current step start",
      "@param isLastStep if true, this step is the last one",
      "@return true if this step is the last one",
      "@return primary set of differential equations",
      "@return dimension of the complete set of equations",
      "@param y array containing the current value of the complete state vector",
      "@param yDot placeholder array where to put the time derivative of the complete state vector",
      "@param secondary secondary equations set",
      "@return index of the secondary equation in the expanded state",
      "@return mapper for the primary set",
      "@return equations mappers for the secondary equations sets",
      "@param time current time",
      "@return current time",
      "@param primaryState primary part of the current state",
      "@throws DimensionMismatchException if the dimension of the array does not\nmatch the primary set",
      "@return primary part of the current state",
      "@return primary part of the current state derivative",
      "@param index index of the part to set as returned by {@link\n#addSecondaryEquations(SecondaryEquations)}",
      "@param secondaryState secondary part of the current state",
      "@throws DimensionMismatchException if the dimension of the partial state does not\nmatch the selected equations set dimension"
   ],
   [
      "@return secondary part of the current state",
      "@return secondary part of the current state derivative",
      "@param completeState complete current state to copy data from",
      "@throws DimensionMismatchException if the dimension of the complete state does not\nmatch the complete equations sets dimension",
      "@return complete current state",
      "@param primary the primary set of differential equations to be integrated.",
      "@return parameters names",
      "@param name parameter name to check",
      "@return true if the parameter is supported",
      "@param expandable expandable set into which variational equations should be registered",
      "@throws MismatchedEquations if the primary set of the expandable set does\nnot match the one used to build the instance",
      "@param provider the parameter Jacobian provider to compute exactly the parameter Jacobian matrix",
      "@param parameterizedOde the parameterized ODE to compute the parameter Jacobian matrix using finite differences",
      "@param parameter parameter to consider for Jacobian processing",
      "@param hP step for Jacobian finite difference computation w.r.t. the specified parameter",
      "@param dYdY0 initial Jacobian matrix w.r.t. state",
      "@throws DimensionMismatchException if matrix dimensions are incorrect",
      "@param pName parameter name",
      "@param dYdP initial Jacobian column vector with respect to the parameter",
      "@throws UnknownParameterException if a parameter is not supported",
      "@throws DimensionMismatchException if the column vector does not match state dimension",
      "@param dYdY0 current Jacobian matrix with respect to state.",
      "@param pName name of the parameter for the computed Jacobian matrix",
      "@param dYdP current Jacobian matrix with respect to the named parameter",
      "@param expected expected dimension"
   ],
   [
      "@param array (may be null if expected is 0)",
      "@throws DimensionMismatchException if the array dimension does not match the expected one",
      "@param fode the primary first order differential equations set to extend",
      "@param hY step used for finite difference computation with respect to state vector",
      "@param parameters parameters to consider for Jacobian matrices processing\n(may be null if parameters Jacobians is not desired)",
      "@throws DimensionMismatchException if there is a dimension mismatch between\nthe steps array {@code hY} and the equation dimension",
      "@param jode the primary first order differential equations set to extend",
      "@param interpolator interpolator for the last accepted step. For\nefficiency purposes, the various integrators reuse the same\nobject on each call, so if the instance wants to keep it across\nall calls (for example to provide at the end of the integration a\ncontinuous model valid throughout the integration range), it\nshould build a local copy using the clone method and store this\ncopy.",
      "@param nextTime the next normalized time",
      "@param interpolator interpolator for the last accepted step, to use to\nget the end time of the current step",
      "@return value indicating whether the next normalized time is in the\ncurrent step",
      "@param interpolator interpolator for the last accepted step, to use to\nget the interpolated information",
      "@param t the time for which to store the interpolated information",
      "@param h fixed time step (sign is not used)",
      "@param handler fixed time step handler to wrap",
      "@param mode step normalizer mode to use",
      "@param bounds step normalizer bounds setting to use",
      "@param t time of the current step",
      "@param y state vector at t. For efficiency purposes, the {@link\nStepNormalizer} class reuses the same array on each call, so if\nthe instance wants to keep it across all calls (for example to\nprovide at the end of the integration a complete array of all\nsteps), it should build a local copy store this copy.",
      "@param yDot derivatives of the state vector state vector at t.\nFor efficiency purposes, the {@link StepNormalizer} class reuses\nthe same array on each call, so if\nthe instance wants to keep it across all calls (for example to\nprovide at the end of the integration a complete array of all\nsteps), it should build a local copy store this copy.",
      "@param interpolator interpolator for the last accepted step. For\nefficiency purposes, the various integrators reuse the same\nobject on each call, so if the instance wants to keep it across\nall calls (for example to provide at the end of the integration a\ncontinuous model valid throughout the integration range, as the\n{@link org.apache.commons.math3.ode.ContinuousOutputModel\nContinuousOutputModel} class does), it should build a local copy\nusing the clone method of the interpolator and store this copy.\nKeeping only a reference to the interpolator and reusing it will\nresult in unpredictable behavior (potentially crashing the application).",
      "@return the only instance",
      "@return state at previous grid point time",
      "@return state at current grid point time",
      "@return true if the integration variable (time) increases during\nintegration"
   ],
   [
      "@return previous grid point time",
      "@return current grid point time",
      "@return interpolation point time",
      "@return state vector at time {@link #getInterpolatedTime}",
      "@return derivatives of the state vector at time {@link #getInterpolatedTime}",
      "@param index index of the secondary set, as returned by {@link\norg.apache.commons.math3.ode.ExpandableStatefulODE#addSecondaryEquations(\norg.apache.commons.math3.ode.SecondaryEquations)\nExpandableStatefulODE.addSecondaryEquations(SecondaryEquations)}",
      "@return interpolated secondary state at the current interpolation date",
      "@return interpolated secondary derivatives at the current interpolation date",
      "@return a deep copy of the instance, which can be used independently.",
      "@param previousState start of the restricted step",
      "@param currentState end of the restricted step",
      "@return restricted version of the instance",
      "@param newForward integration direction indicator",
      "@param newGlobalPreviousState start of the global step",
      "@param newGlobalCurrentState end of the global step",
      "@param newSoftPreviousState start of the restricted step",
      "@param newSoftCurrentState end of the restricted step",
      "@param newMapper equations mapper for the all equations",
      "@return previous global grid point state",
      "@return current global grid point state",
      "@param equationsMapper mapper for ODE equations primary and secondary components",
      "@param time interpolation time",
      "@param thetaH time gap between the previous time and the interpolated time",
      "@param oneMinusThetaH time gap between the interpolated time and\nthe current time",
      "@return interpolated state and derivatives"
   ],
   [
      "@param isForward integration direction indicator",
      "@param globalPreviousState start of the global step",
      "@param globalCurrentState end of the global step",
      "@param softPreviousState start of the restricted step",
      "@param softCurrentState end of the restricted step",
      "@param initialState initial time, state vector and derivative",
      "@param state current value of the independent <i>time</i> variable,\nstate vector and derivative\nFor efficiency purposes, the {@link FieldStepNormalizer} class reuses\nthe same array on each call, so if\nthe instance wants to keep it across all calls (for example to\nprovide at the end of the integration a complete array of all\nsteps), it should build a local copy store this copy.",
      "@param dimension total dimension (negative if arrays should be set to null)",
      "@param y reference to the integrator array holding the state at the end of the step",
      "@param primary equations mapper for the primary equations set",
      "@param secondary equations mappers for the secondary equations sets",
      "@return a copy of the finalized instance",
      "@param t current time",
      "@param softPreviousTime start of the restricted step",
      "@param softCurrentTime end of the restricted step",
      "@return previous global grid point time",
      "@return current global grid point time",
      "@return previous soft grid point time",
      "@return current soft grid point time",
      "@param out stream where to save the state",
      "@throws IOException in case of write error",
      "@param in stream where to read the state from",
      "@return interpolated time to be set later by the caller",
      "@throws IOException in case of read error",
      "@throws ClassNotFoundException if an equation mapper class\ncannot be found"
   ],
   [
      "@param y reference to the integrator array holding the state at\nthe end of the step",
      "@param forward integration direction indicator",
      "@param primaryMapper equations mapper for the primary equations set",
      "@param secondaryMappers equations mappers for the secondary equations sets",
      "@param interpolator interpolator to copy from.",
      "@return value indicating whether the first point should be passed\nto the underlying fixed step size step handler.",
      "@return value indicating whether the last point should be passed\nto the underlying fixed step size step handler.",
      "@param first Whether the first point should be passed to the\nunderlying fixed step size step handler.",
      "@param last Whether the last point should be passed to the\nunderlying fixed step size step handler.",
      "@param time time at which all arrays are defined",
      "@param stepSize step size used in the scaled and Nordsieck arrays",
      "@param scaledDerivative reference to the integrator array holding the first\nscaled derivative",
      "@param nordsieckVector reference to the integrator matrix holding the\nNordsieck vector",
      "@param stepSize new step size to use in the scaled and Nordsieck arrays",
      "@param interpolator interpolator to copy from. The copy is a deep\ncopy: its arrays are separated from the original arrays of the\ninstance",
      "@param newField field to which the time and state vector elements belong",
      "@param newYDotK slopes at the intermediate points",
      "@param coefficients coefficients to apply to the method staged derivatives",
      "@return combined state",
      "@param a array to add to",
      "@return a itself, as a convenience for fluent API",
      "@param yDotK slopes at the intermediate points",
      "@param mapper equations mapper for the all equations",
      "@param step integration step",
      "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
   ],
   [
      "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this",
      "@param p numerator",
      "@param q denominator",
      "@return p/q computed in the instance field",
      "@return external weights for the high order method from Butcher array",
      "@return order of the method",
      "@param yDotK derivatives computed during the first stages",
      "@param y0 estimate of the step at the start of the step",
      "@param y1 estimate of the step at the end of the step",
      "@param h current step",
      "@return error ratio, greater than 1 if step should be rejected",
      "@param fsal index of the pre-computed derivative for <i>fsal</i> methods\nor -1 if method is not <i>fsal</i>",
      "@param highOrder high order scaled derivatives\n(h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))",
      "@param start first order scaled derivatives at step start",
      "@param end first order scaled derivatives at step end",
      "@param highOrder high order scaled derivatives, will be modified\n(h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))",
      "@param nSteps number of steps of the method excluding the one being computed",
      "@param performStabilityCheck if true, stability check will be performed,\n     if false, the check will be skipped",
      "@param maxNumIter maximal number of iterations for which checks are\nperformed (the number of iterations is reset to default if negative\nor null)",
      "@param maxNumChecks maximal number of checks for each iteration\n(the number of checks is reset to default if negative or null)",
      "@param stepsizeReductionFactor stepsize reduction factor in case of\nfailure (the factor is reset to default if lower than 0.0001 or\ngreater than 0.9999)",
      "@param control1 first stepsize control factor (the factor is\nreset to default if lower than 0.0001 or greater than 0.9999)",
      "@param control2 second stepsize control factor (the factor\nis reset to default if lower than 0.0001 or greater than 0.9999)",
      "@param control3 third stepsize control factor (the factor is\nreset to default if lower than 0.0001 or greater than 0.9999)",
      "@param control4 fourth stepsize control factor (the factor\nis reset to default if lower than 1.0001 or greater than 999.9)"
   ],
   [
      "@param maximalOrder maximal order in the extrapolation table (the\nmaximal order is reset to default if order <= 6 or odd)",
      "@param control1 first order control factor (the factor is\nreset to default if lower than 0.0001 or greater than 0.9999)",
      "@param control2 second order control factor (the factor\nis reset to default if lower than 0.0001 or greater than 0.9999)",
      "@param useInterpolationErrorForControl if true, interpolation error is used\nfor stepsize control",
      "@param mudifControlParameter interpolation order control parameter (the parameter\nis reset to default if <= 0 or >= 7)",
      "@param y1 first state vector to use for scaling",
      "@param y2 second state vector to use for scaling",
      "@param scale scaling array to update (can be shorter than state)",
      "@param step global step",
      "@param k iteration number (from 0 to sequence.length - 1)",
      "@param scale scaling array (can be shorter than state)",
      "@param f placeholder where to put the state vector derivatives at each substep\n         (element 0 already contains initial derivative)",
      "@param yMiddle placeholder where to put the state vector at the middle of the step",
      "@param yEnd placeholder where to put the state vector at the end",
      "@param yTmp placeholder for one state vector",
      "@return true if computation was done properly,\n        false if stability check failed before end of computation",
      "@param offset offset to use in the coefficients table",
      "@param k index of the last updated point",
      "@param diag working diagonal of the Aitken-Neville's\ntriangle, without the last element",
      "@param last last element",
      "@param fsal indicate that the method is an <i>fsal</i>",
      "@param c time steps from Butcher array (without the first zero)",
      "@param a internal weights from Butcher array (without the first empty row)",
      "@param b propagation weights for the high order method from Butcher array",
      "@param prototype prototype of the step interpolator to use"
   ],
   [
      "@return Nordsieck transformer for the specified number of steps",
      "@return number of steps of the method\n(excluding the one being computed)",
      "@return P matrix",
      "@param n number of steps of the multistep method\n(excluding the one being computed)",
      "@param rkIntegrator integrator being used",
      "@param yDotArray reference to the integrator array holding all the\nintermediate slopes",
      "@param maxDegree maximal degree to handle",
      "@param mu degree of the interpolation polynomial",
      "@param scale scaling array",
      "@return estimate of the interpolation error",
      "@param y reference to the integrator array holding the current state",
      "@param y0Dot reference to the integrator array holding the slope\nat the beginning of the step",
      "@param y1 reference to the integrator array holding the state at\nthe end of the step",
      "@param y1Dot reference to the integrator array holding the slope\nat the end of the step",
      "@param yMidDots reference to the integrator array holding the\nderivatives at the middle point of the step",
      "@param absoluteTolerance allowed absolute error",
      "@param relativeTolerance allowed relative error",
      "@param forward forward integration indicator",
      "@param scale scaling vector for the state vector (can be shorter than state vector)",
      "@param t0 start time",
      "@param y0 state vector at t0",
      "@param yDot0 first time derivative of y0",
      "@param y1 work array for a state vector",
      "@param yDot1 work array for the first time derivative of y1",
      "@return first integration step"
   ],
   [
      "@param h signed step",
      "@throws NullArgumentException if any of the arguments are null",
      "@return a new array {@code r} where {@code r[i] = a[i] - b[i]}.",
      "@throws DimensionMismatchException if the lengths differ and\n{@code abort} is {@code true}.",
      "@throws NullArgumentException if input array is null",
      "@throws NotPositiveException if any array entries are less than 0.",
      "@throws NullArgumentException if {@code x} or any {@code y} is null.",
      "@throws NullArgumentException if {@code x} or any {@code y} is null",
      "@throws NullArgumentException if either {@code x} or {@code h} is {@code null}.",
      "@throws NoDataException if either {@code x} or {@code h} is empty.",
      "@throws NullPointerException if any of the arrays are null",
      "@throws NullPointerException if data is null",
      "@throws ArrayIndexOutOfBoundsException if <code>index</code> is less than\n        zero or is greater than <code>getNumElements() - 1</code>.",
      "@throws ArrayIndexOutOfBoundsException if <code>index</code> is less than\n        zero.",
      "@throws NullArgumentException if {@code cb} is {@code null}",
      "@throws NullArgumentException if {@code other} is null",
      "@throws NullArgumentException if the collection is null",
      "@throws MathIllegalArgumentException if {@code initialCapacity <= 0}.",
      "@throws NumberIsTooSmallException if {@code contraction <= 1}.",
      "@throws NumberIsTooSmallException if {@code contraction < expansion}.",
      "@throws NumberIsTooSmallException if {@code expansion <= 1 }.",
      "@throws ArrayIndexOutOfBoundsException if <code>index</code> is less than\nzero or is greater than <code>getNumElements() - 1</code>.",
      "@throws ArrayIndexOutOfBoundsException if {@code index < 0}.",
      "@throws MathIllegalArgumentException if expansionFactor is <= 1 or greater\nthan contractionFactor",
      "@throws MathIllegalArgumentException if <code>initialCapacity</code> is not\npositive."
   ],
   [
      "@throws MathIllegalArgumentException if <code>i</code> is negative.",
      "@throws NotStrictlyPositiveException if {@code alpha <= 0} or\n{@code beta <= 0}.",
      "@throws NotStrictlyPositiveException if {@code alpha <= 0} or {@code beta <= 0}.",
      "@throws NotStrictlyPositiveException if {@code sampleSize} is not\npositive.",
      "@throws NotStrictlyPositiveException if {@code sampleSize} is not positive.",
      "@throws NullArgumentException if {@code array} is null",
      "@throws NotStrictlyPositiveException if the dimension is\nnot positive.",
      "@throws MathIllegalArgumentException if values is null or the indices are invalid",
      "@throws IllegalArgumentException if {@code min > max} or the endpoints\ndo not satisfy the requirements specified by the optimizer.",
      "@throws org.apache.commons.math3.exception.NullArgumentException if any\nargument is {@code null}.",
      "@param n the number to factor, must be &gt; 0.",
      "@param n the number to factorize, must be >= PRIME_LAST+2 and must not contain any factor below PRIME_LAST+2",
      "@throws MathIllegalArgumentException if points are null or the number of\n  data points is not compatible with this clusterer",
      "@throws NumberIsTooLargeException if {@code lower > upper}.",
      "@throws NumberIsTooLargeException if maximal number of iterations\nis greater than {@link #TRAPEZOID_MAX_ITERATIONS_COUNT}",
      "@param maximalIterationCount maximum number of iterations\n(must be less than or equal to {@link #TRAPEZOID_MAX_ITERATIONS_COUNT}",
      "@throws NumberIsTooSmallException if the number of generations is &lt; 1",
      "@param acceptSmall if true, steps smaller than the minimal value\nare silently increased up to this value, if false such small\nsteps generate an exception",
      "@return a bounded integration step (h if no bound is reach, or a bounded value)",
      "@throws NumberIsTooSmallException if the step is too small and acceptSmall is false",
      "@return minimal step",
      "@return maximal step",
      "@return time steps from Butcher array (without the first zero",
      "@return internal weights from Butcher array (without the first empty row)",
      "@param t target time for the integration\n(can be set to a value smaller than {@code t0} for backward integration)"
   ],
   [
      "@return state vector at {@code t}",
      "@param reference reference state",
      "@param time time at which state must be estimated",
      "@param scaled first scaled derivative",
      "@param nordsieck Nordsieck vector",
      "@return estimated state",
      "@param <S> the type of the field elements",
      "@param reference reference state from which Taylor expansion are estimated",
      "@return Nordsieck transformer for the specified field and number of steps",
      "@param previousState state vector at step start",
      "@param predictedState predicted state vector at step end",
      "@param predictedScaled predicted value of the scaled derivatives at step end",
      "@param predictedNordsieck predicted value of the Nordsieck vector at step end",
      "@return estimated normalized local discretization error",
      "@param state0 state at integration start time",
      "@param mapper mapper for all the equations",
      "@return dimension of the secondary state parameters",
      "@param primary0 array containing the value of the primary state vector at integration start",
      "@param secondary0 array containing the value of the secondary state vector at integration start",
      "@param primary array containing the current value of the primary state vector",
      "@param primaryDot array containing the derivative of the primary state vector",
      "@param secondary array containing the current value of the secondary state vector",
      "@return derivative of the secondary state vector",
      "@param yDot array containing the current value of the time derivative of the main state vector",
      "@param dFdY placeholder array where to put the jacobian matrix of the ODE w.r.t. the main state vector"
   ],
   [
      "@param secondaryDot placeholder array where to put the derivative of the secondary state vector",
      "@param maxIterationCount upper limit of the iteration count in\nthe event time search events.",
      "@param solver solver to use to locate the event",
      "@return current value of the state at step start time t<sub>i</sub>",
      "@param finalTime target time for the integration\n(can be set to a value smaller than {@code t0} for backward integration)",
      "@return final state, its time will be the same as {@code finalTime} if\nintegration reached its target, but may be different if some {@link\norg.apache.commons.math3.ode.events.FieldEventHandler} stops it at some point.",
      "@param fode main first order differential equations set",
      "@param pode secondary problem, without parameter Jacobian computation skill",
      "@param paramsAndSteps parameters and steps to compute the Jacobians df/dp",
      "@return number of equations mapped",
      "@param state state to map",
      "@return flat array containing the mapped state, including primary and secondary components",
      "@return flat array containing the mapped state derivative, including primary and secondary components",
      "@param t time",
      "@param y state array to map, including primary and secondary components",
      "@param yDot state derivative array to map, including primary and secondary components",
      "@return mapped state",
      "@throws DimensionMismatchException if an array does not match total dimension",
      "@param index index of the equation, must be between 0 included and\n{@link #getNumberOfEquations()} (excluded)",
      "@param complete complete state or derivative array from which\nequation data should be retrieved",
      "@return equation data",
      "@throws MathIllegalArgumentException if index is out of range",
      "@throws DimensionMismatchException if complete state has not enough elements",
      "@param equationData equation data to be inserted into the complete array",
      "@param complete placeholder where to put equation data (only the\npart corresponding to the equation will be overwritten)"
   ],
   [
      "@throws DimensionMismatchException if either array has not enough elements",
      "@param mapper former mapper, with one equation less (null for first equation)",
      "@param dimension dimension of the equation state vector",
      "@return mapper for the set of equations",
      "@return index of the secondary equation in the expanded state, to be used\nas the parameter to {@link FieldODEState#getSecondaryState(int)} and\n{@link FieldODEStateAndDerivative#getSecondaryDerivative(int)} (beware index\n0 corresponds to main state, additional states start at 1)",
      "@return time derivative of the complete state vector",
      "@return dimension of the underlying FODE",
      "@param ode original first order differential equations",
      "@param equations equations to set",
      "@throws NullPointerException if the ODE equations have not been set (i.e. if this method\nis called outside of a call to {@link #integrate(ExpandableStatefulODE, double)} or {@link\n#integrate(FirstOrderDifferentialEquations, double, double[], double, double[])})",
      "@param y state vector at step end time, must be reset if an event\nasks for resetting or if an events stops integration during the step",
      "@return time at end of step",
      "@param equations set of differential equations",
      "@param yDot array containing the current value of the first derivative\nof the state vector",
      "@param yDDot placeholder array where to put the second time derivative\nof the state vector",
      "@param name name of the parameter to check",
      "@param names names of the supported parameters",
      "@return the name of the unknown parameter.",
      "@param name parameter name.",
      "@param secondaryStateIndex index of the secondary set, as returned by {@link\norg.apache.commons.math3.ode.ExpandableStatefulODE#addSecondaryEquations(\norg.apache.commons.math3.ode.SecondaryEquations)\nExpandableStatefulODE.addSecondaryEquations(SecondaryEquations)}",
      "@return index of the first equation element in complete state arrays",
      "@param equationData placeholder where to put equation data",
      "@throws DimensionMismatchException if the dimension of the equation data does not\nmatch the mapper dimension",
      "@param firstIndex index of the first equation element in complete state arrays",
      "@param dimension dimension of the secondary state parameters"
   ],
   [
      "@param g raw value of function g",
      "@return transformed value of function g",
      "@return underlying event handler",
      "@return maximal time interval between events handler checks",
      "@return convergence threshold for event localization",
      "@return upper limit in the iteration count for event localization",
      "@param interpolator valid for the current step",
      "@param interpolator step interpolator for the proposed step",
      "@return true if the event handler triggers an event before\nthe end of the proposed step",
      "@throws NoBracketingException if the event cannot be bracketed",
      "@return occurrence time of the event triggered in the current\nstep or infinity if no events are triggered",
      "@param state state at the end of the step",
      "@return true if the integration should be stopped",
      "@param state state at the beginning of the next step",
      "@return reset state (may by the same as initial state if only\nderivatives should be reset), or null if nothing is reset",
      "@param solver Root-finding algorithm to use to detect state events",
      "@param state current value of the independent <i>time</i> variable, state vector\nand derivative",
      "@return value of the g switching function",
      "@param increasing if true, the value of the switching function increases\nwhen times increases around event (note that increase is measured with respect\nto physical time, not with respect to integration which may go backward in time)",
      "@return indication of what the integrator should do next, this\nvalue must be one of {@link Action#STOP}, {@link Action#RESET_STATE},\n{@link Action#RESET_DERIVATIVES} or {@link Action#CONTINUE}",
      "@return reset state (note that it does not include the derivatives, they will\nbe added automatically by the integrator afterwards)",
      "@param t current value of the independent <i>time</i> variable",
      "@param y array containing the current value of the state vector\nthe new state should be put in the same array",
      "@param expandable equation being integrated",
      "@param interpolator interpolator to use"
   ],
   [
      "@return complete state",
      "@param t value of the independent <i>time</i> variable at the\nend of the step",
      "@param y array containing the current value of the state vector\nat the end of the step",
      "@param t value of the independent <i>time</i> variable at the\nbeginning of the next step",
      "@param y array were to put the desired state vector at the beginning\nof the next step",
      "@return true if the integrator should reset the derivatives too",
      "@param rawHandler event handler to wrap",
      "@param filter filter to use",
      "@return true if triggered events are increasing events",
      "@param previous transformer active on the previous point with respect\nto integration direction (may be null if no previous point is known)",
      "@param g current value of the g function",
      "@return next transformer transformer",
      "@param name parameter name",
      "@return parameter value",
      "@param value parameter value",
      "@param y placeholder where to put the state vector at each successful\n step (and hence at the end of integration), can be the same object as y0",
      "@return stop time, will be the same as target time if integration reached its\ntarget, but may be different if some {@link\norg.apache.commons.math3.ode.events.EventHandler} stops it at some point.",
      "@return returns the NaNStrategy",
      "@return the TiesStrategy",
      "@param data array to be ranked",
      "@return array of ranks",
      "@throws NotANumberException if the selected {@link NaNStrategy} is {@code FAILED}\nand a {@link Double#NaN} is encountered in the input data",
      "@param ranks input array",
      "@return array with NaN-valued entries removed",
      "@param ranks array to recode"
   ],
   [
      "@param value the value to replace NaNs with",
      "@param ranks array to be searched for NaNs",
      "@return true iff ranks contains one or more NaNs",
      "@param ranks array of ranks",
      "@param tiesTrace list of indices where <code>ranks</code> is constant\n-- that is, for any i and j in TiesTrace, <code> ranks[i] == ranks[j]\n</code>",
      "@param data array to modify",
      "@param tiesTrace list of index values to set",
      "@param value value to set",
      "@param ranks array to modify",
      "@param nanPositions list of index values to set to <code>Double.NaN</code>",
      "@param ranks array to search for <code>NaNs</code>",
      "@return list of indexes i such that <code>ranks[i] = NaN</code>",
      "@param tiesStrategy the TiesStrategy to use",
      "@param nanStrategy the NaNStrategy to use",
      "@param nanStrategy NaNStrategy to use",
      "@param tiesStrategy TiesStrategy to use",
      "@param randomGenerator source of random data",
      "@param data array of data to be ranked",
      "@return an array of ranks corresponding to the elements of the input array",
      "@param values array of values to sum",
      "@return the sum of the values or <code>Double.NaN</code> if the array\nis empty",
      "@return the sum of the squared values or <code>Double.NaN</code> if the\narray is empty",
      "@return the sum of the squares of the values or Double.NaN if length = 0",
      "@return the product of the values or Double.NaN if the array is empty",
      "@return the sum of the natural logs of the values or Double.NaN if\nthe array is empty"
   ],
   [
      "@return the sum of the natural logs of the values or Double.NaN if\nlength = 0",
      "@return the mean of the values or Double.NaN if the array is empty",
      "@return the geometric mean of the values or Double.NaN if the array is empty",
      "@return the geometric mean of the values or Double.NaN if length = 0",
      "@return the population variance of the values or Double.NaN if the array is empty",
      "@return the population variance of the values or Double.NaN if length = 0",
      "@return the maximum of the values or Double.NaN if the array is empty",
      "@return the minimum of the values or Double.NaN if the array is empty",
      "@param sample1 the first array",
      "@param sample2 the second array",
      "@return sum of paired differences",
      "@throws DimensionMismatchException if the arrays do not have the same\n(positive) length.",
      "@throws NoDataException if the sample arrays are empty.",
      "@return mean of paired differences",
      "@param meanDifference the mean difference between corresponding entries",
      "@return variance of paired differences",
      "@throws DimensionMismatchException if the arrays do not have the same\nlength.",
      "@param sample Sample to normalize.",
      "@return normalized (standardized) sample.",
      "@param sample input data",
      "@return array of array of the most frequently occurring element(s) sorted in ascending order.",
      "@param begin index (0-based) of the first array element to include",
      "@param values input data",
      "@param numberOfTrials number of trials",
      "@param numberOfSuccesses number of successes"
   ],
   [
      "@param confidenceLevel desired probability that the true probability of\n       success falls within the returned interval",
      "@return Confidence interval containing the probability of success with\n        probability {@code confidenceLevel}",
      "@throws OutOfRangeException if {@code confidenceLevel} is not in the interval {@code (0, 1)}.",
      "@param confidenceLevel desired probability that the true probability of\n       success falls within the interval",
      "@param numberOfSuccesses number of successes (must not exceed numberOfTrials)",
      "@return the lower endpoint of the interval",
      "@return the upper endpoint of the interval",
      "@return the asserted probability that the interval contains the\n        population parameter",
      "@return String representation of the confidence interval",
      "@param lower lower endpoint",
      "@param upper upper endpoint",
      "@param confidence confidence level",
      "@param lowerBound lower endpoint of the interval",
      "@param upperBound upper endpoint of the interval",
      "@param confidenceLevel coverage probability",
      "@throws MathIllegalArgumentException if the preconditions are not met",
      "@param biasCorrected if the covariance estimate shall be corrected for bias",
      "@param i the row index",
      "@param j the column index",
      "@return the corresponding index in the matrix array",
      "@return the {@link StorelessBivariateCovariance} element at the given index",
      "@param cov the {@link StorelessBivariateCovariance} element to be set",
      "@param xIndex row index in the covariance matrix",
      "@param yIndex column index in the covariance matrix",
      "@return the covariance of the given element"
   ],
   [
      "@throws NumberIsTooSmallException if the number of observations\nin the cell is &lt; 2",
      "@param data array representing one row of data.",
      "@throws DimensionMismatchException if the length of <code>rowData</code>\ndoes not match with the covariance matrix",
      "@param sc externally computed StorelessCovariance to add to this",
      "@throws DimensionMismatchException if the dimension of sc does not match this",
      "@throws NumberIsTooSmallException if the number of observations\nin a cell is &lt; 2",
      "@return a two-dimensional double array of covariance values",
      "@throws NumberIsTooSmallException if the number of observations\nfor a cell is &lt; 2",
      "@return nothing as this implementation always throws a\n{@link MathUnsupportedOperationException}",
      "@throws MathUnsupportedOperationException in all cases",
      "@param dim the dimension of the square covariance matrix",
      "@param dim the dimension of the covariance matrix",
      "@param biasCorrected if <code>true</code> the covariance estimate is corrected\nfor bias, i.e. n-1 in the denominator, otherwise there is no bias correction,\ni.e. n in the denominator.",
      "@param x the x value",
      "@param y the y value",
      "@param cov StorelessBivariateCovariance instance to append.",
      "@return the current covariance",
      "@throws NumberIsTooSmallException if the number of observations\nis &lt; 2",
      "@param biasCorrection if <code>true</code> the covariance estimate is corrected\nfor bias, i.e. n-1 in the denominator, otherwise there is no bias correction,\ni.e. n in the denominator.",
      "@return correlation matrix",
      "@param matrix matrix with columns representing variables to correlate",
      "@param xArray first data array",
      "@param yArray second data array",
      "@return Returns Kendall's Tau rank correlation coefficient for the two arrays",
      "@throws DimensionMismatchException if the arrays lengths do not match"
   ],
   [
      "@param n the summation end",
      "@return the sum of the number from 1 to n",
      "@param data rectangular array with columns representing variables",
      "@throws IllegalArgumentException if the input data array is not\nrectangular with at least two rows and two columns.",
      "@param matrix input matrix (must have at least one column and two rows)",
      "@param biasCorrected determines whether or not covariance estimates are bias-corrected",
      "@throws MathIllegalArgumentException if the matrix does not contain sufficient data",
      "@throws MathIllegalArgumentException if matrix does not contain sufficient data",
      "@param data input array (must have at least one column and two rows)",
      "@throws MathIllegalArgumentException if the data array does not contain sufficient\ndata",
      "@throws NotStrictlyPositiveException if the input data array is not\nrectangular with at least one row and one column.",
      "@throws MathIllegalArgumentException if the data array does not contain sufficient data",
      "@param biasCorrected if true, returned value will be bias-corrected",
      "@return returns the covariance for the two arrays",
      "@throws MathIllegalArgumentException if the arrays lengths do not match or\nthere is insufficient data",
      "@param matrix matrix to check",
      "@throws MathIllegalArgumentException if the matrix does not contain sufficient data\nto compute covariance",
      "@param data rectangular array with columns representing covariates",
      "@throws MathIllegalArgumentException if the input data array is not\nrectangular with at least two rows and one column.",
      "@param matrix matrix with columns representing covariates",
      "@throws MathIllegalArgumentException if the input matrix does not have\nat least two rows and one column",
      "@return matrix of correlation standard errors",
      "@throws NullPointerException if this instance was created with no data",
      "@return matrix of p-values",
      "@throws org.apache.commons.math3.exception.MaxCountExceededException if an error occurs estimating probabilities"
   ],
   [
      "@param data matrix with columns representing variables to correlate",
      "@throws MathIllegalArgumentException if the array does not contain sufficient data",
      "@return Returns Pearson's correlation coefficient for the two arrays",
      "@throws MathIllegalArgumentException if there is insufficient data",
      "@param covarianceMatrix the covariance matrix",
      "@param matrix matrix to check for sufficiency",
      "@throws MathIllegalArgumentException if the input data array is not\nrectangular with at least two rows and two columns.",
      "@param covariance Covariance instance",
      "@param covarianceMatrix covariance matrix",
      "@param numberOfObservations the number of observations in the dataset used to compute\nthe covariance matrix",
      "@return Spearman Rank Correlation Matrix",
      "@return PearsonsCorrelation among ranked column data",
      "@return Returns Spearman's rank correlation coefficient for the two arrays",
      "@return a rank-transformed matrix",
      "@param input the input array",
      "@return a list of NaN positions in the input array",
      "@param indices a set containing the indices to be removed",
      "@return the input array without the values at the specified indices",
      "@param rankingAlgorithm ranking algorithm",
      "@param dataMatrix matrix of data with columns representing\nvariables to correlate",
      "@return a reference (not a copy!) to the wrapped array",
      "@param p the point to compute the distance from",
      "@return the distance from the given point",
      "@param p the Collection of points to compute the centroid of",
      "@return the centroid of the given Collection of Points"
   ],
   [
      "@param maxIterationsPerTrial the maximum number of iterations to run the algorithm\n    for at each trial run.  If negative, no maximum will be used",
      "@param maxIterations the maximum number of iterations to run the algorithm\n    for.  If negative, no maximum will be used",
      "@param <T> type of the points to cluster",
      "@param k the number of centers to choose",
      "@param random random generator to use",
      "@param sample1 array of sample data values",
      "@param sample2 array of sample data values",
      "@return t statistic",
      "@throws NoDataException if the arrays are empty",
      "@throws DimensionMismatchException if the length of the arrays is not equal",
      "@return p-value for t-test",
      "@param mu comparison constant",
      "@param observed array of values",
      "@param sampleStats DescriptiveStatistics holding sample summary statitstics",
      "@throws NumberIsTooSmallException if the number of samples is &lt; 2",
      "@param sampleStats1 StatisticalSummary describing data from the first sample",
      "@param sampleStats2 StatisticalSummary describing data from the second sample",
      "@param mu constant value to compare sample mean against",
      "@param sample array of sample data values",
      "@throws MaxCountExceededException if an error computing the p-value",
      "@param sampleStats StatisticalSummary describing sample data",
      "@param sampleStats StatisticalSummary describing sample data values",
      "@param sampleStats1 StatisticalSummary describing sample data values",
      "@param sampleStats2 StatisticalSummary describing sample data values",
      "@return approximate degrees of freedom"
   ],
   [
      "@throws java.lang.IllegalArgumentException If the channels are {@code null}, an empty collection,\n        or any of them do not have the same ChannelType as the one\n        provided.",
      "@param channels The {@link GuildChannel Channels} to order, all of which\n        are on the same Guild specified, and all of which are of the same generic type of GuildChannel\n        corresponding to the the ChannelType specified.",
      "@throws IllegalArgumentException If the provided name is null or not between 1 and  {@value ForumTag#MAX_NAME_LENGTH} characters long",
      "@throws IllegalArgumentException If null is provided or the tag has an invalid name",
      "@param tag The base tag to use",
      "@throws IllegalArgumentException If the provided permission holder is null, or from a different guild",
      "@param permissionHolder The {@link net.dv8tion.jda.api.entities.Member Member} or {@link net.dv8tion.jda.api.entities.Role Role} whose\n        {@link net.dv8tion.jda.api.entities.PermissionOverride PermissionOverride} is requested.",
      "@return a pair formed from the two parameters, not null",
      "@return True, if the specified member is able to read and send messages in this channel",
      "@throws java.lang.IllegalArgumentException <ul>\n            <li>If provided {@code messageId} is {@code null} or empty.</li>\n            <li>If provided {@code emoji} is {@code null}.</li>\n        </ul>",
      "@throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException If the currently logged in account does not have\n        {@link net.dv8tion.jda.api.Permission#MESSAGE_MANAGE Permission.MESSAGE_MANAGE} in this channel.",
      "@param messageId The messageId to remove the reaction from",
      "@param emoji The emoji to remove",
      "@param user The target user of which to remove from",
      "@throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException If this account does not have {@link net.dv8tion.jda.api.Permission#MESSAGE_MANAGE Permission.MESSAGE_MANAGE}",
      "@throws IllegalArgumentException If the size of the list less than 2 or more than 100 messages.",
      "@param messages The collection of messages to delete.",
      "@return {@link net.dv8tion.jda.api.requests.restaction.AuditableRestAction AuditableRestAction}",
      "@throws java.lang.NumberFormatException If any of the provided ids cannot be parsed by {@link Long#parseLong(String)}",
      "@throws java.lang.IllegalArgumentException If the size of the list less than 2 or more than 100 messages.",
      "@throws java.lang.IllegalArgumentException If the provided {@code id} is {@code null} or empty.",
      "@param messageId The not-empty valid message id",
      "@throws InsufficientPermissionException If the currently logged in account does not have {@link Permission#MESSAGE_MANAGE} in the channel",
      "@throws IllegalArgumentException If provided with null",
      "@param messageId The id for the target message"
   ],
   [
      "@param emoji The {@link Emoji} to remove reactions for",
      "@throws IllegalArgumentException <ul>\n          <li>If any of the provided stickers is a {@link GuildSticker},\n              which is either {@link GuildSticker#isAvailable() unavailable} or from a different guild.</li>\n          <li>If the list is empty or has more than 3 stickers</li>\n          <li>If null is provided</li>\n        </ul>",
      "@throws MissingAccessException If the currently logged in account does not have {@link Permission#VIEW_CHANNEL Permission.VIEW_CHANNEL} in this channel",
      "@throws InsufficientPermissionException <ul>\n          <li>If this is a {@link ThreadChannel} and the bot does not have {@link Permission#MESSAGE_SEND_IN_THREADS Permission.MESSAGE_SEND_IN_THREADS}</li>\n          <li>If this is not a {@link ThreadChannel} and the bot does not have {@link Permission#MESSAGE_SEND Permission.MESSAGE_SEND}</li>\n        </ul>",
      "@param stickers Collection of 1-3 stickers to send",
      "@param stickers The 1-3 stickers to send",
      "@throws IllegalArgumentException if any of the provided parameters is {@code null}\n        or the provided entities are not from the same guild",
      "@param issuer The member that tries to interact with 2nd member",
      "@param target The member that is the target of the interaction",
      "@param issuer The member that tries to interact with the role",
      "@param target The role that is the target of the interaction",
      "@param issuer The member that tries to interact with the Emoji",
      "@param emoji The emoji that is the target interaction",
      "@throws IllegalArgumentException if any of the provided parameters is null",
      "@param member The {@link net.dv8tion.jda.api.entities.Member Member} whose permissions are being checked.",
      "@param permissions The {@link net.dv8tion.jda.api.Permission Permissions} being checked for.",
      "@throws IllegalArgumentException If any of the arguments is {@code null}\n        or the specified entities are not from the same {@link net.dv8tion.jda.api.entities.Guild Guild}",
      "@param role The non-null {@link net.dv8tion.jda.api.entities.Role Role} for which to get implicit permissions",
      "@param channel The target channel of which to check {@link net.dv8tion.jda.api.entities.PermissionOverride PermissionOverrides}",
      "@throws IllegalArgumentException If null is provided or the path is empty",
      "@param root The root data object, which is the top level accessor.\n        <br>The very first element in the path corresponds to a field of that name within this root object.",
      "@param path The path of the value, in accordance with the described grammar by {@link DataPath}.\n        This must start with a name element, such as {@code \"foo\"}.",
      "@param fromObject Object relative resolver of the value, this is used for the final reference and resolves the value.\n        The first parameter is the {@link DataObject} where you get the value from, and the second is the field name.\n        An example would be {@code (obj, name) -> obj.getString(name)} or as a method reference {@code DataObject::getString}.",
      "@param fromArray Array relative resolver of the value, this is used for the final reference and resolves the value.\n        The first parameter is the {@link DataArray} where you get the value from, and the second is the field index.\n        An example would be {@code (array, index) -> obj.getString(index)} or as a method reference {@code DataArray::getString}.",
      "@param root The root data array, which is the top level accessor.\n        <br>The very first element in the path corresponds to a field of that name within this root object."
   ],
   [
      "@param path The path of the value, in accordance with the described grammar by {@link DataPath}.\n        This must start with an index element, such as {@code \"[0]\"}.",
      "@throws IllegalArgumentException If cache is enabled, and you are attempting to skip forward in time {@literal (id > last)}",
      "@throws IllegalArgumentException If the provided pagination order is null or unsupported",
      "@throws IllegalStateException If this pagination action has already been used to retrieve entities",
      "@param order The pagination order",
      "@return True, if no entities have been retrieved yet.",
      "@return Immutable {@link java.util.List List} containing all currently cached entities for this PaginationAction",
      "@throws java.util.NoSuchElementException If no entities have been retrieved yet (see {@link #isEmpty()})",
      "@throws java.lang.IllegalArgumentException If the provided limit is out of range",
      "@return The maximum limit",
      "@return The minimum limit",
      "@return limit",
      "@throws IllegalArgumentException If the provided rule is {@code null}",
      "@param rule The rule which must be fulfilled for an element to be added,\n        returns false to discard the element and finish the task",
      "@throws IllegalArgumentException If the provided rule is {@code null} or the limit is negative",
      "@param rule The rule which must be fulfilled for an element to be discarded,\n        returns true to discard the element and finish the task",
      "@throws java.lang.IllegalArgumentException If the provided Procedure is {@code null}",
      "@param action {@link net.dv8tion.jda.api.utils.Procedure Procedure} returning {@code true} if iteration should continue!",
      "@throws java.lang.IllegalArgumentException If the provided Procedure or the failure Consumer is {@code null}",
      "@param failure {@link java.util.function.Consumer Consumer} that should handle any throwables from the action",
      "@throws IllegalArgumentException If this pagination action does not support the reversed order",
      "@param value The new stabilization limit, 0 means no need to stabilize.\n           Else a value larger than zero or equal to 1 is accepted.",
      "@param autoCreate If true (and strict checking is false), nodes are\n           automatically created when referenced when creating a edge,\n           even if not yet inserted in the graph.",
      "@param digraph true if the graph is directed",
      "@param digraph true is exported graph is directed"
   ],
   [
      "@param oldValue The old value of the attribute, null if the attribute was\n           added.",
      "@param newValue The new value of the attribute, null if the attribute is about\n           to be removed.",
      "@return The group set or null.",
      "@return The word eaten.",
      "@param on true to enable autoflush",
      "@param on true to enable message for this event",
      "@param on true to enable events",
      "@param replay true if the source should be replayed. You need a\n           {@link org.graphstream.stream.Replayable} source to enable\n           replay, else nothing happens.",
      "@param on If true the environment is locked.",
      "@return A singleton instance of the global environment.",
      "@return The parameter value (empty string if not set).",
      "@throws NullPointerException if source array is null",
      "@throws NullPointerException if <tt>s</tt> is null",
      "@throws NullPointerException if encodedObject is null",
      "@throws NullPointerException if dataToEncode is null",
      "@return <code>true</code> if the path contains the node.",
      "@return <code>true</code> if the path contains the edge.",
      "@return A value.",
      "@return The diagonal.",
      "@return The size.",
      "@throws NullPointerException If a null value is inserted.",
      "@return Always true.",
      "@param element The element to test.",
      "@return True if the element is visible and therefore must be rendered.",
      "@param graph The graph to search for."
   ],
   [
      "@param x The point abscissa.",
      "@param y The point ordinate.",
      "@return The first node or sprite at the given coordinates or null if\n        nothing found.",
      "@param x1 The rectangle lowest point abscissa.",
      "@param y1 The rectangle lowest point ordinate.",
      "@param x2 The rectangle highest point abscissa.",
      "@param y2 The rectangle highest point ordinate.",
      "@return The set of sprites and nodes in the given rectangle.",
      "@param sprite The sprite.",
      "@param pos Receiver for the sprite 2D position, can be null.",
      "@param units The units in which the position must be computed (the sprite\n           already contains units).",
      "@return The same instance as the one given by parameter pos or a new one\n        if pos was null, containing the computed position in the given\n        units.",
      "@param g2 The Swing graphics to change.",
      "@param g2 The Swing graphics to restore.",
      "@param g2 The Swing graphics.",
      "@param on If true, automatic adjustment is enabled.",
      "@param z The zoom.",
      "@param theta The rotation angle in degrees.",
      "@param viewportWidth The width in pixels of the view port.",
      "@param viewportHeight The width in pixels of the view port.",
      "@param graph The graphic graph.",
      "@param sprite The sprite to check.",
      "@return True if visible.",
      "@param edge The edge to check.",
      "@param node The node to check."
   ],
   [
      "@param X1 The min abscissa of the area.",
      "@param Y1 The min ordinate of the area.",
      "@param X2 The max abscissa of the area.",
      "@param Y2 The max ordinate of the area.",
      "@return True if the node lies in the given area.",
      "@param elt The node.",
      "@return True if (x,y) is in the given element.",
      "@param elt The sprite.",
      "@param pos Where to stored the computed position, if null, the position\n           is created.",
      "@param units The units the computed position must be given into.",
      "@return The same instance as pos, or a new one if pos was null.",
      "@param x0 The left corner of the area.",
      "@param y0 The bottom corner of the area.",
      "@param width The area width.",
      "@param height The area height.",
      "@param style The style.",
      "@return A gradient paint or null if the style does not specify a\n        gradient.",
      "@param x0 The start point abscissa.",
      "@param y0 The start point ordinate.",
      "@param x1 The end point abscissa.",
      "@param y1 The end point ordinate.",
      "@return A paint for the gradient or null if the style specifies no\n        gradient (the fill mode is not a linear gradient or there is only\n        one fill colour).",
      "@param cx The center point abscissa.",
      "@param cy The center point ordinate.",
      "@param fx The start point abscissa."
   ],
   [
      "@param fy The start point ordinate.",
      "@param radius The gradient radius.",
      "@return A paint for the gradient or null if the style specifies no\n        gradient (the fill mode is not a radial gradient or there is only\n        one fill colour).",
      "@return The lowest point.",
      "@return The highest point.",
      "@param value The value to convert.",
      "@param units The units the value to convert is expressed in.",
      "@return The value converted to GU.",
      "@param value The value to convert (it contains its own units).",
      "@param values The values set containing the value to convert (it contains\n           its own units).",
      "@param index Index of the value to convert.",
      "@return The value converted in pixels.",
      "@param ratio The ratio.",
      "@param minx Lowest abscissa.",
      "@param miny Lowest ordinate.",
      "@param minz Lowest depth.",
      "@param maxx Highest abscissa.",
      "@param maxy Highest ordinate.",
      "@param maxz Highest depth.",
      "@param outputName The name of the output to use, for some renderers it is a file,\nfor others it is an URL, a string description of the output, etc.",
      "@return The default singleton image cache instance.",
      "@param fileNameOrUrl A file name or an URL pointing at the image.",
      "@return An image or null if the image cannot be found.",
      "@param forceTryReload If true, try to reload an image that where not found before.",
      "@return An image."
   ],
   [
      "@param style The style to use.",
      "@param metrics The metrics to use.",
      "@return The stroke or null if the style specifies a \"none\" stroke mode.",
      "@return A font.",
      "@return The default singleton font cache instance.",
      "@param name The font name.",
      "@param style A style, taken from the styles available in the style sheets.",
      "@param size The font size in points.",
      "@param g The Swing graphics.",
      "@param camera The camera.",
      "@param element The graphic element concerned by the dynamic style change.",
      "@param element The element to render.",
      "@param x Point at which the edge crosses the node shape.",
      "@param y Point at which the edge crosses the node shape.",
      "@param dx The arrow vector (and length).",
      "@param dy The arrow vector (and length).",
      "@param edge The edge.",
      "@param metrics The metrics.",
      "@return The length from the node centre along the edge to position the\n        arrow.",
      "@param edge The edge representing the vector.",
      "@param w The ellipse first radius (width/2).",
      "@param h The ellipse second radius (height/2).",
      "@return The length of the radius along the edge vector.",
      "@param group The group to render.",
      "@return a Camera instance"
   ],
   [
      "@param readSteps If true, read several events (usually starting with a step\n           event, but it may be preceded by other events), until another\n           step is encountered.",
      "@param stop If true stop at the next step encountered (and push it back so\n           that is is readable at the next call to this method).",
      "@return True if it remains things to read.",
      "@param key The attribute name, already read.",
      "@param key attribute key",
      "@return a vector",
      "@param attribute must name the attribute.",
      "@param attribute_class must be the complete name of a Java class that will represent\n           the attribute.",
      "@param file Name of the file used as source for the tokenizer.",
      "@param file File name to be opened.",
      "@return a reader for the tokenizer.",
      "@throws FileNotFoundException If the given file does not exist or un readable.",
      "@param stream Input stream to be open as a reader.",
      "@param url The URL used as source for the tokenizer.",
      "@param stream The stream used as source for the tokenizer.",
      "@param name The name of the input stream.",
      "@param reader The reader used as source for the tokenizer.",
      "@param reader The reader.",
      "@return The new tokenizer.",
      "@throws IOException For any I/O error.",
      "@return The token read StreamTokenizer.TT_EOL or StreamTokenizer.TT_EOF.",
      "@param words The expected words.",
      "@param word1 The first word to eat.",
      "@param word2 The alternative word to eat.",
      "@return A string."
   ],
   [
      "@throws NumberFormatException if the <code>value</code> is not a truth value.",
      "@throws NumberFormatException if the <code>value</code> is not a double.",
      "@throws NumberFormatException if the <code>value</code> is not a long.",
      "@param eol_is_significant If true EOL will be returned as a token, else it is ignored.",
      "@param commentChar Character used for one line comments.",
      "@param quoteChar Character used to enclose quotations.",
      "@param fileName Name of the file to read.",
      "@throws IOException If an I/O error occurs while reading.",
      "@param url The URL of the file to read.",
      "@param stream The input stream to use for reading.",
      "@param reader The reader to use.",
      "@param reader The file reader to use.",
      "@return true if there are still events to read, false as soon as the file\n        is finished.",
      "@throws IOException If an I/O error occurs while closing the file.",
      "@param declareNodes If true (default=true) this reader outputs nodeAdded events.",
      "@return a new replay controller",
      "@param sink The sink to register.",
      "@param sink The sink to remove, if it does not exist, this is ignored\n           silently.",
      "@param graph The graph to export.",
      "@param filter The filter to use, it can be null to disable global attribute\n           filtering.",
      "@param filter The filter to use, it can be null to disable graph attribute\n           filtering.",
      "@param filter The filter to use, it can be null to disable node attribute\n           filtering.",
      "@param filter The filter to use, it can be null to disable edge attribute\n           filtering.",
      "@return The global attribute filter or null if there is no global filter.",
      "@return The graph attribute filter or null if there is no graph filter."
   ],
   [
      "@return The node global attribute filter or null if there is no node\n        filter.",
      "@return The edge attribute filter or null of there is no edge filter.",
      "@return true if time has been updated",
      "@return true if event is new for the source",
      "@param source source of the events",
      "@param input The source of events we listen at.",
      "@param input The source of graph events we listen at.",
      "@param sharedMBox The message box used to send and receive graph messages across\n           the thread boundary.",
      "@param inputGraph The graph we listen at.",
      "@param replayGraph If false, and if the input graph already contains element they\n           are not replayed.",
      "@param firstListener The initial listener to register.",
      "@param sourceId The source identifier.",
      "@param sourceId The graph identifier.",
      "@param step The step time stamp.",
      "@param nodeId The node identifier.",
      "@param edgeId The edge identifier.",
      "@param fromNodeId The edge start node.",
      "@param toNodeId The edge end node.",
      "@param directed Is the edge directed?.",
      "@param attribute The attribute name.",
      "@param value The attribute value.",
      "@param oldValue The old attribute value.",
      "@param newValue The new attribute value.",
      "@param oldValue The attribute old value.",
      "@param newValue The attribute new value."
   ],
   [
      "@param eltId The changed element identifier.",
      "@param eltType The changed element type.",
      "@param attribute The changed attribute.",
      "@param event The add/change/remove action.",
      "@param oldValue The old attribute value (null if the attribute is removed or\n           added).",
      "@param newValue The new attribute value (null if removed).",
      "@param name Identifier of the stream.",
      "@return the identified pipe",
      "@param name Filter only message with this name to the given message box.",
      "@param stream The ThreadProxyPipe to push the events to.",
      "@throws Exception If another Pipe is already registered at the given name.",
      "@param hostname The host name to listen at messages.",
      "@param port The port to listen at messages.",
      "@param debug If true informations are output for each message received.",
      "@param paker The packer object",
      "@param in The double to encode",
      "@return ByteBuffer with encoded double in it",
      "@param in The float array to encode",
      "@return ByteBuffer with encoded float array in it",
      "@param in The float to encode",
      "@return ByteBuffer with encoded float in it",
      "@param in The long array to encode",
      "@return ByteBuffer with encoded long array in it",
      "@param in The long to encode",
      "@return ByteBuffer with encoded long in it"
   ],
   [
      "@param in The integer array to encode",
      "@return ByteBuffer with encoded integer array in it",
      "@param in The integer to encode",
      "@return ByteBuffer with encoded integer in it",
      "@param b4 A reusable byte array to reduce array instantiation",
      "@param threeBytes the array to convert",
      "@param numSigBytes the number of significant bytes in your array",
      "@return four byte array in Base64 notation.",
      "@param source the array to convert",
      "@param srcOffset the index where conversion begins",
      "@param destination the array to hold the conversion",
      "@param destOffset the index where output will be put",
      "@return the <var>destination</var> array",
      "@param raw input buffer",
      "@param encoded output buffer",
      "@param serializableObject The object to encode",
      "@return The Base64-encoded object",
      "@throws java.io.IOException if there is an error",
      "@throws NullPointerException if serializedObject is null",
      "@param options Specified options",
      "@param source The data to convert",
      "@return The data in Base64-encoded form",
      "@return The Base64-encoded data as a String",
      "@param off Offset in array where conversion should begin",
      "@param len Length of data to convert"
   ],
   [
      "@throws IllegalArgumentException if source array, offset, or length are invalid",
      "@return The Base64-encoded data as a byte[] (of ASCII characters)",
      "@param options alphabet type is pulled from this (standard, url-safe, ordered)",
      "@return the number of decoded bytes converted",
      "@throws NullPointerException if source or destination arrays are null",
      "@throws IllegalArgumentException if srcOffset or destOffset are invalid\n        or there is not enough room in the array.",
      "@param source The Base64 encoded data",
      "@return decoded data",
      "@param off The offset of where to begin decoding",
      "@param len The length of characters to decode",
      "@param options Can specify options such as alphabet type to use",
      "@throws java.io.IOException If bogus characters exist in source data",
      "@param s the string to decode",
      "@return the decoded data",
      "@throws java.io.IOException If there is a problem",
      "@param options encode options such as URL_SAFE",
      "@param encodedObject The Base64 data to decode",
      "@return The decoded and deserialized object",
      "@throws java.io.IOException if there is a general error",
      "@throws ClassNotFoundException if the decoded object is of a\n        class that cannot be found by the JVM",
      "@param options Various parameters related to decoding",
      "@param loader Optional class loader to use in deserializing classes.",
      "@throws ClassNotFoundException if the decoded object is of a \n        class that cannot be found by the JVM",
      "@param dataToEncode byte array of data to encode in base64 form",
      "@param filename Filename for saving encoded data"
   ],
   [
      "@param dataToDecode Base64-encoded data as a string",
      "@param filename Filename for saving decoded data",
      "@param filename Filename for reading encoded data",
      "@return decoded byte array",
      "@param filename Filename for reading binary data",
      "@return base64-encoded string",
      "@param infile Input file",
      "@param outfile Output file",
      "@param buffer The buffer to unpack/decode",
      "@param startIndex the index at which the decoding starts in the buffer",
      "@param endIndex the index at which the decoding stops",
      "@return a ByteBuffer that is the unpacked version of the input one. It may not have the same size.",
      "@param buffer The byteBuffer who's content has the encoded value of the needed  size integer.",
      "@param buffer The buffer to pack/encode",
      "@param startIndex the index at which the encoding starts in the buffer",
      "@param endIndex the index at which the encoding stops",
      "@return a ByteBuffer that is the packed version of the input one. It may not have the same size.",
      "@param attributeName The name of the attribute.",
      "@param attributeValue The value of the attribute.",
      "@return True if the attribute must be removed from the stream of graph\n        events.",
      "@return The identifier value.",
      "@return The index value",
      "@param key The label to search.",
      "@return The label string value or null if not found.",
      "@param key The name of the number to search."
   ],
   [
      "@return The number value or NaN if not found.",
      "@return The vector of numbers or null if not found.",
      "@param key The name of the array to search.",
      "@return The array of objects or null if not found.",
      "@param key The name of the hash to search.",
      "@return The hash or null if not found.",
      "@param key The name of the attribute to search.",
      "@return True if a value is present for this attribute.",
      "@param clazz The expected class of the attribute value.",
      "@param key The name of the label.",
      "@return True if a value is present for this attribute and implements\n        CharSequence.",
      "@param key The name of the number.",
      "@return True if a value is present for this attribute and can contain a\n        double (inherits from Number).",
      "@param key The name of the vector.",
      "@return True if a value is present for this attribute and can contain a\n        sequence of numbers.",
      "@param key The name of the array.",
      "@return True if a value is present for this attribute and can contain an\n        array object.",
      "@param key The name of the hash.",
      "@return True if a value is present for this attribute and can contain a\n        hash.",
      "@return An iterator on the key set of attributes.",
      "@return an iterable view on attribute keys.",
      "@return an unmodifiable collection containing the attribute keys.",
      "@param values The attribute value or set of values.",
      "@param values The attribute value or array of values.",
      "@param attributes A set of (key,value) pairs."
   ],
   [
      "@param attribute Name of the attribute to remove.",
      "@return the number of attributes.",
      "@return The graph containing this node or null if unknown.",
      "@return The number of edges/relations/links.",
      "@return the count of edges that only leave this node plus all undirected\n        edges.",
      "@return the count of edges that only enter this node plus all undirected\n        edges.",
      "@param id Identifier of the target node.",
      "@return True if a directed edge goes from this node to 'id' or if an\n        undirected edge exists.",
      "@param id Identifier of the source node.",
      "@param id Identifier of another node.",
      "@return True if a edge exists between this node and node 'id'.",
      "@return Directed edge going from this node to 'id', or undirected edge if\n        it exists, else null.",
      "@return Directed edge going from node 'id' to this node, or undirected\n        edge if it exists, else null.",
      "@param id Identifier of the opposite node.",
      "@return Edge between node 'id' and this node if it exists, else null.",
      "@return The iterator, edges are iterated in arbitrary order.",
      "@return The iterator, neighbors are iterated in arbitrary order.",
      "@param i Index of the edge.",
      "@return The i-th edge.",
      "@throws IndexOutOfBoundException if <code>i</code> is negative or greater than or equal to the\n            degree",
      "@return The i-th entering edge.",
      "@throws IndexOutOfBoundException if <code>i</code> is negative or greater than or equal to the\n            in-degree",
      "@return The i-th leaving edge.",
      "@throws IndexOutOfBoundException if <code>i</code> is negative or greater than or equal to the\n            out-degree",
      "@return An iterator able to explore the graph in a breadth first way\n        starting at this node."
   ],
   [
      "@param directed If false, the iterator will ignore edge orientation (the\n           default is \"True\").",
      "@return An iterator able to explore the graph in a depth first way\n        starting at this node.",
      "@return A collection containing all directed and undirected edges,\n        leaving or entering.",
      "@return A collection of only edges that leave this node plus all\n        undirected edges.",
      "@return A collection of only edges that enter this node plus all\n        undirected edges.",
      "@param node The target node.",
      "@return True if a directed edge goes from this node to the other node or\n        if an undirected edge exists.",
      "@param index Index of the target node.",
      "@throws IndexOutOfBoundsException if the index is negative or greater than {@code\n            getNodeCount() - 1}.",
      "@param node The source node.",
      "@return True if a directed edge goes from the other node to this node or\n        if an undirected edge exists.",
      "@param index Index of the source node.",
      "@param node Another node.",
      "@return True if an edge exists between this node and the other node.",
      "@param index Index of another node.",
      "@return Directed edge going from this node to the parameter node, or\n        undirected edge if it exists, else null.",
      "@return Directed edge going from the parameter node to this node, or\n        undirected edge if it exists, else null.",
      "@param node The opposite node.",
      "@return Edge between this node and the parameter node if it exists, else\n        null.",
      "@param index The index of the opposite node.",
      "@return Edge between node with index i and this node if it exists, else\n        null.",
      "@param id Identifier of the node to find.",
      "@return The searched node or null if not found.",
      "@param id Identifier of the edge to find.",
      "@return The searched edge or null if not found."
   ],
   [
      "@return True if enabled.",
      "@return True if exceptions must be thrown when accessing a null\n        attribute.",
      "@return The step.",
      "@param on if true, exceptions will be thrown when accessing a non\n           existing attribute.",
      "@param nf the new NodeFactory",
      "@param ef the new EdgeFactory",
      "@param on True or false.",
      "@param id Arbitrary and unique string identifying the node.",
      "@return The created node (or the already existing node).",
      "@throws IdAlreadyInUseException If strict checking is enabled the identifier is already used.",
      "@param id The unique identifier of the node to remove.",
      "@return The removed node. If strict checking is disabled, it can return\n        null if the node to remove does not exist.",
      "@throws ElementNotFoundException If no node matches the given identifier and strict checking\n            is enabled.",
      "@param id Unique and arbitrary string identifying the edge.",
      "@param node1 The first node identifier.",
      "@param node2 The second node identifier.",
      "@return The newly created edge, an existing edge or {@code null} (see the\n        detailed description above)",
      "@throws IdAlreadyInUseException If an edge with the same id already exists and strict\n            checking is enabled.",
      "@throws ElementNotFoundException If strict checking is enabled, and 'node1' or 'node2' are not\n            registered in the graph.",
      "@throws EdgeRejectedException If strict checking is enabled and the edge is not accepted.",
      "@param directed Is the edge directed?",
      "@param from The origin node identifier to select the edge.",
      "@param to The destination node identifier to select the edge.",
      "@return The removed edge, or null if strict checking is disabled and at\n        least one of the two given nodes does not exist or there is no\n        edge between them",
      "@throws ElementNotFoundException If the 'from' or 'to' node is not registered in the graph or\n            not connected and strict checking is enabled."
   ],
   [
      "@param id Identifier of the edge to remove.",
      "@return The removed edge, or null if strict checking is disabled and the\n        edge does not exist.",
      "@throws ElementNotFoundException If no edge matches the identifier and strict checking is\n            enabled.",
      "@param time A numerical value that may give a timestamp to track the\n           evolution of the graph over the time.",
      "@return the set of {@link AttributeSink} under the form of an iterable\n        object.",
      "@return the list of {@link ElementSink} under the form of an iterable\n        object.",
      "@param filename The graph filename (or URL).",
      "@throws ElementNotFoundException If the file cannot be found or if the format is not\n            recognized.",
      "@throws GraphParseException If there is a parsing error while reading the file.",
      "@throws IOException If an input output error occurs during the graph reading.",
      "@param input An appropriate reader for the filename.",
      "@throws ElementNotFoundException If the file cannot be found or if the format is not\n            recognised.",
      "@throws IOException If an input/output error occurs during the graph reading.",
      "@param filename The file that will contain the saved graph (or URL).",
      "@throws IOException If an input/output error occurs during the graph writing.",
      "@param output The output format to use.",
      "@return a graph viewer that allows to command the viewer (it often run in\n        another thread).",
      "@param autoLayout If true a layout algorithm is launched in its own thread to\n           compute best node positions.",
      "@param index Index of the node to find.",
      "@return The node with the given index",
      "@throws IndexOutOfBoundsException If the index is negative or greater than {@code\n            getNodeCount() - 1}.",
      "@param index The index of the edge to find.",
      "@return The edge with the given index",
      "@throws IndexOutOfBoundsException if the index is less than 0 or greater than {@code\n            getNodeCount() - 1}.",
      "@param index1 The first node index"
   ],
   [
      "@param index2 The second node index",
      "@return The newly created edge, an existing edge or {@code null}",
      "@throws IndexOutOfBoundsException If node indices are negative or greater than {@code\n            getNodeCount() - 1}",
      "@param toIndex The first node index",
      "@param fromIndex The second node index",
      "@param node1 The first node",
      "@param node2 The second node",
      "@param from The first node",
      "@param to The second node",
      "@param index The index of the edge to be removed.",
      "@return The removed edge",
      "@throws IndexOutOfBoundsException if the index is negative or greater than {@code\n            getEdgeCount() - 1}",
      "@param fromIndex the index of the source node",
      "@param toIndex the index of the target node",
      "@return the removed edge or {@code null} if no edge is removed",
      "@throws IndexOutOfBoundsException If one of the node indices is negative or greater than\n            {@code getNodeCount() - 1}.",
      "@throws ElementNotFoundException if strict checking is enabled and there is no edge between\n            the two nodes.",
      "@param node1 the first node",
      "@param node2 the second node",
      "@param edge The edge to be removed",
      "@param index The index of the node to be removed",
      "@return The removed node",
      "@param node The node to be removed",
      "@return The conversion of this attribute to a hash.",
      "@return The attribute usual name."
   ],
   [
      "@return The number of nodes.",
      "@return The number of edges.",
      "@return The iterator.",
      "@return An \"iterable\" view of the set of nodes.",
      "@return An \"iterable\" view of the set of edges.",
      "@return A set of nodes that can only be read, not changed.",
      "@return A set of edges that can only be read, not changed.",
      "@param message The message to throw.",
      "@param id The new edge identifier.",
      "@param src The source node.",
      "@param dst The target node.",
      "@param directed Is the edge directed (in the direction source toward target).",
      "@return The newly created edge.",
      "@param sourceId The source of the change.",
      "@param timeId The source time of the change, for synchronization.",
      "@param attribute The attribute name that changed.",
      "@param event The type of event among ADD, CHANGE and REMOVE.",
      "@param id The unique identifier of this element.",
      "@param index the new index",
      "@param id Unique identifier of the graph.",
      "@param strictChecking If true any non-fatal error throws an exception.",
      "@param initialNodeCapacity Initial capacity of the node storage data structures. Use this\n           if you know the approximate maximum number of nodes of the\n           graph. The graph can grow beyond this limit, but storage\n           reallocation is expensive operation.",
      "@param initialEdgeCapacity Initial capacity of the edge storage data structures. Use this\n           if you know the approximate maximum number of edges of the\n           graph. The graph can grow beyond this limit, but storage\n           reallocation is expensive operation.",
      "@param edge a new edge incident to this node",
      "@param edge an edge incident to this node that will be removed"
   ],
   [
      "@param e an edge",
      "@return {@code true} if {@code e} is entering edge for this node.",
      "@return {@code true} if {@code e} is leaving edge for this node.",
      "@return {@code true} if {@code e} is incident edge for this node.",
      "@param graph The graph to which this node belongs.",
      "@param id Unique identifier of this node.",
      "@param g the graph to synchronize",
      "@return a synchronized wrapper for g",
      "@param graphs graphs to merge",
      "@return merge result",
      "@param result destination graph.",
      "@param graphs all graphs that will be merged in result.",
      "@param g the graph to clone",
      "@return a copy of g",
      "@param node the node to be added",
      "@param edge the edge to be added",
      "@param node the node to be removed",
      "@param edge the edge to be removed",
      "@param graphCallback if {@code false}, {@code removeNodeCallback(node)} is not\n           called",
      "@param graphCallback if {@code false}, {@link #removeEdgeCallback(AbstractEdge)} of\n           the graph is not called",
      "@param sourceCallback if {@code false},\n           {@link AbstractNode#removeEdgeCallback(AbstractEdge)} is not\n           called for the source node of the edge",
      "@param targetCallback if {@code false},\n           {@link AbstractNode#removeEdgeCallback(AbstractEdge)} is not\n           called for the target node of the edge",
      "@param id Identifier of the graph",
      "@param id Unique identifier of this edge.",
      "@param source Source node."
   ],
   [
      "@param target Target node.",
      "@param directed Indicates if the edge is directed.",
      "@return A graph instance or null if the graph class was not found.",
      "@return True if the edge is directed.",
      "@return True if this edge is a loop.",
      "@return The first node of the edge.",
      "@return The second node of the edge.",
      "@return The origin node of the edge.",
      "@return The destination node of the edge.",
      "@param node The node we search the opposite of.",
      "@return the opposite node of the given node.",
      "@return the root of the path.",
      "@param root The root of the path.",
      "@param node The node tested for existence in the path.",
      "@param edge The edge tested for existence in the path.",
      "@return <code>true</code> if the path is empty.",
      "@param characteristic The characteristic.",
      "@return Sum of the characteristics.",
      "@return The list of edges representing the path.",
      "@return A list of nodes representing the path.",
      "@param from The start node.",
      "@param edge The edge used.",
      "@param edge The edge to add to the path.",
      "@return The edge that have just been removed.",
      "@return The node that have just been removed."
   ],
   [
      "@return The node at the top of the stack.",
      "@return A copy of this path.",
      "@param p A path to compare to the curent one.",
      "@return True if both paths are equal.",
      "@return A String representation of the path.",
      "@return The size of the path.",
      "@param x1 The selection start abscissa.",
      "@param y1 The selection start ordinate.",
      "@param x The new end selection abscissa.",
      "@param y The new end selection ordinate.",
      "@param x2 The selection stop abscissa.",
      "@param y2 The selection stop ordinate.",
      "@param element The element.",
      "@param x The requested position abscissa in pixels.",
      "@param y The requested position ordinate in pixels.",
      "@param renderer The renderer (or null to remove it).",
      "@param graphics The Swing graphics.",
      "@param graph The graphic representation of the graph.",
      "@param px2Gu The ratio to pass from pixels to graph units.",
      "@param widthPx The width in pixels of the view port.",
      "@param heightPx The height in pixels of the view port.",
      "@param minXGu The minimum visible point abscissa of the graph in graph\n           units.",
      "@param minYGu The minimum visible point ordinate of the graph in graph\n           units.",
      "@param maxXGu The maximum visible point abscissa of the graph in graph\n           units.",
      "@param maxYGu The maximum visible point ordinate of the graph in graph\n           units."
   ],
   [
      "@param on Add the panel in its own frame or remove it if it already was\n          in its own frame.",
      "@param width The new width.",
      "@param height The new height.",
      "@param identifier The view unique identifier.",
      "@return The new layout or the default GraphStream \"Spring-Box\" layout if\n        the \"gs.ui.layout\" system property is either not set or contains\n        a class that cannot be found.",
      "@return a value between 0 and 1. 1 means fully stabilized.",
      "@return The stabilization limit.",
      "@return A number between 0 and 1.",
      "@return A real number.",
      "@param value A number in [0..1].",
      "@param qualityLevel The quality level, a number between 0 and 1.",
      "@param send If true, send node informations to a \"layout.info\" attribute.",
      "@param id The node identifier.",
      "@param x The node new X.",
      "@param y The node new Y.",
      "@param z The node new Z.",
      "@param frozen If true the node is frozen.",
      "@param ms The number of milliseconds to wait.",
      "@param longNap The time to wait between stabilized layout invocations, by\n           default 80.",
      "@param shortNap The time to wait between non stabilized layout invocations, by\n           default 10.",
      "@param source The source of graph events.",
      "@param layout The layout algorithm to use.",
      "@param start Start the layout thread immediately ? Else the start() method\n           must be called later.",
      "@param graph The source of graph events.",
      "@param replay If the graph already contains some data, replay events to\n           create the data, this is mostly always needed."
   ],
   [
      "@return A set of edges.",
      "@param dx The x component.",
      "@param dy The y component.",
      "@param dz The z component.",
      "@param x The new x.",
      "@param y The new y.",
      "@param z The new z.",
      "@param delta The computed displacement vector.",
      "@param e The edge to connect.",
      "@param e THe edge to disconnect.",
      "@param box The spring box.",
      "@param x The abscissa.",
      "@param y The ordinate.",
      "@param z The depth.",
      "@param node One of the nodes of the edge.",
      "@return The other node.",
      "@param id The edge identifier.",
      "@param n0 The first node.",
      "@param n1 The second node.",
      "@return The actual level of energy.",
      "@return A value that indicates the level of stabilization in [0-1].",
      "@return The average energy.",
      "@param stepsBack The number of steps back in history. This number must not be larger than\n           the size of the memory (energy buffer) else it is set to this size.",
      "@return The energy value at stepsBack in time.",
      "@param value The value to accumulate to the current cell."
   ],
   [
      "@return The gravity factor, usually between 0 and 1.",
      "@param value The new gravity factor, usually between 0 and 1.",
      "@return The n-tree.",
      "@return The theta value (between 0 and 1).",
      "@param theta The new value for theta (between 0 and 1).",
      "@param n0 source node of the edge.",
      "@param n1 target node of the edge.",
      "@param id The identifier of the new node/particle.",
      "@return The new node/particle.",
      "@param is3D If true the simulation dimensions count is 3 else 2.",
      "@param randomNumberGenerator The random number generator to use.",
      "@return the vector length.",
      "@param scalar The multiplier.",
      "@param graph The graph to control.",
      "@param view The view to control.",
      "@param event The event that generated the key.",
      "@return The estimated frame-per-second measure of the last frame.",
      "@return The last frame time in seconds.",
      "@return The number of frames measure.",
      "@return The average number of frames per second.",
      "@return The time used by a frame in average.",
      "@return The coordinate at parametric position `t` on the curve.",
      "@return The point at parametric position `t` on the curve.",
      "@return the given reference to `result`.",
      "@return The derivative at parametric position `t` on the curve."
   ],
   [
      "@return The derivative point at parametric position `t` on the curve.",
      "@return A vector perpendicular to the curve at position `t`.",
      "@return The new identifier.",
      "@param ppipe The source of events from another thread or machine (null if\n           source != null).",
      "@param source The source of events from this thread (null if ppipe != null).",
      "@return The new proxy pipe.",
      "@return The new viewer pipe.",
      "@param id The view identifier.",
      "@return A view or null if not found.",
      "@return The default view or null if no default view has been installed.",
      "@param openInAFrame It true, the view is placed in a frame, else the view is only\n           created and you must embed it yourself in your application.",
      "@param view The view to add.",
      "@return The old view that was at the given identifier, if any, else null.",
      "@param id The new view identifier.",
      "@param renderer The renderer to use.",
      "@return The created view.",
      "@param openInAFrame If true the view is open in a frame, else the returned view is\n           a JPanel that can be inserted in a GUI.",
      "@param policy The close frame policy.",
      "@param layoutAlgorithm The algorithm to use (see Layouts.newLayoutAlgorithm() for the\n           default algorithm).",
      "@param graph THe graph to draw.",
      "@param graph The graph to render.",
      "@param threadingModel The threading model.",
      "@return a view id",
      "@return The first node or sprite at the given coordinates or null if\nnothing found.",
      "@param graph The graphic graph to represent."
   ],
   [
      "@param graphChanged True if the graph changed since the last call to this method.",
      "@param frozen If true the element cannot be moved automatically.",
      "@param manager The new manager, or null to set the default manager.",
      "@param manager The new manager, or null to set the default manager",
      "@param l the listener",
      "@return The view centre.",
      "@param x The new abscissa.",
      "@param y The new ordinate.",
      "@param z The new depth.",
      "@return A real for which value 1 means the graph is fully visible and\n        uses the whole view port.",
      "@param percent Percent of the graph visible.",
      "@return The rotation angle in degrees.",
      "@return The graph estimated size in graph units.",
      "@param minx The minimum abscissa visible.",
      "@param miny The minimum ordinate visible.",
      "@param maxx The maximum abscissa visible.",
      "@param maxy The maximum abscissa visible.",
      "@return a GraphMetrics instance",
      "@return The transformed point.",
      "@param x The source point abscissa in pixels.",
      "@param y The source point ordinate in pixels.",
      "@return The resulting points in graph units.",
      "@return The sprite count.",
      "@param identifier The sprite identifier to search for.",
      "@param identifier The sprite identifier."
   ],
   [
      "@return The set of sprites.",
      "@return An iterator on sprites.",
      "@return A Sprite factory.",
      "@param factory The new factory to use.",
      "@param identifier The identifier of the new sprite to add.",
      "@return The created sprite.",
      "@throws InvalidSpriteIDException If the given identifier contains a dot.",
      "@param position The sprite position (or null for (0,0,0)).",
      "@param spriteClass The class of the new sprite to add.",
      "@param position The sprite position, or null for position (0, 0, 0).",
      "@param identifier The identifier of the sprite to remove.",
      "@param graph The graph to associate with this manager;",
      "@param identifier Identifier of the newly created sprite.",
      "@param manager The sprite manager this sprite will pertain to.",
      "@param position The sprite initial position or null for (0,0,0,GU).",
      "@return A new sprite.",
      "@param oldStyle The old style.",
      "@param style The changed style or the new style of the element.",
      "@param others The other colour set to copy.",
      "@param oldRule The style that changed.",
      "@param newRule The style that was added to the style sheet.",
      "@return a style from which some settings are inherited.",
      "@param property The style property the value is searched for.",
      "@param field The field to test.",
      "@return True if this style has a value for the given field."
   ],
   [
      "@param other Another style.",
      "@param parent The new parent.",
      "@param event The event that triggers the alternate style.",
      "@param alternateStyle The alternative style.",
      "@param parent The parent style.",
      "@return A rule.",
      "@return A style.",
      "@return The set of rules for graphs.",
      "@return The set of rules for nodes.",
      "@return The set of rules for edges.",
      "@return The set of rules for sprites.",
      "@param element The element a rules are searched for.",
      "@return A set of rules matching the element, with the main rule at index\n        0.",
      "@param rules The styling rules.",
      "@return The unique identifier of the style group for the element.",
      "@param listener The new listener.",
      "@param listener The listener to remove.",
      "@param fileName Name of the file containing the style sheet.",
      "@throws IOException For any kind of I/O error or parse error.",
      "@param url Name of the file containing the style sheet.",
      "@param styleSheet The string containing the whole style sheet.",
      "@param select The elements for which this style must apply.",
      "@param styleString The style string to parse.",
      "@param styleSheetValue The style sheet name of content.",
      "@throws IOException If the loading or parsing of the style sheet failed."
   ],
   [
      "@param reader The reader pointing at the style sheet.",
      "@param newRule The new rule.",
      "@param anyValue The value to convert.",
      "@return the converted colour or null if the conversion failed.",
      "@return The corresponding string, or null.",
      "@param value The input to convert.",
      "@return The value or -1 if the conversion failed. TODO should be named\n        convertNumber",
      "@param value A Number or a CharSequence.",
      "@param id A string that identifies an element of the graph.",
      "@param clazz A string that matches all elements of a given class.",
      "@param pseudoClass A string that matches all elements of a given pseudo-class.",
      "@return An element type.",
      "@return The identifier or null if the selector is general.",
      "@return A class name or null if the selector is general.",
      "@return A pseudo-class name or null.",
      "@param type The element type of this selector.",
      "@param identifier The element name.",
      "@param clazz The element class.",
      "@param type Either \"node\", \"edge\", \"graph\" or \"sprite\".",
      "@param other The other selector.",
      "@param units The value units.",
      "@param value The value.",
      "@param other The other value to copy.",
      "@return The rule style.",
      "@param identifier The identifier to test for the match."
   ],
   [
      "@return True if matching.",
      "@param style A style specification.",
      "@param groupId The group unique identifier.",
      "@param selector The rule selector.",
      "@param value The object to convert.",
      "@return The value.",
      "@param attributes The node attribute set (can be null).",
      "@return A style group identifier.",
      "@return The type of the style group elements.",
      "@return True if one property is dynamic.",
      "@return True if the group contains some elements changed by an event.",
      "@return True if the element has actually active events.",
      "@return True if the element has actually specific style attributes.",
      "@return True if the group is empty of elements.",
      "@param elementId The element to search.",
      "@return true if the element is in the group.",
      "@param element The element to search.",
      "@param id The searched element identifier.",
      "@return The element corresponding to the identifier or null if not found.",
      "@return The element count.",
      "@return The elements iterator.",
      "@return All the elements in no particular order.",
      "@return The iterable set of bulk elements.",
      "@return The subset of elements modified by one or more events.",
      "@return The subset of dynamic elements of the group."
   ],
   [
      "@return A renderer or null if not found.",
      "@return A set of events or null if none occurring at that time.",
      "@param element The new graph element to add.",
      "@param element The element to remove.",
      "@return The removed element, or null if the element was not found.",
      "@param element The element to modify with an event.",
      "@param event The event to push.",
      "@param event The event.",
      "@param element The element to push events for.",
      "@param id The renderer identifier.",
      "@param renderer The renderer.",
      "@return The removed renderer or null if not found.",
      "@param identifier The unique group identifier (see\n           {@link org.graphstream.ui.graphicGraph.stylesheet.StyleSheet#getStyleGroupIdFor(Element, ArrayList)}\n           ).",
      "@param rules The set of style rules for the style group (see\n           {@link org.graphstream.ui.graphicGraph.stylesheet.StyleSheet#getRulesFor(Element)}\n           ).",
      "@param firstElement The first element to construct the group.",
      "@return A newly allocated array of three floats containing the (x,y,z)\n        position of the node, or null if the node is not part of the\n        graph.",
      "@return A newly allocated point containing the (x,y,z)\n        position of the node, or null if the node is not part of the\n        graph.",
      "@param node The node to consider.",
      "@return A newly allocated array of three floats containing the (x,y,z)\n        position of the node.",
      "@return A newly allocated point containing the (x,y,z)\n        position of the node.",
      "@param xyz An array of at least three cells.",
      "@throws RuntimeException If the node with the given identifier does not exist.",
      "@param pos A point that will receive the node position.",
      "@param o The object to try to convert.",
      "@param xyz The result."
   ],
   [
      "@param pos The result.",
      "@param id The identifier of the edge.",
      "@return The edge length or -1 if the nodes of the edge have no positions.",
      "@throws RuntimeException If the edge cannot be found.",
      "@param n One of the node of this edge.",
      "@return The other node of this edge.",
      "@return The control points coordinates or null if this edge is a straight\n        line.",
      "@return True if control points are available.",
      "@param points The new set of points. See the {@link #getControlPoints()}\n           method for an explanation on the organisation of this array.",
      "@return The edge index between the two nodes if there are several such\n        edges.",
      "@param edgeList The actual set of edges between two nodes (see the\n           connectivity in the graphic graph).",
      "@return The group of edges between two same nodes, null if the edge is\n        alone between the two nodes.",
      "@param id The edge unique identifier.",
      "@param from The source node.",
      "@param to The target node.",
      "@param dir True if the edge is directed in the direction from-to.",
      "@param attributes A set of initial attributes.",
      "@return true if the graph was changed.",
      "@return A style sheet.",
      "@return A style group.",
      "@return The style groups.",
      "@return The maximum node or sprite position.",
      "@return The minimum node or sprite position.",
      "@return The number of groups.",
      "@param groupId The group identifier."
   ],
   [
      "@return The corresponding group or null if not found.",
      "@return An iterator on the group set.",
      "@return An iterable on the set of groups.",
      "@return The z index iterator.",
      "@return The z levels.",
      "@return The shadow groups iterator.",
      "@return All the groups that cast a shadow.",
      "@return True if the node is in this set.",
      "@return True if the edge is in this set.",
      "@param id The sprite identifier.",
      "@return True if the sprite is in this set.",
      "@param id The graph identifier.",
      "@return True if the graph is in this set.",
      "@param id The element id.",
      "@param elt2grp The kind of element.",
      "@return The element or null if not found.",
      "@return The node if it is in this set, else null.",
      "@return The edge if it is in this set, else null.",
      "@return The sprite if it is in this set, else null.",
      "@return The graph if it is in this set, else null.",
      "@return The node count.",
      "@return The edge count.",
      "@return An iterator on all node elements contained in style groups.",
      "@return An iterator on all graph elements contained in style groups.",
      "@return The set of all nodes."
   ],
   [
      "@return The set of all graphs.",
      "@return An iterator on all edge elements contained in style groups.",
      "@return The set of all edges.",
      "@return An iterator on all sprite elements contained in style groups.",
      "@return The set of all sprites.",
      "@param element The element to search for.",
      "@return Identifier of the group containing the element.",
      "@return The style group of the element (which is also a style).",
      "@param node The node to search for.",
      "@return The node style.",
      "@param edge The edge to search for.",
      "@return The edge style.",
      "@param sprite The node to search for.",
      "@return The sprite style.",
      "@param graph The node to search for.",
      "@return The graph style.",
      "@return True if the groups are removed when empty.",
      "@return The Z index.",
      "@return The set of shadowed style groups.",
      "@param on If true the groups will be removed.",
      "@param element The element to add.",
      "@return The style group where the element was added.",
      "@param element The element to move.",
      "@param element The element considered.",
      "@param event The event to remove."
   ],
   [
      "@param event The event to pop.",
      "@param element The element to add to the dynamic subset.",
      "@param element The element to remove from the dynamic subset.",
      "@param listener The listener to add.",
      "@param oldRule The old rule that changed.",
      "@param newRule The new rule that participated in the change.",
      "@param newRule The new style rule.",
      "@param elt2grp The name space.",
      "@param stylesheet The style sheet to use to create groups.",
      "@return The style group corresponding to this element.",
      "@return An object.",
      "@param x The new X.",
      "@param y The new Y.",
      "@param z the new Z.",
      "@param component The component.",
      "@param type type of the event",
      "@param format new format of the message attached with the event",
      "@param prefix new prefix",
      "@param suffix new suffix",
      "@param out stream used to output message",
      "@return True if the environment is locked.",
      "@param parameter The parameter name.",
      "@return True if the given paramter name points to a value.",
      "@return True if the parameter value means \"true\", false for any other\n        value or if the parameter does not exist.",
      "@return 1 if the parameter value means \"true\", 0 if it has any other\n        value, or -1 if it does not exist."
   ],
   [
      "@return The numeric value of the parameter. 0 if the parameter does\n        not exist or is not a number.",
      "@return The number of parameters found in the configuration file.",
      "@return A set of all the names identifying parameters in this\n        environment.",
      "@return An Environment object identical to this one",
      "@param value The new parameter value.",
      "@param object The object to initialize.",
      "@param fieldList The name of the fields to initialize in the object.",
      "@param out The output stream to use.",
      "@param args The command line.",
      "@param trashcan Will be filled by the set of unparsed strings (can be\n       null if these strings can be ignored).",
      "@param fileName Name of the file to save the config in.",
      "@throws IOException For any output error on the given file name.",
      "@param fileName Name of the parameter file to read.",
      "@throws IOException For any error with the given parameter file name.",
      "@param g the graph to start listening for changes.",
      "@param reader stream to be parsed",
      "@return a parser",
      "@return a regular expression as a string",
      "@param format format of the scanner",
      "@return a list of components found in the string format",
      "@throws ParseException if invalid component found",
      "@param format new format of the scanner",
      "@throws ParseException if an error is found in the new format",
      "@param time timestamp in the scanner format",
      "@return a calendar modeling the time value or null if invalid format"
   ],
   [
      "@param calendar the calendar to convert",
      "@return a string modeling the calendar.",
      "@param format format of the scanner.",
      "@throws ParseException if bad directives found",
      "@return directive of the component.",
      "@return true if component is an alias.",
      "@return replacement value",
      "@param value value matching the replacement string",
      "@param calendar calendar we are working on",
      "@param calendar the calendar",
      "@return string representation of this component.",
      "@param directive directive name, should start with a leading '%'.",
      "@param replace replace the directive with the value given here.",
      "@return The number of elements in the array.",
      "@param i The element index.",
      "@return The element at index <code>i</code>.",
      "@return The last insertion index.",
      "@param i Index of the element to remove.",
      "@return The removed element.",
      "@param e The element to remove.",
      "@return True if removed.",
      "@param path path to the file",
      "@return count of step event in the file",
      "@return the count of step",
      "@param sourceId Identifier of the graph where the node was added."
   ],
   [
      "@param nodeId Identifier of the added node.",
      "@param sourceId Identifier of the graph where the node will be removed.",
      "@param nodeId Identifier of the removed node.",
      "@param sourceId Identifier of the graph where the edge was added.",
      "@param edgeId Identifier of the added edge.",
      "@param fromNodeId Identifier of the first node of the edge.",
      "@param toNodeId Identifier of the second node of the edge.",
      "@param directed If true, the edge is directed.",
      "@param sourceId The graph where the edge will be removed.",
      "@param edgeId The edge that will be removed.",
      "@param sourceId The graph cleared.",
      "@param sourceId Identifier of the graph where the step starts.",
      "@param timeId A numerical value that may give a timestamp to track the\n           evolution of the graph over the time.",
      "@param url The URL to fetch.",
      "@throws IOException If an I/O error occurs while fetching the URL.",
      "@param graphId id of the graph",
      "@param port port on which server will be bound",
      "@throws IOException if server creation failed.",
      "@param sourceId Identifier of the graph where the attribute changed.",
      "@param value The attribute new value.",
      "@param sourceId Identifier of the graph where the attribute was removed.",
      "@param attribute The removed attribute name.",
      "@param sourceId Identifier of the graph where the change occurred.",
      "@param nodeId Identifier of the node whose attribute changed.",
      "@param nodeId Identifier of the node whose attribute was removed."
   ],
   [
      "@param edgeId Identifier of the edge whose attribute changed.",
      "@param edgeId Identifier of the edge whose attribute was removed.",
      "@param filename The file name where the graph will be written.",
      "@return A file sink or null.",
      "@param edgesAreDirected If true (default=false) edges are considered directed.",
      "@throws IOException If any I/O error occurs.",
      "@param fileName Name of the file to output to.",
      "@return A new writer.",
      "@param stream An already existing output stream.",
      "@param writer An already existing writer.",
      "@param group the style group to convert",
      "@return string representation of the style group usable in TikZ.",
      "@param graph The graph to send as events to the file.",
      "@param fileName Name of the file to write.",
      "@throws IOException if an I/O error occurs while writing.",
      "@param stream The stream where the graph is sent.",
      "@param writer The writer where the graph is sent.",
      "@param fileName The name of the file where to output the graph events.",
      "@throws IOException If an I/O error occurs while writing.",
      "@param stream The file stream where to output the graph events.",
      "@param writer The writer where to output the graph events.",
      "@throws IOException If an I/O error occurs during write.",
      "@return the next event in the stream",
      "@param e the event",
      "@param e event producing an error"
   ],
   [
      "@param msg message to put in the exception",
      "@param args arguments of the message",
      "@return a new parse exception",
      "@param e event to check",
      "@param type expected type",
      "@param name expected name",
      "@return true is type and name are valid",
      "@throws XMLStreamException if event has invalid type or name",
      "@return the list of every node attributes filtered",
      "@param graphAttributesFiltered the new list",
      "@param attr the filtered attribute",
      "@return true if the attribute has been added, false otherwise",
      "@param attr the no more filtered attribute",
      "@return true if the attribute has been removed, false otherwise",
      "@param nodeAttributesFiltered the new list",
      "@return the list of every edge attributes filtered",
      "@param edgeAttributesFiltered the new list",
      "@return true if this filter is disable, false otherwise",
      "@return true if exported graph is directed",
      "@return a parser factory",
      "@param fileName Name of the graph file.",
      "@return A graph reader suitable for the fileName graph format.",
      "@throws IOException If the file is not readable or accessible.",
      "@param styleSheet the style sheet",
      "@param r resolution"
   ],
   [
      "@param policy policy defining when images are produced",
      "@param policy policy defining how the layout is computed",
      "@param spf step per frame",
      "@param sas step after stabilization.",
      "@param logoFile path to the logo picture-file",
      "@param x x position of the logo (top-left corner is (0;0))",
      "@param y y position of the logo",
      "@throws FileNotFoundException if the {@code file} does not exist",
      "@param c the number of compression rounds (must be positive)",
      "@param d the number of finalization rounds (must be positive)",
      "@throws IOException if {@code swallowIOException} is false and\n    {@link Flushable#flush} throws an {@code IOException}.",
      "@throws IllegalArgumentException if {@code size} is nonpositive",
      "@throws IndexOutOfBoundsException if {@code position} is negative or\n    greater than or equal to the size of {@code iterable}",
      "@throws IndexOutOfBoundsException if {@code position} is negative",
      "@throws IllegalArgumentException if {@code limitSize} is negative",
      "@throws IndexOutOfBoundsException if {@code position} is negative or\n    greater than or equal to the number of elements remaining in\n    {@code iterator}",
      "@throws IllegalArgumentException if {@code offset} or {@code length} is negative",
      "@throws NullPointerException if any of {@code sources} is {@code null}",
      "@throws NullPointerException if {@code element} is null",
      "@throws NullPointerException if any of {@code elements} is null",
      "@param a the instance to convert; will never be null",
      "@return the converted instance; <b>must not</b> be null",
      "@param b the instance to convert; will never be null",
      "@return the converted value; is null <i>if and only if</i> {@code a} is null",
      "@throws NullPointerException if any of the provided values is null"
   ],
   [
      "@throws IllegalArgumentException if {@code k} is negative",
      "@throws IllegalArgumentException if {@code expectedKeys < 0}",
      "@throws IndexOutOfBoundsException if {@code off < 0} or {@code off + len > bytes.length} or\n  {@code len < 0}",
      "@throws IllegalArgumentException if {@code x <= 0}",
      "@throws IllegalArgumentException if {@code k < 0}",
      "@throws IllegalArgumentException if {@code x < 0}",
      "@throws ArithmeticException if {@code q == 0}, or if {@code mode == UNNECESSARY} and {@code a}\n        is not an integer multiple of {@code b}",
      "@throws ArithmeticException if {@code m <= 0}",
      "@throws IllegalArgumentException if {@code a < 0} or {@code b < 0}",
      "@throws IllegalArgumentException if {@code n < 0}",
      "@throws NullPointerException if {@code input} is null and this predicate does not accept null\n    arguments",
      "@throws NullPointerException if both {@code first} and {@code second} are null",
      "@return {@code first} if it is non-null; otherwise {@code second} if it is non-null",
      "@throws IllegalArgumentException if {@code initialCapacity} is negative",
      "@throws IllegalArgumentException if {@code concurrencyLevel} is nonpositive",
      "@throws IllegalArgumentException if {@code size} is negative",
      "@throws IllegalArgumentException if {@code weight} is negative",
      "@throws IllegalArgumentException if {@code duration} is negative",
      "@throws IllegalArgumentException if {@code minLength} or {@code padding} is\n    negative",
      "@throws NullPointerException if {@code collection} or any of its elements\n    is null",
      "@throws IllegalStateException if {@code bits() < 32}",
      "@throws IllegalStateException if {@code bits() < 64}",
      "@throws IndexOutOfBoundsException if {@code off < 0} or {@code off + len > bytes.length}\n  or {@code len < 0}",
      "@throws NullPointerException if {@code string} is null",
      "@throws IllegalArgumentException if any alphabet or padding characters appear in the separator\n        string, or if {@code n <= 0}"
   ],
   [
      "@throws IllegalArgumentException if {@code expression} is false",
      "@throws NullPointerException if the check fails and either {@code errorMessageTemplate} or\n    {@code errorMessageArgs} is null (don't let this happen)",
      "@throws IllegalStateException if {@code expression} is false",
      "@throws NullPointerException if {@code reference} is null",
      "@throws IndexOutOfBoundsException if {@code index} is negative or is not less than {@code size}",
      "@throws IndexOutOfBoundsException if {@code index} is negative or is greater than {@code size}",
      "@throws IndexOutOfBoundsException if either index is negative or is greater than {@code size},\n    or if {@code end} is less than {@code start}",
      "@return the provided element",
      "@throws IllegalArgumentException if {@code capacity} is less than 1",
      "@throws NullPointerException if escaper is null",
      "@throws IllegalArgumentException if {@code expectedKeys} or {@code\n     expectedValuesPerKey} is negative",
      "@throws IllegalArgumentException if {@code expectedSize} is negative",
      "@throws NullPointerException if {@code elements} or any of its contents is\n     null",
      "@throws NullPointerException if {@code comparator} is null",
      "@throws IllegalArgumentException if {@code map} is not empty",
      "@throws NullPointerException if {@code sets}, any one of the {@code sets},\n    or any element of a provided set is null",
      "@throws NullPointerException if {@code set} is or contains {@code null}",
      "@throws IllegalArgumentException if {@code expectedRows} or {@code\n    expectedCellsPerRow} is negative",
      "@throws IllegalArgumentException if {@code array} is empty",
      "@param array a <i>nonempty</i> array of {@code int} values",
      "@throws IllegalArgumentException if {@code distinctElements} is negative",
      "@throws NullPointerException if any of {@code values} is null",
      "@throws IllegalStateException if there has been a call to {@link #peek()}\n    since the most recent call to {@link #next()} and this implementation\n    does not support this sequence of calls (optional)",
      "@param expectedInsertions the number of expected insertions to the constructed\n    {@code BloomFilter<T>}; must be positive",
      "@param fpp the desired false positive probability (must be positive and less than 1.0)"
   ],
   [
      "@param n expected insertions (must be positive)",
      "@param m total number of bits in Bloom filter (must be positive)",
      "@throws IllegalArgumentException if {@code isCompatible(that) == false}",
      "@throws IllegalArgumentException if {@code interfaceType} is a regular\n    class, enum, or annotation type, rather than an interface",
      "@throws InterruptedException if {@code interruptible} is true and our\n    thread is interrupted during execution",
      "@param throwable the non-null {@code Throwable} to extract causes from",
      "@param key the non-null key whose value should be loaded",
      "@return the value associated with {@code key}; <b>must not be null</b>",
      "@param oldValue the non-null old value corresponding to {@code key}",
      "@return the future new value associated with {@code key};\n    <b>must not be null, must not return null</b>",
      "@param function the function to be used for loading values; must never return {@code null}",
      "@param supplier the supplier to be used for loading values; must never return {@code null}",
      "@param array a <i>nonempty</i> array of {@code double} values",
      "@param result the result to return on successful completion. If you don't\n    need a particular result, consider using constructions of the form:\n    {@code ListenableFuture<?> f = ListenableFutureTask.create(runnable,\n    null)}",
      "@param array a <i>nonempty</i> array of {@code float} values",
      "@throws IllegalArgumentException if the specified expected size is negative",
      "@param array a <i>nonempty</i> array of {@code long} values",
      "@param array a <i>nonempty</i> array of unsigned {@code long} values",
      "@throws ArithmeticException if divisor is 0",
      "@throws NullPointerException if {@code s} is null\n        (in contrast to {@link Long#parseLong(String)})",
      "@param plusForSpace true if ASCII space should be escaped to {@code +}\n       rather than {@code %20}",
      "@throws NullPointerException if any element of {@code keys} is\n    {@code null}, or if {@code valueFunction} produces {@code null}\n    for any key",
      "@throws NullPointerException if any elements of {@code values} is null, or\n        if {@code keyFunction} produces {@code null} for any value",
      "@return {@code true} if {@code c} contains {@code o}",
      "@param array a <i>nonempty</i> array of {@code short} values"
   ],
   [
      "@param delegate the multimap for which an unmodifiable view is to be\n    returned",
      "@return an unmodifiable view of the specified multimap",
      "@param collection the collection for which to return an unmodifiable view",
      "@return an unmodifiable view of the collection",
      "@param entries the entries for which to return an unmodifiable view",
      "@return an unmodifiable view of the entries",
      "@param map the backing map for the returned multimap view",
      "@param values the values to use when constructing the {@code\n    ImmutableListMultimap}",
      "@param keyFunction the function used to produce the key for each value",
      "@return {@code ImmutableListMultimap} mapping the result of evaluating the\n    function {@code keyFunction} on each value in the input collection to\n    that value",
      "@throws NullPointerException if any of the following cases is true:\n    <ul>\n    <li>{@code values} is null\n    <li>{@code keyFunction} is null\n    <li>An element in {@code values} is null\n    <li>{@code keyFunction} returns {@code null} for any element of {@code\n        values}\n    </ul>",
      "@return an iterator over the elements contained in this collection",
      "@throws NoSuchElementException if this range map is empty",
      "@throws IllegalArgumentException if {@code lower} is greater than <i>or\n    equal to</i> {@code upper}",
      "@throws IllegalArgumentException if {@code lower} is greater than {@code\n    upper}",
      "@throws ClassCastException if the parameters are not <i>mutually\n    comparable</i>",
      "@throws NoSuchElementException if {@code values} is empty",
      "@throws IllegalStateException if this range is unbounded below (that is, {@link\n    #hasLowerBound()} returns {@code false})",
      "@throws IllegalStateException if this range is unbounded above (that is, {@link\n    #hasUpperBound()} returns {@code false})",
      "@throws IllegalArgumentException if {@code isConnected(connectedRange)} is {@code false}",
      "@throws NullPointerException if any key or value in {@code map} is null",
      "@throws ClassCastException if any value is not an instance of the type\n    specified by its key",
      "@param type the type of elements desired\n\n<p><b>{@code Stream} equivalent:</b> <pre>   {@code",
      "@throws NullPointerException if the first element is null; if this is a possibility, use\n    {@code iterator().next()} or {@link Iterables#getFirst} instead.",
      "@throws NullPointerException if the last element is null; if this is a possibility, use\n    {@link Iterables#getLast} instead."
   ],
   [
      "@param maxSize the maximum number of elements in the returned fluent iterable",
      "@param comparator the function by which to sort list elements",
      "@throws NullPointerException if any element is null",
      "@param comparator the function by which to sort set elements",
      "@throws NullPointerException if any element of this iterable is {@code null}, or if {@code\n    valueFunction} produces {@code null} for any key",
      "@throws NullPointerException if any of the following cases is true:\n    <ul>\n      <li>{@code keyFunction} is null\n      <li>An element in this fluent iterable is null\n      <li>{@code keyFunction} returns {@code null} for any element of this iterable\n    </ul>\n\n<p><b>{@code Stream} equivalent:</b> {@code stream.collect(Collectors.groupingBy(keyFunction))}\nbehaves similarly, but returns a mutable {@code Map<K, List<E>>} instead, and may not preserve\nthe order of entries).",
      "@return a map mapping the result of evaluating the function {@code\n    keyFunction} on each value in this fluent iterable to that value",
      "@throws IllegalArgumentException if {@code keyFunction} produces the same\n    key for more than one value in this fluent iterable",
      "@throws NullPointerException if any elements of this fluent iterable is null, or\n    if {@code keyFunction} produces {@code null} for any value",
      "@param type the type of the elements",
      "@return a newly-allocated array into which all the elements of this fluent iterable have\n    been copied",
      "@param collection the collection to copy elements to",
      "@return {@code collection}, for convenience",
      "@param element the element to check",
      "@param list the list to be searched.",
      "@param key the value to be searched for.",
      "@param comparator the comparator by which the list is ordered.",
      "@param presentBehavior the specification for what to do if at least one element of the list\n       compares as equal to the key.",
      "@param absentBehavior the specification for what to do if no elements of the list compare as\n       equal to the key.",
      "@return the index determined by the {@code KeyPresentBehavior}, if the key is in the list;\n        otherwise the index determined by the {@code KeyAbsentBehavior}.",
      "@return the next element if there was one. If {@code endOfData} was called\n    during execution, the return value will be ignored.",
      "@throws RuntimeException if any unrecoverable error happens. This exception\n    will propagate outward to the {@code hasNext()}, {@code next()}, or\n    {@code peek()} invocation that invoked this method. Any further\n    attempts to use the iterator will result in an\n    {@link IllegalStateException}.",
      "@return {@code null}; a convenience so your {@code computeNext}\n    implementation can use the simple statement {@code return endOfData();}",
      "@param key key to store in the multimap",
      "@param value value to store in the multimap"
   ],
   [
      "@param map place to store the mapping from each key to its corresponding\n    values",
      "@param comparator the comparator that defines the order",
      "@return comparator itself if it is already an {@code Ordering}; otherwise\n    an ordering that wraps that comparator",
      "@param valuesInOrder the values that the returned comparator will be able\n    to compare, in the order the comparator should induce",
      "@return the comparator described above",
      "@throws IllegalArgumentException if {@code valuesInOrder} contains any\n    duplicate values (according to {@link Object#equals})",
      "@param leastValue the value which the returned comparator should consider\n    the \"least\" of all values",
      "@param remainingValuesInOrder the rest of the values that the returned\n    comparator will be able to compare, in the order the comparator should\n    follow",
      "@throws IllegalArgumentException if any duplicate values (according to\n    {@link Object#equals(Object)}) are present among the method arguments",
      "@param comparators the comparators to try in order",
      "@param iterator the iterator whose minimum element is to be determined",
      "@throws NoSuchElementException if {@code iterator} is empty",
      "@throws ClassCastException if the parameters are not <i>mutually\n    comparable</i> under this ordering.",
      "@param iterable the iterable whose minimum element is to be determined",
      "@throws NoSuchElementException if {@code iterable} is empty",
      "@param a value to compare, returned if less than or equal to b.",
      "@param b value to compare.",
      "@param a value to compare, returned if less than or equal to the rest.",
      "@param b value to compare",
      "@param c value to compare",
      "@param rest values to compare",
      "@param iterator the iterator whose maximum element is to be determined",
      "@param iterable the iterable whose maximum element is to be determined",
      "@param a value to compare, returned if greater than or equal to b.",
      "@param a value to compare, returned if greater than or equal to the rest."
   ],
   [
      "@return an immutable {@code RandomAccess} list of the {@code k} least\n    elements in ascending order",
      "@return an immutable {@code RandomAccess} list of the {@code k} greatest\n    elements in <i>descending order</i>",
      "@throws NullPointerException if any of {@code elements} (or {@code\n    elements} itself) is null",
      "@param sortedList the list to be searched",
      "@param key the key to be searched for",
      "@param elements the elements that the multiset should contain",
      "@throws IllegalArgumentException if {@code elements} is empty",
      "@param comparator the comparator that will be used to sort this multiset. A null value indicates that\n         the elements' <i>natural ordering</i> should be used.",
      "@return a view of this immutable list in reverse order",
      "@param expectedKeys the expected number of distinct keys",
      "@param expectedValuesPerKey the expected average number of values per key",
      "@param multimap the multimap whose contents are copied to this multimap",
      "@return a new {@code HashSet} containing a collection of values for one key",
      "@param distinctElements the expected number of distinct elements",
      "@param element the element to look for",
      "@return the nonnegative number of occurrences of the element",
      "@param occurrences the number of occurrences to add",
      "@return the previous count of the element before the operation; possibly zero",
      "@param element the element to remove",
      "@param occurrences the number of occurrences of {@code element} to remove",
      "@return {@code true} if the removal was possible (including if {@code occurrences} is zero)",
      "@return the count of {@code element} in the multiset before this call",
      "@return {@code true} if the change was successful. This usually indicates\n    that the multiset has been modified, but not always: in the case that\n    {@code expectedOldCount == newCount}, the method will return {@code true} if\n    the condition was met.",
      "@throws IllegalArgumentException if duplicate keys are provided",
      "@throws NullPointerException if any key, value, or entry is null"
   ],
   [
      "@throws IllegalArgumentException if two entries have the same key",
      "@throws NullPointerException if any key or value in {@code multimap} is\n        null",
      "@throws IllegalArgumentException if the given value is already bound to a\n    different key in this bimap. The bimap will remain unmodified in this\n    event. To avoid this exception, call {@link #forcePut} instead.",
      "@param key the key with which the specified value is to be associated",
      "@param value the value to be associated with the specified key",
      "@return the value which was previously associated with the key, which may\n    be {@code null}, or {@code null} if there was no previous entry",
      "@throws IllegalArgumentException if an attempt to {@code put} any\n    entry fails. Note that some map entries may have been added to the\n    bimap before the exception was thrown.",
      "@return the inverse view of this bimap",
      "@throws ClassCastException if the elements are not mutually comparable",
      "@return {@code true} if the method increased the size of the multimap, or\n    {@code false} if the multimap already contained the key-value pair and\n    doesn't allow duplicates",
      "@return {@code true} if the multimap changed",
      "@return the collection of replaced values, or an empty collection if no\n    values were previously associated with the key. The collection\n    <i>may</i> be modifiable, but updating it will have no effect on the\n    multimap.",
      "@return the values that were removed (possibly empty). The returned\n    collection <i>may</i> be modifiable, but updating it will have no\n    effect on the multimap.",
      "@throws NullPointerException if any of the first {@code n} elements of {@code contents} is\n         null",
      "@throws IllegalStateException if an initial capacity was already set",
      "@param size the maximum size of the map",
      "@throws IllegalStateException if a maximum size was already set",
      "@throws IllegalStateException if a concurrency level was already set",
      "@throws IllegalStateException if the key strength was already set",
      "@throws IllegalStateException if the value strength was already set",
      "@param duration the length of time after an entry is created that it should be automatically\n    removed",
      "@param unit the unit that {@code duration} is expressed in",
      "@throws IllegalStateException if the time to live or time to idle was already set",
      "@param duration the length of time after an entry is last accessed that it should be\n    automatically removed",
      "@throws IllegalStateException if the time to idle or time to live was already set"
   ],
   [
      "@throws IllegalStateException if a removal listener was already set",
      "@return a serializable concurrent map having the requested features",
      "@param computingFunction the function used to compute new values",
      "@return an empty collection of values",
      "@param key key to associate with values in the collection",
      "@return an iterator across map entries",
      "@param object object whose subscriber methods should be registered.",
      "@param object object whose subscriber methods should be unregistered.",
      "@throws IllegalArgumentException if the object was not previously registered.",
      "@param event event to post.",
      "@param identifier a brief name for this bus, for logging purposes.  Should\n                   be a valid Java identifier.",
      "@param exceptionHandler Handler for subscriber exceptions.",
      "@return the source of this event.",
      "@return the 'dead' event that could not be delivered.",
      "@param source object broadcasting the DeadEvent (generally the\n               {@link EventBus}).",
      "@param event the event that could not be delivered.",
      "@param identifier short name for the bus, for logging purposes.",
      "@param executor Executor to use to dispatch events. It is the caller's\n       responsibility to shut down the executor after the last event has\n       been posted to this event bus.",
      "@param subscriberExceptionHandler Handler used to handle exceptions thrown from subscribers.\n   See {@link SubscriberExceptionHandler} for more information.",
      "@return The {@link EventBus} that handled the event and the subscriber.\n    Useful for broadcasting a a new event based on the error.",
      "@return The event object that caused the subscriber to throw.",
      "@return The object context that the subscriber was called on.",
      "@return The subscribed method that threw the exception.",
      "@param eventBus The {@link EventBus} that handled the event and the\n    subscriber. Useful for broadcasting a a new event based on the error.",
      "@param event The event object that caused the subscriber to throw."
   ],
   [
      "@param subscriber The source subscriber context.",
      "@param subscriberMethod the subscribed method.",
      "@param safeChars a non null string specifying additional safe characters\n       for this escaper (the ranges 0..9, a..z and A..Z are always safe and\n       should not be specified here)",
      "@throws IllegalArgumentException if any of the parameters were invalid",
      "@param domain A domain name (not IP address)",
      "@return Is the domain name syntactically valid?",
      "@param part The domain name part to be validated",
      "@param isFinalPart Is this the final (rightmost) domain part?",
      "@return Whether the part is valid",
      "@return {@code true} if this domain name appears exactly on the public\n    suffix list",
      "@throws IllegalStateException if this domain does not end with a\n    public suffix",
      "@throws IllegalStateException if the domain has no parent, as determined\n    by {@link #hasParent}",
      "@throws IllegalStateException if multiple charset values have been set for this media type",
      "@throws IllegalCharsetNameException if a charset value is present, but illegal",
      "@throws UnsupportedCharsetException if a charset value is present, but no support is available\n    in this instance of the Java virtual machine",
      "@throws IllegalArgumentException if any parameter or value is invalid",
      "@throws IllegalArgumentException if either {@code attribute} or {@code value} is invalid",
      "@throws IllegalArgumentException if type or subtype is invalid or if a wildcard is used for the\ntype, but not the subtype.",
      "@throws IllegalArgumentException if subtype is invalid",
      "@throws IllegalArgumentException if the input is not parsable",
      "@param bytes byte array representing an IPv4 address (should be of length 4)",
      "@return {@link Inet4Address} corresponding to the supplied byte array",
      "@throws IllegalArgumentException if a valid {@link Inet4Address} can not be created",
      "@param ipString {@code String} containing an IPv4 or IPv6 string literal, e.g.\n    {@code \"192.168.0.1\"} or {@code \"2001:db8::1\"}",
      "@return {@link InetAddress} representing the argument"
   ],
   [
      "@throws IllegalArgumentException if the argument is not a valid IP string literal",
      "@param ipString {@code String} to evaluated as an IP string literal",
      "@return {@code true} if the argument is a valid IP string literal",
      "@param addr the raw 4-byte or 16-byte IP address in big-endian order",
      "@return an InetAddress object created from the raw IP address",
      "@param ip {@link InetAddress} to be converted to an address string",
      "@return {@code String} containing the text-formatted IP address",
      "@param hextets {@code int[]} mutable array of eight 16-bit hextets",
      "@param hextets {@code int[]} array of eight 16-bit hextets, or -1s",
      "@param ip {@link InetAddress} to be converted to URI string literal",
      "@return {@code String} containing URI-safe string literal",
      "@param hostAddr A RFC 3986 section 3.2.2 encoded IPv4 or IPv6 address",
      "@return an InetAddress representing the address in {@code hostAddr}",
      "@throws IllegalArgumentException if {@code hostAddr} is not a valid\n    IPv4 address, or IPv6 address surrounded by square brackets",
      "@param ipString {@code String} to evaluated as an IP URI host string literal",
      "@return {@code true} if the argument is a valid IP URI host",
      "@param ip {@link Inet6Address} to be examined for embedded IPv4 compatible address format",
      "@return {@code true} if the argument is a valid \"compat\" address",
      "@param ip {@link Inet6Address} to be examined for an embedded IPv4 address",
      "@return {@link Inet4Address} of the embedded IPv4 address",
      "@throws IllegalArgumentException if the argument is not a valid IPv4 compatible address",
      "@param ip {@link Inet6Address} to be examined for 6to4 address format",
      "@return {@code true} if the argument is a 6to4 address",
      "@param ip {@link Inet6Address} to be examined for embedded IPv4 in 6to4 address",
      "@return {@link Inet4Address} of embedded IPv4 in 6to4 address"
   ],
   [
      "@throws IllegalArgumentException if the argument is not a valid IPv6 6to4 address",
      "@param ip {@link Inet6Address} to be examined for Teredo address format",
      "@return {@code true} if the argument is a Teredo address",
      "@param ip {@link Inet6Address} to be examined for embedded Teredo information",
      "@return extracted {@code TeredoInfo}",
      "@throws IllegalArgumentException if the argument is not a valid IPv6 Teredo address",
      "@param ip {@link Inet6Address} to be examined for ISATAP address format",
      "@return {@code true} if the argument is an ISATAP address",
      "@param ip {@link Inet6Address} to be examined for embedded IPv4 in ISATAP address",
      "@return {@link Inet4Address} of embedded IPv4 in an ISATAP address",
      "@throws IllegalArgumentException if the argument is not a valid IPv6 ISATAP address",
      "@param ip {@link Inet6Address} to be examined for embedded IPv4 client address",
      "@return {@code true} if there is an embedded IPv4 client address",
      "@return {@link Inet4Address} of embedded IPv4 client address",
      "@throws IllegalArgumentException if the argument does not have a valid embedded IPv4 address",
      "@param ipString {@code String} to be examined for embedded IPv4-mapped IPv6 address format",
      "@return {@code true} if the argument is a valid \"mapped\" address",
      "@param ip {@link InetAddress} to \"coerce\"",
      "@return {@link Inet4Address} represented \"coerced\" address",
      "@param ip {@link InetAddress} to convert",
      "@return {@code int}, \"coerced\" if ip is not an IPv4 address",
      "@param address {@code int}, the 32bit integer address to be converted",
      "@return {@link Inet4Address} equivalent of the argument",
      "@param addr the raw IP address in little-endian byte order",
      "@throws UnknownHostException if IP address is of illegal length"
   ],
   [
      "@param address the InetAddress to decrement",
      "@return a new InetAddress that is one less than the passed in address",
      "@throws IllegalArgumentException if InetAddress is at the beginning of its range",
      "@param address the InetAddress to increment",
      "@return a new InetAddress that is one more than the passed in address",
      "@throws IllegalArgumentException if InetAddress is at the end of its range",
      "@return true if the InetAddress is either 255.255.255.255 for IPv4 or\n    ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6",
      "@return a validated port number, in the range [0..65535]",
      "@throws IllegalStateException if no port is defined.  You can use\n        {@link #withDefaultPort(int)} to prevent this from occurring.",
      "@param host the host string to parse.  Must not contain a port number.",
      "@param port a port number from [0..65535]",
      "@return if parsing was successful, a populated HostAndPort object.",
      "@throws IllegalArgumentException if {@code host} contains a port number,\n    or {@code port} is out of range.",
      "@param host the host-only string to parse.  Must not contain a port number.",
      "@throws IllegalArgumentException if {@code host} contains a port number.",
      "@param hostPortString the input string to parse.",
      "@throws IllegalArgumentException if nothing meaningful could be parsed.",
      "@param hostPortString the full bracketed host-port specification. Post might not be specified.",
      "@return an array with 2 strings: host and port, in that order.",
      "@throws IllegalArgumentException if parsing the bracketed host-port string fails.",
      "@param defaultPort a port number, from [0..65535]",
      "@return a HostAndPort instance, guaranteed to have a defined port.",
      "@return {@code this}, to enable chaining of calls.",
      "@throws IllegalArgumentException if bracketless IPv6 is detected.",
      "@param h hash code"
   ],
   [
      "@param hash the hash code for the key",
      "@return the segment",
      "@param x the value to add",
      "@return the sum",
      "@return the String representation of the {@link #sum}",
      "@throws ExecutionException if a checked exception was thrown while loading the value",
      "@throws UncheckedExecutionException if an unchecked exception was thrown while loading the\n    value",
      "@throws ExecutionError if an error was thrown while loading the value",
      "@return the weight of the entry; must be non-negative",
      "@param listener the backing listener",
      "@param executor the executor with which removal notifications are\n    asynchronously executed",
      "@throws ExecutionException if a checked exception was thrown while loading the value. ({@code\n    ExecutionException} is thrown <a\n    href=\"https://github.com/google/guava/wiki/CachesExplained#interruption\">even if\n    computation was interrupted by an {@code InterruptedException}</a>.)",
      "@throws UncheckedExecutionException if an exception was thrown while loading the value. (As\n    explained in the last paragraph above, this should be an unchecked exception only.)",
      "@throws UncheckedExecutionException if an unchecked exception was thrown while loading the\n    values",
      "@throws ExecutionError if an error was thrown while loading the values",
      "@throws UncheckedExecutionException if an exception was thrown while loading the value. (As\n    described in the documentation for {@link #getUnchecked}, {@code LoadingCache} should be\n    used as a {@code Function} only with cache loaders that throw only unchecked exceptions.)",
      "@throws Exception if unable to load the result",
      "@throws InterruptedException if this method is interrupted. {@code InterruptedException} is\n    treated like any other {@code Exception} in all respects except that, when it is caught,\n    the thread's interrupt status is set",
      "@throws Exception if unable to reload the result",
      "@param keys the unique, non-null keys whose values should be loaded",
      "@return a map from each key in {@code keys} to the value associated with that key;\n    <b>may not contain null values</b>",
      "@return a cache loader that loads values by passing each key to {@code function}",
      "@return a cache loader that loads values by calling {@link Supplier#get}, irrespective of the\n    key",
      "@param spec a String in the format specified by {@link CacheBuilderSpec}",
      "@param size the maximum size of the cache"
   ],
   [
      "@throws IllegalStateException if a maximum size or weight was already set",
      "@param weight the maximum total weight of entries the cache may contain",
      "@throws IllegalStateException if a maximum weight or size was already set",
      "@param weigher the weigher to use in calculating the weight of cache entries",
      "@param duration the length of time after an entry is created that it should be considered\n    stale, and thus eligible for refresh",
      "@throws IllegalStateException if the refresh interval was already set",
      "@throws IllegalStateException if a ticker was already set",
      "@return the cache builder reference that should be used instead of {@code this} for any\n    remaining configuration and cache building",
      "@param loader the cache loader used to obtain new values",
      "@return a cache having the requested features",
      "@param cacheBuilderSpecification the string form",
      "@param currentValue the current value (of either base or a cell)",
      "@param newValue the argument from a user update call",
      "@return result of the update function",
      "@param hc the hash code holder",
      "@return a sun.misc.Unsafe",
      "@return the length of the array",
      "@param i the index",
      "@param newValue the new value",
      "@param expect the expected value",
      "@param update the new value",
      "@return true if successful. False return indicates that\nthe actual value was not equal to the expected value.",
      "@return true if successful",
      "@param delta the value to add",
      "@return the updated value"
   ],
   [
      "@return the String representation of the current values of array",
      "@param length the length of the array",
      "@param array the array to copy elements from",
      "@param executor the ExecutorService that will execute the method calls on\n    the target objects; for example, a {@link\n    Executors#newCachedThreadPool()}.",
      "@param executor the executor to modify to make sure it exits when the\n       application is finished",
      "@param terminationTimeout how long to wait for the executor to\n       finish before terminating the JVM",
      "@param timeUnit unit of time for the time parameter",
      "@return an unmodifiable version of the input which will not hang the JVM",
      "@param service ExecutorService which uses daemon threads",
      "@param terminationTimeout how long to wait for the executor to finish\n       before terminating the JVM",
      "@param executor The executor to decorate",
      "@param nameSupplier The source of names for each task",
      "@param service The executor to decorate",
      "@param service the {@code ExecutorService} to shut down",
      "@param timeout the maximum time to wait for the {@code ExecutorService} to terminate",
      "@param unit the time unit of the timeout argument",
      "@return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n    the call timed out or was interrupted",
      "@param listener the listener to run when the manager changes state",
      "@param executor the executor in which the listeners callback methods will be run.",
      "@throws IllegalStateException if any of the Services are not {@link State#NEW new} when the\n    method is called.",
      "@throws IllegalStateException if the service manager reaches a state from which it cannot\n    become {@linkplain #isHealthy() healthy}.",
      "@param timeout the maximum time to wait",
      "@throws TimeoutException if not all of the services have finished starting within the deadline",
      "@throws TimeoutException if not all of the services have stopped within the deadline",
      "@return Map of services and their corresponding startup time in millis, the map entries will be\n    ordered by startup time."
   ],
   [
      "@param services The services to manage",
      "@throws IllegalArgumentException if not all services are {@linkplain State#NEW new} or if there\nare any duplicate services.",
      "@param target the object to proxy",
      "@param interfaceType the interface you wish the returned proxy to\n    implement",
      "@param timeoutDuration with timeoutUnit, the maximum length of time that\n    callers are willing to wait on each method call to the proxy",
      "@param timeoutUnit with timeoutDuration, the maximum length of time that\n    callers are willing to wait on each method call to the proxy",
      "@return a time-limiting proxy",
      "@param callable the Callable to execute",
      "@param timeoutDuration with timeoutUnit, the maximum length of time to wait",
      "@param timeoutUnit with timeoutDuration, the maximum length of time to wait",
      "@param interruptible whether to respond to thread interruption by aborting\n    the operation and throwing InterruptedException; if false, the\n    operation is allowed to complete or time out, and the current thread's\n    interrupt status is re-asserted.",
      "@return the result returned by the Callable",
      "@throws UncheckedTimeoutException if the time limit is reached",
      "@return {@code true} if successful. False return indicates that\nthe actual value was not bitwise equal to the expected value.",
      "@return {@code true} if successful",
      "@return the String representation of the current value",
      "@param initialValue the initial value",
      "@return a new {@code AtomicReference} with no initial value",
      "@return a new {@code AtomicReference} with the given initial value",
      "@return a new {@code AtomicReferenceArray} with the given length",
      "@return a new {@code AtomicReferenceArray} copied from the given array",
      "@throws NullPointerException if any element of {@code tasks} is null",
      "@throws java.lang.IllegalStateException if this executor is not suspended.",
      "@throws X if {@link #get()} throws an {@link InterruptedException},\n        {@link CancellationException}, or {@link ExecutionException}",
      "@throws TimeoutException {@inheritDoc}"
   ],
   [
      "@throws ExecutionException if the computation threw an exception",
      "@throws CancellationException if the computation was cancelled",
      "@throws TimeoutException if the wait timed out",
      "@throws ClassCastException if the class of the specified element prevents\n    it from being added to the given queue",
      "@throws IllegalArgumentException if some property of the specified element\n    prevents it from being added to the given queue",
      "@throws InterruptedException if the current thread was interrupted before\n    or during the call (optional but recommended).",
      "@throws CancellationException {@inheritDoc}",
      "@param value the value to be used as the result",
      "@return true if the attempt was accepted, completing the {@code Future}",
      "@param throwable the exception to be used as the failed result",
      "@param future the future to delegate to",
      "@return true if the attempt was accepted, indicating that the {@code Future} was not previously\n    cancelled or set.",
      "@param future the done future to complete this future with.",
      "@param expected the expected value of the {@link #value} field.",
      "@throws RuntimeException if the {@code Future} has not failed",
      "@param callable the callable task",
      "@param runnable the runnable task",
      "@param permitsPerSecond the rate of the returned {@code RateLimiter}, measured in\n       how many permits become available per second",
      "@param warmupPeriod the duration of the period where the {@code RateLimiter} ramps up its\n       rate, before reaching its stable (maximum) rate",
      "@param unit the time unit of the warmupPeriod argument",
      "@param permitsPerSecond the new stable rate of this {@code RateLimiter}",
      "@return time spent sleeping to enforce rate, in seconds; 0.0 if not rate-limited",
      "@param permits the number of permits to acquire",
      "@return time in microseconds to wait until the resource can be acquired, never negative",
      "@param timeout the maximum time to wait for the permit. Negative values are treated as zero."
   ],
   [
      "@return {@code true} if the permit was acquired, {@code false} otherwise",
      "@throws IllegalArgumentException if the requested number of permits is negative or zero",
      "@return {@code true} if the permits were acquired, {@code false} otherwise",
      "@param timeout the maximum time to wait for the permits. Negative values are treated as zero.",
      "@return the required wait time, never negative",
      "@return the time that permits are available, or, if permits are available immediately, an\n    arbitrary past or present time",
      "@return the time that the permits may be used, or, if the permits may be used immediately, an\n    arbitrary past or present time",
      "@param nameFormat a {@link String#format(String, Object...)}-compatible\n    format String, to which a unique integer (0, 1, etc.) will be supplied\n    as the single parameter. This integer will be unique to the built\n    instance of the ThreadFactory and will be assigned sequentially. For\n    example, {@code \"rpc-pool-%d\"} will generate thread names like\n    {@code \"rpc-pool-0\"}, {@code \"rpc-pool-1\"}, {@code \"rpc-pool-2\"}, etc.",
      "@return this for the builder pattern",
      "@param daemon whether or not new Threads created with this ThreadFactory\n    will be daemon threads",
      "@param priority the priority for new Threads created with this\n    ThreadFactory",
      "@param uncaughtExceptionHandler the uncaught exception handler for new\n    Threads created with this ThreadFactory",
      "@param backingThreadFactory the backing {@link ThreadFactory} which will\n    be delegated to during thread creation.",
      "@return the fully constructed {@link ThreadFactory}",
      "@throws IllegalStateException if the service is not {@link State#STARTING}.",
      "@throws IllegalStateException if the service is neither {@link State#STOPPING} nor\n        {@link State#RUNNING}.",
      "@throws IllegalStateException if the service is not {@link State#NEW}",
      "@throws IllegalStateException if the service reaches a state from which it is not possible to\n    enter the {@link State#RUNNING} state. e.g. if the {@code state} is \n    {@code State#TERMINATED} when this method is called then this will throw an \n    IllegalStateException.",
      "@throws TimeoutException if the service has not reached the given state within the deadline",
      "@throws IllegalStateException if the service reaches a state from which it is not possible to\n    enter the {@link State#RUNNING RUNNING} state. e.g. if the {@code state} is \n    {@code State#TERMINATED} when this method is called then this will throw an \n    IllegalStateException.",
      "@throws IllegalStateException if the service {@linkplain State#FAILED fails}.",
      "@throws IllegalStateException if this service's state isn't {@linkplain State#FAILED FAILED}.",
      "@param listener the listener to run when the service changes state is complete",
      "@param executor the executor in which the listeners callback methods will be run. For fast,\n    lightweight listeners that would be safe to execute in any thread, consider \n    {@link MoreExecutors#directExecutor}.",
      "@param callable The callable to wrap"
   ],
   [
      "@param nameSupplier The supplier of thread names, {@link Supplier#get get} will be called once\n    for each invocation of the wrapped callable.",
      "@param task The Runnable to wrap",
      "@param t the exception that made the future fail. If the future's {@link Future#get() get}\n    method throws an {@link ExecutionException}, then the cause is passed to this method. Any\n    other thrown object is passed unaltered.",
      "@param key an arbitrary, non-null key",
      "@return the stripe that the passed key corresponds to",
      "@param index the index of the stripe to return; must be in {@code [0...size())}",
      "@return the stripe at the specified index",
      "@param keys arbitrary non-null keys",
      "@return the stripes corresponding to the objects (one per each object, derived by delegating\n        to {@link #get(Object)}; may contain duplicates), in an increasing index order.",
      "@param stripes the minimum number of stripes (locks) required",
      "@return a new {@code Striped<Lock>}",
      "@param stripes the minimum number of stripes (semaphores) required",
      "@param permits the number of permits in each semaphore",
      "@return a new {@code Striped<Semaphore>}",
      "@return a new {@code Striped<ReadWriteLock>}",
      "@param input the primary input {@code Future}",
      "@param fallback the {@link FutureFallback} implementation to be called if\n    {@code input} fails",
      "@param executor the executor that runs {@code fallback} if {@code input}\n    fails",
      "@param exceptionType the exception type that triggers use of {@code fallback}. To avoid hiding\n    bugs and other unrecoverable errors, callers should prefer more specific types, avoiding\n    {@code Throwable.class} in particular.",
      "@param fallback the {@link Function} implementation to be called if {@code input} fails with\n    the expected exception type",
      "@param executor the executor that runs {@code fallback} if {@code input} fails",
      "@param fallback the {@link AsyncFunction} implementation to be called if {@code input} fails\n    with the expected exception type",
      "@param delegate The future to delegate to.",
      "@param time when to timeout the future",
      "@param unit the time unit of the time parameter"
   ],
   [
      "@param scheduledExecutor The executor service to enforce the timeout.",
      "@param input The future to transform",
      "@param function A function to transform the result of the input future\n    to the result of the output future",
      "@return A future that holds result of the function (if the input succeeded)\n    or the original input's failure (if not)",
      "@param executor Executor to run the function in.",
      "@param function A function to transform the result of the input future to the result of the\n    output future",
      "@return A future that holds result of the function (if the input succeeded) or the original\n    input's failure (if not)",
      "@param function A Function to transform the results of the provided future\n    to the results of the returned future.  This will be run in the thread\n    that notifies input it is complete.",
      "@return A future that holds result of the transformation.",
      "@param function A Function to transform the results of the provided future\n    to the results of the returned future.",
      "@return A future that returns the result of the transformation.",
      "@param nested The nested future to transform.",
      "@return A future that holds result of the inner future.",
      "@param futures futures to combine",
      "@return a future that provides a list of the results of the component\n        futures",
      "@param future The future attach the callback to.",
      "@param callback The callback to invoke when {@code future} is completed.",
      "@param executor The executor to run {@code callback} when the future\n   completes.",
      "@throws X if {@code get} throws any checked exception except for an {@code\n        ExecutionException} whose cause is not itself a checked exception",
      "@throws UncheckedExecutionException if {@code get} throws an {@code\n        ExecutionException} with a {@code RuntimeException} as its cause",
      "@throws ExecutionError if {@code get} throws an {@code ExecutionException}\n        with an {@code Error} as its cause",
      "@throws CancellationException if {@code get} throws a {@code\n        CancellationException}",
      "@throws IllegalArgumentException if {@code exceptionClass} extends {@code\n        RuntimeException} or does not have a suitable constructor",
      "@throws X if {@code get} throws any checked exception except for an {@code\n    ExecutionException} whose cause is not itself a checked exception",
      "@throws UncheckedExecutionException if {@code get} throws an {@code\n    ExecutionException} with a {@code RuntimeException} as its cause"
   ],
   [
      "@throws ExecutionError if {@code get} throws an {@code ExecutionException}\n    with an {@code Error} as its cause",
      "@throws CancellationException if {@code get} throws a {@code\n    CancellationException}",
      "@throws IllegalArgumentException if {@code exceptionClass} extends {@code\n    RuntimeException} or does not have a suitable constructor",
      "@throws UncheckedExecutionException if {@code get} throws an {@code\n        ExecutionException} with an {@code Exception} as its cause",
      "@param listener the listener to run when the computation is complete",
      "@param executor the executor to run the listener in",
      "@throws NullPointerException if the executor or listener was null",
      "@throws RejectedExecutionException if we tried to execute the listener\n        immediately but the executor rejected it.",
      "@throws InterruptedException if interrupted while waiting",
      "@return whether the monitor was entered",
      "@return whether the monitor was entered, which guarantees that the guard is now satisfied",
      "@param fair whether this monitor should use a fair ordering policy rather than a non-fair (but\n       fast) one",
      "@return a {@code ListenableFuture} representing pending completion of the task",
      "@throws RejectedExecutionException {@inheritDoc}",
      "@return A list of {@code ListenableFuture} instances representing the tasks, in the same\n        sequential order as produced by the iterator for the given task list, each of which has\n        completed.",
      "@return a list of {@code ListenableFuture} instances representing the tasks, in the same\n        sequential order as produced by the iterator for the given task list. If the operation\n        did not time out, each task will have completed. If it did time out, some of these\n        tasks will not have completed.",
      "@return the result of executing the future.",
      "@throws X on interruption, cancellation or execution exceptions.",
      "@throws TimeoutException if retrieving the result timed out.",
      "@param k0 the first half of the key",
      "@param k1 the second half of the key",
      "@param minimumBits a positive integer (can be arbitrarily large)",
      "@return a hash function, described above, that produces hash codes of length {@code\n    minimumBits} or greater",
      "@throws IllegalArgumentException if {@code hashCodes} is empty, or the hash codes\n    do not all have the same bit length",
      "@param dest the byte array into which the hash code will be written"
   ],
   [
      "@param offset the start offset in the data",
      "@param maxLength the maximum number of bytes to write",
      "@return the number of bytes written to {@code dest}",
      "@throws IndexOutOfBoundsException if there is not enough room in {@code dest}",
      "@param b a byte",
      "@return this instance",
      "@param bytes a byte array",
      "@param off the start offset in the array",
      "@param len the number of bytes to write",
      "@return true if the bloom filter's bits changed as a result of this operation. If the bits\n    changed, this is <i>definitely</i> the first time {@code object} has been added to the\n    filter. If the bits haven't changed, this <i>might</i> be the first time {@code object}\n    has been added to the filter. Note that {@code put(t)} always returns the\n    <i>opposite</i> result to what {@code mightContain(t)} would have returned at the time\n    it is called.\"",
      "@param that The bloom filter to check for compatibility.",
      "@param that The bloom filter to combine this bloom filter with. It is not mutated.",
      "@param funnel the funnel of T's that the constructed {@code BloomFilter<T>} will use",
      "@return a {@code BloomFilter}",
      "@param p false positive rate (must be 0 < p < 1)",
      "@throws IOException if the InputStream throws an {@code IOException}, or if its data does\n    not appear to be a BloomFilter serialized using the\n    {@linkplain #writeTo(OutputStream)} method.",
      "@throws IOException this operation is not supported",
      "@throws IOException if the attempt to read class path resources (jar files or directories)\n        failed.",
      "@throws ExceptionInInitializerError if an exception is thrown during\n  initialization of a class",
      "@throws IllegalArgumentException if {@code interfaceType} does not specify\n    the type of a Java interface",
      "@param <X> The parameter type",
      "@param typeParam the parameter type variable",
      "@param typeArg the actual type to substitute",
      "@return the value previously associated with this class (possibly {@code null}),\n        or {@code null} if there was no previous entry.",
      "@return the value previously associated with this type (possibly {@code null}),\n        or {@code null} if there was no previous entry."
   ],
   [
      "@param formal The type whose type variables or itself is mapped to other type(s). It's almost\n       always a bug if {@code formal} isn't a type variable and contains no type variable. Make\n       sure you are passing the two parameters in the right order.",
      "@param actual The type that the formal type variable(s) are mapped to. It can be or contain yet\n       other type variables, in which case these type variables will be further resolved if\n       corresponding mappings exist in the current {@code TypeResolver} instance.",
      "@throws IOException if an I/O error occurs in the process of opening the reader",
      "@throws IOException if an I/O error occurs in the process of reading the length of this source",
      "@throws IOException if an I/O error occurs in the process of reading from this source or\n    writing to {@code appendable}",
      "@throws IOException if an I/O error occurs in the process of reading from this source or\n    writing to {@code sink}",
      "@throws IOException if an I/O error occurs in the process of reading from this source",
      "@throws IOException if an I/O error occurs in the process of reading from this source or if\n    {@code processor} throws an {@code IOException}",
      "@throws IOException if an I/O error occurs",
      "@param sources the sources to concatenate",
      "@return a {@code CharSource} containing the concatenated data",
      "@throws IOException if an I/O error occurs in the process of opening the writer",
      "@throws IOException if an I/O error in the process of writing to this sink",
      "@throws IOException if an I/O error occurs in the process of writing to this sink",
      "@throws IOException if an I/O error occurs in the process of reading from {@code readable} or\n    writing to this sink",
      "@param target target to which to append output",
      "@param it an iterator of I/O suppliers that will provide each substream",
      "@throws IOException if an I/O error occurs in the process of opening the stream",
      "@throws IOException if an I/O occurs in the process of writing to this sink",
      "@throws IOException if an I/O occurs in the process of reading from {@code input} or writing to\n    this sink",
      "@return this method does not return; it always throws",
      "@throws IOException when the given throwable is an IOException",
      "@throws X when the given throwable is of the declared type X",
      "@throws X1 when the given throwable is of the declared type X1",
      "@throws X2 when the given throwable is of the declared type X2"
   ],
   [
      "@param patternStr the pattern string on which to filter file names",
      "@throws PatternSyntaxException if pattern compilation fails (runtime)",
      "@param pattern the pattern on which to filter file names",
      "@param closeable the {@code Closeable} object to be closed, or null, in which case this method\n    does nothing",
      "@param swallowIOException if true, don't propagate IO exceptions thrown by the {@code close}\n    methods",
      "@param inputStream the input stream to be closed, or {@code null} in which case this method\n    does nothing",
      "@param reader the reader to be closed, or {@code null} in which case this method does nothing",
      "@throws IllegalArgumentException if the input is not a valid encoded string according to this\n        encoding.",
      "@throws DecodingException if the input is not a valid encoded string according to this\n        encoding.",
      "@throws IllegalArgumentException if this padding character is already used in the alphabet or a\n        separator",
      "@throws UnsupportedOperationException if this encoding already uses a separator",
      "@throws IllegalStateException if the alphabet used by this encoding contains mixed upper- and\n        lower-case characters",
      "@param cbuf the character buffer to process",
      "@param off the offset into the buffer",
      "@param len the number of characters to process",
      "@param line a line of text (possibly empty), without any line separators",
      "@param end the line separator; one of {@code \"\\r\"}, {@code \"\\n\"},\n    {@code \"\\r\\n\"}, or {@code \"\"}",
      "@param file the file to read from",
      "@param charset the charset used to decode the input stream; see {@link\n    Charsets} for helpful predefined constants",
      "@return the buffered reader",
      "@param file the file to write to",
      "@param charset the charset used to encode the output stream; see {@link\n    Charsets} for helpful predefined constants",
      "@return the buffered writer",
      "@return a byte array containing all the bytes from file",
      "@throws IllegalArgumentException if the file is bigger than the largest\n    possible byte array (2^31 - 1)"
   ],
   [
      "@return a string containing all the characters from the file",
      "@param from the bytes to write",
      "@param to the destination file",
      "@param from the source file",
      "@param to the output stream",
      "@throws IllegalArgumentException if {@code from.equals(to)}",
      "@param from the character sequence to write",
      "@param from the character sequence to append",
      "@param append true to append, false to overwrite",
      "@param to the appendable object",
      "@return the newly-created directory",
      "@throws IllegalStateException if the directory could not be created",
      "@param file the file to create or update",
      "@throws IOException if an I/O error occurs, or if any necessary but\n    nonexistent parent directories of the specified file could not be\n    created.",
      "@return the first line, or null if the file is empty",
      "@return a mutable {@link List} containing all the lines",
      "@param callback the {@link LineProcessor} to use to handle the lines",
      "@return the output of processing the lines",
      "@param file the file to read",
      "@param processor the object to which the bytes of the file are passed.",
      "@return the result of the byte processor",
      "@param hashFunction the hash function to use to hash the data",
      "@return the {@link HashCode} of all of the bytes in the file",
      "@param file the file to map",
      "@return a read-only buffer reflecting {@code file}"
   ],
   [
      "@param mode the mode to use when mapping {@code file}",
      "@return a buffer reflecting {@code file}",
      "@param file The name of the file to trim the extension from. This can be either a fully\n    qualified file name (including a path) or just a file name.",
      "@return The file name without its path or extension.",
      "@param from the object to read from",
      "@param to the object to write to",
      "@return the number of characters copied",
      "@param r the object to read from",
      "@return a string containing all the characters",
      "@return a {@link StringBuilder} containing all the characters",
      "@param reader the reader to read from",
      "@param n the number of characters to skip",
      "@throws EOFException if this stream reaches the end before skipping all\n    the characters",
      "@param target the object to which output will be sent",
      "@return a new Writer object, unless target is a Writer, in which case the\n    target is returned",
      "@param url the URL to read from",
      "@return a byte array containing all the bytes from the URL",
      "@return a string containing all the characters from the URL",
      "@throws IOException if an I/O error occurs.",
      "@param callback the LineProcessor to use to handle the lines",
      "@param from the URL to read from",
      "@throws IllegalArgumentException if the resource is not found",
      "@param from the input stream to read from",
      "@param to the output stream to write to",
      "@return the number of bytes copied"
   ],
   [
      "@param from the readable channel to read from",
      "@param to the writable channel to write to",
      "@param in the input stream to read from",
      "@return a byte array containing all the bytes from the stream",
      "@param in the input stream to be wrapped",
      "@param limit the maximum number of bytes to be read",
      "@return a length-limited {@link InputStream}",
      "@param in the input stream to read from.",
      "@param b the buffer into which the data is read.",
      "@throws EOFException if this stream reaches the end before reading all\n    the bytes.",
      "@param off an int specifying the offset into the data.",
      "@param len an int specifying the number of bytes to read.",
      "@param n the number of bytes to skip",
      "@throws EOFException if this stream reaches the end before skipping all\n    the bytes",
      "@throws IOException if an I/O error occurs, or the stream does not\n    support skipping",
      "@param input the input stream to process",
      "@param processor the object to which to pass the bytes of the stream",
      "@param b the buffer into which the data is read",
      "@param off an int specifying the offset into the data",
      "@param len an int specifying the number of bytes to read",
      "@return the number of bytes read",
      "@param flushable the {@code Flushable} object to be flushed.",
      "@throws IllegalArgumentException if {@code value} is greater than {@link\n    Short#MAX_VALUE} or less than {@link Short#MIN_VALUE}",
      "@throws IllegalArgumentException if {@code bytes} has fewer than 2\n    elements",
      "@param array a <i>nonempty</i> array of {@code char} values"
   ],
   [
      "@throws IllegalArgumentException if {@code countMap} is not empty",
      "@param countMap backing map for storing the elements in the multiset and\n    their counts. It must be empty.",
      "@throws IllegalArgumentException if {@code occurrences} is negative, or if\n    the resulting amount would exceed {@link Integer#MAX_VALUE}",
      "@throws IllegalArgumentException if {@code occurrences} is negative",
      "@throws IllegalArgumentException if {@code count} is negative",
      "@throws IllegalArgumentException if {@code expectedOldCount} or {@code newCount} is negative",
      "@throws NullPointerException if {@code comparator} or any of\n    {@code elements} is null",
      "@throws NullPointerException if {@code comparator} or any of {@code\n        elements} is null",
      "@throws NullPointerException if {@code sortedSet} or any of its elements\n    is null",
      "@param array a <i>nonempty</i> array of unsigned {@code int} values",
      "@throws NullPointerException if {@code s} is null\n        (in contrast to {@link Integer#parseInt(String)})",
      "@throws IllegalArgumentException if {@code initialArraySize} is negative",
      "@throws IllegalArgumentException if {@code estimatedSize} is negative",
      "@throws NullPointerException if {@code lists}, any one of the {@code lists},\n    or any element of a provided list is null",
      "@throws NullPointerException if {@code lists}, any one of the\n    {@code lists}, or any element of a provided list is null",
      "@throws IllegalArgumentException if {@code value} is negative",
      "@throws IllegalArgumentException if {@code duration} is not positive",
      "@return {@code true} always",
      "@throws IllegalArgumentException if {@code backingMap} is not empty",
      "@return whether the guard is now satisfied",
      "@throws NullPointerException if {@code input} is null and this function does not accept null\n    arguments",
      "@throws NullPointerException if any of the provided keys is null",
      "@throws IllegalArgumentException if the provided table is empty",
      "@param wasUncontended false if CAS failed before call",
      "@throws IllegalArgumentException if {@code n} is negative"
   ],
   [
      "@throws IllegalStateException if the stopwatch is already running.",
      "@param array a <i>nonempty</i> array of {@code byte} values",
      "@throws NullPointerException if {@code sample} is null",
      "@throws IllegalArgumentException if {@code name} is not syntactically valid\n    according to {@link #isValid}",
      "@throws NullPointerException if leftParts is null",
      "@param swallowIOException if true, don't propagate IO exceptions\n    thrown by the {@code flush} method",
      "@param out the output stream to be wrapped",
      "@throws IOException if an I/O error occurs in the process of reading the size of this source",
      "@throws IOException if an I/O error occurs in the process of reading from this source or\n    writing to {@code output}",
      "@throws IOException if an I/O error occurs in the process of reading from this source or\n    {@code other}",
      "@return a {@code ByteSource} containing the concatenated data",
      "@return the next two bytes of the input stream, interpreted as an \n        unsigned 16-bit integer in little-endian byte order",
      "@return the next four bytes of the input stream, interpreted as an \n        {@code int} in little-endian byte order",
      "@return the next eight bytes of the input stream, interpreted as a \n        {@code long} in little-endian byte order",
      "@return the next four bytes of the input stream, interpreted as a\n        {@code float} in little-endian byte order",
      "@return the next eight bytes of the input stream, interpreted as a\n        {@code double} in little-endian byte order",
      "@return the next two bytes of the input stream, interpreted as a\n        {@code short} in little-endian byte order.",
      "@return the next two bytes of the input stream, interpreted as a \n        {@code char} in little-endian byte order",
      "@return byte read from input",
      "@throws IOException if an error is encountered while reading",
      "@throws EOFException if the end of file (EOF) is encountered.",
      "@param in the stream to delegate to",
      "@param line the line read from the input, without delimiter",
      "@return true to continue processing, false to stop",
      "@throws IOException if an I/O error occurred while deleting the file buffer"
   ],
   [
      "@param fileThreshold the number of bytes before the stream should\n    switch to buffering to a file",
      "@param resetOnFinalize if true, the {@link #reset} method will\n    be called when the {@link ByteSource} returned by {@link\n    #asByteSource} is finalized",
      "@return a {@code String} containing the contents of the line, not\n    including any line-termination characters, or {@code null} if the\n    end of the stream has been reached.",
      "@param out the stream to delegate to",
      "@param buf the byte array containing the data to process",
      "@param off the initial offset into the array",
      "@param len the length of data to be processed",
      "@throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}\n        is not a power of two",
      "@throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}\n        is not a power of ten",
      "@throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and\n        {@code sqrt(x)} is not an integer",
      "@throws ArithmeticException if {@code a + b} overflows in signed {@code long} arithmetic",
      "@throws ArithmeticException if {@code a - b} overflows in signed {@code long} arithmetic",
      "@throws ArithmeticException if {@code a * b} overflows in signed {@code long} arithmetic",
      "@throws ArithmeticException if {@code b} to the {@code k}th power overflows in signed\n        {@code long} arithmetic",
      "@throws IllegalArgumentException if {@code n < 0}, {@code k < 0}, or {@code k > n}",
      "@throws ArithmeticException if {@code a + b} overflows in signed {@code int} arithmetic",
      "@throws ArithmeticException if {@code a - b} overflows in signed {@code int} arithmetic",
      "@throws ArithmeticException if {@code a * b} overflows in signed {@code int} arithmetic",
      "@throws ArithmeticException if {@code b} to the {@code k}th power overflows in signed\n        {@code int} arithmetic",
      "@throws IllegalArgumentException if {@code n < 0}, {@code k < 0} or {@code k > n}",
      "@throws ArithmeticException if\n        <ul>\n        <li>{@code x} is infinite or NaN\n        <li>{@code x}, after being rounded to a mathematical integer using the specified\n        rounding mode, is either less than {@code Integer.MIN_VALUE} or greater than {@code\n        Integer.MAX_VALUE}\n        <li>{@code x} is not a mathematical integer and {@code mode} is\n        {@link RoundingMode#UNNECESSARY}\n        </ul>",
      "@throws ArithmeticException if\n        <ul>\n        <li>{@code x} is infinite or NaN\n        <li>{@code x}, after being rounded to a mathematical integer using the specified\n        rounding mode, is either less than {@code Long.MIN_VALUE} or greater than {@code\n        Long.MAX_VALUE}\n        <li>{@code x} is not a mathematical integer and {@code mode} is\n        {@link RoundingMode#UNNECESSARY}\n        </ul>",
      "@throws ArithmeticException if\n        <ul>\n        <li>{@code x} is infinite or NaN\n        <li>{@code x} is not a mathematical integer and {@code mode} is\n        {@link RoundingMode#UNNECESSARY}\n        </ul>",
      "@throws IllegalArgumentException if {@code x <= 0.0}, {@code x} is NaN, or {@code x} is\n        infinite",
      "@param values a nonempty series of values, which will be converted to {@code double} values\n    (this may cause loss of precision for longs of magnitude over 2^53 (slightly over 9e15))"
   ],
   [
      "@param values a nonempty series of values, which will be converted to {@code double} values\n    (this may cause loss of precision)",
      "@throws IllegalArgumentException if {@code values} is empty or contains any non-finite value",
      "@param value a primitive {@code float} value",
      "@return a hash code for the value",
      "@param a the first {@code float} to compare",
      "@param b the second {@code float} to compare",
      "@return the result of invoking {@link Float#compare(float, float)}",
      "@param array an array of {@code float} values, possibly empty",
      "@param target a primitive {@code float} value",
      "@return {@code true} if {@code array[i] == target} for some value of {@code\n    i}",
      "@return the least index {@code i} for which {@code array[i] == target}, or\n    {@code -1} if no such index exists.",
      "@param array the array to search for the sequence {@code target}",
      "@param target the array to search for as a sub-sequence of {@code array}",
      "@return the greatest index {@code i} for which {@code array[i] == target},\n    or {@code -1} if no such index exists.",
      "@return the value present in {@code array} that is less than or equal to\n    every other value in the array",
      "@return the value present in {@code array} that is greater than or equal to\n    every other value in the array",
      "@param arrays zero or more {@code float} arrays",
      "@return a single array containing all the values from the source arrays, in\n    order",
      "@param array the source array",
      "@param minLength the minimum length the returned array must guarantee",
      "@param padding an extra amount to \"grow\" the array by if growth is\n    necessary",
      "@return an array containing the values of {@code array}, with guaranteed\n    minimum length {@code minLength}",
      "@param separator the text that should appear between consecutive values in\n    the resulting string (but not at the start or end)",
      "@param collection a collection of {@code Number} instances",
      "@return an array containing the same values as {@code collection}, in the\n    same order, converted to primitives"
   ],
   [
      "@param backingArray the array to back the list",
      "@return a list view of the array",
      "@param string the string representation of a {@code float} value",
      "@return the floating point value represented by {@code string}, or\n    {@code null} if {@code string} has a length of zero or cannot be\n    parsed as a {@code float} value",
      "@param value a primitive {@code boolean} value",
      "@param a the first {@code boolean} to compare",
      "@param b the second {@code boolean} to compare",
      "@return a positive number if only {@code a} is {@code true}, a negative\n    number if only {@code b} is true, or zero if {@code a == b}",
      "@param array an array of {@code boolean} values, possibly empty",
      "@param target a primitive {@code boolean} value",
      "@param arrays zero or more {@code boolean} arrays",
      "@param collection a collection of {@code Boolean} objects",
      "@param a the first unsigned {@code long} to compare",
      "@param b the second unsigned {@code long} to compare",
      "@return a negative value if {@code a} is less than {@code b}; a positive value if {@code a} is\n        greater than {@code b}; or zero if they are equal",
      "@return the value present in {@code array} that is less than or equal to every other value in\n        the array according to {@link #compare}",
      "@return the value present in {@code array} that is greater than or equal to every other value\n        in the array according to {@link #compare}",
      "@param separator the text that should appear between consecutive values in the resulting\n       string (but not at the start or end)",
      "@param array an array of unsigned {@code long} values, possibly empty",
      "@param dividend the dividend (numerator)",
      "@param divisor the divisor (denominator)",
      "@throws NumberFormatException if the string does not contain a valid unsigned {@code long}\n        value",
      "@param s the string containing the unsigned {@code long} representation to be parsed.",
      "@param radix the radix to use while parsing {@code s}",
      "@throws NumberFormatException if the string does not contain a valid unsigned {@code long}\n        with the given radix, or if {@code radix} is not between {@link Character#MIN_RADIX}\n        and {@link Character#MAX_RADIX}."
   ],
   [
      "@param x the value to convert to a string.",
      "@param radix the radix to use while working with {@code x}",
      "@throws IllegalArgumentException if {@code radix} is not between {@link Character#MIN_RADIX}\n        and {@link Character#MAX_RADIX}.",
      "@param value a primitive {@code short} value",
      "@param value any value in the range of the {@code short} type",
      "@return the {@code short} value that equals {@code value}",
      "@param value any {@code long} value",
      "@return the same value cast to {@code short} if it is in the range of the\n    {@code short} type, {@link Short#MAX_VALUE} if it is too large,\n    or {@link Short#MIN_VALUE} if it is too small",
      "@param a the first {@code short} to compare",
      "@param b the second {@code short} to compare",
      "@return a negative value if {@code a} is less than {@code b}; a positive\n    value if {@code a} is greater than {@code b}; or zero if they are equal",
      "@param array an array of {@code short} values, possibly empty",
      "@param target a primitive {@code short} value",
      "@param arrays zero or more {@code short} arrays",
      "@param value any value in the range of the {@code byte} type",
      "@return the {@code byte} value that equals {@code value}",
      "@throws IllegalArgumentException if {@code value} is greater than {@link\n    Byte#MAX_VALUE} or less than {@link Byte#MIN_VALUE}",
      "@return the same value cast to {@code byte} if it is in the range of the\n    {@code byte} type, {@link Byte#MAX_VALUE} if it is too large,\n    or {@link Byte#MIN_VALUE} if it is too small",
      "@param array an array of {@code byte} values, possibly empty",
      "@param value a primitive {@code double} value",
      "@param a the first {@code double} to compare",
      "@param b the second {@code double} to compare",
      "@param array an array of {@code double} values, possibly empty",
      "@param target a primitive {@code double} value",
      "@param arrays zero or more {@code double} arrays"
   ],
   [
      "@param string the string representation of a {@code double} value",
      "@return the floating point value represented by {@code string}, or\n    {@code null} if {@code string} has a length of zero or cannot be\n    parsed as a {@code double} value",
      "@param value a primitive {@code byte} value",
      "@param target a primitive {@code byte} value",
      "@param arrays zero or more {@code byte} arrays",
      "@param a the first unsigned {@code int} to compare",
      "@param b the second unsigned {@code int} to compare",
      "@param array an array of unsigned {@code int} values, possibly empty",
      "@throws NumberFormatException if the string does not contain a valid unsigned {@code int} value",
      "@param string the string containing the unsigned integer representation to be parsed.",
      "@param radix the radix to use while parsing {@code s}; must be between\n       {@link Character#MIN_RADIX} and {@link Character#MAX_RADIX}.",
      "@throws NumberFormatException if the string does not contain a valid unsigned {@code int}, or\n        if supplied radix is invalid.",
      "@throws IllegalArgumentException if {@code value} is negative or {@code value >= 2^64}",
      "@throws NumberFormatException if the string does not contain a parsable unsigned {@code long}\n    value",
      "@throws NumberFormatException if the string does not contain a parsable unsigned {@code long}\n    value, or {@code radix} is not between {@link Character#MIN_RADIX} and\n    {@link Character#MAX_RADIX}",
      "@param value a primitive {@code int} value",
      "@param value any value in the range of the {@code int} type",
      "@return the {@code int} value that equals {@code value}",
      "@throws IllegalArgumentException if {@code value} is greater than {@link\n    Integer#MAX_VALUE} or less than {@link Integer#MIN_VALUE}",
      "@return the same value cast to {@code int} if it is in the range of the\n    {@code int} type, {@link Integer#MAX_VALUE} if it is too large,\n    or {@link Integer#MIN_VALUE} if it is too small",
      "@param a the first {@code int} to compare",
      "@param b the second {@code int} to compare",
      "@param array an array of {@code int} values, possibly empty",
      "@param target a primitive {@code int} value",
      "@param arrays zero or more {@code int} arrays"
   ],
   [
      "@throws IllegalArgumentException if {@code bytes} has fewer than 4 elements",
      "@param string the string representation of an integer value",
      "@return the integer value represented by {@code string}, or {@code null} if\n    {@code string} has a length of zero or cannot be parsed as an integer\n    value",
      "@param radix the radix to use when parsing",
      "@return the integer value represented by {@code string} using\n    {@code radix}, or {@code null} if {@code string} has a length of zero\n    or cannot be parsed as an integer value",
      "@throws IllegalArgumentException if {@code radix < Character.MIN_RADIX} or\n    {@code radix > Character.MAX_RADIX}",
      "@param value a value between 0 and 255 inclusive",
      "@return the {@code byte} value that, when treated as unsigned, equals\n    {@code value}",
      "@return {@code (byte) 255} if {@code value >= 255}, {@code (byte) 0} if\n    {@code value <= 0}, and {@code value} cast to {@code byte} otherwise",
      "@param a the first {@code byte} to compare",
      "@param b the second {@code byte} to compare",
      "@return the value present in {@code array} that is greater than or equal\n    to every other value in the array",
      "@throws NumberFormatException if the string does not contain a valid unsigned {@code byte}\n        value",
      "@throws NullPointerException if {@code s} is null\n        (in contrast to {@link Byte#parseByte(String)})",
      "@param string the string containing the unsigned {@code byte} representation to be parsed.",
      "@param radix the radix to use while parsing {@code string}",
      "@throws NumberFormatException if the string does not contain a valid unsigned {@code byte}\n        with the given radix, or if {@code radix} is not between {@link Character#MIN_RADIX}\n        and {@link Character#MAX_RADIX}.",
      "@param value a primitive {@code char} value",
      "@param value any value in the range of the {@code char} type",
      "@return the {@code char} value that equals {@code value}",
      "@throws IllegalArgumentException if {@code value} is greater than {@link\n    Character#MAX_VALUE} or less than {@link Character#MIN_VALUE}",
      "@return the same value cast to {@code char} if it is in the range of the\n    {@code char} type, {@link Character#MAX_VALUE} if it is too large,\n    or {@link Character#MIN_VALUE} if it is too small",
      "@param a the first {@code char} to compare",
      "@param b the second {@code char} to compare",
      "@param array an array of {@code char} values, possibly empty"
   ],
   [
      "@param target a primitive {@code char} value",
      "@param arrays zero or more {@code char} arrays",
      "@param collection a collection of {@code Character} objects",
      "@throws IllegalArgumentException if {@code value} is negative or {@code value >= 2^32}",
      "@throws NumberFormatException if the string does not contain a parsable unsigned {@code int}\n        value",
      "@throws ArithmeticException if {@code val} is zero",
      "@param value a primitive {@code long} value",
      "@param a the first {@code long} to compare",
      "@param b the second {@code long} to compare",
      "@param array an array of {@code long} values, possibly empty",
      "@param target a primitive {@code long} value",
      "@param arrays zero or more {@code long} arrays",
      "@throws IllegalArgumentException if {@code bytes} has fewer than 8\n    elements",
      "@param string the string representation of a long value",
      "@return the long value represented by {@code string}, or {@code null} if\n    {@code string} has a length of zero or cannot be parsed as a long\n    value",
      "@param string the string representation of an long value",
      "@return the long value represented by {@code string} using\n    {@code radix}, or {@code null} if {@code string} has a length of zero\n    or cannot be parsed as a long value",
      "@param expression a boolean expression",
      "@param errorMessage the exception message to use if the check fails; will be converted to a\n    string using {@link String#valueOf(Object)}",
      "@param errorMessageTemplate a template for the exception message should the check fail. The\n    message is formed by replacing each {@code %s} placeholder in the template with an\n    argument. These are matched by position - the first {@code %s} gets {@code\n    errorMessageArgs[0]}, etc.  Unmatched arguments will be appended to the formatted message\n    in square braces. Unmatched placeholders will be left as-is.",
      "@param errorMessageArgs the arguments to be substituted into the message template. Arguments\n    are converted to strings using {@link String#valueOf(Object)}.",
      "@param reference an object reference",
      "@return the non-null reference that was validated",
      "@param index a user-supplied index identifying an element of an array, list or string",
      "@param size the size of that array, list or string"
   ],
   [
      "@return the value of {@code index}",
      "@param desc the text to use to describe this index in an error message",
      "@param index a user-supplied index identifying a position in an array, list or string",
      "@param start a user-supplied index identifying a starting position in an array, list or string",
      "@param end a user-supplied index identifying a ending position in an array, list or string",
      "@throws IllegalArgumentException if {@code maxLength} is less than the length of\n    {@code truncationIndicator}",
      "@param duration the length of time after a value is created that it\n    should stop being returned by subsequent {@code get()} calls",
      "@param map source map that determines the function behavior",
      "@param defaultValue the value to return for inputs that aren't map keys",
      "@param g the second function to apply",
      "@param f the first function to apply",
      "@return the composition of {@code f} and {@code g}",
      "@param value the constant value for the function to return",
      "@return a function that always returns {@code value}",
      "@param self the object to generate the string for (typically {@code this}),\n       used only for its class name",
      "@param clazz the {@link Class} of the instance",
      "@param className the name of the instance type",
      "@return {@code first} if {@code first} is not {@code null}, or\n    {@code second} if {@code first} is {@code null} and {@code second} is\n    not {@code null}",
      "@throws NullPointerException if both {@code first} and {@code second} were\n    {@code null}",
      "@throws IllegalStateException if the instance is absent ({@link #isPresent} returns\n    {@code false}); depending on this <i>specific</i> exception type (over the more general\n    {@link RuntimeException}) is discouraged",
      "@throws NullPointerException if this optional's value is absent and the supplier returns\n    {@code null}",
      "@throws NullPointerException if the function returns {@code null}",
      "@return this {@code Stopwatch} instance",
      "@throws IllegalStateException if the stopwatch is already stopped.",
      "@param referent to softly reference"
   ],
   [
      "@param queue that should finalize the referent",
      "@param string the string to test and possibly return",
      "@param string a string reference to check",
      "@param string the string which should appear at the end of the result",
      "@param minLength the minimum length the resulting string must have. Can be\n    zero or negative, in which case the input string is always returned.",
      "@param padChar the character to insert at the beginning of the result until\n    the minimum length is reached",
      "@return the padded string",
      "@param string the string which should appear at the beginning of the result",
      "@param padChar the character to append to the end of the result until the\n    minimum length is reached",
      "@return an instance of the appropriate type",
      "@param finalizableReferenceClass FinalizableReference.class.",
      "@param queue a reference queue that the thread will poll.",
      "@param frqReference a phantom reference to the FinalizableReferenceQueue, which will be\nqueued either when the FinalizableReferenceQueue is no longer referenced anywhere, or when\nits close() method is called.",
      "@return true if the caller should continue, false if the associated FinalizableReferenceQueue\nis no longer referenced.",
      "@return Finalizer.class",
      "@param self the object to generate the string for (typically {@code this}), used only for its\n    class name",
      "@throws IllegalArgumentException if {@code sequence} contains ill-formed UTF-16 (unpaired\n    surrogates)",
      "@param bytes the input buffer",
      "@param off the offset in the buffer of the first byte to read",
      "@param len the number of bytes to read from the buffer",
      "@param throwable the Throwable to possibly propagate",
      "@param declaredType the single checked exception type declared by the calling method",
      "@param declaredType1 any checked exception type declared by the calling method",
      "@param declaredType2 any other checked exception type declared by the calling method",
      "@param throwable the Throwable to propagate"
   ],
   [
      "@return nothing will ever be returned; this return type is only for your convenience, as\n    illustrated in the example above",
      "@return an unmodifiable list containing the cause chain starting with {@code throwable}",
      "@throws UnsupportedOperationException if backward conversion is not implemented; this should be\n    very rare. Note that if backward conversion is not only unimplemented but\n    unimplement<i>able</i> (for example, consider a {@code Converter<Chicken, ChickenNugget>}),\n    then this is not logically a {@code Converter} at all, and should just implement {@link\n    Function}.",
      "@param separator the character to recognize as a separator",
      "@return a splitter, with default settings, that recognizes that separator",
      "@param separatorMatcher a {@link CharMatcher} that determines whether a\n    character is a separator",
      "@return a splitter, with default settings, that uses this matcher",
      "@param separatorPattern the pattern that determines whether a subsequence\n    is a separator. This pattern may not match the empty string.",
      "@return a splitter, with default settings, that uses this pattern",
      "@throws IllegalArgumentException if {@code separatorPattern} matches the\n    empty string",
      "@throws java.util.regex.PatternSyntaxException if {@code separatorPattern}\n    is a malformed expression",
      "@return a splitter, with default settings, that can split into fixed sized\n    pieces",
      "@return a splitter with the desired configuration",
      "@param limit the maximum number of items returned",
      "@param sequence the sequence of characters to split",
      "@return an iteration over the segments split from the parameter.",
      "@return an immutable list of the segments split from the parameter",
      "@param sequence the character sequence to examine, possibly empty",
      "@return {@code true} if this matcher matches at least one character in the sequence",
      "@return {@code true} if this matcher matches every character in the sequence, including when\n        the sequence is empty",
      "@param sequence the character sequence to examine from the beginning",
      "@return an index, or {@code -1} if no character matches",
      "@param sequence the character sequence to examine",
      "@param sequence the character sequence to examine from the end",
      "@param sequence the character sequence to replace matching characters in"
   ],
   [
      "@param replacement the character to append to the result string in place of each matching\n       character in {@code sequence}",
      "@return the new string",
      "@param replacement the characters to append to the result string in place of each matching\n       character in {@code sequence}",
      "@param sequence the character sequence to replace matching groups of characters in",
      "@param replacement the character to append to the result string in place of each group of\n       matching characters in {@code sequence}",
      "@param target the collection that may contain the function input",
      "@return the composition of the provided function and predicate",
      "@throws java.util.regex.PatternSyntaxException if the pattern is invalid",
      "@param errorMessageTemplate a template for the exception message should the\n    check fail. The message is formed by replacing each {@code %s}\n    placeholder in the template with an argument. These are matched by\n    position - the first {@code %s} gets {@code errorMessageArgs[0]}, etc.\n    Unmatched arguments will be appended to the formatted message in square\n    braces. Unmatched placeholders will be left as-is.",
      "@param errorMessageArgs the arguments to be substituted into the message\n    template. Arguments are converted to strings using\n    {@link String#valueOf(Object)}.",
      "@param referent to weakly reference",
      "@param referent to phantom reference",
      "@param stack The prefixes that preceed the characters represented by this\n    node. Each entry of the stack is in reverse order.",
      "@param encoded The serialized trie.",
      "@param builder A map builder to which all entries will be added.",
      "@return The number of characters consumed from {@code encoded}.",
      "@throws IllegalArgumentException if the resulting name is not valid",
      "@return function that returns {@code map.get(a)} when {@code a} is a key, or {@code\n        defaultValue} otherwise",
      "@throws IllegalArgumentException if {@code tolerance} is {@code < 0} or NaN",
      "@param values a nonempty series of values",
      "@throws IllegalArgumentException if {@code values} is empty",
      "@return {@code dest}",
      "@throws NullPointerException if any task is null",
      "@throws IllegalArgumentException if {@code length} is zero or negative",
      "@param separator the literal, nonempty string to recognize as a separator"
   ],
   [
      "@param length the desired length of pieces after splitting, a positive\n    integer",
      "@throws IndexOutOfBoundsException if {@code position} is negative or is\n        greater than {@code size}",
      "@throws NullPointerException if {@code comparator} or any of {@code elements} is null",
      "@throws NullPointerException if {@code sortedMultiset} or any of its elements is null",
      "@throws NullPointerException if {@code columnKey} is {@code null}",
      "@throws NullPointerException if {@code rowKey} is {@code null}",
      "@throws IOException if {@code swallowIOException} is false and {@code close} throws an\n    {@code IOException}.",
      "@throws NullPointerException if the specified iterable is null or has any\n    null elements.",
      "@throws NullPointerException If the specified iterable is null, has any\n    null elements, or if the specified comparator is null.",
      "@throws NullPointerException if the specified collection is null or has any\n    null elements.",
      "@throws NoSuchElementException if the queue is empty",
      "@throws IllegalArgumentException if {@code permitsPerSecond} is negative or zero or\n    {@code warmupPeriod} is negative",
      "@throws IllegalArgumentException if {@code permitsPerSecond} is negative or zero",
      "@return {@code false} always",
      "@throws IllegalArgumentException if {@code endInclusive < startInclusive}",
      "@throws IndexOutOfBoundsException if start is negative or greater than {@code\n        sequence.length()}",
      "@param start the first index to examine; must be nonnegative and no greater than {@code\n       sequence.length()}",
      "@return the index of the first matching character, guaranteed to be no less than {@code start},\n        or {@code -1} if no character matches",
      "@return {@code string} itself if it is non-null; {@code \"\"} if it is null",
      "@return {@code string} itself if it is nonempty; {@code null} if it is\n    empty or null",
      "@return {@code true} if the string is null or is the empty string",
      "@param string any non-null string",
      "@param count the number of times to repeat it; a nonnegative integer",
      "@return a string containing {@code string} repeated {@code count} times\n    (the empty string if {@code count} is zero)",
      "@throws IndexOutOfBoundsException if {@code start} is negative or greater\n    than the length of the array"
   ],
   [
      "@throws IllegalArgumentException if {@code occurrences} is negative, or if\n    this operation would result in more than {@link Integer#MAX_VALUE}\n    occurrences of the element",
      "@throws NullPointerException if {@code element} is null and this\n    implementation does not permit null elements. Note that if {@code\n    occurrences} is zero, the implementation may opt to return normally.",
      "@param occurrences the number of occurrences of the element to add. May be\n    zero, in which case no change will be made.",
      "@param element the element to conditionally remove occurrences of",
      "@param occurrences the number of occurrences of the element to remove. May\n    be zero, in which case no change will be made.",
      "@throws NullPointerException if {@code element} is null and this\n    implementation does not permit null elements. Note that if {@code\n    count} is zero, the implementor may optionally return zero instead.",
      "@throws IllegalArgumentException if {@code oldCount} or {@code newCount} is\n    negative",
      "@throws NullPointerException if {@code element} is null and the\n    implementation does not permit null elements. Note that if {@code\n    oldCount} and {@code newCount} are both zero, the implementor may\n    optionally return {@code true} instead.",
      "@throws NullPointerException if {@code elements} is null",
      "@throws NullPointerException if {@code element} is null and this\n    implementation does not permit null elements",
      "@throws IllegalArgumentException if {@code value} is negative or greater\n    than 255",
      "@throws IllegalArgumentException if the specifier is not valid.",
      "@throws ParseException if the specifier is not valid.",
      "@throws IllegalArgumentException if {@code expectedKeys} is negative",
      "@throws NoSuchElementException if this set is empty",
      "@throws VerifyException if {@code expression} is {@code false}",
      "@throws VerifyException if {@code reference} is {@code null}",
      "@return {@code reference}, guaranteed to be non-null, for convenience",
      "@param string the literal string to be escaped",
      "@return the escaped form of {@code string}",
      "@param s the literal string to be escaped",
      "@param index the index to start escaping from",
      "@param c the character to escape if necessary",
      "@return the replacement characters, or {@code null} if no escaping was needed",
      "@param replacements a map of characters to their escaped representations"
   ],
   [
      "@param cp the Unicode code point to escape",
      "@return the replacement characters, or {@code null} if no escaping was\n        required",
      "@param replacementMap a map of characters to their escaped representations",
      "@param safeMin the lowest character value in the safe range",
      "@param safeMax the highest character value in the safe range",
      "@param unsafeReplacement the default replacement for unsafe characters or\n    null if no default replacement is required",
      "@param escaperMap the map of replacements",
      "@return a \"sparse\" array that holds the replacement mappings.",
      "@return an escaper that escapes based on the underlying array.",
      "@param escaper the instance to be wrapped",
      "@return a UnicodeEscaper with the same behavior as the given instance",
      "@throws IllegalArgumentException if escaper is not a UnicodeEscaper or a\n        CharEscaper",
      "@return the replacement string, or {@code null} if no escaping was needed",
      "@param cp the Unicode code point to escape if necessary",
      "@throws IllegalArgumentException if {@code string} contains badly formed UTF-16 or cannot be\n        escaped for any other reason",
      "@return the replacement characters, or {@code null} if no escaping was\n    needed",
      "@param csq a sequence of characters",
      "@param start the index of the first character to be scanned",
      "@param end the index immediately after the last character to be scanned",
      "@throws IllegalArgumentException if the scanned sub-sequence of {@code csq}\n    contains invalid surrogate pairs",
      "@throws IllegalArgumentException if invalid surrogate characters are\n        encountered",
      "@param seq the sequence of characters from which to decode the code point",
      "@param index the index of the first character to decode",
      "@param end the index beyond the last valid character to decode",
      "@return the Unicode code point for the given index or the negated value of\n        the trailing high surrogate character at the end of the sequence"
   ],
   [
      "@param escaperMap the mapping of characters to be escaped",
      "@param value any value of type {@code C}",
      "@return the least value greater than {@code value}, or {@code null} if\n    {@code value} is {@code maxValue()}",
      "@return the greatest value less than {@code value}, or {@code null} if\n    {@code value} is {@code minValue()}",
      "@return the distance as described above, or {@link Long#MIN_VALUE} or\n    {@link Long#MAX_VALUE} if the distance is too small or too large,\n    respectively.",
      "@return the minimum value of type {@code C}; never null",
      "@throws NoSuchElementException if the type has no (practical) minimum\n    value; for example, {@link java.math.BigInteger}",
      "@return the maximum value of type {@code C}; never null",
      "@throws NoSuchElementException if the type has no (practical) maximum\n    value; for example, {@link java.math.BigInteger}",
      "@throws IllegalArgumentException if the two keys are equal according to\n    their natural ordering",
      "@throws IllegalArgumentException if any two keys are equal according to\n    their natural ordering",
      "@throws ClassCastException if the keys in {@code map} are not mutually\n        comparable",
      "@throws IllegalArgumentException if any two keys are equal according to\n        their natural ordering",
      "@throws IllegalArgumentException if any two keys are equal according to the\n        comparator",
      "@param element the element to count occurrences of",
      "@return the number of occurrences of the element in this multiset; possibly\n    zero but never negative",
      "@param element the element to add occurrences of; may be null only if\n    explicitly allowed by the implementation",
      "@return the count of the element before the operation; possibly zero",
      "@param element the element to add or remove occurrences of; may be null\n    only if explicitly allowed by the implementation",
      "@param count the desired count of the element in this multiset",
      "@param element the element to conditionally set the count of; may be null\n    only if explicitly allowed by the implementation",
      "@param oldCount the expected present count of the element in this multiset",
      "@param newCount the desired count of the element in this multiset",
      "@return {@code true} if the condition for modification was met. This\n    implies that the multiset was indeed modified, unless\n    {@code oldCount == newCount}.",
      "@return a view of the set of distinct elements in this multiset"
   ],
   [
      "@return a set of entries representing the data of this multiset",
      "@param element the element to check for",
      "@return {@code true} if this multiset contains at least one occurrence of\n    the element",
      "@param elements the collection of elements to be checked for containment in\n    this multiset",
      "@return {@code true} if this multiset contains at least one occurrence of\n    each element contained in {@code elements}",
      "@param element the element to add one occurrence of; may be null only if\n    explicitly allowed by the implementation",
      "@return {@code true} always, since this call is required to modify the\n    multiset, unlike other {@link Collection} types",
      "@throws IllegalArgumentException if {@link Integer#MAX_VALUE} occurrences\n    of {@code element} are already contained in this multiset",
      "@param element the element to remove one occurrence of",
      "@return {@code true} if an occurrence was found and removed",
      "@return the value previously associated with this class (possibly {@code\n    null}), or {@code null} if there was no previous entry.",
      "@throws IllegalArgumentException if the call would result in more than\n    {@link Integer#MAX_VALUE} occurrences of {@code element} in this\n    multiset.",
      "@return {@code true} if the method increased the size of the multimap, or\n    {@code false} if the multimap already contained the key-value pair",
      "@param expectedSize the number of elements you expect to add to the\n       returned set",
      "@return a new, empty {@code HashSet} with enough capacity to hold {@code\n        expectedSize} elements without resizing",
      "@return a new, empty thread-safe {@code Set}",
      "@param elements the elements that the set should contain",
      "@return a new thread-safe set containing those elements (minus duplicates)",
      "@return a new, empty {@code LinkedHashSet}",
      "@return a new, empty {@code LinkedHashSet} with enough capacity to hold\n        {@code expectedSize} elements without resizing",
      "@param elements the elements that the set should contain, in order",
      "@return a new {@code LinkedHashSet} containing those elements (minus\n    duplicates)",
      "@return a new, empty {@code TreeSet}",
      "@return a new {@code TreeSet} containing those elements (minus duplicates)",
      "@param comparator the comparator to use to sort the set"
   ],
   [
      "@return a new, empty {@code CopyOnWriteArraySet}",
      "@return a new {@code CopyOnWriteArraySet} containing those elements",
      "@param collection the collection whose complement should be stored in the\n    enum set",
      "@return a new, modifiable {@code EnumSet} containing all values of the enum\n    that aren't present in the given collection",
      "@throws IllegalArgumentException if {@code collection} is not an\n    {@code EnumSet} instance and contains no elements",
      "@param collection the collection whose complement should be stored in the\n    {@code EnumSet}",
      "@param type the type of the elements in the set",
      "@return a new, modifiable {@code EnumSet} initially containing all the\n    values of the enum not present in the given collection",
      "@param map the backing map",
      "@return the set backed by the map",
      "@param sets the sets to choose elements from, in the order that\n    the elements chosen from those sets should appear in the resulting\n    lists",
      "@param <B> any common base class shared by all axes (often just {@link\n    Object})",
      "@return the Cartesian product, as an immutable set containing immutable\n    lists",
      "@param set the set of elements to construct a power set from",
      "@return the power set, as an immutable set of immutable sets",
      "@throws IllegalArgumentException if {@code set} has more than 30 unique\n    elements (causing the power set size to exceed the {@code int} range)",
      "@param set the navigable set for which an unmodifiable view is to be\n       returned",
      "@return an unmodifiable view of the specified navigable set",
      "@param navigableSet the navigable set to be \"wrapped\" in a synchronized\n   navigable set.",
      "@return a synchronized view of the specified navigable set.",
      "@param map the map to constrain",
      "@param constraint the constraint that validates added entries",
      "@return a constrained view of the specified map",
      "@param multimap the multimap to constrain",
      "@return a constrained view of the multimap"
   ],
   [
      "@return a constrained view of the specified multimap",
      "@param entry the entry to constrain",
      "@param constraint the constraint for the entry",
      "@return a constrained view of the specified entry",
      "@param entry the {@code asMap} entry to constrain",
      "@param entries the entries to constrain",
      "@param constraint the constraint for the entries",
      "@return a constrained view of the entries",
      "@return a constrained view of the specified entries",
      "@param map the bimap to constrain",
      "@return a constrained view of the specified bimap",
      "@param expectedRows the expected number of distinct row keys",
      "@param expectedCellsPerRow the expected number of column key / value\n    mappings in each row",
      "@param table the table to copy",
      "@throws NullPointerException if any of the row keys, column keys, or values\n    in {@code table} is null",
      "@param removeFrom the iterable to (potentially) remove elements from",
      "@param elementsToRemove the elements to remove",
      "@return {@code true} if any element was removed from {@code iterable}",
      "@param elementsToRetain the elements to retain",
      "@param predicate a predicate that determines whether an element should\n    be removed",
      "@return {@code true} if any elements were removed from the iterable",
      "@throws UnsupportedOperationException if the iterable does not support\n    {@code remove()}.",
      "@throws NoSuchElementException if the iterable is empty",
      "@throws IllegalArgumentException if the iterable contains multiple\n    elements",
      "@throws IllegalArgumentException if the iterator contains multiple\n    elements"
   ],
   [
      "@param iterable the iterable to copy",
      "@return a newly-allocated array into which all the elements of the iterable\n    have been copied",
      "@return {@code true} if {@code collection} was modified as a result of this\n    operation.",
      "@throws NullPointerException if any of the provided iterables is null",
      "@param iterable the iterable to return a partitioned view of",
      "@param size the desired size of each partition (the last may be smaller)",
      "@return an iterable of unmodifiable lists containing the elements of {@code\n    iterable} divided into partitions",
      "@param size the desired size of each partition",
      "@return an iterable of unmodifiable lists containing the elements of {@code\n    iterable} divided into partitions (the final iterable may have\n    trailing null elements)",
      "@param unfiltered an iterable containing objects of any type",
      "@param type the type of elements desired",
      "@return an unmodifiable iterable containing all elements of the original\n    iterable that were of the requested type",
      "@throws NoSuchElementException if no element in {@code iterable} matches\n    the given predicate",
      "@param position position of the element to return",
      "@return the element at the specified position in {@code iterable}",
      "@param defaultValue the default value to return if {@code position} is\n    greater than or equal to the size of the iterable",
      "@return the element at the specified position in {@code iterable} or\n    {@code defaultValue} if {@code iterable} contains fewer than\n    {@code position + 1} elements.",
      "@param defaultValue the default value to return if the iterable is empty",
      "@return the first element of {@code iterable} or the default value",
      "@return the last element of {@code iterable}",
      "@param defaultValue the value to return if {@code iterable} is empty",
      "@return the last element of {@code iterable} or the default value",
      "@param iterable the iterable to limit",
      "@param limitSize the maximum number of elements in the returned iterable",
      "@return a view of the supplied iterable that wraps each generated iterator\n    through {@link Iterators#consumingIterator(Iterator)}; for queues,\n    an iterable that generates iterators that return and consume the\n    queue's elements in queue order"
   ],
   [
      "@return {@code true} if the iterable contains no elements",
      "@param removeFrom the iterator to (potentially) remove elements from",
      "@return {@code true} if any element was removed from {@code iterator}",
      "@return {@code true} if any elements were removed from the iterator",
      "@throws NoSuchElementException if the iterator is empty",
      "@throws IllegalArgumentException if the iterator contains multiple\n    elements.  The state of the iterator is unspecified.",
      "@param iterator the iterator to copy",
      "@return a newly-allocated array into which all the elements of the iterator\n        have been copied",
      "@return {@code true} if {@code collection} was modified as a result of this\n        operation",
      "@throws NullPointerException if any of the provided iterators is null",
      "@param iterator the iterator to return a partitioned view of",
      "@return an iterator of immutable lists containing the elements of {@code\n    iterator} divided into partitions",
      "@return an iterator of immutable lists containing the elements of {@code\n    iterator} divided into partitions (the final iterable may have\n    trailing null elements)",
      "@param unfiltered an iterator containing objects of any type",
      "@return an unmodifiable iterator containing all elements of the original\n    iterator that were of the requested type",
      "@throws NoSuchElementException if no element in {@code iterator} matches\n    the given predicate",
      "@return the element at the specified position in {@code iterator}",
      "@param defaultValue the default value to return if the iterator is empty\n    or if {@code position} is greater than the number of elements\n    remaining in {@code iterator}",
      "@return the element at the specified position in {@code iterator} or\n    {@code defaultValue} if {@code iterator} produces fewer than\n    {@code position + 1} elements.",
      "@param defaultValue the default value to return if the iterator is empty",
      "@return the next element of {@code iterator} or the default value",
      "@return the last element of {@code iterator}",
      "@return the number of elements the iterator was advanced",
      "@param iterator the iterator to limit",
      "@param limitSize the maximum number of elements in the returned iterator"
   ],
   [
      "@param iterator the iterator to remove and return elements from",
      "@return an iterator that removes and returns elements from the\n    supplied iterator",
      "@param iterator the backing iterator. The {@link PeekingIterator} assumes\n    ownership of this iterator, so users should cease making direct calls\n    to it after calling this method.",
      "@return a peeking iterator backed by that iterator. Apart from the\n    additional {@link PeekingIterator#peek()} method, this iterator behaves\n    exactly the same as {@code iterator}.",
      "@param collection the collection to constrain",
      "@param constraint the constraint that validates added elements",
      "@return a constrained view of the collection",
      "@param set the set to constrain",
      "@return a constrained view of the set",
      "@param sortedSet the sorted set to constrain",
      "@return a constrained view of the sorted set",
      "@param list the list to constrain",
      "@return a constrained view of the list",
      "@param listIterator the iterator for which to return a constrained view",
      "@param constraint the constraint for elements in the list",
      "@return a constrained view of the specified iterator",
      "@throws NullPointerException if any key or value in {@code multimap} is\n    null",
      "@param keyComparator the comparator that determines the key ordering",
      "@param valueComparator the comparator that determines the value ordering",
      "@return a new {@code TreeSet} containing a collection of values for one\n    key",
      "@return a new {@code LinkedHashSet} containing a collection of values for\n    one key",
      "@return a new decorated set containing a collection of values for one key",
      "@throws NullPointerException if any of the first {@code n} elements of {@code elements} is\n         null",
      "@param map the map to make an immutable copy of",
      "@return an immutable map containing those entries"
   ],
   [
      "@return a new, empty {@code HashMap}",
      "@param expectedSize the number of entries you expect to add to the\n       returned map",
      "@return a new, empty {@code HashMap} with enough capacity to hold {@code\n        expectedSize} entries without resizing",
      "@param map the mappings to be placed in the new map",
      "@return a new {@code HashMap} initialized with the mappings from {@code\n        map}",
      "@return a new, empty {@code LinkedHashMap}",
      "@return a new, empty {@code LinkedHashMap} with enough capacity to hold\n        {@code expectedSize} entries without resizing",
      "@return a new, {@code LinkedHashMap} initialized with the mappings from\n        {@code map}",
      "@return a new, empty {@code ConcurrentMap}",
      "@return a new, empty {@code TreeMap}",
      "@param map the sorted map whose mappings are to be placed in the new map\n       and whose comparator is to be used to sort the new map",
      "@return a new {@code TreeMap} initialized with the mappings from {@code\n        map} and using the comparator of {@code map}",
      "@param comparator the comparator to sort the keys with",
      "@param type the key type for this map",
      "@return a new, empty {@code EnumMap}",
      "@param map the map from which to initialize this {@code EnumMap}",
      "@return a new {@code EnumMap} initialized with the mappings from {@code\n        map}",
      "@throws IllegalArgumentException if {@code m} is not an {@code EnumMap}\n        instance and contains no mappings",
      "@return a new, empty {@code IdentityHashMap}",
      "@param left the map to treat as the \"left\" map for purposes of comparison",
      "@param right the map to treat as the \"right\" map for purposes of comparison",
      "@return the difference between the two maps",
      "@param valueEquivalence the equivalence relationship to use to compare\n   values",
      "@param values the values to use when constructing the {@code Map}",
      "@return a map mapping the result of evaluating the function {@code\n        keyFunction} on each value in the input collection to that value"
   ],
   [
      "@throws IllegalArgumentException if {@code keyFunction} produces the same\n        key for more than one value in the input collection",
      "@param properties a {@code Properties} object to be converted",
      "@return an immutable map containing all the entries in {@code properties}",
      "@throws ClassCastException if any key in {@code Properties} is not a {@code\n        String}",
      "@throws NullPointerException if any key or value in {@code Properties} is\n        null",
      "@param key the key to be associated with the returned entry",
      "@param value the value to be associated with the returned entry",
      "@param entrySet the entries for which to return an unmodifiable view",
      "@param entry the entry for which to return an unmodifiable view",
      "@return an unmodifiable view of the entry",
      "@param bimap the bimap to be wrapped in a synchronized view",
      "@return a sychronized view of the specified bimap",
      "@param bimap the bimap for which an unmodifiable view is to be returned",
      "@return an unmodifiable view of the specified bimap",
      "@param map the navigable map for which an unmodifiable view is to be returned",
      "@return an unmodifiable view of the specified navigable map",
      "@param navigableMap the navigable map to be \"wrapped\" in a synchronized\n   navigable map.",
      "@return a synchronized view of the specified navigable map.",
      "@param c the delegate (unwrapped) collection of map entries",
      "@param o the object that might be contained in {@code c}",
      "@param o the object to remove from {@code c}",
      "@return {@code true} if {@code c} was changed",
      "@throws IllegalArgumentException if duplicate keys or values are added",
      "@throws IllegalArgumentException if two keys have the same value",
      "@throws IllegalArgumentException if two keys have the same value or two\n        values have the same key"
   ],
   [
      "@throws IllegalArgumentException if neither range nor the domain has a lower bound, or if\n    neither has an upper bound",
      "@throws NoSuchElementException if this range set is {@linkplain #isEmpty() empty}",
      "@throws UnsupportedOperationException if this range set does not support the {@code add}\n        operation",
      "@throws UnsupportedOperationException if this range set does not support the {@code remove}\n        operation",
      "@throws UnsupportedOperationException if this range set does not support the {@code clear}\n        operation",
      "@throws UnsupportedOperationException if this range set does not support the {@code addAll}\n        operation",
      "@throws UnsupportedOperationException if this range set does not support the {@code removeAll}\n        operation",
      "@param self a collection which might contain all elements in {@code c}",
      "@param c a collection whose elements might be contained by {@code self}",
      "@param elements the original iterable whose elements have to be permuted.",
      "@return an immutable {@link Collection} containing all the different\n    permutations of the original iterable.",
      "@param comparator a comparator for the iterable's elements.",
      "@param elements the original collection whose elements have to be permuted.",
      "@return an immutable {@link Collection} containing all the different\n    permutations of the original collection.",
      "@param elements the elements that the queue should contain, in order",
      "@return a new {@code LinkedBlockingQueue} containing those elements",
      "@param q the blocking queue to be drained",
      "@param buffer where to add the transferred elements",
      "@param numElements the number of elements to be waited for",
      "@param timeout how long to wait before giving up, in units of {@code unit}",
      "@param unit a {@code TimeUnit} determining how to interpret the timeout parameter",
      "@return the number of elements transferred",
      "@param queue the queue to be wrapped in a synchronized view",
      "@return a synchronized view of the specified queue",
      "@param deque the deque to be wrapped in a synchronized view"
   ],
   [
      "@return a synchronized view of the specified deque",
      "@param rowKey key of row to search for",
      "@param columnKey key of column to search for",
      "@param value value to search for",
      "@param rowKey row key that the value should be associated with",
      "@param columnKey column key that the value should be associated with",
      "@param value value to be associated with the specified keys",
      "@return the value previously associated with the keys, or {@code null} if\n    no mapping existed for the keys",
      "@param table the table to add to this table",
      "@param rowKey row key of mapping to be removed",
      "@param columnKey column key of mapping to be removed",
      "@return the value previously associated with the keys, or {@code null} if\n    no such value existed",
      "@param rowKey key of row to search for in the table",
      "@return the corresponding map from column keys to values",
      "@param columnKey key of column to search for in the table",
      "@return the corresponding map from row keys to values",
      "@return set of table cells consisting of row key / column key / value\n    triplets",
      "@return set of row keys",
      "@return set of column keys",
      "@return collection of values",
      "@return a map view from each row key to a secondary map from column keys to\n    values",
      "@return a map view from each column key to a secondary map from row keys to\n    values",
      "@param keyType the key type",
      "@param valueType the value type",
      "@throws IllegalArgumentException if map is not an {@code EnumBiMap}\n    instance and contains no mappings"
   ],
   [
      "@param type the component type",
      "@param length the length of the new array",
      "@param reference any array of the desired type",
      "@param first the first array of elements to concatenate",
      "@param second the second array of elements to concatenate",
      "@param type the component type of the returned array",
      "@param element the element to prepend to the front of {@code array}",
      "@param array the array of elements to append",
      "@return an array whose size is one larger than {@code array}, with\n    {@code element} occupying the first position, and the\n    elements of {@code array} occupying the remaining elements.",
      "@param array the array of elements to prepend",
      "@param element the element to append to the end",
      "@return an array whose size is one larger than {@code array}, with\n    the same contents as {@code array}, plus {@code element} occupying the\n    last position.",
      "@param c the collection for which to return an array of elements",
      "@param array the array in which to place the collection elements",
      "@throws ArrayStoreException if the runtime type of the specified array is\n    not a supertype of the runtime type of every element in the specified\n    collection",
      "@throws NoSuchElementException if the iteration has no more elements\n    according to {@link #hasNext()}",
      "@param rowKeys row keys that may be stored in the generated table",
      "@param columnKeys column keys that may be stored in the generated table",
      "@throws IllegalArgumentException if {@code rowKeys} or {@code columnKeys}\n    contains duplicates or is empty",
      "@throws NullPointerException if {@code table} has a null key",
      "@param rowIndex position of the row key in {@link #rowKeyList()}",
      "@param columnIndex position of the row key in {@link #columnKeyList()}",
      "@return the value with the specified row and column",
      "@throws IndexOutOfBoundsException if either index is negative, {@code\n    rowIndex} is greater then or equal to the number of allowed row keys,\n    or {@code columnIndex} is greater then or equal to the number of\n    allowed column keys",
      "@param value value to store in the table"
   ],
   [
      "@return the previous value with the specified row and column",
      "@param valueClass class of values stored in the returned array",
      "@throws IllegalArgumentException if {@code rowKey} is not in {@link\n    #rowKeySet()} or {@code columnKey} is not in {@link #columnKeySet()}.",
      "@throws IllegalArgumentException if any of the provided table's row keys or\n    column keys is not in {@link #rowKeySet()} or {@link #columnKeySet()}",
      "@param rowKey row key of mapping to be erased",
      "@param columnKey column key of mapping to be erased",
      "@return immutable set of column keys",
      "@return immutable set of row keys",
      "@throws IllegalArgumentException if neither this range nor the domain has a lower bound, or if\n        neither has an upper bound",
      "@param initialArraySize the exact size of the initial backing array for\n    the returned array list ({@code ArrayList} documentation calls this\n    value the \"capacity\")",
      "@return a new, empty {@code ArrayList} which is guaranteed not to resize\n    itself unless its size reaches {@code initialArraySize + 1}",
      "@param estimatedSize an estimate of the eventual {@link List#size()} of\n    the new list",
      "@return a new, empty {@code ArrayList}, sized appropriately to hold the\n    estimated number of elements",
      "@return a new, empty {@code CopyOnWriteArrayList}",
      "@param elements the elements that the list should contain, in order",
      "@return a new {@code CopyOnWriteArrayList} containing those elements",
      "@param first the first element",
      "@param rest an array of additional elements, possibly empty",
      "@return an unmodifiable list containing the specified elements",
      "@param second the second element",
      "@param lists the lists to choose elements from, in the order that\n    the elements chosen from those lists should appear in the resulting\n    lists",
      "@return the Cartesian product, as an immutable list containing immutable\n    lists",
      "@throws IllegalArgumentException if the size of the cartesian product would\n    be greater than {@link Integer#MAX_VALUE}",
      "@param size the desired size of each sublist (the last may be\n    smaller)",
      "@throws IllegalArgumentException if {@code partitionSize} is nonpositive"
   ],
   [
      "@param sequence the character sequence to view as a {@code List} of\n       characters",
      "@return an {@code List<Character>} view of the character sequence",
      "@param rowComparator the comparator that orders the row keys",
      "@param columnComparator the comparator that orders the column keys",
      "@param expectedSize the expected number of entries",
      "@param multiset the multiset for which an unmodifiable view is to be\n    generated",
      "@return an unmodifiable view of the multiset",
      "@param sortedMultiset the sorted multiset for which an unmodifiable view is\n    to be generated",
      "@param e the element to be associated with the returned entry",
      "@param n the count to be associated with the returned entry",
      "@return {@code true} if {@code multisetToModify} was changed as a result\n        of this operation",
      "@return {@code true} if {@code multisetToModify} was changed as a result of\n        this operation",
      "@param rowKey the row key to be associated with the returned cell",
      "@param columnKey the column key to be associated with the returned cell",
      "@param value the value to be associated with the returned cell",
      "@param backingMap place to store the mapping from each row key to its\n    corresponding column key / value map",
      "@param factory supplier of new, empty maps that will each hold all column\n    key / value mappings for a given row key",
      "@param table the table for which an unmodifiable view is to be returned",
      "@return an unmodifiable view of the specified table",
      "@param table the row-sorted table for which an unmodifiable view is to be returned",
      "@throws IllegalArgumentException if map is not an {@code EnumBiMap} or an\n    {@code EnumHashBiMap} instance and contains no mappings",
      "@return a string representation of the multimap",
      "@param factory supplier of new, empty collections that will each hold all\n    values for a given key",
      "@param factory supplier of new, empty lists that will each hold all values\n    for a given key",
      "@param factory supplier of new, empty sets that will each hold all values\n    for a given key"
   ],
   [
      "@param factory supplier of new, empty sorted sets that will each hold\n    all values for a given key",
      "@param source any multimap",
      "@param dest the multimap to copy into; usually empty",
      "@param multimap the multimap to be wrapped in a synchronized view",
      "@return a synchronized view of the specified multimap",
      "@param multimap the multimap to be wrapped",
      "@param name the name of the Class",
      "@param className the name of the Class",
      "@param instance the instance to check",
      "@throws IllegalArgumentException if the className is empty",
      "@return the class name of the class without the package name",
      "@return the file name of the \".class\" file",
      "@return the qualified name of the class",
      "@return the method (never {@code null})",
      "@return the corresponding fully qualified class name",
      "@return the common ancestor (i.e. common superclass, one interface\n        extending the other), or {@code null} if none found. If any of\n        the given classes is {@code null}, the other class will be\n        returned.",
      "@throws NullPointerException if the specified graph or startVertex is\n<code>null</code>.",
      "@throws IllegalArgumentException if nMaxHops is negative or 0.",
      "@throws IllegalArgumentException if nPaths is negative or 0.",
      "@throws IllegalArgumentException if the graph argument is <code>\nnull</code>.",
      "@return event edge",
      "@return event source vertex",
      "@return event target vertex",
      "@throws IllegalArgumentException if <code>g==null</code> or does not\ncontain <code>startVertex</code>",
      "@param edge the edge via which the vertex was encountered, or null if the\nvertex is a starting point"
   ],
   [
      "@param queue queue to use for tie-break in case of partial order (e.g. a\nPriorityQueue can be used to break ties according to vertex priority);\nmust be initially empty",
      "@return <tt>true</tt> if the target graph did not already contain the\nspecified edge.",
      "@throws NullPointerException if the specified vertices contains one or\nmore null vertices, or if the specified vertex collection is <tt>\nnull</tt>.",
      "@throws IllegalArgumentException if the graph is neither DirectedGraph\nnor UndirectedGraph.",
      "@throws IllegalArgumentException iff <code>g==null</code>",
      "@throws IllegalArgumentException if the argument is <code>null</code>.",
      "@throws IllegalArgumentException if the current graph is null.",
      "@param edge the edge that was added.",
      "@param edge the edge that was removed.",
      "@param vertex the vertex that was added.",
      "@param vertex the vertex that was removed.",
      "@throws IllegalArgumentException if the specified size is negative.",
      "@throws IllegalArgumentException if source or target vertices are not\nfound in the graph.",
      "@throws NullPointerException if any of the specified vertices is <code>\nnull</code>.",
      "@return <tt>true</tt> if this graph did not already contain the specified\nedge.",
      "@throws NullPointerException if the specified vertex is <code>\nnull</code>.",
      "@return <tt>true</tt> if this graph did not already contain the specified\nvertex.",
      "@throws IllegalArgumentException if vertex is not found in the graph.",
      "@throws NullPointerException if vertex is <code>null</code>.",
      "@throws NullPointerException if the specified edge collection is <tt>\nnull</tt>.",
      "@throws NullPointerException if the specified vertex collection is <tt>\nnull</tt>.",
      "@return <code>true</code> if and only if the graph contained the\nspecified edge.",
      "@return <code>true</code> if the graph contained the specified vertex;\n<code>false</code> otherwise.",
      "@throws NullPointerException if specified vertex is <code>null</code>.",
      "@throws IllegalArgumentException if specified vertex does not exist in\nthis graph."
   ],
   [
      "@return this builder object",
      "@throws NullPointerException if the specified edge factory is <code>\nnull</code>.",
      "@throws IllegalArgumentException if <code>maxSize</code> is negative or\n0.",
      "@throws NullPointerException if the specified prevPathElementList or edge\nis <code>null</code>.",
      "@throws NullPointerException if the specified path-element is <code>\nnull</code>.",
      "@return G<sub>1</sub>",
      "@param resultMap some array of vertices",
      "@param numVertices1 number of vertices in the first partition",
      "@param numVertices2 number of vertices in the second partition",
      "@param numEdges number of edges to be generated",
      "@param numVertices number of vertices in the k partitions",
      "@param numEdges number of edges to be generated between any two\npartitions",
      "@return vertices",
      "@return an iterator that will traverse the graph in topological order",
      "@return whether new vertex was added",
      "@return null if the edge is already in the graph, else the created edge\nis returned",
      "@throws IllegalArgumentException If either fromVertex or toVertex is not\na member of the graph",
      "@throws CycleFoundException if the edge would induce a cycle in the graph",
      "@return true if the edge was added to the graph",
      "@throws CycleFoundException if adding an edge (fromVertex, toVertex) to\nthe graph would induce a cycle.",
      "@param vertex the vertex being visited",
      "@param df the set we are populating with forward connected vertices in\nthe Affected Region",
      "@param visited a simple data structure that lets us know if we already\nvisited a node with a given topo index",
      "@param topoIndexMap for quick lookups, a map from vertex to topo index in\nthe AR",
      "@param ub the topo index of the original fromVertex -- used for cycle\ndetection"
   ],
   [
      "@throws CycleFoundException if a cycle is discovered",
      "@param db the set we are populating with back-connected vertices in the\nAR",
      "@param g the graph of which a square is to be created.",
      "@param numVertices number of vertices to be generated",
      "@param l the listener to be added.",
      "@param l the listener to be removed.",
      "@param value the new value to set.",
      "@param anotherInteger the <code>ModifiableInteger</code> to be compared.",
      "@return the value <code>0</code> if this <code>ModifiableInteger</code>\nis equal to the argument <code>ModifiableInteger</code>; a value less\nthan <code>0</code> if this <code>ModifiableInteger</code> is numerically\nless than the argument <code>ModifiableInteger</code>; and a value\ngreater than <code>0</code> if this <code>ModifiableInteger</code> is\nnumerically greater than the argument <code>ModifiableInteger</code>\n(signed comparison).",
      "@param o the object to compare with.",
      "@return <code>true</code> if the objects are the same; <code>false</code>\notherwise.",
      "@return a hash code value for this object, equal to the primitive <code>\nint</code> value represented by this <code>ModifiableInteger</code>\nobject.",
      "@return an <code>Integer</code> representation of the value of this\nobject.",
      "@return a string representation of the value of this object in\nbase&nbsp;10.",
      "@param value the value to be represented by the <code>\nModifiableInteger</code> object.",
      "@return string representing this object",
      "@param data data for this node",
      "@param a first weight",
      "@param b second weight",
      "@return result of the operator",
      "@return true if the heap is empty, false otherwise",
      "@param x node to decrease the key of",
      "@param k new key value for node x",
      "@throws IllegalArgumentException Thrown if k is larger than x.key\nvalue.",
      "@param x node to remove from heap"
   ],
   [
      "@param node new node to insert into heap",
      "@param key key value associated with data object",
      "@return heap node with the smallest key",
      "@return node with the smallest key",
      "@return number of elements in the heap",
      "@param h1 first heap",
      "@param h2 second heap",
      "@return new heap containing h1 and h2",
      "@return String of this.",
      "@param y node to perform cascading cut on",
      "@param x child of y to be removed from y's child list",
      "@param y parent of x about to lose a child",
      "@param y node to become child",
      "@param x node to become parent",
      "@param o object to be cast",
      "@param typeDecl conveys the target type information; the actual value is\nunused and can be null since this is all just stupid compiler tricks",
      "@return the result of the cast",
      "@param v The vertex in question",
      "@return true if contains, false otherwise",
      "@return the new vertex",
      "@param sourceVertex source vertex of the edge.",
      "@param targetVertex target vertex of the edge.",
      "@return a set of all edges connecting source vertex to target vertex.",
      "@return an edge connecting source vertex to target vertex.",
      "@return the edge factory using which this graph creates new edges."
   ],
   [
      "@return The newly created edge if added to the graph, otherwise <code>\nnull</code>.",
      "@param e edge to be added to this graph.",
      "@throws ClassCastException if the specified edge is not assignment\ncompatible with the class of edges produced by the edge factory of this\ngraph.",
      "@param v vertex to be added to this graph.",
      "@return <tt>true</tt> if this graph contains the specified edge.",
      "@param e edge whose presence in this graph is to be tested.",
      "@param v vertex whose presence in this graph is to be tested.",
      "@return <tt>true</tt> if this graph contains the specified vertex.",
      "@return a set of the edges contained in this graph.",
      "@param vertex the vertex for which a set of touching edges is to be\nreturned.",
      "@return a set of all edges touching the specified vertex.",
      "@param edges edges to be removed from this graph.",
      "@return <tt>true</tt> if this graph changed as a result of the call",
      "@return the removed edges, or <code>null</code> if either vertex is not\npart of graph",
      "@param vertices vertices to be removed from this graph.",
      "@return The removed edge, or <code>null</code> if no edge removed.",
      "@param e edge to be removed from this graph, if present.",
      "@param v vertex to be removed from this graph, if present.",
      "@return a set view of the vertices contained in this graph.",
      "@param e edge of interest",
      "@return source vertex",
      "@return target vertex",
      "@return edge weight",
      "@return the containing graph",
      "@return the start vertex"
   ],
   [
      "@return the end vertex",
      "@return list of edges traversed by the path",
      "@return the weight of the path",
      "@param ef the edge factory of the new graph.",
      "@param edgeClass class on which to base factory for edges",
      "@param edge edge.",
      "@param vertex vertex.",
      "@return G<sub>2</sub>",
      "@return <code>true</code> if and only if graph loops are allowed.",
      "@return <code>true</code> if and only if multiple edges are allowed.",
      "@param edgeSetFactory factory to use for subsequently created edge sets\n(this call has no effect on existing edge sets)",
      "@return a shallow copy of this set.",
      "@param allowMultipleEdges whether to allow multiple edges or not.",
      "@param allowLoops whether to allow edges that are self-loops or not.",
      "@return weight of this edge",
      "@param base the backing graph.",
      "@param g the backing graph over which an unweighted view is to be\ncreated.",
      "@param vertex the vertex for which the edge set is being created;\nsophisticated factories may be able to use this information to choose an\noptimal set representation (e.g. ArrayUnenforcedSet for a vertex expected\nto have low degree, and LinkedHashSet for a vertex expected to have high\ndegree)",
      "@return new set",
      "@param g the backing graph (the delegate).",
      "@param reuseEvents whether to reuse previously fired event objects\ninstead of creating a new event object for each event.",
      "@return the value of the <code>reuseEvents</code> flag.",
      "@param source edge source",
      "@param target edge target",
      "@param g the backing graph."
   ],
   [
      "@throws IllegalArgumentException if the backing graph is already a\nlistenable graph.",
      "@param g the backing directed graph over which an undirected view is to\nbe created.",
      "@return source of this edge",
      "@return target of this edge",
      "@param base the base (backing) graph on which the subgraph will be based.",
      "@param vertexSubset vertices to include in the subgraph. If <code>\nnull</code> then all vertices are included.",
      "@param edgeSubset edges to in include in the subgraph. If <code>\nnull</code> then all the edges whose vertices found in the graph are\nincluded.",
      "@param g the backing graph on which an unmodifiable graph is to be\ncreated.",
      "@param v the vertex to be added.",
      "@return <code>true</code> if the vertex was added, otherwise <code>\nfalse</code>.",
      "@return a string representation of this graph.",
      "@param v vertex",
      "@return <code>true</code> if this assertion holds.",
      "@return <tt>true</tt> if this graph changed as a result of the call.",
      "@param vertexSet the vertex set V to be printed",
      "@param edgeSet the edge set E to be printed",
      "@param directed true to use parens for each edge (representing directed);\nfalse to use curly braces (representing undirected)",
      "@return a string representation of (V,E)",
      "@return the hash code value this graph",
      "@param obj object to be compared for equality with this graph",
      "@return <code>true</code> if the specified object is equal to this graph",
      "@param mask vertices and edges to exclude in the subgraph. If a\nvertex/edge is masked, it is as if it is not in the subgraph.",
      "@param g the backing graph over which a weighted view is to be created.",
      "@param weightMap A mapping of edges to weights. If an edge is not present\nin the weight map, the edge weight for the underlying graph is returned.\nNote that a live reference to this map is retained, so if the caller\nchanges the map after construction, the changes will affect the",
      "@param g the base (backing) graph on which the edge-reversed view will be\nbased."
   ],
   [
      "@param weightMap A mapping of edges to weights. If an edge is not present\nin the weight map, the edge weight for the underlying graph is returned.\nNote that a live reference to this map is retained, so if the caller\nchanges the map after construction, the changes will affect the\nAsWeightedGraph instance as well.",
      "@param baseGraph the graph object to base building on",
      "@param source source vertex of the edge.",
      "@param target target vertex of the edge.",
      "@param weight weight of the edge.",
      "@return the {@code this} object.",
      "@param vertex the vertex to add",
      "@param vertices the vertices to add",
      "@param vertex the vertex to remove",
      "@param vertices the vertices to remove",
      "@return the built graph.",
      "@return the built unmodifiable graph.",
      "@return A list of the vertices that define the path.",
      "@param simpleGraph The simple graph where the path is.",
      "@param vertices A list of vertices that make up the path.",
      "@throws IllegalArgumentException if the vertices are not in the path or\nif they do not define a path in the graph.",
      "@param g the graph for which the edge to be added.",
      "@param g the graph for which the specified edge to be added.",
      "@param targetGraph the graph for which the specified edge to be added.",
      "@param sourceGraph the graph in which the specified edge is already\npresent",
      "@param edge edge to add",
      "@param destination the graph to which vertices and edges are added.",
      "@param source the graph used as source for vertices and edges to add.",
      "@return <code>true</code> if and only if the destination graph has been\nchanged as a result of this operation.",
      "@param destination the graph to which edges are to be added"
   ],
   [
      "@param source the graph used as a source for edges to add",
      "@param edges the edges to be added",
      "@param vertices the vertices to be added to the graph.",
      "@return <tt>true</tt> if graph changed as a result of the call",
      "@param g the graph to look for neighbors in.",
      "@param vertex the vertex to get the neighbors of.",
      "@return a list of the vertices that are the neighbors of the specified\nvertex.",
      "@param g the graph to look for predecessors in.",
      "@param vertex the vertex to get the predecessors of.",
      "@return a list of the vertices that are the direct predecessors of the\nspecified vertex.",
      "@param g the graph to look for successors in.",
      "@param vertex the vertex to get the successors of.",
      "@return a list of the vertices that are the direct successors of the\nspecified vertex.",
      "@param g the graph for which an undirected view is to be returned.",
      "@return an undirected view of the specified graph, if it is directed, or\nor the specified graph itself if it is already undirected.",
      "@param g graph containing e and v",
      "@param e edge in g",
      "@param v vertex in g",
      "@return true iff e is incident on v",
      "@return vertex opposite to v across e",
      "@param path path of interest",
      "@return corresponding vertex list",
      "@param vertex vertex whose degree is to be calculated.",
      "@return the degree of the specified vertex.",
      "@param vertex the vertex for which the list of incoming edges to be\nreturned."
   ],
   [
      "@return a set of all edges incoming into the specified vertex.",
      "@param vertex the vertex for which the list of outgoing edges to be\nreturned.",
      "@return a set of all edges outgoing from the specified vertex.",
      "@param e edge on which to set weight",
      "@param weight new weight for edge",
      "@param dim This is the dimension of the hypercube.",
      "@param size number of vertices to be generated",
      "@param size number of vertices to be generated.",
      "@param inwardSpokes if <code>true</code> and graph is directed, spokes\nare oriented from rim to hub; else from hub to rim.",
      "@param rows the number of rows",
      "@param cols the number of columns",
      "@param target receives the generated edges and vertices; if this is\nnon-empty on entry, the result will be a disconnected graph since\ngenerated elements will not be connected to existing elements",
      "@param vertexFactory called to produce new vertices",
      "@param resultMap unused parameter",
      "@param seed initial seed for the random generator",
      "@throws IllegalArgumentException if the aNumOfEdges passed in the\nconstructor, cannot be created on a graph of the concrete type with\naNumOfVertexes.\norg.jgrapht.generate.RandomGraphGenerator.DefaultEdgeTopologyFactory#isNumberOfEdgesValid(org.jgrapht.Graph,\nint)",
      "@param partitionOne This is the number of vertices in the first partition",
      "@param partitionTwo This is the number of vertices in the second parition",
      "@param resultMap if non-null, receives implementation-specific mappings\nfrom String roles to graph elements (or collections of graph elements)",
      "@param order number of total vertices including the center vertex",
      "@param vertex the vertex whose in-degree will be decremented.",
      "@param dg the directed graph to be iterated.",
      "@param queue initializer for queue",
      "@param inDegreeMap initializer for inDegreeMap",
      "@return the graph being traversed"
   ],
   [
      "@return <tt>true</tt> if there are no more uniterated vertices in the\ncurrently iterated connected component; <tt>false</tt> otherwise.",
      "@param vertex the vertex encountered",
      "@return the next vertex to be returned by this iterator.",
      "@param vertex a vertex which has already been seen.",
      "@return data associated with the seen vertex or <code>null</code> if no\ndata was associated with the vertex. A <code>null</code> return can also\nindicate that the vertex was explicitly associated with <code>\nnull</code>.",
      "@param vertex vertex in question",
      "@return <tt>true</tt> if vertex has already been seen",
      "@param vertex the vertex re-encountered",
      "@param edge the edge via which the vertex was re-encountered",
      "@param vertex a vertex which has been seen.",
      "@param data data to be associated with the seen vertex.",
      "@return previous value associated with specified vertex or <code>\nnull</code> if no data was associated with the vertex. A <code>\nnull</code> return can also indicate that the vertex was explicitly\nassociated with <code>null</code>.",
      "@param vertex vertex which has been finished",
      "@return TODO Document me",
      "@param g the graph to be iterated.",
      "@param startVertex the vertex iteration to be started.",
      "@param crossComponentTraversal if <code>true</code> traverses across\nconnected components.",
      "@return <code>true</code> if traverses across connected components,\notherwise <code>false</code>.",
      "@param l the traversal listener to be added.",
      "@param l the traversal listener to be removed.",
      "@param e the connected component finished event.",
      "@param e the connected component started event.",
      "@param e the edge traversal event.",
      "@param e the vertex traversal event.",
      "@param vertex vertex being sought from start vertex"
   ],
   [
      "@return weighted length of shortest path known, or\nDouble.POSITIVE_INFINITY if no path found yet",
      "@param vertex the spanned vertex.",
      "@return the spanning tree edge, or null if the vertex either has not been\nseen yet or is the start vertex.",
      "@param vertex the vertex for which to calculate the path length.",
      "@param edge the edge via which the path is being extended.",
      "@return calculated path length.",
      "@param vertex a vertex which has just been encountered.",
      "@param edge the edge via which the vertex was encountered.",
      "@return the new heap node.",
      "@param radius limit on weighted path length, or Double.POSITIVE_INFINITY\nfor unbounded search.",
      "@return stack",
      "@param sourceVertex the source vertex.",
      "@param targetVertex the target vertex.",
      "@return a new edge whose endpoints are the specified source and target\nvertices.",
      "@param vertex vertex in one of the graphs",
      "@param forward if true, uses mapping from graph1 to graph2; if false, use\nmapping from graph2 to graph1",
      "@return corresponding vertex in other graph, or null if none",
      "@param edge edge in one of the graphs",
      "@return corresponding edge in other graph, or null if none",
      "@param e the vertex event.",
      "@return the traversed edge.",
      "@param eventSource the source of the event.",
      "@param edge the traversed edge.",
      "@param e the traversal event.",
      "@param eventSource the source of this event."
   ],
   [
      "@param type the event type of this event.",
      "@param edge the edge that this event is related to.",
      "@param edgeSource edge source vertex",
      "@param edgeTarget edge target vertex",
      "@return the traversed vertex.",
      "@param vertex the traversed vertex.",
      "@return the event type.",
      "@param type the type of event.",
      "@param e the edge event.",
      "@return the vertex that this event is related to.",
      "@param type the type of the event.",
      "@param vertex the vertex that the event is related to.",
      "@param vertex vertex in the initial graph.",
      "@param sourceVertex the source vertex",
      "@param targetVertex the target vertex",
      "@param simplePathsOnly if true, only search simple\n(non-self-intersecting) paths",
      "@param maxPathLength maximum number of edges to allow in a path (if null,\nall paths are considered, which may be very slow due to potentially huge\noutput)",
      "@param sourceVertices the source vertices",
      "@param targetVertices the target vertices",
      "@return list of all paths from the sources to the targets containing no\nmore than maxPathLength edges",
      "@param maxPathLength maximum number of edges to allow in a path (if null,\nall edges will be considered, which may be expensive)",
      "@return the minimum number of edges in a path from each edge to the\ntargets, encoded in a Map",
      "@param maxPathLength maximum number of edges to allow in a path",
      "@param simplePathsOnly if true, only search simple\n(non-self-intersecting) paths (if null, all edges will be considered,\nwhich may be expensive)",
      "@param edgeMinDistancesFromTargets the minimum number of edges in a path\nto a target through each edge, as computed by {@code\nedgeMinDistancesBackwards}."
   ],
   [
      "@return a List of all GraphPaths from the sources to the targets\nsatisfying the given constraints",
      "@param edges the edges",
      "@return the corresponding GraphPath",
      "@return <code>true</code> if at least one path has been improved during\nthe previous pass, <code>false</code> otherwise.",
      "@param endVertex end vertex.",
      "@return list of <code>RankingPathElement</code>, or <code>null</code> of\nno path exists between the start vertex and the end vertex.",
      "@return the new entry.",
      "@param vertex vertex reached by a path.",
      "@param edge edge reaching the vertex.",
      "@param graph graph on which shortest paths are searched.",
      "@param startVertex start vertex of the calculated paths.",
      "@param endVertex end vertex of the calculated paths.",
      "@param maxSize number of paths stored at end vertex of the graph.",
      "@return minimum spanning-tree edges set",
      "@return minimum spanning-tree total weight",
      "@param graph the graph to be searched",
      "@return the graph inspected by this StrongConnectivityAlgorithm",
      "@return true if the graph is strongly connected, false otherwise",
      "@return <code>List</code> of <code>Set</code> s containing the strongly\nconnected components",
      "@return a list of subgraphs representing the strongly connected\ncomponents",
      "@param directedGraph the graph to inspect",
      "@return false, if there are no more pairs left",
      "@return is the matching already complete?",
      "@return true, if the already matched vertices of graph1 plus the first\nvertex of nextPair are isomorphic to the already matched vertices of\ngraph2 and the second one vertex of nextPair.",
      "@return v1 and v2 are equivalent"
   ],
   [
      "@return edges are equivalent",
      "@param g1 GraphOrdering on first graph",
      "@param g2 GraphOrdering on second graph (possible subgraph)",
      "@param vertexComparator comparator for semantic equality of vertices",
      "@param edgeComparator comparator for semantic equality of edges",
      "@return true, if the already matched vertices of graph1 plus the first\nvertex of nextPair are graph isomorphic to the already matched vertices\nof graph2 and the second one vertex of nextPair.",
      "@param graph1 the first graph",
      "@param graph2 the second graph",
      "@param vertexComparator comparator for semantic equivalence of vertices",
      "@param edgeComparator comparator for semantic equivalence of edges",
      "@param cacheEdges if true, edges get cached for faster access",
      "@return true, if the already matched vertices of graph1 plus the first\nvertex of nextPair are subgraph isomorphic to the already matched\nvertices of graph2 and the second one vertex of nextPair.",
      "@param graph2 the second graph (possible subgraph of graph1)",
      "@return returns the number of vertices in the graph.",
      "@param vertexNumber the number which identifies the vertex v in this\norder.",
      "@return the identifying numbers of all vertices which are connected to v\nby an edge outgoing from v.",
      "@return the identifying numbers of all vertices which are connected to v\nby an edge incoming to v.",
      "@param v1Number the number of the first vertex v1",
      "@param v2Number the number of the second vertex v2",
      "@return exists the edge from v1 to v2",
      "@param vertexNumber the number identifying the vertex v",
      "@return v",
      "@param v1Number the number identifying the vertex v1",
      "@param v2Number the number identifying the vertex v2",
      "@return the edge from v1 to v2"
   ],
   [
      "@param graph the graph to be ordered",
      "@param orderByDegree should the vertices be ordered by their degree. This\nspeeds up the VF2 algorithm.",
      "@param cacheEdges if true, the class creates a adjacency matrix and two\narrays for incoming and outgoing edges for fast access.",
      "@return is there a corresponding vertex to v in the subgraph",
      "@return is there a corresponding edge to e in the subgraph",
      "@param rel the corresponding mapping",
      "@return do both relations map to the same vertices",
      "@param g1 the first graph",
      "@param g2 the second graph which is a possible subgraph of g1",
      "@param core1 the mapping as array (forwards)",
      "@param core2 the mapping as array (backwards)",
      "@return null or one matching between graph1 and graph2",
      "@return Collection of cliques (each of which is represented as a Set of\nvertices)",
      "@param graph the graph in which cliques are to be found; graph must be\nsimple",
      "@param g an undirected graph to find the chromatic number of",
      "@return integer the approximate chromatic number from the greedy\nalgorithm",
      "@param g an undirected graph for which to find the coloring",
      "@return the cost of the shortest path between the start vertex and the\nend vertex.",
      "@return list of <code>Edge</code>, or null if no path exists between the\nstart vertex and the end vertex.",
      "@param startVertex the vertex at which the path should start",
      "@param endVertex the vertex at which the path should end",
      "@return List of Edges, or null if no path exists",
      "@param nMaxHops maximum number of edges of the calculated paths.",
      "@param epsilon tolerance factor.",
      "@return path representation, or null if no path exists"
   ],
   [
      "@return path length, or Double.POSITIVE_INFINITY if no path exists",
      "@param radius limit on weighted path length, or Double.POSITIVE_INFINITY\nfor unbounded search",
      "@return <code>null</code> is the path is empty.",
      "@param edge edge reaching the end vertex of the path element created.",
      "@param weight total cost of the created path element.",
      "@param vertex end vertex of the path element.",
      "@param admissibleHeuristic admissible heuristic",
      "@param sourceVertex source vertex",
      "@param targetVertex target vertex",
      "@param admissibleHeuristic admissible heuristic which estimates the\ndistance from a node to the target node.",
      "@return the shortest path from sourceVertex to targetVertex",
      "@param startVertex starting vertex of the path",
      "@param targetVertex ending vertex of the path",
      "@param pathLength length of the path",
      "@return the shortest path from startVertex to endVertex",
      "@param currentNode node",
      "@return List of edges/arcs that constitutes the path",
      "@return number of expanded nodes",
      "@param source source vertex",
      "@param sink sink vertex",
      "@return maximum flow value",
      "@return <i>read-only</i> mapping from edges to doubles - flow values",
      "@return current source",
      "@return current sink",
      "@param network network, where maximum flow will be calculated"
   ],
   [
      "@param epsilon tolerance for comparing doubles",
      "@param cost total cost of the created path element.",
      "@param original source to copy from",
      "@return the graph on which this algorithm operates",
      "@return total number of shortest paths",
      "@param a first vertex",
      "@param b second vertex",
      "@return shortest distance between a and b",
      "@return the diameter (longest of all the shortest paths) computed for the\ngraph. If the graph is vertexless, return 0.0.",
      "@param a From vertice",
      "@param b To vertice",
      "@return the path, or null if none found",
      "@param v the originating vertex",
      "@return List of paths",
      "@return map from element to parent element",
      "@return map from element to rank",
      "@param element The element to find.",
      "@return The element representing the set the element is in.",
      "@param element1 The first element to union.",
      "@param element2 The second element to union.",
      "@param v1 the first vertex to be compared.",
      "@param v2 the second vertex to be compared.",
      "@return -1 if <code>v1</code> comes before <code>v2</code>, +1 if <code>\nv1</code> comes after <code>v2</code>, 0 if equal.",
      "@param g graph with respect to which the degree is calculated.",
      "@param ascendingOrder true - compares in ascending order of degrees\n(lowest first), false - compares in descending order of degrees (highest\nfirst)."
   ],
   [
      "@param a first element",
      "@param b second element",
      "@return new pair",
      "@return the graph inspected",
      "@param u the Integer to be removed.",
      "@param list the list from which all the occurrences of u must be removed.",
      "@param graph the DirectedGraph in which to find cycles.",
      "@return The graph.",
      "@param graph the graph.",
      "@return The list of all simple cycles. Possibly empty but never <code>\nnull</code>.",
      "@param graph - the DirectedGraph in which to find cycles.",
      "@return A list of cycles constituting a cycle base for the graph.\nPossibly empty but never <code>null</code>.",
      "@return set of all biconnected vertex-components containing the vertex.",
      "@return <code>true</code> if and only if inspected graph is connected.",
      "@param vertex the vertex for which the connected set to be returned.",
      "@return a set of all vertices that are in the maximally connected\ncomponent together with the specified vertex.",
      "@return Returns a list of <code>Set</code> s, where each set contains all\nvertices that are in the same maximally connected component.",
      "@param sourceVertex one end of the path.",
      "@param targetVertex another end of the path.",
      "@return <code>true</code> if and only if there is a path from the source\nvertex to the target vertex.",
      "@param g the graph for which a connectivity inspector to be created.",
      "@return Returns the min cut partition containing the source, or null if\nthere was no call to computeMinCut(V source, V sink)",
      "@return returns the min cut partition containing the sink",
      "@return cut weight",
      "@return all edges which have their tail in S, and their head in T. If\ncomputeMinCut(V source, V sink) has not been invoked, this method returns\nnull."
   ],
   [
      "@return source of last minCut call, null if there was no call",
      "@return sink of last minCut call, null if there was no call",
      "@param elementList list of paths at vertex v.",
      "@param edge edge (v->y).",
      "@return <code>true</code> if at least one path has been added in the\nlist, <code>false</code> otherwise.",
      "@return list of <code>RankingPathElement</code>.",
      "@return the cost obtained by concatenation.",
      "@return <code>true</code> if the specified path element disconnects the\nguard-vertex, <code>false</code> otherwise.",
      "@return <code>true</code> if the resulting path (obtained by\nconcatenating the specified edge to the specified path) is simple, <code>\nfalse</code> otherwise.",
      "@param maxSize max number of paths the list is able to store.",
      "@param prevPathElementList paths, list of <code>\nRankingPathElement</code>.",
      "@param edge edge reaching the end vertex of the created paths.",
      "@param maxSize maximum number of paths the list is able to store.",
      "@return set of Edges",
      "@param graph - Graph to compute transitive closure for.",
      "@return true if the intersection is NOT empty.",
      "@param graph graph over which to run algorithm",
      "@throws IllegalArgumentException if a negative weight edge is found",
      "@throws IllegalArgumentException if graph has less than 2 vertices",
      "@param elementList paths, list of <code>AbstractPathElement</code>.",
      "@throws IllegalArgumentException if <code>pathElement</code> is not\nempty.",
      "@param G target weighted bipartite graph to find matching in",
      "@param S first vertex partition of the target bipartite graph",
      "@param T second vertex partition of the target bipartite graph",
      "@param matrix the original matrix to transform into a path matrix"
   ],
   [
      "@param pathMatrix the path matrix to reduce",
      "@param directedGraph the directed graph that will be reduced transitively",
      "@param g The graph to be checked",
      "@return true for Eulerian and false for non-Eulerian",
      "@param g The graph to find an Eulerian circuit",
      "@return null if no Eulerian circuit exists, or a list of vertices\nrepresenting the Eulerian circuit if one does exist",
      "@param v the vertex whose predecessors are desired",
      "@return all unique predecessors of the specified vertex",
      "@return all predecessors of the specified vertex",
      "@param v the vertex whose successors are desired",
      "@return all unique successors of the specified vertex",
      "@return all successors of the specified vertex",
      "@param g the graph for which a neighbor index is to be created.",
      "@param a the first element to find LCA for",
      "@param b the other element to find the LCA for",
      "@return the first found LCA of a and b, or null if there is no LCA.",
      "@return the set of all LCA of a and b, or empty set if there is no LCA.",
      "@param vertexSet the set of vertex to find parents of",
      "@return a set of every parent of every vertex passed in",
      "@param x set containing vertex",
      "@param y set containing vertex, which may be ordered to give predictable\nresults",
      "@return the first element of y that is also in x, or null if no such\nelement",
      "@param graph simple undirected weighted bipartite graph to find matching\nin, with positive integer edge weights",
      "@param vertexPartition1 first vertex partition of the bipartite graph,\ndisjoint from vertexPartition2",
      "@param vertexPartition2 second vertex partition of the bipartite graph,\ndisjoint from vertexPartition1"
   ],
   [
      "@param g is the graph to find the optimal tour for.",
      "@return The optimal tour as a list of vertices.",
      "@param endVertex target vertex of the calculated paths.",
      "@return list of paths, or <code>null</code> if no path exists between the\nstart vertex and the end vertex.",
      "@param k number of paths to be computed.",
      "@param nPaths number of ranking paths between the start vertex and an end\nvertex.",
      "@param v the vertex whose neighbors are desired",
      "@return all unique neighbors of the specified vertex",
      "@return all neighbors of the specified vertex",
      "@param g the graph for which vertex cover approximation is to be found.",
      "@return a set of vertices which is a vertex cover for the specified\ngraph.",
      "@return true iff the graph contains at least one cycle",
      "@param v the vertex to test",
      "@return true if v is on at least one cycle",
      "@return set of all vertices which participate in at least one cycle in\nthis graph",
      "@return set of all vertices reachable from v via at least one cycle",
      "@param graph the DirectedGraph in which to detect cycles",
      "@return weight of a matching found",
      "@param source source of the flow inside the network",
      "@param sink sink of the flow inside the network",
      "@return maximum flow",
      "@param vertexLabels Map that gives a label for each vertex.",
      "@return Vertex with the maximal label.",
      "@param k vertex' label",
      "@param v the vertex"
   ],
   [
      "@param r the reach structure.",
      "@param vertices the vertices to induce the subgraph from.",
      "@return true if the induced subgraph is a clique.",
      "@param graph the graph to copy.",
      "@return A copy of the graph projected to a SimpleGraph.",
      "@return true if the graph is chordal, false otherwise.",
      "@return Set of fill edges.",
      "@return Triangulated graph.",
      "@return List of generators.",
      "@return The minimal elimination ordering.",
      "@return A map from separators to integers (component count).",
      "@return Set of atoms, where each atom is described as the set of its\nvertices.",
      "@return Set of separators, where each separator is described as the set\nof its vertices.",
      "@return Original graph.",
      "@param g The graph to decompose.",
      "@throws IllegalArgumentException if the graph is undirected and the\nedge-weight is negative.",
      "@return data associated with the seen vertex or <code>null</code> if no\ndata was associated with the vertex.",
      "@param vertex vertex in question.",
      "@return <tt>true</tt> if vertex has already been seen.",
      "@return previous value associated with specified vertex or <code>\nnull</code> if no data was associated with the vertex.",
      "@param cost cost of the created path element.",
      "@return <code>true</code> if the cost has been improved, <code>\nfalse</code> otherwise.",
      "@param startVertex start vertex.",
      "@return list of <code>Edge</code>.",
      "@return <code>null</code> if the path is empty."
   ],
   [
      "@param observationRegistry must not be {@literal null}.",
      "@param serviceName service name to be used.",
      "@param convention the observation convention to use",
      "@param coordinates the score.",
      "@param optional the optional. May be empty but never {@code null}.",
      "@param value the value. Must not be {@code null}.",
      "@param coordinates the coordinates.",
      "@throws NoSuchElementException if the value is not present.",
      "@param host the host",
      "@param timeout timeout value",
      "@param uri The URI string.",
      "@param source the initialization source, must not be {@code null}.",
      "@param source must not be {@code null}.",
      "@param username the username, must not be {@code null}.",
      "@param timeout the command timeout for synchronous command execution.",
      "@param database the Redis database number.",
      "@param libraryName the library name.",
      "@param libraryVersion the library version.",
      "@param verifyMode verification mode to use when using {@link #isSsl() SSL}.",
      "@param socket the host name",
      "@param host the host name",
      "@param port the port",
      "@param redisURI the sentinel URI",
      "@param host the port",
      "@param verifyMode the mode to verify hosts when using SSL"
   ],
   [
      "@param database the database number",
      "@param clientName the client name",
      "@param username the user name",
      "@param password the password name",
      "@param credentialsProvider must not be {@code null}.",
      "@param password the password",
      "@param timeout must not be {@code null} or negative.",
      "@param sentinelMasterId sentinel master id, must not be empty or {@code null}",
      "@return this file's name",
      "@return the path separator used by this file",
      "@return true if this file is hidden",
      "@throws IOException if the file could not be created, either because it already exists or because of an I/O error",
      "@throws IOException if this operation is not possible (file is not browsable) or if an error occurred.",
      "@return a string representation of this file's permissions",
      "@return {@link MonitoredFile} that can monitor changes to the content of this file.",
      "@return an AbstractFile representing the requested child file, never null",
      "@throws IOException in any of the cases listed above",
      "@throws IOException if the directory could not be created, either because the file already exists or for any\nother reason.",
      "@throws IOException if this file already exists or if an I/O error occurred.",
      "@throws FileTransferException in any of the cases listed above, use {@link FileTransferException#getReason()} to\nknow the reason.",
      "@param destFile destination file, cannot be null",
      "@return an int describing the collision type, or {@link #NO_COLLISION} if no collision was detected (see constants)",
      "@param p non-null Process to limit the execution of",
      "@throws ArrayIndexOutOfBoundsException if the array has length 0",
      "@throws IllegalArgumentException if obj is null or is not one of the types mentioned above."
   ],
   [
      "@throws IllegalArgumentException if a value of a is outside of arange",
      "@param arange length of the argument's range and the result's domain",
      "@throws IllegalArgumentException If the initial capacity is negative,\n     or if the load factor is nonpositive.",
      "@throws IllegalArgumentException If the initial capacity is negative.",
      "@throws NullPointerException if the specified map is null.",
      "@return the object in this set that is equal to key, or null",
      "@param filename non-null file name for stream being read",
      "@throws Error if argument is not a regex",
      "@return its argument",
      "@return negative of a",
      "@return ~a, the bitwise complement of a",
      "@return x * y",
      "@return x / y",
      "@return x % y",
      "@return x &lt;&lt; y",
      "@return x &gt;&gt; y",
      "@return x &gt;&gt;&gt; y",
      "@return x &amp; y",
      "@return the logical and of x and y; the result is always 0 or 1",
      "@return x ^ y",
      "@return the logical xor of x and y; the result is always 0 or 1",
      "@return x | y",
      "@return the logical or of x and y; the result is always 0 or 1",
      "@return x % y, where the result is constrained to be non-negative",
      "@throws IllegalArgumentException If the initial capacity is less than\n                                  zero, or if the load factor is\n                                  nonpositive"
   ],
   [
      "@throws IllegalArgumentException If the initial capacity is less than\n                                  zero",
      "@param a value to negate",
      "@param a value to bitwise-complement",
      "@param x first multiplicand",
      "@param y second multiplicand",
      "@param x dividend",
      "@param y divisor",
      "@param x valued to be modded",
      "@param y modulus",
      "@param x valued to be left-shifted",
      "@param y magnitude of the left-shift",
      "@param x valued to be right-shifted",
      "@param y magnitude of the right-shift",
      "@param x first operand",
      "@param y second operand",
      "@param a value to have its sign taken",
      "@return the sign of a: -1, 0, or 1",
      "@param base the base",
      "@param expt the exponent",
      "@return base to the expt power",
      "@param a first operand",
      "@param b second operand",
      "@return greatest common divisor of a and b",
      "@param a array of operands",
      "@return greatest common divisor of the elements of a"
   ],
   [
      "@return greatest common divisor of the differences between the elements of a",
      "@param x value to be modded",
      "@param nums array of operands",
      "@return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n  or null if no such exists or the iterator contains fewer than 3 elements",
      "@param itor iterator of operands",
      "@return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n  or null if no such exists or the iterator contains fewer than 3 elements",
      "@param nonstrict_ends whether endpoints are NOT subject to the strict density requirement",
      "@return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n  or null if no such exists or the array contains fewer than 3 elements",
      "@param nums numbers to be excluded; length &gt; 0; may contain duplicates",
      "@return the set: [min(nums)..max(nums)] - nums",
      "@param nums the list of operands",
      "@return a (remainder, modulus) pair that fails to match elements of nums",
      "@param filename the file to read",
      "@param md the MessageDigest",
      "@return the message digest",
      "@throws IOException if there is a problem reading the file",
      "@param bytes the bytes to convert to a String",
      "@return a String representation of the input bytes",
      "@param s the String to convert to an array of bytes",
      "@return the bytes equivalent to the input String",
      "@param delimiter the delimiter to be put between strings that are\nappended to this",
      "@return bytes in the string, or null",
      "@param s the String for which to count bytes",
      "@param c a character",
      "@return number of bytes used to represent c"
   ],
   [
      "@param a a list",
      "@return true iff a does not contain duplicate elements",
      "@param a an array, representing a function",
      "@return true iff all elements of a are in [0..a.length) and a\ncontains no duplicates.",
      "@param length the length of the result",
      "@return fresh array that is the identity function of the given length",
      "@param a the input permutation",
      "@return fresh array which is the inverse of the given permutation",
      "@param a an array representing a function from [0..a.length) to [0..arange);\n each element of a is between 0 and arange inclusive",
      "@return function from [0..arange) to [0..a.length) that is the inverse of a",
      "@throws UnsupportedOperationException when the function is not invertible",
      "@param a function from [0..a.length) to [0..b.length)",
      "@param b function from [0..b.length) to range R",
      "@return function from [0..a.length) to range R that is the\ncomposition of a and b",
      "@param smaller first set to test",
      "@param bigger second set to test",
      "@return true iff smaller is a subset of bigger",
      "@return the next token",
      "@return the current token",
      "@param ch the comment character",
      "@param ch the quoting character",
      "@return the type of the current token",
      "@param tok string to check next token against",
      "@return next token, if if it a word; otherwise calls the error handling routine",
      "@param s string to tokenize"
   ],
   [
      "@param e error handler",
      "@throws ArgException if there is an illegal argument",
      "@return maximum capacity of the set representation",
      "@param <T> (super)type of elements of the sets",
      "@param max_values the maximum size for the returned LimitedSizeSet",
      "@param slist a list of LimitedSizeSet, whose elements will be merged",
      "@return a LimitedSizeSet that merges the elements of slist",
      "@param max_values the maximum number of values this set will be able to hold",
      "@return the string that was read, or null at end of file",
      "@return a line-by-line iterator for this file",
      "@return whether there is another line to read",
      "@return the next line in the multi-file\nThrows NoSuchElementException at end of file",
      "@return the next entry (paragraph) in the file",
      "@return next line from the reader, or null if there is no more input",
      "@return the current filename",
      "@return the current line number",
      "@param lineNumber new line number for the current file",
      "@param entry_start_re regular expression that starts a long entry",
      "@param entry_stop_re regular expression that ends a long entry",
      "@param args command-line arguments: filename [comment_re [include_re]]",
      "@throws IOException if there is a problem reading a file",
      "@throws UnsupportedEncodingException if the charset encoding is not supported",
      "@param in source from which to read entries",
      "@param charsetName the character set to use",
      "@param comment_re_string regular expression that matches comments.\n                     Any text that matches comment_re is removed.\n                     A line that is entirely a comment is ignored."
   ],
   [
      "@param include_re_string regular expression that matches include directives.\n                     The expression should define one group that contains\n                     the include file name.",
      "@param in the InputStream",
      "@param filename the file name",
      "@param reader source from which to read entries",
      "@param filename file name corresponding to reader, for use in error messages",
      "@param comment_re_string regular expression that matches comments.\n                     Any text that matches comment_re is removed.\n                     A line that is entirely a comment is ignored",
      "@param include_re_string regular expression that matches include directives.\n                     The expression should define one group that contains\n                     the include file name",
      "@param file initial file to read",
      "@param comment_re regular expression that matches comments.\n                     Any text that matches comment_re is removed.\n                     A line that is entirely a comment is ignored.",
      "@param include_re regular expression that matches include directives.\n                     The expression should define one group that contains\n                     the include file name.",
      "@param filename initial file to read",
      "@param filename source from which to read entries",
      "@param o the object to test",
      "@return whether the object satisfies the filter",
      "@param rel_diff the new relative diff to use",
      "@param a1 the first value to compare",
      "@param a2 the first value to compare",
      "@return true if a1 and a2 are set equivalent, false otherwise",
      "@param smaller the possibly-smaller subset",
      "@param bigger the possibly-larger set",
      "@return true if smaller is a subset (each element of smaller is\nalso a element of bigger) of bigger, false otherwise",
      "@param rel_diff the relative diff to use",
      "@return number of bytes printed so far",
      "@return number of bytes written so far",
      "@return number of characters printed so far"
   ],
   [
      "@param s the string to be printed, or null",
      "@param b the boolean to be printed",
      "@param c the char to be printed",
      "@param s the char[] to be printed",
      "@param d the double to be printed",
      "@param f the float to be printed",
      "@param i the int to be printed",
      "@param l the long to be printed",
      "@param obj the object to be printed",
      "@param s the string to be printed",
      "@param buf the char[] to be printed",
      "@param buf character array",
      "@param off offset from which to start writing characters",
      "@param len number of characters to write",
      "@param s string to be printed",
      "@param out an output stream",
      "@param autoFlush if true, the println() methods will flush the output buffer",
      "@param out a Writer",
      "@param out a writer",
      "@return previous value associated with specified key, or <code>null</code>\n       if there was no mapping for key.  A <code>null</code> return can\n       also indicate that the HashMap previously associated\n       <code>null</code> with the specified key.",
      "@param newCapacity the new capacity, MUST be a power of two;\n       must be greater than current capacity unless current\n       capacity is MAXIMUM_CAPACITY (in which case value\n       is irrelevant).",
      "@param m mappings to be stored in this map.",
      "@return previous value associated with specified key, or <code>null</code>\n       if there was no mapping for key.  A <code>null</code> return can\n       also indicate that the map previously associated <code>null</code>\n       with the specified key.",
      "@param initialCapacity the initial capacity of the\n     <code>WeakIdentityHashMap</code>",
      "@param loadFactor the load factor of the\n     <code>WeakIdentityHashMap</code>"
   ],
   [
      "@param t the map whose mappings are to be placed in this map.",
      "@param iter the iterator to wrap.",
      "@param args command-line arguments; see documentation",
      "@param reader where to read the entry from",
      "@return the next entry, or null",
      "@param entry the entry whose first line to return",
      "@return the first line of entry",
      "@param <A> type of first argument",
      "@param <B> type of second argument",
      "@param a first argument",
      "@param b second argument",
      "@return a pair of the values (a, b)",
      "@param a the first element of the pair",
      "@param b the second element of the pair",
      "@return the error output from compiling the files",
      "@param fileNames paths to the files to be compiled as Strings",
      "@param filenames the paths of the Java source to be compiled as Strings",
      "@return the process that executed the external compile command",
      "@throws Error if an empty list of filenames is provided.",
      "@param fileNames all the files that were attempted to be compiled",
      "@param errorString the error string that indicates which files\n  could not be compiled",
      "@param sourceFilePath the path to the .java file",
      "@return the path to the corresponding .class file",
      "@param pathName path to check for existence",
      "@return true iff the file exists"
   ],
   [
      "@param compiler an array of Strings representing a command that runs a\nJava compiler (it could be the full path name or whatever is used on\nthe commandline), plus any command-line options.",
      "@param timeLimit the maximum permitted compilation time, in msec",
      "@param compiler a list of Strings representing a command that runs a\nJava compiler (it could be the full path name or whatever is used on\nthe commandline), plus any command-line options.",
      "@param compiler a command that runs a Java compiler; for instance, it\ncould be the full path name or whatever is used on the commandline.\nIt may contain command-line arguments, and is split on spaces.",
      "@return an iterator of all objects selected.",
      "@param num_elts the number of elements to select from each bucket",
      "@param eq partioner that determines how to partition the objects from\n the iteration",
      "@return a String representing the elapsed time",
      "@param task the task to be queued on the task list",
      "@param responsible name of the responsible party, or null; search for tasks assigned to responsible",
      "@return a TaskManger with only those tasks assigned to responsible",
      "@param milestone milestone to search for",
      "@return TaskManger with only the tasks in the given milestone",
      "@return a new TaskManger with only completed tasks",
      "@param filenames list of files to read tasks from",
      "@throws IOException if there is trouble reading a file",
      "@param key the key that is to be mapped to the given\n               <code>value</code>",
      "@param value the value to which the given <code>key</code> is to be\n               mapped",
      "@return the previous value to which this key was mapped, or\n         <code>null</code> if if there was no mapping for the key",
      "@param key the key whose mapping is to be removed",
      "@return the value to which this key was mapped, or <code>null</code> if\n         there was no mapping for the key",
      "@param initialCapacity the initial capacity of the\n                         <code>WeakHashMap</code>",
      "@param loadFactor the load factor of the <code>WeakHashMap</code>",
      "@param h the Hasher to use when hashing values for this map",
      "@param args command-line arguments"
   ],
   [
      "@throws IOException if a file cannot be read",
      "@param filename file name to appear in printed messages",
      "@param is input stream from which to read classfile bytes to process",
      "@param is input stream from which to read a class",
      "@return array of three version numbers",
      "@return a WeakIdentityPair of (a, b)",
      "@param root the root document",
      "@return true if processing completed without an error",
      "@param option the command-line option",
      "@return the number of command-line arguments needed when using the option",
      "@param options the command-line options to be checked: an array of 1- or 2-element arrays",
      "@param reporter where to report errors",
      "@return true iff the command-line options are valid",
      "@param options the command-line options to parse: a list of 1- or 2-element arrays",
      "@throws Exception if there is trouble",
      "@return the user-visible doclet output",
      "@return the HTML documentation for the underlying options instance",
      "@param padding the padding to add in the Javadoc output",
      "@param oi the option to describe",
      "@return HTML describing oi",
      "@param doc a Javadoc comment to convert to HTML",
      "@return HTML version of doc",
      "@param s string to check for being a regular expression",
      "@param groups number of groups expected",
      "@return true iff s is a regular expression with groups groups"
   ],
   [
      "@param c char to check for being a regular expression",
      "@return true iff c is a regular expression",
      "@return null, or a string describing why the argument is not a regex",
      "@return null, or a PatternSyntaxException describing why the argument is not a regex",
      "@param p pattern whose groups to count",
      "@return the count of groups in the argument",
      "@param className name of the class",
      "@return class URL, or null of the class was not found",
      "@return true iff the process has timed out",
      "@return the timeout time in msecs",
      "@return the exit value for the subprocess",
      "@return the error stream",
      "@return the input stream",
      "@return the output stream",
      "@return the exit value of the subprocess",
      "@return true if the process if finished, false otherwise",
      "@param timeLimit in milliseconds",
      "@param cacheStdout If true, causes the TimeLimitProcess to consume the standard output of the\nunderlying process, and to cache it.  After the process terminates (on\nits own or by being timed out), the output is available via the\ncached_stdout method.  This is necessary because when a Java process\nis terminated, its standard output is no longer available.",
      "@param a the array whose elements to intern in place",
      "@return an interned version of a",
      "@param value the value to test for interning",
      "@return true iff value is interned",
      "@param i the value to intern",
      "@return an interned Integer with value i",
      "@param s the string to parse"
   ],
   [
      "@return an interned Integer parsed from s",
      "@return an interned Long parsed from s",
      "@param a the array to canonicalize",
      "@return a canonical representation for the int[] array",
      "@return a canonical representation for the long[] array",
      "@param d the value to intern",
      "@return an interned Double with value d",
      "@return an interned Double parsed from s",
      "@return a canonical representation for the double[] array",
      "@return a canonical representation for the String[] array",
      "@return a canonical representation for the Object[] array",
      "@param a an Object to canonicalize",
      "@return a canonical version of a",
      "@param seq the sequence whose subsequence should be interned",
      "@param start the index of the start of the subsequence to be interned",
      "@param end the index of the end of the subsequence to be interned",
      "@return a subsequence of seq from start to end that is interned",
      "@param <T> type of the graph nodes",
      "@param predecessors a graph, represented as a predecessor map",
      "@return a map from each node to a list of its pre-dominators",
      "@param <T> the type of nodes of the graph",
      "@param graph the graph to print",
      "@param ps the PrintStream to which to print the graph",
      "@param indent the number of spaces by which to indent the printed representation",
      "@return the merged DateTime"
   ],
   [
      "@return a Date read from the given string",
      "@param next value to be added to this selector",
      "@return current_values",
      "@param num_elts the number of elements intended to be selected\nfrom the input elements\n\nSets 'number_to_take' = num_elts",
      "@param num_elts the number of elements intended to be selected\nfrom the input elements",
      "@param r the seed to give for random number generation.\n\nSets 'number_to_take' = num_elts",
      "@param keep_probability the probability that each element is\nselected from the oncoming Iteration",
      "@param r the seed to give for random number generation",
      "@param gen class whose methods to print",
      "@param m the method",
      "@return a string describing the method declaration",
      "@param m the method whose access flags to retrieve",
      "@return a string representation of the access flags of method m",
      "@param a the attribute",
      "@return the attribute name for the specified attribute",
      "@param pool the constant pool",
      "@param index the index in the constant pool",
      "@return the constant string at the specified offset in the constant pool",
      "@param mg the method to test",
      "@return true iff the method is a constructor",
      "@param m the method to test",
      "@return true iff the method is a class initializer",
      "@param gen the class to test",
      "@return true iff the class is part of the JDK (rt.jar)",
      "@param classname the class to test, in the format of Class.getName();\n  the class should not be an array"
   ],
   [
      "@param classname the class to test, in internal form",
      "@param gen the class whose methods to print",
      "@param mgen the class to check",
      "@param gen the class to check",
      "@param mg method to be augmented",
      "@param nl instructions to prepend to the method",
      "@param jc javaclass to dump",
      "@param dump_dir directory in which to write the file",
      "@param mg the method whose local variables to describe",
      "@return a description of the local variables (one per line)",
      "@param mg the method whose line numbers to extract",
      "@param il the instruction list to augment with line numbers",
      "@param mg the method whose locals to set",
      "@param mg the method to clear out",
      "@return true iff the attribute is a local variable type table",
      "@param mg the method to check",
      "@return true iff the method is a main method",
      "@param type the type",
      "@return the Java classname that corresponds to type",
      "@return the Java class that corresponds to type",
      "@param types the array to extend",
      "@param new_type the element to add to the end of the types array",
      "@return the array (or a new one), with new_type at the end",
      "@param new_type the element to add to the beginning of the types array",
      "@return the array (or a new one), with new_type at the beginning"
   ],
   [
      "@param classname the class to convert to a type",
      "@return the type corresponding to the given class name",
      "@param a the first BitSet to intersect",
      "@param b the second BitSet to intersect",
      "@param i the cardinality bound",
      "@return true iff size(a intersect b) &ge; i",
      "@param c the third BitSet to intersect",
      "@return true iff size(a intersect b intersect c) &ge; i",
      "@return size(a intersect b)",
      "@return size(a intersect b intersect c)",
      "@param file the possibly-compressed file to read",
      "@return an InputStream for file",
      "@throws IOException if there is trouble reading the file",
      "@param filename the possibly-compressed file to read",
      "@return an InputStream for filename",
      "@throws FileNotFoundException if the file is not found",
      "@return an InputStreamReader for file",
      "@throws FileNotFoundException if the file cannot be found",
      "@param charsetName null, or the name of a Charset to use when reading the file",
      "@return a BufferedReader for file",
      "@param file the possibility-compressed file to read",
      "@param charsetName the character set to use when reading the file",
      "@return a BufferedReader for filename",
      "@return a LineNumberReader for filename",
      "@return a LineNumberReader for file"
   ],
   [
      "@param filename the possibly-compressed file to write",
      "@return a BufferedWriter for filename",
      "@throws IOException if there is trouble writing the file",
      "@param append if true, the resulting BufferedOutputStream appends to the end\nof the file instead of the beginning",
      "@return a BufferedOutputStream for filename",
      "@param classname name of the class, in binary class name format",
      "@return name of the class, in field descriptor format",
      "@param primitive_name name of the type, in Java format",
      "@return name of the type, in field descriptor format",
      "@throws IllegalArgumentException if primitive_name is not a valid primitive type name.",
      "@param bn the binary name to convert",
      "@return the class name, in Class.getName format",
      "@param fd the class, in field descriptor format",
      "@param arglist an argument list, in Java format",
      "@return argument list, in JVML format",
      "@param classname name of the type, in JVML format",
      "@return name of the type, in Java format",
      "@param arglist an argument list, in JVML format",
      "@return argument list, in Java format",
      "@param dir directory to add to the system classpath",
      "@param filename file whose size to count",
      "@return number of lines in filename",
      "@param filename the file to infer a line separator from",
      "@return the inferred line separator used in filename",
      "@param file the file to infer a line separator from"
   ],
   [
      "@param file1 first file to compare",
      "@param file2 second file to compare",
      "@param trimLines if true, call String.trim on each line before comparing",
      "@return true iff the files have the same contents",
      "@param file the file to create and write",
      "@return true iff the file can be created and written",
      "@param prefix the prefix string to be used in generating the file's\n name; must be at least three characters long",
      "@param suffix the suffix string to be used in generating the file's\n name; may be null, in which case the suffix \".tmp\" will be used Returns:\n An abstract pathname denoting a newly-created empty file",
      "@return a File representing the newly-created temporary directory",
      "@throws IllegalArgumentException If the prefix argument contains fewer\n than three characters",
      "@throws IOException If a file could not be created",
      "@throws SecurityException If a security manager exists and its\n SecurityManager.checkWrite(java.lang.String) method does not allow a\n file to be created",
      "@param dirName the directory to delete",
      "@return true if and only if the file or directory is successfully deleted; false otherwise",
      "@param dir the directory to delete",
      "@param name file whose name to expand",
      "@return file with expanded file",
      "@param name filename to expand",
      "@return expanded filename",
      "@param name file to quote",
      "@return a string version of the name that can be used in Java source",
      "@param o the object to write",
      "@param file the file to which to write the object",
      "@param file the file from which to read",
      "@return the object read from the file"
   ],
   [
      "@throws ClassNotFoundException if the object's class cannot be found",
      "@param r the Reader to read",
      "@return the entire contents of the reader, as a string",
      "@param contents the text to put in the file",
      "@param x value to be hashed",
      "@return a hash of the arguments",
      "@param a value to be hashed",
      "@param b value to be hashed",
      "@param c value to be hashed",
      "@param l value to be hashed",
      "@param <T> type of the iterator elements",
      "@param itor elements to be randomly selected from",
      "@param num_elts number of elements to select",
      "@return list of num_elts elements from itor",
      "@param random the Random instance to use to make selections",
      "@param <T> type of keys in the map",
      "@param m map to have one of its values incremented",
      "@param key the key for the element whose value will be incremented",
      "@param count how much to increment the value by",
      "@return the old value, before it was incremented",
      "@throws Error if the key is in the Map but maps to a non-Integer.",
      "@param <K> type of map keys",
      "@param <V> type of map values",
      "@param m map to be converted to a string",
      "@return a multi-line string representation of m"
   ],
   [
      "@param sb an Appendable (such as StringBuilder) to which to write a multi-line string representation of m",
      "@param linePrefix prefix to write at the beginning of each line",
      "@param <K> type of the map keys",
      "@param <V> type of the map values",
      "@param m a map whose keyset will be sorted",
      "@return a sorted version of m.keySet()",
      "@param comparator the Comparator to use for sorting",
      "@param method a method signature",
      "@return the method corresponding to the given signature",
      "@throws ClassNotFoundException if the class is not found",
      "@throws NoSuchMethodException if the method is not found",
      "@param classname class in which to find the method",
      "@param methodname the method name",
      "@param params the parameters of the method",
      "@return the method named classname.methodname with parameters params",
      "@param command a command to execute on the command line",
      "@return all the output of the command",
      "@param command a command to execute on the command line, as a list of\nstrings (the command, then its arguments)",
      "@param p a Properties object in which to look up the property",
      "@param key name of the property to look up",
      "@return true iff the property has value \"true\", \"yes\", or \"1\"",
      "@param value value to concatenate to the previous value of the property",
      "@return the previous value of the property",
      "@param value value to set the property to, if it is not already set",
      "@param o object in which to set the field"
   ],
   [
      "@param fieldName name of field to set",
      "@param value new value of field",
      "@throws NoSuchFieldException if the field does not exist in the object",
      "@return new value of field",
      "@param set a set in which to look up the value",
      "@param key the value to look up in the set",
      "@param from input stream",
      "@param to output stream",
      "@param is input stream to read",
      "@return a String containing all the characters from the input stream",
      "@param target the string to do replacement in",
      "@param oldStr the substring to replace",
      "@param newStr the replacement",
      "@return target with all instances of oldStr replaced by newStr",
      "@param s the string to split",
      "@param delim delimiter to split the string on",
      "@return array of length at least 1, containing s split on delimiter",
      "@return an array of Strings, one for each line in the argument",
      "@param a array of values to concatenate",
      "@param delim delimiter to place between printed representations",
      "@return the concatenation of the string representations of the values, with the delimiter between",
      "@return the concatenation of the string representations of the values, each on its own line",
      "@param v list of values to concatenate",
      "@param orig string to quote",
      "@return quoted version of orig"
   ],
   [
      "@param ch character to quote",
      "@return quoted version och ch",
      "@param c character to quote",
      "@return quoted version of c",
      "@param orig string to quoto",
      "@param arg string to remove whitespace in",
      "@param delimiter string to remove whitespace abutting",
      "@return version of arg, with whitespace abutting delimiter removed",
      "@param delimiter string to remove whitespace after",
      "@return version of arg, with whitespace after delimiter removed",
      "@param delimiter string to remove whitespace before",
      "@return version of arg, with whitespace before delimiter removed",
      "@param n count of nouns",
      "@param noun word being counted",
      "@return noun, if n==1; otherwise, pluralization of noun",
      "@param s string to truncate or pad",
      "@param length goal length",
      "@return s truncated or padded to length characters",
      "@param num int whose string representation to truncate or pad",
      "@return a string representation of num truncated or padded to length characters",
      "@param num double whose string representation to truncate or pad",
      "@param s string to search in",
      "@param ch character to search for",
      "@return number of times the character appears in the string",
      "@param sub string to search for"
   ],
   [
      "@return number of times the substring appears in the string",
      "@param str a string to be parsed",
      "@param delim the delimiters",
      "@param returnDelims flag indicating whether to return the delimiters as tokens",
      "@return vector of strings resulting from tokenization",
      "@param t the Throwable to obtain a backtrace of",
      "@return a String representation of the backtrace of the given Throwable",
      "@return a sorted version of the list",
      "@param <T> type of elements of the list",
      "@param l a list to sort",
      "@param c a sorted version of the list",
      "@param l a list to remove duplicates from",
      "@return a copy of the list with duplicates removed",
      "@param o1 first value to compare",
      "@param o2 second value to comare",
      "@return true iff o1 and o2 are deeply equal",
      "@param <T> type of the enumeration and vector elements",
      "@param e an enumeration to convert to a Vector",
      "@return a vector containing the elements of the enumeration",
      "@param <T> type of the input list elements, and type of the innermost output list elements",
      "@param dims number of dimensions:  that is, size of each innermost list",
      "@param start initial index",
      "@param objs list of elements to",
      "@return list of lists of length dims, each of which combines elements from objs",
      "@param arity size of each innermost list"
   ],
   [
      "@param start initial value",
      "@param cnt maximum element value",
      "@return list of lists of length arity, each of which combines integers from start to cnt",
      "@param qualified_name the fully-qualified name of a class",
      "@return the simple unqualified name of the class",
      "@param cls a class",
      "@param val a numeric value",
      "@return an abbreviated string representation of the value",
      "@param o object whose hash code to compute",
      "@return o's hash code",
      "@param o1 the first value to test for equality",
      "@param o2 the second value to test for equality",
      "@return whether o1 equals o2",
      "@param max_values the maximum size for the returned LimitedSizeIntSet",
      "@param slist a list of LimitedSizeIntSet, whose elements will be merged",
      "@return a LimitedSizeIntSet that merges the elements of slist",
      "@param obj the Object to be assigned to a bucket",
      "@return a key representing the bucket containing obj",
      "@param <C> type of third argument",
      "@param c third argument",
      "@return a triple of the values (a, b, c)",
      "@param enabled whether to enable or disable logging",
      "@param val whether to parse arguments after a non-option command-line argument",
      "@param val whether to parse long options with a single dash, as in -longOption",
      "@param args the commandline to be parsed"
   ],
   [
      "@return all non-option arguments",
      "@throws ArgException if the command line contains unknown option or\nmisused options.",
      "@param args the command line to parse",
      "@throws ArgException if the command line contains misused options or an unknown option.",
      "@param ps where to print usage information",
      "@param msg message to print before usage information",
      "@param msg messag. to print before usage information",
      "@param format message to print before usage information",
      "@param args objects to put in formatted message",
      "@return the command-line usage message",
      "@param group_names the list of option groups to include in the usage\nmessage.  If empty and option groups are being used, will return usage\nfor all option groups that are not unpublicized.  If empty and option\ngroups are not being used, will return usage for all options that are\nnot unpublicized.",
      "@param include_unpublicized if true, treat all unpublicized options\nand option groups as publicized",
      "@return the length of the longest synopsis message in a list of options",
      "@param <T> the enum type",
      "@return a short name for the specified type for use in messages",
      "@return options, similarly to supplied on the command line",
      "@return a description of all of the known options",
      "@param args the classes whose options to process",
      "@param usage_synopsis a synopsis of how to call your program",
      "@param a an array",
      "@return the smallest value in the array",
      "@return the largest value in the array",
      "@return a two-element array containing the smallest and largest values in the array",
      "@return the difference between the smallest and largest array elements",
      "@return the sum of an array of integers"
   ],
   [
      "@param a a 2d array",
      "@return the sum of all the elements of a 2d array of integers",
      "@return the sum of an array of doubles",
      "@return the sum of all the elements of a 2d array of doubles",
      "@param <T> the base type of the result",
      "@param lst the list to convert to an array",
      "@return the result of lst.toArray, casted to a more precise type than Object[]",
      "@param <T> the type of the sequence elements",
      "@param a the first sequence to concatenate",
      "@param b the second sequence to concatenate",
      "@return an array that concatenates the arguments",
      "@param a the first array to concatenate",
      "@param b the second array to concatenate",
      "@param quoted whether to quote the array elements",
      "@return a string representation of the array",
      "@param a a collection",
      "@param quoted whether to quote the collection elements that are Java strings",
      "@return a string representation of the list",
      "@param obj an array",
      "@param obj a list",
      "@param <T> the type of the elements"
   ]
]