[{"id":33194,"label":false,"oracleId":1482,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param update the value that replaces the old value.","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"expect","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33195,"label":false,"oracleId":1482,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param update the value that replaces the old value.","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33196,"label":false,"oracleId":1482,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param update the value that replaces the old value.","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33197,"label":true,"oracleId":1482,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param update the value that replaces the old value.","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33198,"label":false,"oracleId":1482,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param update the value that replaces the old value.","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33199,"label":false,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} upon success","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"expect","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33200,"label":false,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} upon success","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33201,"label":false,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} upon success","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33202,"label":false,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} upon success","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33203,"label":true,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} upon success","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33204,"label":false,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} upon success","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33205,"label":false,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} in case of success.","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"expect","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33206,"label":false,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} in case of success.","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33207,"label":false,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} in case of success.","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33208,"label":false,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} in case of success.","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33209,"label":true,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} in case of success.","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33210,"label":false,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} in case of success.","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33211,"label":false,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"expect","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33212,"label":false,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33213,"label":false,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33214,"label":false,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33215,"label":true,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33216,"label":false,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33217,"label":false,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} if the operation is successful.","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"expect","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33218,"label":false,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} if the operation is successful.","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33219,"label":false,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} if the operation is successful.","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33220,"label":false,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} if the operation is successful.","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33221,"label":true,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} if the operation is successful.","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33222,"label":false,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} if the operation is successful.","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33223,"label":false,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} if the task succeeds.","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"expect","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33224,"label":false,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} if the task succeeds.","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33225,"label":false,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} if the task succeeds.","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33226,"label":false,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} if the task succeeds.","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33227,"label":true,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} if the task succeeds.","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33228,"label":false,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} if the task succeeds.","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33229,"label":false,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} if the process is successful","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"expect","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33230,"label":false,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} if the process is successful","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33231,"label":false,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} if the process is successful","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33232,"label":false,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} if the process is successful","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33233,"label":true,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} if the process is successful","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33234,"label":false,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} if the process is successful","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33235,"label":false,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to raise","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"delta","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33236,"label":false,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to raise","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33237,"label":false,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to raise","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33238,"label":true,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to raise","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33239,"label":false,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to raise","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33240,"label":false,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to increase","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"delta","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33241,"label":false,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to increase","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33242,"label":false,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to increase","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33243,"label":true,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to increase","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33244,"label":false,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to increase","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33245,"label":false,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to augment.","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"delta","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33246,"label":false,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to augment.","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33247,"label":false,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to augment.","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33248,"label":true,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to augment.","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33249,"label":false,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to augment.","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33250,"label":false,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to raise by","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"delta","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33251,"label":false,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to raise by","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33252,"label":false,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to raise by","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33253,"label":true,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to raise by","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33254,"label":false,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to raise by","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33255,"label":false,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"delta","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33256,"label":false,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33257,"label":false,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33258,"label":true,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33259,"label":false,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33260,"label":false,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to increment","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"delta","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33261,"label":false,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to increment","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33262,"label":false,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to increment","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33263,"label":true,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to increment","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33264,"label":false,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to increment","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33265,"label":false,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that was earlier.","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"delta","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33266,"label":false,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that was earlier.","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33267,"label":false,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that was earlier.","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33268,"label":false,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that was earlier.","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33269,"label":true,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that was earlier.","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33270,"label":false,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that was earlier.","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33271,"label":false,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that came before","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"delta","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33272,"label":false,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that came before","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33273,"label":false,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that came before","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33274,"label":false,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that came before","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33275,"label":true,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that came before","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33276,"label":false,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that came before","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33277,"label":false,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that preceded","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"delta","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33278,"label":false,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that preceded","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33279,"label":false,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that preceded","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33280,"label":false,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that preceded","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33281,"label":true,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that preceded","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33282,"label":false,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that preceded","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33283,"label":false,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that was prior","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"delta","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33284,"label":false,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that was prior","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33285,"label":false,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that was prior","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33286,"label":false,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that was prior","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33287,"label":true,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that was prior","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33288,"label":false,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that was prior","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33289,"label":false,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"delta","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33290,"label":false,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33291,"label":false,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33292,"label":false,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33293,"label":true,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33294,"label":false,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33295,"label":false,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that was already","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"delta","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33296,"label":false,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that was already","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33297,"label":false,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that was already","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33298,"label":false,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that was already","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33299,"label":true,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that was already","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33300,"label":false,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that was already","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33301,"label":false,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to increase","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"delta","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33302,"label":false,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to increase","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33303,"label":false,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to increase","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33304,"label":true,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to increase","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33305,"label":false,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to increase","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33306,"label":false,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to raise","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"delta","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33307,"label":false,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to raise","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33308,"label":false,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to raise","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33309,"label":true,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to raise","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33310,"label":false,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to raise","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33311,"label":false,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"delta","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33312,"label":false,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33313,"label":false,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33314,"label":true,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33315,"label":false,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33316,"label":false,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to increment","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"delta","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33317,"label":false,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to increment","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33318,"label":false,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to increment","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33319,"label":true,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to increment","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33320,"label":false,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to increment","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33321,"label":false,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to augment.","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"delta","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33322,"label":false,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to augment.","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33323,"label":false,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to augment.","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33324,"label":true,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to augment.","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33325,"label":false,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to augment.","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33326,"label":false,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to raise by","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"delta","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33327,"label":false,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to raise by","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33328,"label":false,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to raise by","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33329,"label":true,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to raise by","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33330,"label":false,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to raise by","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33331,"label":false,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that is modified","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"delta","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33332,"label":false,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that is modified","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33333,"label":false,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that is modified","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33334,"label":false,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that is modified","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33335,"label":true,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that is modified","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33336,"label":false,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that is modified","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33337,"label":false,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value after updating","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"delta","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33338,"label":false,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value after updating","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33339,"label":false,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value after updating","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33340,"label":false,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value after updating","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33341,"label":true,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value after updating","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33342,"label":false,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value after updating","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33343,"label":false,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"delta","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33344,"label":false,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33345,"label":false,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33346,"label":false,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33347,"label":true,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33348,"label":false,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33349,"label":false,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the modified value","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"delta","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33350,"label":false,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the modified value","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33351,"label":false,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the modified value","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33352,"label":false,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the modified value","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33353,"label":true,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the modified value","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33354,"label":false,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the modified value","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33355,"label":false,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that has undergone changes.","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"delta","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33356,"label":false,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that has undergone changes.","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33357,"label":false,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that has undergone changes.","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33358,"label":false,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that has undergone changes.","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33359,"label":true,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that has undergone changes.","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33360,"label":false,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that has undergone changes.","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33361,"label":false,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that has been updated","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"delta","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33362,"label":false,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that has been updated","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33363,"label":false,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that has been updated","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33364,"label":false,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that has been updated","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33365,"label":true,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that has been updated","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33366,"label":false,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value that has been updated","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33367,"label":false,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33368,"label":false,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33369,"label":false,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33370,"label":true,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33371,"label":false,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33372,"label":false,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the current value represented as a String","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33373,"label":false,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the current value represented as a String","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33374,"label":false,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the current value represented as a String","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33375,"label":true,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the current value represented as a String","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33376,"label":false,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the current value represented as a String","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33377,"label":false,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the String that represents the current value.","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33378,"label":false,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the String that represents the current value.","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33379,"label":false,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the String that represents the current value.","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33380,"label":true,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the String that represents the current value.","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33381,"label":false,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the String that represents the current value.","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33382,"label":false,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the current value as a String.","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33383,"label":false,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the current value as a String.","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33384,"label":false,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the current value as a String.","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33385,"label":true,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the current value as a String.","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33386,"label":false,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the current value as a String.","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33387,"label":false,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value as a String in its present state","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33388,"label":false,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value as a String in its present state","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33389,"label":false,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value as a String in its present state","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33390,"label":true,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value as a String in its present state","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33391,"label":false,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value as a String in its present state","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33392,"label":false,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value in its current state as a String","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33393,"label":false,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value in its current state as a String","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AtomicDouble"]},{"id":33394,"label":false,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value in its current state as a String","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33395,"label":true,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value in its current state as a String","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33396,"label":false,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the value in its current state as a String","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33397,"label":false,"oracleId":1489,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param initialValue the value to initialize with","methodJavadoc":"    /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */","methodSourceCode":"public AtomicDouble(double initialValue){\n    value = doubleToRawLongBits(initialValue);\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"initialValue","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33398,"label":false,"oracleId":1489,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param initialValue the value to initialize with","methodJavadoc":"    /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */","methodSourceCode":"public AtomicDouble(double initialValue){\n    value = doubleToRawLongBits(initialValue);\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33399,"label":true,"oracleId":1489,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param initialValue the value to initialize with","methodJavadoc":"    /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */","methodSourceCode":"public AtomicDouble(double initialValue){\n    value = doubleToRawLongBits(initialValue);\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33400,"label":false,"oracleId":1489,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param initialValue the value to initialize with","methodJavadoc":"    /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */","methodSourceCode":"public AtomicDouble(double initialValue){\n    value = doubleToRawLongBits(initialValue);\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33401,"label":false,"oracleId":1489,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param initialValue the value to set as initial.","methodJavadoc":"    /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */","methodSourceCode":"public AtomicDouble(double initialValue){\n    value = doubleToRawLongBits(initialValue);\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"initialValue","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33402,"label":false,"oracleId":1489,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param initialValue the value to set as initial.","methodJavadoc":"    /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */","methodSourceCode":"public AtomicDouble(double initialValue){\n    value = doubleToRawLongBits(initialValue);\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33403,"label":true,"oracleId":1489,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param initialValue the value to set as initial.","methodJavadoc":"    /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */","methodSourceCode":"public AtomicDouble(double initialValue){\n    value = doubleToRawLongBits(initialValue);\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33404,"label":false,"oracleId":1489,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param initialValue the value to set as initial.","methodJavadoc":"    /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */","methodSourceCode":"public AtomicDouble(double initialValue){\n    value = doubleToRawLongBits(initialValue);\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33405,"label":false,"oracleId":1489,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param initialValue the value to start with","methodJavadoc":"    /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */","methodSourceCode":"public AtomicDouble(double initialValue){\n    value = doubleToRawLongBits(initialValue);\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"initialValue","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33406,"label":false,"oracleId":1489,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param initialValue the value to start with","methodJavadoc":"    /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */","methodSourceCode":"public AtomicDouble(double initialValue){\n    value = doubleToRawLongBits(initialValue);\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33407,"label":true,"oracleId":1489,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param initialValue the value to start with","methodJavadoc":"    /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */","methodSourceCode":"public AtomicDouble(double initialValue){\n    value = doubleToRawLongBits(initialValue);\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33408,"label":false,"oracleId":1489,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param initialValue the value to start with","methodJavadoc":"    /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */","methodSourceCode":"public AtomicDouble(double initialValue){\n    value = doubleToRawLongBits(initialValue);\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33409,"label":false,"oracleId":1489,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */","methodSourceCode":"public AtomicDouble(double initialValue){\n    value = doubleToRawLongBits(initialValue);\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"initialValue","tokenClass":"MethodArgument","tokenInfo":["","double"]},{"id":33410,"label":false,"oracleId":1489,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */","methodSourceCode":"public AtomicDouble(double initialValue){\n    value = doubleToRawLongBits(initialValue);\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33411,"label":true,"oracleId":1489,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */","methodSourceCode":"public AtomicDouble(double initialValue){\n    value = doubleToRawLongBits(initialValue);\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33412,"label":false,"oracleId":1489,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"","methodJavadoc":"    /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */","methodSourceCode":"public AtomicDouble(double initialValue){\n    value = doubleToRawLongBits(initialValue);\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33413,"label":false,"oracleId":1490,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a brand new {@code AtomicReference} without any initial value","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(){\n    return new AtomicReference<V>();\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33414,"label":false,"oracleId":1490,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a brand new {@code AtomicReference} without any initial value","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(){\n    return new AtomicReference<V>();\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33415,"label":true,"oracleId":1490,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a brand new {@code AtomicReference} without any initial value","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(){\n    return new AtomicReference<V>();\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33416,"label":false,"oracleId":1490,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a brand new {@code AtomicReference} without any initial value","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(){\n    return new AtomicReference<V>();\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33417,"label":false,"oracleId":1490,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return an uninitialized {@code AtomicReference} instance.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(){\n    return new AtomicReference<V>();\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33418,"label":false,"oracleId":1490,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return an uninitialized {@code AtomicReference} instance.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(){\n    return new AtomicReference<V>();\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33419,"label":true,"oracleId":1490,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return an uninitialized {@code AtomicReference} instance.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(){\n    return new AtomicReference<V>();\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33420,"label":false,"oracleId":1490,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return an uninitialized {@code AtomicReference} instance.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(){\n    return new AtomicReference<V>();\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33421,"label":false,"oracleId":1490,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a freshly created {@code AtomicReference} with no initial value","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(){\n    return new AtomicReference<V>();\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33422,"label":false,"oracleId":1490,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a freshly created {@code AtomicReference} with no initial value","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(){\n    return new AtomicReference<V>();\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33423,"label":true,"oracleId":1490,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a freshly created {@code AtomicReference} with no initial value","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(){\n    return new AtomicReference<V>();\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33424,"label":false,"oracleId":1490,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a freshly created {@code AtomicReference} with no initial value","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(){\n    return new AtomicReference<V>();\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33425,"label":false,"oracleId":1490,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(){\n    return new AtomicReference<V>();\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33426,"label":false,"oracleId":1490,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(){\n    return new AtomicReference<V>();\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33427,"label":true,"oracleId":1490,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(){\n    return new AtomicReference<V>();\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33428,"label":false,"oracleId":1490,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(){\n    return new AtomicReference<V>();\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33429,"label":false,"oracleId":1491,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param initialValue the value to set as initial.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"initialValue","tokenClass":"MethodArgument","tokenInfo":["","V"]},{"id":33430,"label":false,"oracleId":1491,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param initialValue the value to set as initial.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33431,"label":true,"oracleId":1491,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param initialValue the value to set as initial.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33432,"label":false,"oracleId":1491,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param initialValue the value to set as initial.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33433,"label":false,"oracleId":1491,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param initialValue the value to initialize with","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"initialValue","tokenClass":"MethodArgument","tokenInfo":["","V"]},{"id":33434,"label":false,"oracleId":1491,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param initialValue the value to initialize with","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33435,"label":true,"oracleId":1491,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param initialValue the value to initialize with","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33436,"label":false,"oracleId":1491,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param initialValue the value to initialize with","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33437,"label":false,"oracleId":1491,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"initialValue","tokenClass":"MethodArgument","tokenInfo":["","V"]},{"id":33438,"label":false,"oracleId":1491,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33439,"label":true,"oracleId":1491,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33440,"label":false,"oracleId":1491,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33441,"label":false,"oracleId":1491,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param initialValue the value to start with","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"initialValue","tokenClass":"MethodArgument","tokenInfo":["","V"]},{"id":33442,"label":false,"oracleId":1491,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param initialValue the value to start with","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33443,"label":true,"oracleId":1491,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param initialValue the value to start with","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33444,"label":false,"oracleId":1491,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param initialValue the value to start with","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33445,"label":false,"oracleId":1492,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a newly created {@code AtomicReference} with the specified initial value","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"initialValue","tokenClass":"MethodArgument","tokenInfo":["","V"]},{"id":33446,"label":false,"oracleId":1492,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a newly created {@code AtomicReference} with the specified initial value","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33447,"label":false,"oracleId":1492,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a newly created {@code AtomicReference} with the specified initial value","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33448,"label":true,"oracleId":1492,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a newly created {@code AtomicReference} with the specified initial value","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33449,"label":false,"oracleId":1492,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a newly created {@code AtomicReference} with the specified initial value","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33450,"label":false,"oracleId":1492,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return an uninitialized {@code AtomicReference} with the initial value set","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"initialValue","tokenClass":"MethodArgument","tokenInfo":["","V"]},{"id":33451,"label":false,"oracleId":1492,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return an uninitialized {@code AtomicReference} with the initial value set","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33452,"label":false,"oracleId":1492,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return an uninitialized {@code AtomicReference} with the initial value set","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33453,"label":true,"oracleId":1492,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return an uninitialized {@code AtomicReference} with the initial value set","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33454,"label":false,"oracleId":1492,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return an uninitialized {@code AtomicReference} with the initial value set","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33455,"label":false,"oracleId":1492,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"initialValue","tokenClass":"MethodArgument","tokenInfo":["","V"]},{"id":33456,"label":false,"oracleId":1492,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33457,"label":false,"oracleId":1492,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33458,"label":true,"oracleId":1492,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33459,"label":false,"oracleId":1492,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33460,"label":false,"oracleId":1492,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a freshly instantiated {@code AtomicReference} with the provided initial\nvalue","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"initialValue","tokenClass":"MethodArgument","tokenInfo":["","V"]},{"id":33461,"label":false,"oracleId":1492,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a freshly instantiated {@code AtomicReference} with the provided initial\nvalue","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33462,"label":false,"oracleId":1492,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a freshly instantiated {@code AtomicReference} with the provided initial\nvalue","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33463,"label":true,"oracleId":1492,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a freshly instantiated {@code AtomicReference} with the provided initial\nvalue","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33464,"label":false,"oracleId":1492,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a freshly instantiated {@code AtomicReference} with the provided initial\nvalue","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33465,"label":false,"oracleId":1493,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param length the size of the array.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"length","tokenClass":"MethodArgument","tokenInfo":["","int"]},{"id":33466,"label":false,"oracleId":1493,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param length the size of the array.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33467,"label":true,"oracleId":1493,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param length the size of the array.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33468,"label":false,"oracleId":1493,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param length the size of the array.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33469,"label":false,"oracleId":1493,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param length the array size.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"length","tokenClass":"MethodArgument","tokenInfo":["","int"]},{"id":33470,"label":false,"oracleId":1493,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param length the array size.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33471,"label":true,"oracleId":1493,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param length the array size.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33472,"label":false,"oracleId":1493,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param length the array size.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33473,"label":false,"oracleId":1493,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param length indicates the length of the array.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"length","tokenClass":"MethodArgument","tokenInfo":["","int"]},{"id":33474,"label":false,"oracleId":1493,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param length indicates the length of the array.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33475,"label":true,"oracleId":1493,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param length indicates the length of the array.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33476,"label":false,"oracleId":1493,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param length indicates the length of the array.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33477,"label":false,"oracleId":1493,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"length","tokenClass":"MethodArgument","tokenInfo":["","int"]},{"id":33478,"label":false,"oracleId":1493,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33479,"label":true,"oracleId":1493,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33480,"label":false,"oracleId":1493,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33481,"label":false,"oracleId":1494,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a newly created {@code AtomicReferenceArray} with the given length","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"length","tokenClass":"MethodArgument","tokenInfo":["","int"]},{"id":33482,"label":false,"oracleId":1494,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a newly created {@code AtomicReferenceArray} with the given length","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33483,"label":false,"oracleId":1494,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a newly created {@code AtomicReferenceArray} with the given length","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33484,"label":true,"oracleId":1494,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a newly created {@code AtomicReferenceArray} with the given length","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33485,"label":false,"oracleId":1494,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a newly created {@code AtomicReferenceArray} with the given length","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33486,"label":false,"oracleId":1494,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return an uninitialized {@code AtomicReferenceArray} of the specified size","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"length","tokenClass":"MethodArgument","tokenInfo":["","int"]},{"id":33487,"label":false,"oracleId":1494,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return an uninitialized {@code AtomicReferenceArray} of the specified size","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33488,"label":false,"oracleId":1494,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return an uninitialized {@code AtomicReferenceArray} of the specified size","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33489,"label":true,"oracleId":1494,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return an uninitialized {@code AtomicReferenceArray} of the specified size","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33490,"label":false,"oracleId":1494,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return an uninitialized {@code AtomicReferenceArray} of the specified size","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33491,"label":false,"oracleId":1494,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"length","tokenClass":"MethodArgument","tokenInfo":["","int"]},{"id":33492,"label":false,"oracleId":1494,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33493,"label":false,"oracleId":1494,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33494,"label":true,"oracleId":1494,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33495,"label":false,"oracleId":1494,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33496,"label":false,"oracleId":1494,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a new {@code AtomicReferenceArray} of the specified length","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"length","tokenClass":"MethodArgument","tokenInfo":["","int"]},{"id":33497,"label":false,"oracleId":1494,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a new {@code AtomicReferenceArray} of the specified length","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33498,"label":false,"oracleId":1494,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a new {@code AtomicReferenceArray} of the specified length","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33499,"label":true,"oracleId":1494,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a new {@code AtomicReferenceArray} of the specified length","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33500,"label":false,"oracleId":1494,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a new {@code AtomicReferenceArray} of the specified length","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33501,"label":false,"oracleId":1495,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param array refers to the array to clone elements from","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"array","tokenClass":"MethodArgument","tokenInfo":["","E[]"]},{"id":33502,"label":false,"oracleId":1495,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param array refers to the array to clone elements from","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33503,"label":true,"oracleId":1495,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param array refers to the array to clone elements from","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33504,"label":false,"oracleId":1495,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param array refers to the array to clone elements from","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33505,"label":false,"oracleId":1495,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param array refers to the array to clone elements from","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"Arrays","tokenClass":"ArraysClass","tokenInfo":[]},{"id":33506,"label":false,"oracleId":1495,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param array the original array to replicate elements from.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"array","tokenClass":"MethodArgument","tokenInfo":["","E[]"]},{"id":33507,"label":false,"oracleId":1495,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param array the original array to replicate elements from.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33508,"label":true,"oracleId":1495,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param array the original array to replicate elements from.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33509,"label":false,"oracleId":1495,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param array the original array to replicate elements from.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33510,"label":false,"oracleId":1495,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param array the original array to replicate elements from.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"Arrays","tokenClass":"ArraysClass","tokenInfo":[]},{"id":33511,"label":false,"oracleId":1495,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"array","tokenClass":"MethodArgument","tokenInfo":["","E[]"]},{"id":33512,"label":false,"oracleId":1495,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33513,"label":true,"oracleId":1495,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33514,"label":false,"oracleId":1495,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33515,"label":false,"oracleId":1495,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"Arrays","tokenClass":"ArraysClass","tokenInfo":[]},{"id":33516,"label":false,"oracleId":1495,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param array the source array to duplicate elements","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"array","tokenClass":"MethodArgument","tokenInfo":["","E[]"]},{"id":33517,"label":false,"oracleId":1495,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param array the source array to duplicate elements","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33518,"label":true,"oracleId":1495,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param array the source array to duplicate elements","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33519,"label":false,"oracleId":1495,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param array the source array to duplicate elements","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33520,"label":false,"oracleId":1495,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param array the source array to duplicate elements","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"Arrays","tokenClass":"ArraysClass","tokenInfo":[]},{"id":33521,"label":false,"oracleId":1496,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a freshly created {@code AtomicReferenceArray} that is a replica of the given\narray.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"array","tokenClass":"MethodArgument","tokenInfo":["","E[]"]},{"id":33522,"label":false,"oracleId":1496,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a freshly created {@code AtomicReferenceArray} that is a replica of the given\narray.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33523,"label":false,"oracleId":1496,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a freshly created {@code AtomicReferenceArray} that is a replica of the given\narray.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33524,"label":true,"oracleId":1496,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a freshly created {@code AtomicReferenceArray} that is a replica of the given\narray.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33525,"label":false,"oracleId":1496,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a freshly created {@code AtomicReferenceArray} that is a replica of the given\narray.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33526,"label":false,"oracleId":1496,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a freshly created {@code AtomicReferenceArray} that is a replica of the given\narray.","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"Arrays","tokenClass":"ArraysClass","tokenInfo":[]},{"id":33527,"label":false,"oracleId":1496,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a new {@code AtomicReferenceArray} that is a copy of the provided array","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"array","tokenClass":"MethodArgument","tokenInfo":["","E[]"]},{"id":33528,"label":false,"oracleId":1496,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a new {@code AtomicReferenceArray} that is a copy of the provided array","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33529,"label":false,"oracleId":1496,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a new {@code AtomicReferenceArray} that is a copy of the provided array","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33530,"label":true,"oracleId":1496,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a new {@code AtomicReferenceArray} that is a copy of the provided array","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33531,"label":false,"oracleId":1496,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a new {@code AtomicReferenceArray} that is a copy of the provided array","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33532,"label":false,"oracleId":1496,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a new {@code AtomicReferenceArray} that is a copy of the provided array","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"Arrays","tokenClass":"ArraysClass","tokenInfo":[]},{"id":33533,"label":false,"oracleId":1496,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return an uninitialized {@code AtomicReferenceArray} that has been populated with\nelements from the provided array","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"array","tokenClass":"MethodArgument","tokenInfo":["","E[]"]},{"id":33534,"label":false,"oracleId":1496,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return an uninitialized {@code AtomicReferenceArray} that has been populated with\nelements from the provided array","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33535,"label":false,"oracleId":1496,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return an uninitialized {@code AtomicReferenceArray} that has been populated with\nelements from the provided array","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33536,"label":true,"oracleId":1496,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return an uninitialized {@code AtomicReferenceArray} that has been populated with\nelements from the provided array","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33537,"label":false,"oracleId":1496,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return an uninitialized {@code AtomicReferenceArray} that has been populated with\nelements from the provided array","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33538,"label":false,"oracleId":1496,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return an uninitialized {@code AtomicReferenceArray} that has been populated with\nelements from the provided array","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"Arrays","tokenClass":"ArraysClass","tokenInfo":[]},{"id":33539,"label":false,"oracleId":1496,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"array","tokenClass":"MethodArgument","tokenInfo":["","E[]"]},{"id":33540,"label":false,"oracleId":1496,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33541,"label":false,"oracleId":1496,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33542,"label":true,"oracleId":1496,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33543,"label":false,"oracleId":1496,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33544,"label":false,"oracleId":1496,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"Arrays","tokenClass":"ArraysClass","tokenInfo":[]},{"id":33545,"label":false,"oracleId":1497,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"WrappingExecutorService","javadocTag":"","methodJavadoc":"    /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */","methodSourceCode":"private final <T> ImmutableList<Callable<T>> wrapTasks(Collection<? extends Callable<T>> tasks){\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n        builder.add(wrapTask(task));\n    }\n    return builder.build();\n}","classJavadoc":"/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */","classSourceCode":"/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */\nabstract class WrappingExecutorService implements ExecutorService {\n  private final ExecutorService delegate;\n\n  protected WrappingExecutorService(ExecutorService delegate) {\n    this.delegate = checkNotNull(delegate);\n  }\n\n  /**\n   * Wraps a {@code Callable} for submission to the underlying executor. This\n   * method is also applied to any {@code Runnable} passed to the default\n   * implementation of {@link #wrapTask(Runnable)}.\n   */\n  protected abstract <T> Callable<T> wrapTask(Callable<T> callable);\n\n  /**\n   * Wraps a {@code Runnable} for submission to the underlying executor. The\n   * default implementation delegates to {@link #wrapTask(Callable)}.\n   */\n  protected Runnable wrapTask(Runnable command) {\n    final Callable<Object> wrapped = wrapTask(\n        Executors.callable(command, null));\n    return new Runnable() {\n      @Override public void run() {\n        try {\n          wrapped.call();\n        } catch (Exception e) {\n          Throwables.propagate(e);\n        }\n      }\n    };\n  }\n\n  /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */\n  private final <T> ImmutableList<Callable<T>> wrapTasks(\n      Collection<? extends Callable<T>> tasks) {\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n      builder.add(wrapTask(task));\n    }\n    return builder.build();\n  }\n\n  // These methods wrap before delegating.\n  @Override\n  public final void execute(Runnable command) {\n    delegate.execute(wrapTask(command));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Callable<T> task) {\n    return delegate.submit(wrapTask(checkNotNull(task)));\n  }\n\n  @Override\n  public final Future<?> submit(Runnable task) {\n    return delegate.submit(wrapTask(task));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Runnable task, T result) {\n    return delegate.submit(wrapTask(task), result);\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks) throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks), timeout, unit);\n  }\n\n  @Override\n  public final <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n      throws InterruptedException, ExecutionException {\n    return delegate.invokeAny(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> T invokeAny(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException, ExecutionException, TimeoutException {\n    return delegate.invokeAny(wrapTasks(tasks), timeout, unit);\n  }\n\n  // The remaining methods just delegate.\n\n  @Override\n  public final void shutdown() {\n    delegate.shutdown();\n  }\n\n  @Override\n  public final List<Runnable> shutdownNow() {\n    return delegate.shutdownNow();\n  }\n\n  @Override\n  public final boolean isShutdown() {\n    return delegate.isShutdown();\n  }\n\n  @Override\n  public final boolean isTerminated() {\n    return delegate.isTerminated();\n  }\n\n  @Override\n  public final boolean awaitTermination(long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.awaitTermination(timeout, unit);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"tasks","tokenClass":"MethodArgument","tokenInfo":["java.util","Collection"]},{"id":33546,"label":false,"oracleId":1497,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"WrappingExecutorService","javadocTag":"","methodJavadoc":"    /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */","methodSourceCode":"private final <T> ImmutableList<Callable<T>> wrapTasks(Collection<? extends Callable<T>> tasks){\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n        builder.add(wrapTask(task));\n    }\n    return builder.build();\n}","classJavadoc":"/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */","classSourceCode":"/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */\nabstract class WrappingExecutorService implements ExecutorService {\n  private final ExecutorService delegate;\n\n  protected WrappingExecutorService(ExecutorService delegate) {\n    this.delegate = checkNotNull(delegate);\n  }\n\n  /**\n   * Wraps a {@code Callable} for submission to the underlying executor. This\n   * method is also applied to any {@code Runnable} passed to the default\n   * implementation of {@link #wrapTask(Runnable)}.\n   */\n  protected abstract <T> Callable<T> wrapTask(Callable<T> callable);\n\n  /**\n   * Wraps a {@code Runnable} for submission to the underlying executor. The\n   * default implementation delegates to {@link #wrapTask(Callable)}.\n   */\n  protected Runnable wrapTask(Runnable command) {\n    final Callable<Object> wrapped = wrapTask(\n        Executors.callable(command, null));\n    return new Runnable() {\n      @Override public void run() {\n        try {\n          wrapped.call();\n        } catch (Exception e) {\n          Throwables.propagate(e);\n        }\n      }\n    };\n  }\n\n  /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */\n  private final <T> ImmutableList<Callable<T>> wrapTasks(\n      Collection<? extends Callable<T>> tasks) {\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n      builder.add(wrapTask(task));\n    }\n    return builder.build();\n  }\n\n  // These methods wrap before delegating.\n  @Override\n  public final void execute(Runnable command) {\n    delegate.execute(wrapTask(command));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Callable<T> task) {\n    return delegate.submit(wrapTask(checkNotNull(task)));\n  }\n\n  @Override\n  public final Future<?> submit(Runnable task) {\n    return delegate.submit(wrapTask(task));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Runnable task, T result) {\n    return delegate.submit(wrapTask(task), result);\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks) throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks), timeout, unit);\n  }\n\n  @Override\n  public final <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n      throws InterruptedException, ExecutionException {\n    return delegate.invokeAny(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> T invokeAny(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException, ExecutionException, TimeoutException {\n    return delegate.invokeAny(wrapTasks(tasks), timeout, unit);\n  }\n\n  // The remaining methods just delegate.\n\n  @Override\n  public final void shutdown() {\n    delegate.shutdown();\n  }\n\n  @Override\n  public final List<Runnable> shutdownNow() {\n    return delegate.shutdownNow();\n  }\n\n  @Override\n  public final boolean isShutdown() {\n    return delegate.isShutdown();\n  }\n\n  @Override\n  public final boolean isTerminated() {\n    return delegate.isTerminated();\n  }\n\n  @Override\n  public final boolean awaitTermination(long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.awaitTermination(timeout, unit);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33547,"label":false,"oracleId":1497,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"WrappingExecutorService","javadocTag":"","methodJavadoc":"    /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */","methodSourceCode":"private final <T> ImmutableList<Callable<T>> wrapTasks(Collection<? extends Callable<T>> tasks){\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n        builder.add(wrapTask(task));\n    }\n    return builder.build();\n}","classJavadoc":"/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */","classSourceCode":"/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */\nabstract class WrappingExecutorService implements ExecutorService {\n  private final ExecutorService delegate;\n\n  protected WrappingExecutorService(ExecutorService delegate) {\n    this.delegate = checkNotNull(delegate);\n  }\n\n  /**\n   * Wraps a {@code Callable} for submission to the underlying executor. This\n   * method is also applied to any {@code Runnable} passed to the default\n   * implementation of {@link #wrapTask(Runnable)}.\n   */\n  protected abstract <T> Callable<T> wrapTask(Callable<T> callable);\n\n  /**\n   * Wraps a {@code Runnable} for submission to the underlying executor. The\n   * default implementation delegates to {@link #wrapTask(Callable)}.\n   */\n  protected Runnable wrapTask(Runnable command) {\n    final Callable<Object> wrapped = wrapTask(\n        Executors.callable(command, null));\n    return new Runnable() {\n      @Override public void run() {\n        try {\n          wrapped.call();\n        } catch (Exception e) {\n          Throwables.propagate(e);\n        }\n      }\n    };\n  }\n\n  /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */\n  private final <T> ImmutableList<Callable<T>> wrapTasks(\n      Collection<? extends Callable<T>> tasks) {\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n      builder.add(wrapTask(task));\n    }\n    return builder.build();\n  }\n\n  // These methods wrap before delegating.\n  @Override\n  public final void execute(Runnable command) {\n    delegate.execute(wrapTask(command));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Callable<T> task) {\n    return delegate.submit(wrapTask(checkNotNull(task)));\n  }\n\n  @Override\n  public final Future<?> submit(Runnable task) {\n    return delegate.submit(wrapTask(task));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Runnable task, T result) {\n    return delegate.submit(wrapTask(task), result);\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks) throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks), timeout, unit);\n  }\n\n  @Override\n  public final <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n      throws InterruptedException, ExecutionException {\n    return delegate.invokeAny(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> T invokeAny(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException, ExecutionException, TimeoutException {\n    return delegate.invokeAny(wrapTasks(tasks), timeout, unit);\n  }\n\n  // The remaining methods just delegate.\n\n  @Override\n  public final void shutdown() {\n    delegate.shutdown();\n  }\n\n  @Override\n  public final List<Runnable> shutdownNow() {\n    return delegate.shutdownNow();\n  }\n\n  @Override\n  public final boolean isShutdown() {\n    return delegate.isShutdown();\n  }\n\n  @Override\n  public final boolean isTerminated() {\n    return delegate.isTerminated();\n  }\n\n  @Override\n  public final boolean awaitTermination(long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.awaitTermination(timeout, unit);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","WrappingExecutorService"]},{"id":33548,"label":false,"oracleId":1497,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"WrappingExecutorService","javadocTag":"","methodJavadoc":"    /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */","methodSourceCode":"private final <T> ImmutableList<Callable<T>> wrapTasks(Collection<? extends Callable<T>> tasks){\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n        builder.add(wrapTask(task));\n    }\n    return builder.build();\n}","classJavadoc":"/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */","classSourceCode":"/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */\nabstract class WrappingExecutorService implements ExecutorService {\n  private final ExecutorService delegate;\n\n  protected WrappingExecutorService(ExecutorService delegate) {\n    this.delegate = checkNotNull(delegate);\n  }\n\n  /**\n   * Wraps a {@code Callable} for submission to the underlying executor. This\n   * method is also applied to any {@code Runnable} passed to the default\n   * implementation of {@link #wrapTask(Runnable)}.\n   */\n  protected abstract <T> Callable<T> wrapTask(Callable<T> callable);\n\n  /**\n   * Wraps a {@code Runnable} for submission to the underlying executor. The\n   * default implementation delegates to {@link #wrapTask(Callable)}.\n   */\n  protected Runnable wrapTask(Runnable command) {\n    final Callable<Object> wrapped = wrapTask(\n        Executors.callable(command, null));\n    return new Runnable() {\n      @Override public void run() {\n        try {\n          wrapped.call();\n        } catch (Exception e) {\n          Throwables.propagate(e);\n        }\n      }\n    };\n  }\n\n  /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */\n  private final <T> ImmutableList<Callable<T>> wrapTasks(\n      Collection<? extends Callable<T>> tasks) {\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n      builder.add(wrapTask(task));\n    }\n    return builder.build();\n  }\n\n  // These methods wrap before delegating.\n  @Override\n  public final void execute(Runnable command) {\n    delegate.execute(wrapTask(command));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Callable<T> task) {\n    return delegate.submit(wrapTask(checkNotNull(task)));\n  }\n\n  @Override\n  public final Future<?> submit(Runnable task) {\n    return delegate.submit(wrapTask(task));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Runnable task, T result) {\n    return delegate.submit(wrapTask(task), result);\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks) throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks), timeout, unit);\n  }\n\n  @Override\n  public final <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n      throws InterruptedException, ExecutionException {\n    return delegate.invokeAny(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> T invokeAny(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException, ExecutionException, TimeoutException {\n    return delegate.invokeAny(wrapTasks(tasks), timeout, unit);\n  }\n\n  // The remaining methods just delegate.\n\n  @Override\n  public final void shutdown() {\n    delegate.shutdown();\n  }\n\n  @Override\n  public final List<Runnable> shutdownNow() {\n    return delegate.shutdownNow();\n  }\n\n  @Override\n  public final boolean isShutdown() {\n    return delegate.isShutdown();\n  }\n\n  @Override\n  public final boolean isTerminated() {\n    return delegate.isTerminated();\n  }\n\n  @Override\n  public final boolean awaitTermination(long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.awaitTermination(timeout, unit);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33549,"label":true,"oracleId":1497,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"WrappingExecutorService","javadocTag":"","methodJavadoc":"    /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */","methodSourceCode":"private final <T> ImmutableList<Callable<T>> wrapTasks(Collection<? extends Callable<T>> tasks){\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n        builder.add(wrapTask(task));\n    }\n    return builder.build();\n}","classJavadoc":"/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */","classSourceCode":"/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */\nabstract class WrappingExecutorService implements ExecutorService {\n  private final ExecutorService delegate;\n\n  protected WrappingExecutorService(ExecutorService delegate) {\n    this.delegate = checkNotNull(delegate);\n  }\n\n  /**\n   * Wraps a {@code Callable} for submission to the underlying executor. This\n   * method is also applied to any {@code Runnable} passed to the default\n   * implementation of {@link #wrapTask(Runnable)}.\n   */\n  protected abstract <T> Callable<T> wrapTask(Callable<T> callable);\n\n  /**\n   * Wraps a {@code Runnable} for submission to the underlying executor. The\n   * default implementation delegates to {@link #wrapTask(Callable)}.\n   */\n  protected Runnable wrapTask(Runnable command) {\n    final Callable<Object> wrapped = wrapTask(\n        Executors.callable(command, null));\n    return new Runnable() {\n      @Override public void run() {\n        try {\n          wrapped.call();\n        } catch (Exception e) {\n          Throwables.propagate(e);\n        }\n      }\n    };\n  }\n\n  /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */\n  private final <T> ImmutableList<Callable<T>> wrapTasks(\n      Collection<? extends Callable<T>> tasks) {\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n      builder.add(wrapTask(task));\n    }\n    return builder.build();\n  }\n\n  // These methods wrap before delegating.\n  @Override\n  public final void execute(Runnable command) {\n    delegate.execute(wrapTask(command));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Callable<T> task) {\n    return delegate.submit(wrapTask(checkNotNull(task)));\n  }\n\n  @Override\n  public final Future<?> submit(Runnable task) {\n    return delegate.submit(wrapTask(task));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Runnable task, T result) {\n    return delegate.submit(wrapTask(task), result);\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks) throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks), timeout, unit);\n  }\n\n  @Override\n  public final <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n      throws InterruptedException, ExecutionException {\n    return delegate.invokeAny(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> T invokeAny(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException, ExecutionException, TimeoutException {\n    return delegate.invokeAny(wrapTasks(tasks), timeout, unit);\n  }\n\n  // The remaining methods just delegate.\n\n  @Override\n  public final void shutdown() {\n    delegate.shutdown();\n  }\n\n  @Override\n  public final List<Runnable> shutdownNow() {\n    return delegate.shutdownNow();\n  }\n\n  @Override\n  public final boolean isShutdown() {\n    return delegate.isShutdown();\n  }\n\n  @Override\n  public final boolean isTerminated() {\n    return delegate.isTerminated();\n  }\n\n  @Override\n  public final boolean awaitTermination(long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.awaitTermination(timeout, unit);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33550,"label":false,"oracleId":1497,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"WrappingExecutorService","javadocTag":"","methodJavadoc":"    /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */","methodSourceCode":"private final <T> ImmutableList<Callable<T>> wrapTasks(Collection<? extends Callable<T>> tasks){\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n        builder.add(wrapTask(task));\n    }\n    return builder.build();\n}","classJavadoc":"/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */","classSourceCode":"/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */\nabstract class WrappingExecutorService implements ExecutorService {\n  private final ExecutorService delegate;\n\n  protected WrappingExecutorService(ExecutorService delegate) {\n    this.delegate = checkNotNull(delegate);\n  }\n\n  /**\n   * Wraps a {@code Callable} for submission to the underlying executor. This\n   * method is also applied to any {@code Runnable} passed to the default\n   * implementation of {@link #wrapTask(Runnable)}.\n   */\n  protected abstract <T> Callable<T> wrapTask(Callable<T> callable);\n\n  /**\n   * Wraps a {@code Runnable} for submission to the underlying executor. The\n   * default implementation delegates to {@link #wrapTask(Callable)}.\n   */\n  protected Runnable wrapTask(Runnable command) {\n    final Callable<Object> wrapped = wrapTask(\n        Executors.callable(command, null));\n    return new Runnable() {\n      @Override public void run() {\n        try {\n          wrapped.call();\n        } catch (Exception e) {\n          Throwables.propagate(e);\n        }\n      }\n    };\n  }\n\n  /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */\n  private final <T> ImmutableList<Callable<T>> wrapTasks(\n      Collection<? extends Callable<T>> tasks) {\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n      builder.add(wrapTask(task));\n    }\n    return builder.build();\n  }\n\n  // These methods wrap before delegating.\n  @Override\n  public final void execute(Runnable command) {\n    delegate.execute(wrapTask(command));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Callable<T> task) {\n    return delegate.submit(wrapTask(checkNotNull(task)));\n  }\n\n  @Override\n  public final Future<?> submit(Runnable task) {\n    return delegate.submit(wrapTask(task));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Runnable task, T result) {\n    return delegate.submit(wrapTask(task), result);\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks) throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks), timeout, unit);\n  }\n\n  @Override\n  public final <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n      throws InterruptedException, ExecutionException {\n    return delegate.invokeAny(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> T invokeAny(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException, ExecutionException, TimeoutException {\n    return delegate.invokeAny(wrapTasks(tasks), timeout, unit);\n  }\n\n  // The remaining methods just delegate.\n\n  @Override\n  public final void shutdown() {\n    delegate.shutdown();\n  }\n\n  @Override\n  public final List<Runnable> shutdownNow() {\n    return delegate.shutdownNow();\n  }\n\n  @Override\n  public final boolean isShutdown() {\n    return delegate.isShutdown();\n  }\n\n  @Override\n  public final boolean isTerminated() {\n    return delegate.isTerminated();\n  }\n\n  @Override\n  public final boolean awaitTermination(long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.awaitTermination(timeout, unit);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33551,"label":false,"oracleId":1497,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"WrappingExecutorService","javadocTag":"@throws NullPointerException if any element within {@code tasks} is null","methodJavadoc":"    /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */","methodSourceCode":"private final <T> ImmutableList<Callable<T>> wrapTasks(Collection<? extends Callable<T>> tasks){\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n        builder.add(wrapTask(task));\n    }\n    return builder.build();\n}","classJavadoc":"/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */","classSourceCode":"/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */\nabstract class WrappingExecutorService implements ExecutorService {\n  private final ExecutorService delegate;\n\n  protected WrappingExecutorService(ExecutorService delegate) {\n    this.delegate = checkNotNull(delegate);\n  }\n\n  /**\n   * Wraps a {@code Callable} for submission to the underlying executor. This\n   * method is also applied to any {@code Runnable} passed to the default\n   * implementation of {@link #wrapTask(Runnable)}.\n   */\n  protected abstract <T> Callable<T> wrapTask(Callable<T> callable);\n\n  /**\n   * Wraps a {@code Runnable} for submission to the underlying executor. The\n   * default implementation delegates to {@link #wrapTask(Callable)}.\n   */\n  protected Runnable wrapTask(Runnable command) {\n    final Callable<Object> wrapped = wrapTask(\n        Executors.callable(command, null));\n    return new Runnable() {\n      @Override public void run() {\n        try {\n          wrapped.call();\n        } catch (Exception e) {\n          Throwables.propagate(e);\n        }\n      }\n    };\n  }\n\n  /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */\n  private final <T> ImmutableList<Callable<T>> wrapTasks(\n      Collection<? extends Callable<T>> tasks) {\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n      builder.add(wrapTask(task));\n    }\n    return builder.build();\n  }\n\n  // These methods wrap before delegating.\n  @Override\n  public final void execute(Runnable command) {\n    delegate.execute(wrapTask(command));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Callable<T> task) {\n    return delegate.submit(wrapTask(checkNotNull(task)));\n  }\n\n  @Override\n  public final Future<?> submit(Runnable task) {\n    return delegate.submit(wrapTask(task));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Runnable task, T result) {\n    return delegate.submit(wrapTask(task), result);\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks) throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks), timeout, unit);\n  }\n\n  @Override\n  public final <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n      throws InterruptedException, ExecutionException {\n    return delegate.invokeAny(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> T invokeAny(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException, ExecutionException, TimeoutException {\n    return delegate.invokeAny(wrapTasks(tasks), timeout, unit);\n  }\n\n  // The remaining methods just delegate.\n\n  @Override\n  public final void shutdown() {\n    delegate.shutdown();\n  }\n\n  @Override\n  public final List<Runnable> shutdownNow() {\n    return delegate.shutdownNow();\n  }\n\n  @Override\n  public final boolean isShutdown() {\n    return delegate.isShutdown();\n  }\n\n  @Override\n  public final boolean isTerminated() {\n    return delegate.isTerminated();\n  }\n\n  @Override\n  public final boolean awaitTermination(long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.awaitTermination(timeout, unit);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"tasks","tokenClass":"MethodArgument","tokenInfo":["java.util","Collection"]},{"id":33552,"label":false,"oracleId":1497,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"WrappingExecutorService","javadocTag":"@throws NullPointerException if any element within {@code tasks} is null","methodJavadoc":"    /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */","methodSourceCode":"private final <T> ImmutableList<Callable<T>> wrapTasks(Collection<? extends Callable<T>> tasks){\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n        builder.add(wrapTask(task));\n    }\n    return builder.build();\n}","classJavadoc":"/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */","classSourceCode":"/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */\nabstract class WrappingExecutorService implements ExecutorService {\n  private final ExecutorService delegate;\n\n  protected WrappingExecutorService(ExecutorService delegate) {\n    this.delegate = checkNotNull(delegate);\n  }\n\n  /**\n   * Wraps a {@code Callable} for submission to the underlying executor. This\n   * method is also applied to any {@code Runnable} passed to the default\n   * implementation of {@link #wrapTask(Runnable)}.\n   */\n  protected abstract <T> Callable<T> wrapTask(Callable<T> callable);\n\n  /**\n   * Wraps a {@code Runnable} for submission to the underlying executor. The\n   * default implementation delegates to {@link #wrapTask(Callable)}.\n   */\n  protected Runnable wrapTask(Runnable command) {\n    final Callable<Object> wrapped = wrapTask(\n        Executors.callable(command, null));\n    return new Runnable() {\n      @Override public void run() {\n        try {\n          wrapped.call();\n        } catch (Exception e) {\n          Throwables.propagate(e);\n        }\n      }\n    };\n  }\n\n  /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */\n  private final <T> ImmutableList<Callable<T>> wrapTasks(\n      Collection<? extends Callable<T>> tasks) {\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n      builder.add(wrapTask(task));\n    }\n    return builder.build();\n  }\n\n  // These methods wrap before delegating.\n  @Override\n  public final void execute(Runnable command) {\n    delegate.execute(wrapTask(command));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Callable<T> task) {\n    return delegate.submit(wrapTask(checkNotNull(task)));\n  }\n\n  @Override\n  public final Future<?> submit(Runnable task) {\n    return delegate.submit(wrapTask(task));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Runnable task, T result) {\n    return delegate.submit(wrapTask(task), result);\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks) throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks), timeout, unit);\n  }\n\n  @Override\n  public final <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n      throws InterruptedException, ExecutionException {\n    return delegate.invokeAny(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> T invokeAny(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException, ExecutionException, TimeoutException {\n    return delegate.invokeAny(wrapTasks(tasks), timeout, unit);\n  }\n\n  // The remaining methods just delegate.\n\n  @Override\n  public final void shutdown() {\n    delegate.shutdown();\n  }\n\n  @Override\n  public final List<Runnable> shutdownNow() {\n    return delegate.shutdownNow();\n  }\n\n  @Override\n  public final boolean isShutdown() {\n    return delegate.isShutdown();\n  }\n\n  @Override\n  public final boolean isTerminated() {\n    return delegate.isTerminated();\n  }\n\n  @Override\n  public final boolean awaitTermination(long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.awaitTermination(timeout, unit);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33553,"label":false,"oracleId":1497,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"WrappingExecutorService","javadocTag":"@throws NullPointerException if any element within {@code tasks} is null","methodJavadoc":"    /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */","methodSourceCode":"private final <T> ImmutableList<Callable<T>> wrapTasks(Collection<? extends Callable<T>> tasks){\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n        builder.add(wrapTask(task));\n    }\n    return builder.build();\n}","classJavadoc":"/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */","classSourceCode":"/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */\nabstract class WrappingExecutorService implements ExecutorService {\n  private final ExecutorService delegate;\n\n  protected WrappingExecutorService(ExecutorService delegate) {\n    this.delegate = checkNotNull(delegate);\n  }\n\n  /**\n   * Wraps a {@code Callable} for submission to the underlying executor. This\n   * method is also applied to any {@code Runnable} passed to the default\n   * implementation of {@link #wrapTask(Runnable)}.\n   */\n  protected abstract <T> Callable<T> wrapTask(Callable<T> callable);\n\n  /**\n   * Wraps a {@code Runnable} for submission to the underlying executor. The\n   * default implementation delegates to {@link #wrapTask(Callable)}.\n   */\n  protected Runnable wrapTask(Runnable command) {\n    final Callable<Object> wrapped = wrapTask(\n        Executors.callable(command, null));\n    return new Runnable() {\n      @Override public void run() {\n        try {\n          wrapped.call();\n        } catch (Exception e) {\n          Throwables.propagate(e);\n        }\n      }\n    };\n  }\n\n  /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */\n  private final <T> ImmutableList<Callable<T>> wrapTasks(\n      Collection<? extends Callable<T>> tasks) {\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n      builder.add(wrapTask(task));\n    }\n    return builder.build();\n  }\n\n  // These methods wrap before delegating.\n  @Override\n  public final void execute(Runnable command) {\n    delegate.execute(wrapTask(command));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Callable<T> task) {\n    return delegate.submit(wrapTask(checkNotNull(task)));\n  }\n\n  @Override\n  public final Future<?> submit(Runnable task) {\n    return delegate.submit(wrapTask(task));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Runnable task, T result) {\n    return delegate.submit(wrapTask(task), result);\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks) throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks), timeout, unit);\n  }\n\n  @Override\n  public final <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n      throws InterruptedException, ExecutionException {\n    return delegate.invokeAny(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> T invokeAny(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException, ExecutionException, TimeoutException {\n    return delegate.invokeAny(wrapTasks(tasks), timeout, unit);\n  }\n\n  // The remaining methods just delegate.\n\n  @Override\n  public final void shutdown() {\n    delegate.shutdown();\n  }\n\n  @Override\n  public final List<Runnable> shutdownNow() {\n    return delegate.shutdownNow();\n  }\n\n  @Override\n  public final boolean isShutdown() {\n    return delegate.isShutdown();\n  }\n\n  @Override\n  public final boolean isTerminated() {\n    return delegate.isTerminated();\n  }\n\n  @Override\n  public final boolean awaitTermination(long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.awaitTermination(timeout, unit);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","WrappingExecutorService"]},{"id":33554,"label":false,"oracleId":1497,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"WrappingExecutorService","javadocTag":"@throws NullPointerException if any element within {@code tasks} is null","methodJavadoc":"    /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */","methodSourceCode":"private final <T> ImmutableList<Callable<T>> wrapTasks(Collection<? extends Callable<T>> tasks){\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n        builder.add(wrapTask(task));\n    }\n    return builder.build();\n}","classJavadoc":"/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */","classSourceCode":"/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */\nabstract class WrappingExecutorService implements ExecutorService {\n  private final ExecutorService delegate;\n\n  protected WrappingExecutorService(ExecutorService delegate) {\n    this.delegate = checkNotNull(delegate);\n  }\n\n  /**\n   * Wraps a {@code Callable} for submission to the underlying executor. This\n   * method is also applied to any {@code Runnable} passed to the default\n   * implementation of {@link #wrapTask(Runnable)}.\n   */\n  protected abstract <T> Callable<T> wrapTask(Callable<T> callable);\n\n  /**\n   * Wraps a {@code Runnable} for submission to the underlying executor. The\n   * default implementation delegates to {@link #wrapTask(Callable)}.\n   */\n  protected Runnable wrapTask(Runnable command) {\n    final Callable<Object> wrapped = wrapTask(\n        Executors.callable(command, null));\n    return new Runnable() {\n      @Override public void run() {\n        try {\n          wrapped.call();\n        } catch (Exception e) {\n          Throwables.propagate(e);\n        }\n      }\n    };\n  }\n\n  /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */\n  private final <T> ImmutableList<Callable<T>> wrapTasks(\n      Collection<? extends Callable<T>> tasks) {\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n      builder.add(wrapTask(task));\n    }\n    return builder.build();\n  }\n\n  // These methods wrap before delegating.\n  @Override\n  public final void execute(Runnable command) {\n    delegate.execute(wrapTask(command));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Callable<T> task) {\n    return delegate.submit(wrapTask(checkNotNull(task)));\n  }\n\n  @Override\n  public final Future<?> submit(Runnable task) {\n    return delegate.submit(wrapTask(task));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Runnable task, T result) {\n    return delegate.submit(wrapTask(task), result);\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks) throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks), timeout, unit);\n  }\n\n  @Override\n  public final <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n      throws InterruptedException, ExecutionException {\n    return delegate.invokeAny(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> T invokeAny(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException, ExecutionException, TimeoutException {\n    return delegate.invokeAny(wrapTasks(tasks), timeout, unit);\n  }\n\n  // The remaining methods just delegate.\n\n  @Override\n  public final void shutdown() {\n    delegate.shutdown();\n  }\n\n  @Override\n  public final List<Runnable> shutdownNow() {\n    return delegate.shutdownNow();\n  }\n\n  @Override\n  public final boolean isShutdown() {\n    return delegate.isShutdown();\n  }\n\n  @Override\n  public final boolean isTerminated() {\n    return delegate.isTerminated();\n  }\n\n  @Override\n  public final boolean awaitTermination(long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.awaitTermination(timeout, unit);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33555,"label":true,"oracleId":1497,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"WrappingExecutorService","javadocTag":"@throws NullPointerException if any element within {@code tasks} is null","methodJavadoc":"    /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */","methodSourceCode":"private final <T> ImmutableList<Callable<T>> wrapTasks(Collection<? extends Callable<T>> tasks){\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n        builder.add(wrapTask(task));\n    }\n    return builder.build();\n}","classJavadoc":"/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */","classSourceCode":"/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */\nabstract class WrappingExecutorService implements ExecutorService {\n  private final ExecutorService delegate;\n\n  protected WrappingExecutorService(ExecutorService delegate) {\n    this.delegate = checkNotNull(delegate);\n  }\n\n  /**\n   * Wraps a {@code Callable} for submission to the underlying executor. This\n   * method is also applied to any {@code Runnable} passed to the default\n   * implementation of {@link #wrapTask(Runnable)}.\n   */\n  protected abstract <T> Callable<T> wrapTask(Callable<T> callable);\n\n  /**\n   * Wraps a {@code Runnable} for submission to the underlying executor. The\n   * default implementation delegates to {@link #wrapTask(Callable)}.\n   */\n  protected Runnable wrapTask(Runnable command) {\n    final Callable<Object> wrapped = wrapTask(\n        Executors.callable(command, null));\n    return new Runnable() {\n      @Override public void run() {\n        try {\n          wrapped.call();\n        } catch (Exception e) {\n          Throwables.propagate(e);\n        }\n      }\n    };\n  }\n\n  /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */\n  private final <T> ImmutableList<Callable<T>> wrapTasks(\n      Collection<? extends Callable<T>> tasks) {\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n      builder.add(wrapTask(task));\n    }\n    return builder.build();\n  }\n\n  // These methods wrap before delegating.\n  @Override\n  public final void execute(Runnable command) {\n    delegate.execute(wrapTask(command));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Callable<T> task) {\n    return delegate.submit(wrapTask(checkNotNull(task)));\n  }\n\n  @Override\n  public final Future<?> submit(Runnable task) {\n    return delegate.submit(wrapTask(task));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Runnable task, T result) {\n    return delegate.submit(wrapTask(task), result);\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks) throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks), timeout, unit);\n  }\n\n  @Override\n  public final <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n      throws InterruptedException, ExecutionException {\n    return delegate.invokeAny(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> T invokeAny(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException, ExecutionException, TimeoutException {\n    return delegate.invokeAny(wrapTasks(tasks), timeout, unit);\n  }\n\n  // The remaining methods just delegate.\n\n  @Override\n  public final void shutdown() {\n    delegate.shutdown();\n  }\n\n  @Override\n  public final List<Runnable> shutdownNow() {\n    return delegate.shutdownNow();\n  }\n\n  @Override\n  public final boolean isShutdown() {\n    return delegate.isShutdown();\n  }\n\n  @Override\n  public final boolean isTerminated() {\n    return delegate.isTerminated();\n  }\n\n  @Override\n  public final boolean awaitTermination(long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.awaitTermination(timeout, unit);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33556,"label":false,"oracleId":1497,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"WrappingExecutorService","javadocTag":"@throws NullPointerException if any element within {@code tasks} is null","methodJavadoc":"    /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */","methodSourceCode":"private final <T> ImmutableList<Callable<T>> wrapTasks(Collection<? extends Callable<T>> tasks){\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n        builder.add(wrapTask(task));\n    }\n    return builder.build();\n}","classJavadoc":"/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */","classSourceCode":"/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */\nabstract class WrappingExecutorService implements ExecutorService {\n  private final ExecutorService delegate;\n\n  protected WrappingExecutorService(ExecutorService delegate) {\n    this.delegate = checkNotNull(delegate);\n  }\n\n  /**\n   * Wraps a {@code Callable} for submission to the underlying executor. This\n   * method is also applied to any {@code Runnable} passed to the default\n   * implementation of {@link #wrapTask(Runnable)}.\n   */\n  protected abstract <T> Callable<T> wrapTask(Callable<T> callable);\n\n  /**\n   * Wraps a {@code Runnable} for submission to the underlying executor. The\n   * default implementation delegates to {@link #wrapTask(Callable)}.\n   */\n  protected Runnable wrapTask(Runnable command) {\n    final Callable<Object> wrapped = wrapTask(\n        Executors.callable(command, null));\n    return new Runnable() {\n      @Override public void run() {\n        try {\n          wrapped.call();\n        } catch (Exception e) {\n          Throwables.propagate(e);\n        }\n      }\n    };\n  }\n\n  /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */\n  private final <T> ImmutableList<Callable<T>> wrapTasks(\n      Collection<? extends Callable<T>> tasks) {\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n      builder.add(wrapTask(task));\n    }\n    return builder.build();\n  }\n\n  // These methods wrap before delegating.\n  @Override\n  public final void execute(Runnable command) {\n    delegate.execute(wrapTask(command));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Callable<T> task) {\n    return delegate.submit(wrapTask(checkNotNull(task)));\n  }\n\n  @Override\n  public final Future<?> submit(Runnable task) {\n    return delegate.submit(wrapTask(task));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Runnable task, T result) {\n    return delegate.submit(wrapTask(task), result);\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks) throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks), timeout, unit);\n  }\n\n  @Override\n  public final <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n      throws InterruptedException, ExecutionException {\n    return delegate.invokeAny(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> T invokeAny(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException, ExecutionException, TimeoutException {\n    return delegate.invokeAny(wrapTasks(tasks), timeout, unit);\n  }\n\n  // The remaining methods just delegate.\n\n  @Override\n  public final void shutdown() {\n    delegate.shutdown();\n  }\n\n  @Override\n  public final List<Runnable> shutdownNow() {\n    return delegate.shutdownNow();\n  }\n\n  @Override\n  public final boolean isShutdown() {\n    return delegate.isShutdown();\n  }\n\n  @Override\n  public final boolean isTerminated() {\n    return delegate.isTerminated();\n  }\n\n  @Override\n  public final boolean awaitTermination(long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.awaitTermination(timeout, unit);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33557,"label":false,"oracleId":1497,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"WrappingExecutorService","javadocTag":"@throws NullPointerException if there is a null element in the {@code tasks} array","methodJavadoc":"    /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */","methodSourceCode":"private final <T> ImmutableList<Callable<T>> wrapTasks(Collection<? extends Callable<T>> tasks){\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n        builder.add(wrapTask(task));\n    }\n    return builder.build();\n}","classJavadoc":"/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */","classSourceCode":"/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */\nabstract class WrappingExecutorService implements ExecutorService {\n  private final ExecutorService delegate;\n\n  protected WrappingExecutorService(ExecutorService delegate) {\n    this.delegate = checkNotNull(delegate);\n  }\n\n  /**\n   * Wraps a {@code Callable} for submission to the underlying executor. This\n   * method is also applied to any {@code Runnable} passed to the default\n   * implementation of {@link #wrapTask(Runnable)}.\n   */\n  protected abstract <T> Callable<T> wrapTask(Callable<T> callable);\n\n  /**\n   * Wraps a {@code Runnable} for submission to the underlying executor. The\n   * default implementation delegates to {@link #wrapTask(Callable)}.\n   */\n  protected Runnable wrapTask(Runnable command) {\n    final Callable<Object> wrapped = wrapTask(\n        Executors.callable(command, null));\n    return new Runnable() {\n      @Override public void run() {\n        try {\n          wrapped.call();\n        } catch (Exception e) {\n          Throwables.propagate(e);\n        }\n      }\n    };\n  }\n\n  /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */\n  private final <T> ImmutableList<Callable<T>> wrapTasks(\n      Collection<? extends Callable<T>> tasks) {\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n      builder.add(wrapTask(task));\n    }\n    return builder.build();\n  }\n\n  // These methods wrap before delegating.\n  @Override\n  public final void execute(Runnable command) {\n    delegate.execute(wrapTask(command));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Callable<T> task) {\n    return delegate.submit(wrapTask(checkNotNull(task)));\n  }\n\n  @Override\n  public final Future<?> submit(Runnable task) {\n    return delegate.submit(wrapTask(task));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Runnable task, T result) {\n    return delegate.submit(wrapTask(task), result);\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks) throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks), timeout, unit);\n  }\n\n  @Override\n  public final <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n      throws InterruptedException, ExecutionException {\n    return delegate.invokeAny(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> T invokeAny(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException, ExecutionException, TimeoutException {\n    return delegate.invokeAny(wrapTasks(tasks), timeout, unit);\n  }\n\n  // The remaining methods just delegate.\n\n  @Override\n  public final void shutdown() {\n    delegate.shutdown();\n  }\n\n  @Override\n  public final List<Runnable> shutdownNow() {\n    return delegate.shutdownNow();\n  }\n\n  @Override\n  public final boolean isShutdown() {\n    return delegate.isShutdown();\n  }\n\n  @Override\n  public final boolean isTerminated() {\n    return delegate.isTerminated();\n  }\n\n  @Override\n  public final boolean awaitTermination(long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.awaitTermination(timeout, unit);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"tasks","tokenClass":"MethodArgument","tokenInfo":["java.util","Collection"]},{"id":33558,"label":false,"oracleId":1497,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"WrappingExecutorService","javadocTag":"@throws NullPointerException if there is a null element in the {@code tasks} array","methodJavadoc":"    /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */","methodSourceCode":"private final <T> ImmutableList<Callable<T>> wrapTasks(Collection<? extends Callable<T>> tasks){\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n        builder.add(wrapTask(task));\n    }\n    return builder.build();\n}","classJavadoc":"/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */","classSourceCode":"/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */\nabstract class WrappingExecutorService implements ExecutorService {\n  private final ExecutorService delegate;\n\n  protected WrappingExecutorService(ExecutorService delegate) {\n    this.delegate = checkNotNull(delegate);\n  }\n\n  /**\n   * Wraps a {@code Callable} for submission to the underlying executor. This\n   * method is also applied to any {@code Runnable} passed to the default\n   * implementation of {@link #wrapTask(Runnable)}.\n   */\n  protected abstract <T> Callable<T> wrapTask(Callable<T> callable);\n\n  /**\n   * Wraps a {@code Runnable} for submission to the underlying executor. The\n   * default implementation delegates to {@link #wrapTask(Callable)}.\n   */\n  protected Runnable wrapTask(Runnable command) {\n    final Callable<Object> wrapped = wrapTask(\n        Executors.callable(command, null));\n    return new Runnable() {\n      @Override public void run() {\n        try {\n          wrapped.call();\n        } catch (Exception e) {\n          Throwables.propagate(e);\n        }\n      }\n    };\n  }\n\n  /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */\n  private final <T> ImmutableList<Callable<T>> wrapTasks(\n      Collection<? extends Callable<T>> tasks) {\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n      builder.add(wrapTask(task));\n    }\n    return builder.build();\n  }\n\n  // These methods wrap before delegating.\n  @Override\n  public final void execute(Runnable command) {\n    delegate.execute(wrapTask(command));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Callable<T> task) {\n    return delegate.submit(wrapTask(checkNotNull(task)));\n  }\n\n  @Override\n  public final Future<?> submit(Runnable task) {\n    return delegate.submit(wrapTask(task));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Runnable task, T result) {\n    return delegate.submit(wrapTask(task), result);\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks) throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks), timeout, unit);\n  }\n\n  @Override\n  public final <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n      throws InterruptedException, ExecutionException {\n    return delegate.invokeAny(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> T invokeAny(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException, ExecutionException, TimeoutException {\n    return delegate.invokeAny(wrapTasks(tasks), timeout, unit);\n  }\n\n  // The remaining methods just delegate.\n\n  @Override\n  public final void shutdown() {\n    delegate.shutdown();\n  }\n\n  @Override\n  public final List<Runnable> shutdownNow() {\n    return delegate.shutdownNow();\n  }\n\n  @Override\n  public final boolean isShutdown() {\n    return delegate.isShutdown();\n  }\n\n  @Override\n  public final boolean isTerminated() {\n    return delegate.isTerminated();\n  }\n\n  @Override\n  public final boolean awaitTermination(long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.awaitTermination(timeout, unit);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33559,"label":false,"oracleId":1497,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"WrappingExecutorService","javadocTag":"@throws NullPointerException if there is a null element in the {@code tasks} array","methodJavadoc":"    /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */","methodSourceCode":"private final <T> ImmutableList<Callable<T>> wrapTasks(Collection<? extends Callable<T>> tasks){\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n        builder.add(wrapTask(task));\n    }\n    return builder.build();\n}","classJavadoc":"/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */","classSourceCode":"/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */\nabstract class WrappingExecutorService implements ExecutorService {\n  private final ExecutorService delegate;\n\n  protected WrappingExecutorService(ExecutorService delegate) {\n    this.delegate = checkNotNull(delegate);\n  }\n\n  /**\n   * Wraps a {@code Callable} for submission to the underlying executor. This\n   * method is also applied to any {@code Runnable} passed to the default\n   * implementation of {@link #wrapTask(Runnable)}.\n   */\n  protected abstract <T> Callable<T> wrapTask(Callable<T> callable);\n\n  /**\n   * Wraps a {@code Runnable} for submission to the underlying executor. The\n   * default implementation delegates to {@link #wrapTask(Callable)}.\n   */\n  protected Runnable wrapTask(Runnable command) {\n    final Callable<Object> wrapped = wrapTask(\n        Executors.callable(command, null));\n    return new Runnable() {\n      @Override public void run() {\n        try {\n          wrapped.call();\n        } catch (Exception e) {\n          Throwables.propagate(e);\n        }\n      }\n    };\n  }\n\n  /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */\n  private final <T> ImmutableList<Callable<T>> wrapTasks(\n      Collection<? extends Callable<T>> tasks) {\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n      builder.add(wrapTask(task));\n    }\n    return builder.build();\n  }\n\n  // These methods wrap before delegating.\n  @Override\n  public final void execute(Runnable command) {\n    delegate.execute(wrapTask(command));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Callable<T> task) {\n    return delegate.submit(wrapTask(checkNotNull(task)));\n  }\n\n  @Override\n  public final Future<?> submit(Runnable task) {\n    return delegate.submit(wrapTask(task));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Runnable task, T result) {\n    return delegate.submit(wrapTask(task), result);\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks) throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks), timeout, unit);\n  }\n\n  @Override\n  public final <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n      throws InterruptedException, ExecutionException {\n    return delegate.invokeAny(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> T invokeAny(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException, ExecutionException, TimeoutException {\n    return delegate.invokeAny(wrapTasks(tasks), timeout, unit);\n  }\n\n  // The remaining methods just delegate.\n\n  @Override\n  public final void shutdown() {\n    delegate.shutdown();\n  }\n\n  @Override\n  public final List<Runnable> shutdownNow() {\n    return delegate.shutdownNow();\n  }\n\n  @Override\n  public final boolean isShutdown() {\n    return delegate.isShutdown();\n  }\n\n  @Override\n  public final boolean isTerminated() {\n    return delegate.isTerminated();\n  }\n\n  @Override\n  public final boolean awaitTermination(long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.awaitTermination(timeout, unit);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","WrappingExecutorService"]},{"id":33560,"label":false,"oracleId":1497,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"WrappingExecutorService","javadocTag":"@throws NullPointerException if there is a null element in the {@code tasks} array","methodJavadoc":"    /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */","methodSourceCode":"private final <T> ImmutableList<Callable<T>> wrapTasks(Collection<? extends Callable<T>> tasks){\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n        builder.add(wrapTask(task));\n    }\n    return builder.build();\n}","classJavadoc":"/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */","classSourceCode":"/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */\nabstract class WrappingExecutorService implements ExecutorService {\n  private final ExecutorService delegate;\n\n  protected WrappingExecutorService(ExecutorService delegate) {\n    this.delegate = checkNotNull(delegate);\n  }\n\n  /**\n   * Wraps a {@code Callable} for submission to the underlying executor. This\n   * method is also applied to any {@code Runnable} passed to the default\n   * implementation of {@link #wrapTask(Runnable)}.\n   */\n  protected abstract <T> Callable<T> wrapTask(Callable<T> callable);\n\n  /**\n   * Wraps a {@code Runnable} for submission to the underlying executor. The\n   * default implementation delegates to {@link #wrapTask(Callable)}.\n   */\n  protected Runnable wrapTask(Runnable command) {\n    final Callable<Object> wrapped = wrapTask(\n        Executors.callable(command, null));\n    return new Runnable() {\n      @Override public void run() {\n        try {\n          wrapped.call();\n        } catch (Exception e) {\n          Throwables.propagate(e);\n        }\n      }\n    };\n  }\n\n  /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */\n  private final <T> ImmutableList<Callable<T>> wrapTasks(\n      Collection<? extends Callable<T>> tasks) {\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n      builder.add(wrapTask(task));\n    }\n    return builder.build();\n  }\n\n  // These methods wrap before delegating.\n  @Override\n  public final void execute(Runnable command) {\n    delegate.execute(wrapTask(command));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Callable<T> task) {\n    return delegate.submit(wrapTask(checkNotNull(task)));\n  }\n\n  @Override\n  public final Future<?> submit(Runnable task) {\n    return delegate.submit(wrapTask(task));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Runnable task, T result) {\n    return delegate.submit(wrapTask(task), result);\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks) throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks), timeout, unit);\n  }\n\n  @Override\n  public final <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n      throws InterruptedException, ExecutionException {\n    return delegate.invokeAny(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> T invokeAny(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException, ExecutionException, TimeoutException {\n    return delegate.invokeAny(wrapTasks(tasks), timeout, unit);\n  }\n\n  // The remaining methods just delegate.\n\n  @Override\n  public final void shutdown() {\n    delegate.shutdown();\n  }\n\n  @Override\n  public final List<Runnable> shutdownNow() {\n    return delegate.shutdownNow();\n  }\n\n  @Override\n  public final boolean isShutdown() {\n    return delegate.isShutdown();\n  }\n\n  @Override\n  public final boolean isTerminated() {\n    return delegate.isTerminated();\n  }\n\n  @Override\n  public final boolean awaitTermination(long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.awaitTermination(timeout, unit);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33561,"label":true,"oracleId":1497,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"WrappingExecutorService","javadocTag":"@throws NullPointerException if there is a null element in the {@code tasks} array","methodJavadoc":"    /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */","methodSourceCode":"private final <T> ImmutableList<Callable<T>> wrapTasks(Collection<? extends Callable<T>> tasks){\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n        builder.add(wrapTask(task));\n    }\n    return builder.build();\n}","classJavadoc":"/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */","classSourceCode":"/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */\nabstract class WrappingExecutorService implements ExecutorService {\n  private final ExecutorService delegate;\n\n  protected WrappingExecutorService(ExecutorService delegate) {\n    this.delegate = checkNotNull(delegate);\n  }\n\n  /**\n   * Wraps a {@code Callable} for submission to the underlying executor. This\n   * method is also applied to any {@code Runnable} passed to the default\n   * implementation of {@link #wrapTask(Runnable)}.\n   */\n  protected abstract <T> Callable<T> wrapTask(Callable<T> callable);\n\n  /**\n   * Wraps a {@code Runnable} for submission to the underlying executor. The\n   * default implementation delegates to {@link #wrapTask(Callable)}.\n   */\n  protected Runnable wrapTask(Runnable command) {\n    final Callable<Object> wrapped = wrapTask(\n        Executors.callable(command, null));\n    return new Runnable() {\n      @Override public void run() {\n        try {\n          wrapped.call();\n        } catch (Exception e) {\n          Throwables.propagate(e);\n        }\n      }\n    };\n  }\n\n  /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */\n  private final <T> ImmutableList<Callable<T>> wrapTasks(\n      Collection<? extends Callable<T>> tasks) {\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n      builder.add(wrapTask(task));\n    }\n    return builder.build();\n  }\n\n  // These methods wrap before delegating.\n  @Override\n  public final void execute(Runnable command) {\n    delegate.execute(wrapTask(command));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Callable<T> task) {\n    return delegate.submit(wrapTask(checkNotNull(task)));\n  }\n\n  @Override\n  public final Future<?> submit(Runnable task) {\n    return delegate.submit(wrapTask(task));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Runnable task, T result) {\n    return delegate.submit(wrapTask(task), result);\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks) throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks), timeout, unit);\n  }\n\n  @Override\n  public final <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n      throws InterruptedException, ExecutionException {\n    return delegate.invokeAny(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> T invokeAny(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException, ExecutionException, TimeoutException {\n    return delegate.invokeAny(wrapTasks(tasks), timeout, unit);\n  }\n\n  // The remaining methods just delegate.\n\n  @Override\n  public final void shutdown() {\n    delegate.shutdown();\n  }\n\n  @Override\n  public final List<Runnable> shutdownNow() {\n    return delegate.shutdownNow();\n  }\n\n  @Override\n  public final boolean isShutdown() {\n    return delegate.isShutdown();\n  }\n\n  @Override\n  public final boolean isTerminated() {\n    return delegate.isTerminated();\n  }\n\n  @Override\n  public final boolean awaitTermination(long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.awaitTermination(timeout, unit);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33562,"label":false,"oracleId":1497,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"WrappingExecutorService","javadocTag":"@throws NullPointerException if there is a null element in the {@code tasks} array","methodJavadoc":"    /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */","methodSourceCode":"private final <T> ImmutableList<Callable<T>> wrapTasks(Collection<? extends Callable<T>> tasks){\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n        builder.add(wrapTask(task));\n    }\n    return builder.build();\n}","classJavadoc":"/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */","classSourceCode":"/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */\nabstract class WrappingExecutorService implements ExecutorService {\n  private final ExecutorService delegate;\n\n  protected WrappingExecutorService(ExecutorService delegate) {\n    this.delegate = checkNotNull(delegate);\n  }\n\n  /**\n   * Wraps a {@code Callable} for submission to the underlying executor. This\n   * method is also applied to any {@code Runnable} passed to the default\n   * implementation of {@link #wrapTask(Runnable)}.\n   */\n  protected abstract <T> Callable<T> wrapTask(Callable<T> callable);\n\n  /**\n   * Wraps a {@code Runnable} for submission to the underlying executor. The\n   * default implementation delegates to {@link #wrapTask(Callable)}.\n   */\n  protected Runnable wrapTask(Runnable command) {\n    final Callable<Object> wrapped = wrapTask(\n        Executors.callable(command, null));\n    return new Runnable() {\n      @Override public void run() {\n        try {\n          wrapped.call();\n        } catch (Exception e) {\n          Throwables.propagate(e);\n        }\n      }\n    };\n  }\n\n  /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */\n  private final <T> ImmutableList<Callable<T>> wrapTasks(\n      Collection<? extends Callable<T>> tasks) {\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n      builder.add(wrapTask(task));\n    }\n    return builder.build();\n  }\n\n  // These methods wrap before delegating.\n  @Override\n  public final void execute(Runnable command) {\n    delegate.execute(wrapTask(command));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Callable<T> task) {\n    return delegate.submit(wrapTask(checkNotNull(task)));\n  }\n\n  @Override\n  public final Future<?> submit(Runnable task) {\n    return delegate.submit(wrapTask(task));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Runnable task, T result) {\n    return delegate.submit(wrapTask(task), result);\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks) throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks), timeout, unit);\n  }\n\n  @Override\n  public final <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n      throws InterruptedException, ExecutionException {\n    return delegate.invokeAny(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> T invokeAny(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException, ExecutionException, TimeoutException {\n    return delegate.invokeAny(wrapTasks(tasks), timeout, unit);\n  }\n\n  // The remaining methods just delegate.\n\n  @Override\n  public final void shutdown() {\n    delegate.shutdown();\n  }\n\n  @Override\n  public final List<Runnable> shutdownNow() {\n    return delegate.shutdownNow();\n  }\n\n  @Override\n  public final boolean isShutdown() {\n    return delegate.isShutdown();\n  }\n\n  @Override\n  public final boolean isTerminated() {\n    return delegate.isTerminated();\n  }\n\n  @Override\n  public final boolean awaitTermination(long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.awaitTermination(timeout, unit);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33563,"label":false,"oracleId":1497,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"WrappingExecutorService","javadocTag":"@throws NullPointerException if any task element is null inside the {@code tasks}\narray","methodJavadoc":"    /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */","methodSourceCode":"private final <T> ImmutableList<Callable<T>> wrapTasks(Collection<? extends Callable<T>> tasks){\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n        builder.add(wrapTask(task));\n    }\n    return builder.build();\n}","classJavadoc":"/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */","classSourceCode":"/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */\nabstract class WrappingExecutorService implements ExecutorService {\n  private final ExecutorService delegate;\n\n  protected WrappingExecutorService(ExecutorService delegate) {\n    this.delegate = checkNotNull(delegate);\n  }\n\n  /**\n   * Wraps a {@code Callable} for submission to the underlying executor. This\n   * method is also applied to any {@code Runnable} passed to the default\n   * implementation of {@link #wrapTask(Runnable)}.\n   */\n  protected abstract <T> Callable<T> wrapTask(Callable<T> callable);\n\n  /**\n   * Wraps a {@code Runnable} for submission to the underlying executor. The\n   * default implementation delegates to {@link #wrapTask(Callable)}.\n   */\n  protected Runnable wrapTask(Runnable command) {\n    final Callable<Object> wrapped = wrapTask(\n        Executors.callable(command, null));\n    return new Runnable() {\n      @Override public void run() {\n        try {\n          wrapped.call();\n        } catch (Exception e) {\n          Throwables.propagate(e);\n        }\n      }\n    };\n  }\n\n  /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */\n  private final <T> ImmutableList<Callable<T>> wrapTasks(\n      Collection<? extends Callable<T>> tasks) {\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n      builder.add(wrapTask(task));\n    }\n    return builder.build();\n  }\n\n  // These methods wrap before delegating.\n  @Override\n  public final void execute(Runnable command) {\n    delegate.execute(wrapTask(command));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Callable<T> task) {\n    return delegate.submit(wrapTask(checkNotNull(task)));\n  }\n\n  @Override\n  public final Future<?> submit(Runnable task) {\n    return delegate.submit(wrapTask(task));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Runnable task, T result) {\n    return delegate.submit(wrapTask(task), result);\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks) throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks), timeout, unit);\n  }\n\n  @Override\n  public final <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n      throws InterruptedException, ExecutionException {\n    return delegate.invokeAny(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> T invokeAny(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException, ExecutionException, TimeoutException {\n    return delegate.invokeAny(wrapTasks(tasks), timeout, unit);\n  }\n\n  // The remaining methods just delegate.\n\n  @Override\n  public final void shutdown() {\n    delegate.shutdown();\n  }\n\n  @Override\n  public final List<Runnable> shutdownNow() {\n    return delegate.shutdownNow();\n  }\n\n  @Override\n  public final boolean isShutdown() {\n    return delegate.isShutdown();\n  }\n\n  @Override\n  public final boolean isTerminated() {\n    return delegate.isTerminated();\n  }\n\n  @Override\n  public final boolean awaitTermination(long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.awaitTermination(timeout, unit);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"tasks","tokenClass":"MethodArgument","tokenInfo":["java.util","Collection"]},{"id":33564,"label":false,"oracleId":1497,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"WrappingExecutorService","javadocTag":"@throws NullPointerException if any task element is null inside the {@code tasks}\narray","methodJavadoc":"    /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */","methodSourceCode":"private final <T> ImmutableList<Callable<T>> wrapTasks(Collection<? extends Callable<T>> tasks){\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n        builder.add(wrapTask(task));\n    }\n    return builder.build();\n}","classJavadoc":"/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */","classSourceCode":"/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */\nabstract class WrappingExecutorService implements ExecutorService {\n  private final ExecutorService delegate;\n\n  protected WrappingExecutorService(ExecutorService delegate) {\n    this.delegate = checkNotNull(delegate);\n  }\n\n  /**\n   * Wraps a {@code Callable} for submission to the underlying executor. This\n   * method is also applied to any {@code Runnable} passed to the default\n   * implementation of {@link #wrapTask(Runnable)}.\n   */\n  protected abstract <T> Callable<T> wrapTask(Callable<T> callable);\n\n  /**\n   * Wraps a {@code Runnable} for submission to the underlying executor. The\n   * default implementation delegates to {@link #wrapTask(Callable)}.\n   */\n  protected Runnable wrapTask(Runnable command) {\n    final Callable<Object> wrapped = wrapTask(\n        Executors.callable(command, null));\n    return new Runnable() {\n      @Override public void run() {\n        try {\n          wrapped.call();\n        } catch (Exception e) {\n          Throwables.propagate(e);\n        }\n      }\n    };\n  }\n\n  /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */\n  private final <T> ImmutableList<Callable<T>> wrapTasks(\n      Collection<? extends Callable<T>> tasks) {\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n      builder.add(wrapTask(task));\n    }\n    return builder.build();\n  }\n\n  // These methods wrap before delegating.\n  @Override\n  public final void execute(Runnable command) {\n    delegate.execute(wrapTask(command));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Callable<T> task) {\n    return delegate.submit(wrapTask(checkNotNull(task)));\n  }\n\n  @Override\n  public final Future<?> submit(Runnable task) {\n    return delegate.submit(wrapTask(task));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Runnable task, T result) {\n    return delegate.submit(wrapTask(task), result);\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks) throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks), timeout, unit);\n  }\n\n  @Override\n  public final <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n      throws InterruptedException, ExecutionException {\n    return delegate.invokeAny(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> T invokeAny(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException, ExecutionException, TimeoutException {\n    return delegate.invokeAny(wrapTasks(tasks), timeout, unit);\n  }\n\n  // The remaining methods just delegate.\n\n  @Override\n  public final void shutdown() {\n    delegate.shutdown();\n  }\n\n  @Override\n  public final List<Runnable> shutdownNow() {\n    return delegate.shutdownNow();\n  }\n\n  @Override\n  public final boolean isShutdown() {\n    return delegate.isShutdown();\n  }\n\n  @Override\n  public final boolean isTerminated() {\n    return delegate.isTerminated();\n  }\n\n  @Override\n  public final boolean awaitTermination(long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.awaitTermination(timeout, unit);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33565,"label":false,"oracleId":1497,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"WrappingExecutorService","javadocTag":"@throws NullPointerException if any task element is null inside the {@code tasks}\narray","methodJavadoc":"    /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */","methodSourceCode":"private final <T> ImmutableList<Callable<T>> wrapTasks(Collection<? extends Callable<T>> tasks){\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n        builder.add(wrapTask(task));\n    }\n    return builder.build();\n}","classJavadoc":"/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */","classSourceCode":"/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */\nabstract class WrappingExecutorService implements ExecutorService {\n  private final ExecutorService delegate;\n\n  protected WrappingExecutorService(ExecutorService delegate) {\n    this.delegate = checkNotNull(delegate);\n  }\n\n  /**\n   * Wraps a {@code Callable} for submission to the underlying executor. This\n   * method is also applied to any {@code Runnable} passed to the default\n   * implementation of {@link #wrapTask(Runnable)}.\n   */\n  protected abstract <T> Callable<T> wrapTask(Callable<T> callable);\n\n  /**\n   * Wraps a {@code Runnable} for submission to the underlying executor. The\n   * default implementation delegates to {@link #wrapTask(Callable)}.\n   */\n  protected Runnable wrapTask(Runnable command) {\n    final Callable<Object> wrapped = wrapTask(\n        Executors.callable(command, null));\n    return new Runnable() {\n      @Override public void run() {\n        try {\n          wrapped.call();\n        } catch (Exception e) {\n          Throwables.propagate(e);\n        }\n      }\n    };\n  }\n\n  /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */\n  private final <T> ImmutableList<Callable<T>> wrapTasks(\n      Collection<? extends Callable<T>> tasks) {\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n      builder.add(wrapTask(task));\n    }\n    return builder.build();\n  }\n\n  // These methods wrap before delegating.\n  @Override\n  public final void execute(Runnable command) {\n    delegate.execute(wrapTask(command));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Callable<T> task) {\n    return delegate.submit(wrapTask(checkNotNull(task)));\n  }\n\n  @Override\n  public final Future<?> submit(Runnable task) {\n    return delegate.submit(wrapTask(task));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Runnable task, T result) {\n    return delegate.submit(wrapTask(task), result);\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks) throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks), timeout, unit);\n  }\n\n  @Override\n  public final <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n      throws InterruptedException, ExecutionException {\n    return delegate.invokeAny(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> T invokeAny(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException, ExecutionException, TimeoutException {\n    return delegate.invokeAny(wrapTasks(tasks), timeout, unit);\n  }\n\n  // The remaining methods just delegate.\n\n  @Override\n  public final void shutdown() {\n    delegate.shutdown();\n  }\n\n  @Override\n  public final List<Runnable> shutdownNow() {\n    return delegate.shutdownNow();\n  }\n\n  @Override\n  public final boolean isShutdown() {\n    return delegate.isShutdown();\n  }\n\n  @Override\n  public final boolean isTerminated() {\n    return delegate.isTerminated();\n  }\n\n  @Override\n  public final boolean awaitTermination(long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.awaitTermination(timeout, unit);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","WrappingExecutorService"]},{"id":33566,"label":false,"oracleId":1497,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"WrappingExecutorService","javadocTag":"@throws NullPointerException if any task element is null inside the {@code tasks}\narray","methodJavadoc":"    /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */","methodSourceCode":"private final <T> ImmutableList<Callable<T>> wrapTasks(Collection<? extends Callable<T>> tasks){\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n        builder.add(wrapTask(task));\n    }\n    return builder.build();\n}","classJavadoc":"/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */","classSourceCode":"/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */\nabstract class WrappingExecutorService implements ExecutorService {\n  private final ExecutorService delegate;\n\n  protected WrappingExecutorService(ExecutorService delegate) {\n    this.delegate = checkNotNull(delegate);\n  }\n\n  /**\n   * Wraps a {@code Callable} for submission to the underlying executor. This\n   * method is also applied to any {@code Runnable} passed to the default\n   * implementation of {@link #wrapTask(Runnable)}.\n   */\n  protected abstract <T> Callable<T> wrapTask(Callable<T> callable);\n\n  /**\n   * Wraps a {@code Runnable} for submission to the underlying executor. The\n   * default implementation delegates to {@link #wrapTask(Callable)}.\n   */\n  protected Runnable wrapTask(Runnable command) {\n    final Callable<Object> wrapped = wrapTask(\n        Executors.callable(command, null));\n    return new Runnable() {\n      @Override public void run() {\n        try {\n          wrapped.call();\n        } catch (Exception e) {\n          Throwables.propagate(e);\n        }\n      }\n    };\n  }\n\n  /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */\n  private final <T> ImmutableList<Callable<T>> wrapTasks(\n      Collection<? extends Callable<T>> tasks) {\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n      builder.add(wrapTask(task));\n    }\n    return builder.build();\n  }\n\n  // These methods wrap before delegating.\n  @Override\n  public final void execute(Runnable command) {\n    delegate.execute(wrapTask(command));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Callable<T> task) {\n    return delegate.submit(wrapTask(checkNotNull(task)));\n  }\n\n  @Override\n  public final Future<?> submit(Runnable task) {\n    return delegate.submit(wrapTask(task));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Runnable task, T result) {\n    return delegate.submit(wrapTask(task), result);\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks) throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks), timeout, unit);\n  }\n\n  @Override\n  public final <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n      throws InterruptedException, ExecutionException {\n    return delegate.invokeAny(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> T invokeAny(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException, ExecutionException, TimeoutException {\n    return delegate.invokeAny(wrapTasks(tasks), timeout, unit);\n  }\n\n  // The remaining methods just delegate.\n\n  @Override\n  public final void shutdown() {\n    delegate.shutdown();\n  }\n\n  @Override\n  public final List<Runnable> shutdownNow() {\n    return delegate.shutdownNow();\n  }\n\n  @Override\n  public final boolean isShutdown() {\n    return delegate.isShutdown();\n  }\n\n  @Override\n  public final boolean isTerminated() {\n    return delegate.isTerminated();\n  }\n\n  @Override\n  public final boolean awaitTermination(long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.awaitTermination(timeout, unit);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33567,"label":true,"oracleId":1497,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"WrappingExecutorService","javadocTag":"@throws NullPointerException if any task element is null inside the {@code tasks}\narray","methodJavadoc":"    /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */","methodSourceCode":"private final <T> ImmutableList<Callable<T>> wrapTasks(Collection<? extends Callable<T>> tasks){\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n        builder.add(wrapTask(task));\n    }\n    return builder.build();\n}","classJavadoc":"/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */","classSourceCode":"/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */\nabstract class WrappingExecutorService implements ExecutorService {\n  private final ExecutorService delegate;\n\n  protected WrappingExecutorService(ExecutorService delegate) {\n    this.delegate = checkNotNull(delegate);\n  }\n\n  /**\n   * Wraps a {@code Callable} for submission to the underlying executor. This\n   * method is also applied to any {@code Runnable} passed to the default\n   * implementation of {@link #wrapTask(Runnable)}.\n   */\n  protected abstract <T> Callable<T> wrapTask(Callable<T> callable);\n\n  /**\n   * Wraps a {@code Runnable} for submission to the underlying executor. The\n   * default implementation delegates to {@link #wrapTask(Callable)}.\n   */\n  protected Runnable wrapTask(Runnable command) {\n    final Callable<Object> wrapped = wrapTask(\n        Executors.callable(command, null));\n    return new Runnable() {\n      @Override public void run() {\n        try {\n          wrapped.call();\n        } catch (Exception e) {\n          Throwables.propagate(e);\n        }\n      }\n    };\n  }\n\n  /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */\n  private final <T> ImmutableList<Callable<T>> wrapTasks(\n      Collection<? extends Callable<T>> tasks) {\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n      builder.add(wrapTask(task));\n    }\n    return builder.build();\n  }\n\n  // These methods wrap before delegating.\n  @Override\n  public final void execute(Runnable command) {\n    delegate.execute(wrapTask(command));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Callable<T> task) {\n    return delegate.submit(wrapTask(checkNotNull(task)));\n  }\n\n  @Override\n  public final Future<?> submit(Runnable task) {\n    return delegate.submit(wrapTask(task));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Runnable task, T result) {\n    return delegate.submit(wrapTask(task), result);\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks) throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks), timeout, unit);\n  }\n\n  @Override\n  public final <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n      throws InterruptedException, ExecutionException {\n    return delegate.invokeAny(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> T invokeAny(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException, ExecutionException, TimeoutException {\n    return delegate.invokeAny(wrapTasks(tasks), timeout, unit);\n  }\n\n  // The remaining methods just delegate.\n\n  @Override\n  public final void shutdown() {\n    delegate.shutdown();\n  }\n\n  @Override\n  public final List<Runnable> shutdownNow() {\n    return delegate.shutdownNow();\n  }\n\n  @Override\n  public final boolean isShutdown() {\n    return delegate.isShutdown();\n  }\n\n  @Override\n  public final boolean isTerminated() {\n    return delegate.isTerminated();\n  }\n\n  @Override\n  public final boolean awaitTermination(long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.awaitTermination(timeout, unit);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33568,"label":false,"oracleId":1497,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"WrappingExecutorService","javadocTag":"@throws NullPointerException if any task element is null inside the {@code tasks}\narray","methodJavadoc":"    /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */","methodSourceCode":"private final <T> ImmutableList<Callable<T>> wrapTasks(Collection<? extends Callable<T>> tasks){\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n        builder.add(wrapTask(task));\n    }\n    return builder.build();\n}","classJavadoc":"/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */","classSourceCode":"/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */\nabstract class WrappingExecutorService implements ExecutorService {\n  private final ExecutorService delegate;\n\n  protected WrappingExecutorService(ExecutorService delegate) {\n    this.delegate = checkNotNull(delegate);\n  }\n\n  /**\n   * Wraps a {@code Callable} for submission to the underlying executor. This\n   * method is also applied to any {@code Runnable} passed to the default\n   * implementation of {@link #wrapTask(Runnable)}.\n   */\n  protected abstract <T> Callable<T> wrapTask(Callable<T> callable);\n\n  /**\n   * Wraps a {@code Runnable} for submission to the underlying executor. The\n   * default implementation delegates to {@link #wrapTask(Callable)}.\n   */\n  protected Runnable wrapTask(Runnable command) {\n    final Callable<Object> wrapped = wrapTask(\n        Executors.callable(command, null));\n    return new Runnable() {\n      @Override public void run() {\n        try {\n          wrapped.call();\n        } catch (Exception e) {\n          Throwables.propagate(e);\n        }\n      }\n    };\n  }\n\n  /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */\n  private final <T> ImmutableList<Callable<T>> wrapTasks(\n      Collection<? extends Callable<T>> tasks) {\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n      builder.add(wrapTask(task));\n    }\n    return builder.build();\n  }\n\n  // These methods wrap before delegating.\n  @Override\n  public final void execute(Runnable command) {\n    delegate.execute(wrapTask(command));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Callable<T> task) {\n    return delegate.submit(wrapTask(checkNotNull(task)));\n  }\n\n  @Override\n  public final Future<?> submit(Runnable task) {\n    return delegate.submit(wrapTask(task));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Runnable task, T result) {\n    return delegate.submit(wrapTask(task), result);\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks) throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks), timeout, unit);\n  }\n\n  @Override\n  public final <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n      throws InterruptedException, ExecutionException {\n    return delegate.invokeAny(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> T invokeAny(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException, ExecutionException, TimeoutException {\n    return delegate.invokeAny(wrapTasks(tasks), timeout, unit);\n  }\n\n  // The remaining methods just delegate.\n\n  @Override\n  public final void shutdown() {\n    delegate.shutdown();\n  }\n\n  @Override\n  public final List<Runnable> shutdownNow() {\n    return delegate.shutdownNow();\n  }\n\n  @Override\n  public final boolean isShutdown() {\n    return delegate.isShutdown();\n  }\n\n  @Override\n  public final boolean isTerminated() {\n    return delegate.isTerminated();\n  }\n\n  @Override\n  public final boolean awaitTermination(long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.awaitTermination(timeout, unit);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33569,"label":false,"oracleId":1498,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"SerializingExecutor","javadocTag":"@throws java.lang.IllegalStateException if this executor is not in a suspended state.","methodJavadoc":"    /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */","methodSourceCode":"public void resume(){\n    synchronized (internalLock) {\n        Preconditions.checkState(suspensions > 0);\n        suspensions--;\n    }\n    startQueueWorker();\n}","classJavadoc":"/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.concurrent.Executor;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */\nfinal class SerializingExecutor implements Executor {\n  private static final Logger log =\n      Logger.getLogger(SerializingExecutor.class.getName());\n\n  /** Underlying executor that all submitted Runnable objects are run on. */\n  private final Executor executor;\n\n  @GuardedBy(\"internalLock\")\n  private final Deque<Runnable> queue = new ArrayDeque<Runnable>();\n  @GuardedBy(\"internalLock\")\n  private boolean isWorkerRunning = false;\n  @GuardedBy(\"internalLock\")\n  private int suspensions = 0;\n\n  private final Object internalLock = new Object();\n\n  public SerializingExecutor(Executor executor) {\n    this.executor = Preconditions.checkNotNull(executor);\n  }\n\n  /**\n   * Adds a task to the queue and makes sure a worker thread is running, unless the queue has been\n   * suspended.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #resume()} is\n   * made.\n   */\n  public void execute(Runnable task) {\n    synchronized (internalLock) {\n      queue.add(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Prepends a task to the front of the queue and makes sure a worker thread is running, unless the\n   * queue has been suspended.\n   */\n  public void executeFirst(Runnable task) {\n    synchronized (internalLock) {\n      queue.addFirst(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Suspends the running of tasks until {@link #resume()} is called. This can be called multiple\n   * times to increase the suspensions count and execution will not continue until {@link #resume}\n   * has been called the same number of times as {@code suspend} has been.\n   *\n   * <p>Any task that has already been pulled off the queue for execution will be completed\n   * before execution is suspended.\n   */\n  public void suspend() {\n    synchronized (internalLock) {\n      suspensions++;\n    }\n  }\n\n  /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */\n  public void resume() {\n    synchronized (internalLock) {\n      Preconditions.checkState(suspensions > 0);\n      suspensions--;\n    }\n    startQueueWorker();\n  }\n\n  private void startQueueWorker() {\n    synchronized (internalLock) {\n      // We sometimes try to start a queue worker without knowing if there is any work to do.\n      if (queue.peek() == null) {\n        return;\n      }\n      if (suspensions > 0) {\n        return;\n      }\n      if (isWorkerRunning) {\n        return;\n      }\n      isWorkerRunning = true;\n    }\n    boolean executionRejected = true;\n    try {\n      executor.execute(new QueueWorker());\n      executionRejected = false;\n    } finally {\n      if (executionRejected) {\n        // The best we can do is to stop executing the queue, but reset the state so that\n        // execution can be resumed later if the caller so wishes.\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n      }\n    }\n  }\n\n  /**\n   * Worker that runs tasks off the queue until it is empty or the queue is suspended.\n   */\n  private final class QueueWorker implements Runnable {\n    @Override\n    public void run() {\n      try {\n        workOnQueue();\n      } catch (Error e) {\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n        throw e;\n        // The execution of a task has ended abnormally.\n        // We could have tasks left in the queue, so should perhaps try to restart a worker,\n        // but then the Error will get delayed if we are using a direct (same thread) executor.\n      }\n    }\n\n    private void workOnQueue() {\n      while (true) {\n        Runnable task = null;\n        synchronized (internalLock) {\n          // TODO(user): How should we handle interrupts and shutdowns?\n          if (suspensions == 0) {\n            task = queue.poll();\n          }\n          if (task == null) {\n            isWorkerRunning = false;\n            return;\n          }\n        }\n        try {\n          task.run();\n        } catch (RuntimeException e) {\n          log.log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n        }\n      }\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33570,"label":false,"oracleId":1498,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"SerializingExecutor","javadocTag":"@throws java.lang.IllegalStateException if this executor is not in a suspended state.","methodJavadoc":"    /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */","methodSourceCode":"public void resume(){\n    synchronized (internalLock) {\n        Preconditions.checkState(suspensions > 0);\n        suspensions--;\n    }\n    startQueueWorker();\n}","classJavadoc":"/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.concurrent.Executor;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */\nfinal class SerializingExecutor implements Executor {\n  private static final Logger log =\n      Logger.getLogger(SerializingExecutor.class.getName());\n\n  /** Underlying executor that all submitted Runnable objects are run on. */\n  private final Executor executor;\n\n  @GuardedBy(\"internalLock\")\n  private final Deque<Runnable> queue = new ArrayDeque<Runnable>();\n  @GuardedBy(\"internalLock\")\n  private boolean isWorkerRunning = false;\n  @GuardedBy(\"internalLock\")\n  private int suspensions = 0;\n\n  private final Object internalLock = new Object();\n\n  public SerializingExecutor(Executor executor) {\n    this.executor = Preconditions.checkNotNull(executor);\n  }\n\n  /**\n   * Adds a task to the queue and makes sure a worker thread is running, unless the queue has been\n   * suspended.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #resume()} is\n   * made.\n   */\n  public void execute(Runnable task) {\n    synchronized (internalLock) {\n      queue.add(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Prepends a task to the front of the queue and makes sure a worker thread is running, unless the\n   * queue has been suspended.\n   */\n  public void executeFirst(Runnable task) {\n    synchronized (internalLock) {\n      queue.addFirst(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Suspends the running of tasks until {@link #resume()} is called. This can be called multiple\n   * times to increase the suspensions count and execution will not continue until {@link #resume}\n   * has been called the same number of times as {@code suspend} has been.\n   *\n   * <p>Any task that has already been pulled off the queue for execution will be completed\n   * before execution is suspended.\n   */\n  public void suspend() {\n    synchronized (internalLock) {\n      suspensions++;\n    }\n  }\n\n  /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */\n  public void resume() {\n    synchronized (internalLock) {\n      Preconditions.checkState(suspensions > 0);\n      suspensions--;\n    }\n    startQueueWorker();\n  }\n\n  private void startQueueWorker() {\n    synchronized (internalLock) {\n      // We sometimes try to start a queue worker without knowing if there is any work to do.\n      if (queue.peek() == null) {\n        return;\n      }\n      if (suspensions > 0) {\n        return;\n      }\n      if (isWorkerRunning) {\n        return;\n      }\n      isWorkerRunning = true;\n    }\n    boolean executionRejected = true;\n    try {\n      executor.execute(new QueueWorker());\n      executionRejected = false;\n    } finally {\n      if (executionRejected) {\n        // The best we can do is to stop executing the queue, but reset the state so that\n        // execution can be resumed later if the caller so wishes.\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n      }\n    }\n  }\n\n  /**\n   * Worker that runs tasks off the queue until it is empty or the queue is suspended.\n   */\n  private final class QueueWorker implements Runnable {\n    @Override\n    public void run() {\n      try {\n        workOnQueue();\n      } catch (Error e) {\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n        throw e;\n        // The execution of a task has ended abnormally.\n        // We could have tasks left in the queue, so should perhaps try to restart a worker,\n        // but then the Error will get delayed if we are using a direct (same thread) executor.\n      }\n    }\n\n    private void workOnQueue() {\n      while (true) {\n        Runnable task = null;\n        synchronized (internalLock) {\n          // TODO(user): How should we handle interrupts and shutdowns?\n          if (suspensions == 0) {\n            task = queue.poll();\n          }\n          if (task == null) {\n            isWorkerRunning = false;\n            return;\n          }\n        }\n        try {\n          task.run();\n        } catch (RuntimeException e) {\n          log.log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n        }\n      }\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","SerializingExecutor"]},{"id":33571,"label":false,"oracleId":1498,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"SerializingExecutor","javadocTag":"@throws java.lang.IllegalStateException if this executor is not in a suspended state.","methodJavadoc":"    /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */","methodSourceCode":"public void resume(){\n    synchronized (internalLock) {\n        Preconditions.checkState(suspensions > 0);\n        suspensions--;\n    }\n    startQueueWorker();\n}","classJavadoc":"/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.concurrent.Executor;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */\nfinal class SerializingExecutor implements Executor {\n  private static final Logger log =\n      Logger.getLogger(SerializingExecutor.class.getName());\n\n  /** Underlying executor that all submitted Runnable objects are run on. */\n  private final Executor executor;\n\n  @GuardedBy(\"internalLock\")\n  private final Deque<Runnable> queue = new ArrayDeque<Runnable>();\n  @GuardedBy(\"internalLock\")\n  private boolean isWorkerRunning = false;\n  @GuardedBy(\"internalLock\")\n  private int suspensions = 0;\n\n  private final Object internalLock = new Object();\n\n  public SerializingExecutor(Executor executor) {\n    this.executor = Preconditions.checkNotNull(executor);\n  }\n\n  /**\n   * Adds a task to the queue and makes sure a worker thread is running, unless the queue has been\n   * suspended.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #resume()} is\n   * made.\n   */\n  public void execute(Runnable task) {\n    synchronized (internalLock) {\n      queue.add(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Prepends a task to the front of the queue and makes sure a worker thread is running, unless the\n   * queue has been suspended.\n   */\n  public void executeFirst(Runnable task) {\n    synchronized (internalLock) {\n      queue.addFirst(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Suspends the running of tasks until {@link #resume()} is called. This can be called multiple\n   * times to increase the suspensions count and execution will not continue until {@link #resume}\n   * has been called the same number of times as {@code suspend} has been.\n   *\n   * <p>Any task that has already been pulled off the queue for execution will be completed\n   * before execution is suspended.\n   */\n  public void suspend() {\n    synchronized (internalLock) {\n      suspensions++;\n    }\n  }\n\n  /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */\n  public void resume() {\n    synchronized (internalLock) {\n      Preconditions.checkState(suspensions > 0);\n      suspensions--;\n    }\n    startQueueWorker();\n  }\n\n  private void startQueueWorker() {\n    synchronized (internalLock) {\n      // We sometimes try to start a queue worker without knowing if there is any work to do.\n      if (queue.peek() == null) {\n        return;\n      }\n      if (suspensions > 0) {\n        return;\n      }\n      if (isWorkerRunning) {\n        return;\n      }\n      isWorkerRunning = true;\n    }\n    boolean executionRejected = true;\n    try {\n      executor.execute(new QueueWorker());\n      executionRejected = false;\n    } finally {\n      if (executionRejected) {\n        // The best we can do is to stop executing the queue, but reset the state so that\n        // execution can be resumed later if the caller so wishes.\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n      }\n    }\n  }\n\n  /**\n   * Worker that runs tasks off the queue until it is empty or the queue is suspended.\n   */\n  private final class QueueWorker implements Runnable {\n    @Override\n    public void run() {\n      try {\n        workOnQueue();\n      } catch (Error e) {\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n        throw e;\n        // The execution of a task has ended abnormally.\n        // We could have tasks left in the queue, so should perhaps try to restart a worker,\n        // but then the Error will get delayed if we are using a direct (same thread) executor.\n      }\n    }\n\n    private void workOnQueue() {\n      while (true) {\n        Runnable task = null;\n        synchronized (internalLock) {\n          // TODO(user): How should we handle interrupts and shutdowns?\n          if (suspensions == 0) {\n            task = queue.poll();\n          }\n          if (task == null) {\n            isWorkerRunning = false;\n            return;\n          }\n        }\n        try {\n          task.run();\n        } catch (RuntimeException e) {\n          log.log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n        }\n      }\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33572,"label":true,"oracleId":1498,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"SerializingExecutor","javadocTag":"@throws java.lang.IllegalStateException if this executor is not in a suspended state.","methodJavadoc":"    /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */","methodSourceCode":"public void resume(){\n    synchronized (internalLock) {\n        Preconditions.checkState(suspensions > 0);\n        suspensions--;\n    }\n    startQueueWorker();\n}","classJavadoc":"/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.concurrent.Executor;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */\nfinal class SerializingExecutor implements Executor {\n  private static final Logger log =\n      Logger.getLogger(SerializingExecutor.class.getName());\n\n  /** Underlying executor that all submitted Runnable objects are run on. */\n  private final Executor executor;\n\n  @GuardedBy(\"internalLock\")\n  private final Deque<Runnable> queue = new ArrayDeque<Runnable>();\n  @GuardedBy(\"internalLock\")\n  private boolean isWorkerRunning = false;\n  @GuardedBy(\"internalLock\")\n  private int suspensions = 0;\n\n  private final Object internalLock = new Object();\n\n  public SerializingExecutor(Executor executor) {\n    this.executor = Preconditions.checkNotNull(executor);\n  }\n\n  /**\n   * Adds a task to the queue and makes sure a worker thread is running, unless the queue has been\n   * suspended.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #resume()} is\n   * made.\n   */\n  public void execute(Runnable task) {\n    synchronized (internalLock) {\n      queue.add(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Prepends a task to the front of the queue and makes sure a worker thread is running, unless the\n   * queue has been suspended.\n   */\n  public void executeFirst(Runnable task) {\n    synchronized (internalLock) {\n      queue.addFirst(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Suspends the running of tasks until {@link #resume()} is called. This can be called multiple\n   * times to increase the suspensions count and execution will not continue until {@link #resume}\n   * has been called the same number of times as {@code suspend} has been.\n   *\n   * <p>Any task that has already been pulled off the queue for execution will be completed\n   * before execution is suspended.\n   */\n  public void suspend() {\n    synchronized (internalLock) {\n      suspensions++;\n    }\n  }\n\n  /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */\n  public void resume() {\n    synchronized (internalLock) {\n      Preconditions.checkState(suspensions > 0);\n      suspensions--;\n    }\n    startQueueWorker();\n  }\n\n  private void startQueueWorker() {\n    synchronized (internalLock) {\n      // We sometimes try to start a queue worker without knowing if there is any work to do.\n      if (queue.peek() == null) {\n        return;\n      }\n      if (suspensions > 0) {\n        return;\n      }\n      if (isWorkerRunning) {\n        return;\n      }\n      isWorkerRunning = true;\n    }\n    boolean executionRejected = true;\n    try {\n      executor.execute(new QueueWorker());\n      executionRejected = false;\n    } finally {\n      if (executionRejected) {\n        // The best we can do is to stop executing the queue, but reset the state so that\n        // execution can be resumed later if the caller so wishes.\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n      }\n    }\n  }\n\n  /**\n   * Worker that runs tasks off the queue until it is empty or the queue is suspended.\n   */\n  private final class QueueWorker implements Runnable {\n    @Override\n    public void run() {\n      try {\n        workOnQueue();\n      } catch (Error e) {\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n        throw e;\n        // The execution of a task has ended abnormally.\n        // We could have tasks left in the queue, so should perhaps try to restart a worker,\n        // but then the Error will get delayed if we are using a direct (same thread) executor.\n      }\n    }\n\n    private void workOnQueue() {\n      while (true) {\n        Runnable task = null;\n        synchronized (internalLock) {\n          // TODO(user): How should we handle interrupts and shutdowns?\n          if (suspensions == 0) {\n            task = queue.poll();\n          }\n          if (task == null) {\n            isWorkerRunning = false;\n            return;\n          }\n        }\n        try {\n          task.run();\n        } catch (RuntimeException e) {\n          log.log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n        }\n      }\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33573,"label":false,"oracleId":1498,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"SerializingExecutor","javadocTag":"@throws java.lang.IllegalStateException if this executor is not in a suspended state.","methodJavadoc":"    /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */","methodSourceCode":"public void resume(){\n    synchronized (internalLock) {\n        Preconditions.checkState(suspensions > 0);\n        suspensions--;\n    }\n    startQueueWorker();\n}","classJavadoc":"/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.concurrent.Executor;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */\nfinal class SerializingExecutor implements Executor {\n  private static final Logger log =\n      Logger.getLogger(SerializingExecutor.class.getName());\n\n  /** Underlying executor that all submitted Runnable objects are run on. */\n  private final Executor executor;\n\n  @GuardedBy(\"internalLock\")\n  private final Deque<Runnable> queue = new ArrayDeque<Runnable>();\n  @GuardedBy(\"internalLock\")\n  private boolean isWorkerRunning = false;\n  @GuardedBy(\"internalLock\")\n  private int suspensions = 0;\n\n  private final Object internalLock = new Object();\n\n  public SerializingExecutor(Executor executor) {\n    this.executor = Preconditions.checkNotNull(executor);\n  }\n\n  /**\n   * Adds a task to the queue and makes sure a worker thread is running, unless the queue has been\n   * suspended.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #resume()} is\n   * made.\n   */\n  public void execute(Runnable task) {\n    synchronized (internalLock) {\n      queue.add(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Prepends a task to the front of the queue and makes sure a worker thread is running, unless the\n   * queue has been suspended.\n   */\n  public void executeFirst(Runnable task) {\n    synchronized (internalLock) {\n      queue.addFirst(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Suspends the running of tasks until {@link #resume()} is called. This can be called multiple\n   * times to increase the suspensions count and execution will not continue until {@link #resume}\n   * has been called the same number of times as {@code suspend} has been.\n   *\n   * <p>Any task that has already been pulled off the queue for execution will be completed\n   * before execution is suspended.\n   */\n  public void suspend() {\n    synchronized (internalLock) {\n      suspensions++;\n    }\n  }\n\n  /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */\n  public void resume() {\n    synchronized (internalLock) {\n      Preconditions.checkState(suspensions > 0);\n      suspensions--;\n    }\n    startQueueWorker();\n  }\n\n  private void startQueueWorker() {\n    synchronized (internalLock) {\n      // We sometimes try to start a queue worker without knowing if there is any work to do.\n      if (queue.peek() == null) {\n        return;\n      }\n      if (suspensions > 0) {\n        return;\n      }\n      if (isWorkerRunning) {\n        return;\n      }\n      isWorkerRunning = true;\n    }\n    boolean executionRejected = true;\n    try {\n      executor.execute(new QueueWorker());\n      executionRejected = false;\n    } finally {\n      if (executionRejected) {\n        // The best we can do is to stop executing the queue, but reset the state so that\n        // execution can be resumed later if the caller so wishes.\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n      }\n    }\n  }\n\n  /**\n   * Worker that runs tasks off the queue until it is empty or the queue is suspended.\n   */\n  private final class QueueWorker implements Runnable {\n    @Override\n    public void run() {\n      try {\n        workOnQueue();\n      } catch (Error e) {\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n        throw e;\n        // The execution of a task has ended abnormally.\n        // We could have tasks left in the queue, so should perhaps try to restart a worker,\n        // but then the Error will get delayed if we are using a direct (same thread) executor.\n      }\n    }\n\n    private void workOnQueue() {\n      while (true) {\n        Runnable task = null;\n        synchronized (internalLock) {\n          // TODO(user): How should we handle interrupts and shutdowns?\n          if (suspensions == 0) {\n            task = queue.poll();\n          }\n          if (task == null) {\n            isWorkerRunning = false;\n            return;\n          }\n        }\n        try {\n          task.run();\n        } catch (RuntimeException e) {\n          log.log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n        }\n      }\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33574,"label":false,"oracleId":1498,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"SerializingExecutor","javadocTag":"@throws java.lang.IllegalStateException if the executor is not currently suspended.","methodJavadoc":"    /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */","methodSourceCode":"public void resume(){\n    synchronized (internalLock) {\n        Preconditions.checkState(suspensions > 0);\n        suspensions--;\n    }\n    startQueueWorker();\n}","classJavadoc":"/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.concurrent.Executor;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */\nfinal class SerializingExecutor implements Executor {\n  private static final Logger log =\n      Logger.getLogger(SerializingExecutor.class.getName());\n\n  /** Underlying executor that all submitted Runnable objects are run on. */\n  private final Executor executor;\n\n  @GuardedBy(\"internalLock\")\n  private final Deque<Runnable> queue = new ArrayDeque<Runnable>();\n  @GuardedBy(\"internalLock\")\n  private boolean isWorkerRunning = false;\n  @GuardedBy(\"internalLock\")\n  private int suspensions = 0;\n\n  private final Object internalLock = new Object();\n\n  public SerializingExecutor(Executor executor) {\n    this.executor = Preconditions.checkNotNull(executor);\n  }\n\n  /**\n   * Adds a task to the queue and makes sure a worker thread is running, unless the queue has been\n   * suspended.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #resume()} is\n   * made.\n   */\n  public void execute(Runnable task) {\n    synchronized (internalLock) {\n      queue.add(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Prepends a task to the front of the queue and makes sure a worker thread is running, unless the\n   * queue has been suspended.\n   */\n  public void executeFirst(Runnable task) {\n    synchronized (internalLock) {\n      queue.addFirst(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Suspends the running of tasks until {@link #resume()} is called. This can be called multiple\n   * times to increase the suspensions count and execution will not continue until {@link #resume}\n   * has been called the same number of times as {@code suspend} has been.\n   *\n   * <p>Any task that has already been pulled off the queue for execution will be completed\n   * before execution is suspended.\n   */\n  public void suspend() {\n    synchronized (internalLock) {\n      suspensions++;\n    }\n  }\n\n  /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */\n  public void resume() {\n    synchronized (internalLock) {\n      Preconditions.checkState(suspensions > 0);\n      suspensions--;\n    }\n    startQueueWorker();\n  }\n\n  private void startQueueWorker() {\n    synchronized (internalLock) {\n      // We sometimes try to start a queue worker without knowing if there is any work to do.\n      if (queue.peek() == null) {\n        return;\n      }\n      if (suspensions > 0) {\n        return;\n      }\n      if (isWorkerRunning) {\n        return;\n      }\n      isWorkerRunning = true;\n    }\n    boolean executionRejected = true;\n    try {\n      executor.execute(new QueueWorker());\n      executionRejected = false;\n    } finally {\n      if (executionRejected) {\n        // The best we can do is to stop executing the queue, but reset the state so that\n        // execution can be resumed later if the caller so wishes.\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n      }\n    }\n  }\n\n  /**\n   * Worker that runs tasks off the queue until it is empty or the queue is suspended.\n   */\n  private final class QueueWorker implements Runnable {\n    @Override\n    public void run() {\n      try {\n        workOnQueue();\n      } catch (Error e) {\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n        throw e;\n        // The execution of a task has ended abnormally.\n        // We could have tasks left in the queue, so should perhaps try to restart a worker,\n        // but then the Error will get delayed if we are using a direct (same thread) executor.\n      }\n    }\n\n    private void workOnQueue() {\n      while (true) {\n        Runnable task = null;\n        synchronized (internalLock) {\n          // TODO(user): How should we handle interrupts and shutdowns?\n          if (suspensions == 0) {\n            task = queue.poll();\n          }\n          if (task == null) {\n            isWorkerRunning = false;\n            return;\n          }\n        }\n        try {\n          task.run();\n        } catch (RuntimeException e) {\n          log.log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n        }\n      }\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33575,"label":false,"oracleId":1498,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"SerializingExecutor","javadocTag":"@throws java.lang.IllegalStateException if the executor is not currently suspended.","methodJavadoc":"    /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */","methodSourceCode":"public void resume(){\n    synchronized (internalLock) {\n        Preconditions.checkState(suspensions > 0);\n        suspensions--;\n    }\n    startQueueWorker();\n}","classJavadoc":"/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.concurrent.Executor;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */\nfinal class SerializingExecutor implements Executor {\n  private static final Logger log =\n      Logger.getLogger(SerializingExecutor.class.getName());\n\n  /** Underlying executor that all submitted Runnable objects are run on. */\n  private final Executor executor;\n\n  @GuardedBy(\"internalLock\")\n  private final Deque<Runnable> queue = new ArrayDeque<Runnable>();\n  @GuardedBy(\"internalLock\")\n  private boolean isWorkerRunning = false;\n  @GuardedBy(\"internalLock\")\n  private int suspensions = 0;\n\n  private final Object internalLock = new Object();\n\n  public SerializingExecutor(Executor executor) {\n    this.executor = Preconditions.checkNotNull(executor);\n  }\n\n  /**\n   * Adds a task to the queue and makes sure a worker thread is running, unless the queue has been\n   * suspended.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #resume()} is\n   * made.\n   */\n  public void execute(Runnable task) {\n    synchronized (internalLock) {\n      queue.add(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Prepends a task to the front of the queue and makes sure a worker thread is running, unless the\n   * queue has been suspended.\n   */\n  public void executeFirst(Runnable task) {\n    synchronized (internalLock) {\n      queue.addFirst(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Suspends the running of tasks until {@link #resume()} is called. This can be called multiple\n   * times to increase the suspensions count and execution will not continue until {@link #resume}\n   * has been called the same number of times as {@code suspend} has been.\n   *\n   * <p>Any task that has already been pulled off the queue for execution will be completed\n   * before execution is suspended.\n   */\n  public void suspend() {\n    synchronized (internalLock) {\n      suspensions++;\n    }\n  }\n\n  /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */\n  public void resume() {\n    synchronized (internalLock) {\n      Preconditions.checkState(suspensions > 0);\n      suspensions--;\n    }\n    startQueueWorker();\n  }\n\n  private void startQueueWorker() {\n    synchronized (internalLock) {\n      // We sometimes try to start a queue worker without knowing if there is any work to do.\n      if (queue.peek() == null) {\n        return;\n      }\n      if (suspensions > 0) {\n        return;\n      }\n      if (isWorkerRunning) {\n        return;\n      }\n      isWorkerRunning = true;\n    }\n    boolean executionRejected = true;\n    try {\n      executor.execute(new QueueWorker());\n      executionRejected = false;\n    } finally {\n      if (executionRejected) {\n        // The best we can do is to stop executing the queue, but reset the state so that\n        // execution can be resumed later if the caller so wishes.\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n      }\n    }\n  }\n\n  /**\n   * Worker that runs tasks off the queue until it is empty or the queue is suspended.\n   */\n  private final class QueueWorker implements Runnable {\n    @Override\n    public void run() {\n      try {\n        workOnQueue();\n      } catch (Error e) {\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n        throw e;\n        // The execution of a task has ended abnormally.\n        // We could have tasks left in the queue, so should perhaps try to restart a worker,\n        // but then the Error will get delayed if we are using a direct (same thread) executor.\n      }\n    }\n\n    private void workOnQueue() {\n      while (true) {\n        Runnable task = null;\n        synchronized (internalLock) {\n          // TODO(user): How should we handle interrupts and shutdowns?\n          if (suspensions == 0) {\n            task = queue.poll();\n          }\n          if (task == null) {\n            isWorkerRunning = false;\n            return;\n          }\n        }\n        try {\n          task.run();\n        } catch (RuntimeException e) {\n          log.log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n        }\n      }\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","SerializingExecutor"]},{"id":33576,"label":false,"oracleId":1498,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"SerializingExecutor","javadocTag":"@throws java.lang.IllegalStateException if the executor is not currently suspended.","methodJavadoc":"    /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */","methodSourceCode":"public void resume(){\n    synchronized (internalLock) {\n        Preconditions.checkState(suspensions > 0);\n        suspensions--;\n    }\n    startQueueWorker();\n}","classJavadoc":"/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.concurrent.Executor;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */\nfinal class SerializingExecutor implements Executor {\n  private static final Logger log =\n      Logger.getLogger(SerializingExecutor.class.getName());\n\n  /** Underlying executor that all submitted Runnable objects are run on. */\n  private final Executor executor;\n\n  @GuardedBy(\"internalLock\")\n  private final Deque<Runnable> queue = new ArrayDeque<Runnable>();\n  @GuardedBy(\"internalLock\")\n  private boolean isWorkerRunning = false;\n  @GuardedBy(\"internalLock\")\n  private int suspensions = 0;\n\n  private final Object internalLock = new Object();\n\n  public SerializingExecutor(Executor executor) {\n    this.executor = Preconditions.checkNotNull(executor);\n  }\n\n  /**\n   * Adds a task to the queue and makes sure a worker thread is running, unless the queue has been\n   * suspended.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #resume()} is\n   * made.\n   */\n  public void execute(Runnable task) {\n    synchronized (internalLock) {\n      queue.add(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Prepends a task to the front of the queue and makes sure a worker thread is running, unless the\n   * queue has been suspended.\n   */\n  public void executeFirst(Runnable task) {\n    synchronized (internalLock) {\n      queue.addFirst(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Suspends the running of tasks until {@link #resume()} is called. This can be called multiple\n   * times to increase the suspensions count and execution will not continue until {@link #resume}\n   * has been called the same number of times as {@code suspend} has been.\n   *\n   * <p>Any task that has already been pulled off the queue for execution will be completed\n   * before execution is suspended.\n   */\n  public void suspend() {\n    synchronized (internalLock) {\n      suspensions++;\n    }\n  }\n\n  /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */\n  public void resume() {\n    synchronized (internalLock) {\n      Preconditions.checkState(suspensions > 0);\n      suspensions--;\n    }\n    startQueueWorker();\n  }\n\n  private void startQueueWorker() {\n    synchronized (internalLock) {\n      // We sometimes try to start a queue worker without knowing if there is any work to do.\n      if (queue.peek() == null) {\n        return;\n      }\n      if (suspensions > 0) {\n        return;\n      }\n      if (isWorkerRunning) {\n        return;\n      }\n      isWorkerRunning = true;\n    }\n    boolean executionRejected = true;\n    try {\n      executor.execute(new QueueWorker());\n      executionRejected = false;\n    } finally {\n      if (executionRejected) {\n        // The best we can do is to stop executing the queue, but reset the state so that\n        // execution can be resumed later if the caller so wishes.\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n      }\n    }\n  }\n\n  /**\n   * Worker that runs tasks off the queue until it is empty or the queue is suspended.\n   */\n  private final class QueueWorker implements Runnable {\n    @Override\n    public void run() {\n      try {\n        workOnQueue();\n      } catch (Error e) {\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n        throw e;\n        // The execution of a task has ended abnormally.\n        // We could have tasks left in the queue, so should perhaps try to restart a worker,\n        // but then the Error will get delayed if we are using a direct (same thread) executor.\n      }\n    }\n\n    private void workOnQueue() {\n      while (true) {\n        Runnable task = null;\n        synchronized (internalLock) {\n          // TODO(user): How should we handle interrupts and shutdowns?\n          if (suspensions == 0) {\n            task = queue.poll();\n          }\n          if (task == null) {\n            isWorkerRunning = false;\n            return;\n          }\n        }\n        try {\n          task.run();\n        } catch (RuntimeException e) {\n          log.log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n        }\n      }\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33577,"label":true,"oracleId":1498,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"SerializingExecutor","javadocTag":"@throws java.lang.IllegalStateException if the executor is not currently suspended.","methodJavadoc":"    /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */","methodSourceCode":"public void resume(){\n    synchronized (internalLock) {\n        Preconditions.checkState(suspensions > 0);\n        suspensions--;\n    }\n    startQueueWorker();\n}","classJavadoc":"/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.concurrent.Executor;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */\nfinal class SerializingExecutor implements Executor {\n  private static final Logger log =\n      Logger.getLogger(SerializingExecutor.class.getName());\n\n  /** Underlying executor that all submitted Runnable objects are run on. */\n  private final Executor executor;\n\n  @GuardedBy(\"internalLock\")\n  private final Deque<Runnable> queue = new ArrayDeque<Runnable>();\n  @GuardedBy(\"internalLock\")\n  private boolean isWorkerRunning = false;\n  @GuardedBy(\"internalLock\")\n  private int suspensions = 0;\n\n  private final Object internalLock = new Object();\n\n  public SerializingExecutor(Executor executor) {\n    this.executor = Preconditions.checkNotNull(executor);\n  }\n\n  /**\n   * Adds a task to the queue and makes sure a worker thread is running, unless the queue has been\n   * suspended.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #resume()} is\n   * made.\n   */\n  public void execute(Runnable task) {\n    synchronized (internalLock) {\n      queue.add(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Prepends a task to the front of the queue and makes sure a worker thread is running, unless the\n   * queue has been suspended.\n   */\n  public void executeFirst(Runnable task) {\n    synchronized (internalLock) {\n      queue.addFirst(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Suspends the running of tasks until {@link #resume()} is called. This can be called multiple\n   * times to increase the suspensions count and execution will not continue until {@link #resume}\n   * has been called the same number of times as {@code suspend} has been.\n   *\n   * <p>Any task that has already been pulled off the queue for execution will be completed\n   * before execution is suspended.\n   */\n  public void suspend() {\n    synchronized (internalLock) {\n      suspensions++;\n    }\n  }\n\n  /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */\n  public void resume() {\n    synchronized (internalLock) {\n      Preconditions.checkState(suspensions > 0);\n      suspensions--;\n    }\n    startQueueWorker();\n  }\n\n  private void startQueueWorker() {\n    synchronized (internalLock) {\n      // We sometimes try to start a queue worker without knowing if there is any work to do.\n      if (queue.peek() == null) {\n        return;\n      }\n      if (suspensions > 0) {\n        return;\n      }\n      if (isWorkerRunning) {\n        return;\n      }\n      isWorkerRunning = true;\n    }\n    boolean executionRejected = true;\n    try {\n      executor.execute(new QueueWorker());\n      executionRejected = false;\n    } finally {\n      if (executionRejected) {\n        // The best we can do is to stop executing the queue, but reset the state so that\n        // execution can be resumed later if the caller so wishes.\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n      }\n    }\n  }\n\n  /**\n   * Worker that runs tasks off the queue until it is empty or the queue is suspended.\n   */\n  private final class QueueWorker implements Runnable {\n    @Override\n    public void run() {\n      try {\n        workOnQueue();\n      } catch (Error e) {\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n        throw e;\n        // The execution of a task has ended abnormally.\n        // We could have tasks left in the queue, so should perhaps try to restart a worker,\n        // but then the Error will get delayed if we are using a direct (same thread) executor.\n      }\n    }\n\n    private void workOnQueue() {\n      while (true) {\n        Runnable task = null;\n        synchronized (internalLock) {\n          // TODO(user): How should we handle interrupts and shutdowns?\n          if (suspensions == 0) {\n            task = queue.poll();\n          }\n          if (task == null) {\n            isWorkerRunning = false;\n            return;\n          }\n        }\n        try {\n          task.run();\n        } catch (RuntimeException e) {\n          log.log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n        }\n      }\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33578,"label":false,"oracleId":1498,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"SerializingExecutor","javadocTag":"@throws java.lang.IllegalStateException if the executor is not currently suspended.","methodJavadoc":"    /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */","methodSourceCode":"public void resume(){\n    synchronized (internalLock) {\n        Preconditions.checkState(suspensions > 0);\n        suspensions--;\n    }\n    startQueueWorker();\n}","classJavadoc":"/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.concurrent.Executor;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */\nfinal class SerializingExecutor implements Executor {\n  private static final Logger log =\n      Logger.getLogger(SerializingExecutor.class.getName());\n\n  /** Underlying executor that all submitted Runnable objects are run on. */\n  private final Executor executor;\n\n  @GuardedBy(\"internalLock\")\n  private final Deque<Runnable> queue = new ArrayDeque<Runnable>();\n  @GuardedBy(\"internalLock\")\n  private boolean isWorkerRunning = false;\n  @GuardedBy(\"internalLock\")\n  private int suspensions = 0;\n\n  private final Object internalLock = new Object();\n\n  public SerializingExecutor(Executor executor) {\n    this.executor = Preconditions.checkNotNull(executor);\n  }\n\n  /**\n   * Adds a task to the queue and makes sure a worker thread is running, unless the queue has been\n   * suspended.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #resume()} is\n   * made.\n   */\n  public void execute(Runnable task) {\n    synchronized (internalLock) {\n      queue.add(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Prepends a task to the front of the queue and makes sure a worker thread is running, unless the\n   * queue has been suspended.\n   */\n  public void executeFirst(Runnable task) {\n    synchronized (internalLock) {\n      queue.addFirst(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Suspends the running of tasks until {@link #resume()} is called. This can be called multiple\n   * times to increase the suspensions count and execution will not continue until {@link #resume}\n   * has been called the same number of times as {@code suspend} has been.\n   *\n   * <p>Any task that has already been pulled off the queue for execution will be completed\n   * before execution is suspended.\n   */\n  public void suspend() {\n    synchronized (internalLock) {\n      suspensions++;\n    }\n  }\n\n  /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */\n  public void resume() {\n    synchronized (internalLock) {\n      Preconditions.checkState(suspensions > 0);\n      suspensions--;\n    }\n    startQueueWorker();\n  }\n\n  private void startQueueWorker() {\n    synchronized (internalLock) {\n      // We sometimes try to start a queue worker without knowing if there is any work to do.\n      if (queue.peek() == null) {\n        return;\n      }\n      if (suspensions > 0) {\n        return;\n      }\n      if (isWorkerRunning) {\n        return;\n      }\n      isWorkerRunning = true;\n    }\n    boolean executionRejected = true;\n    try {\n      executor.execute(new QueueWorker());\n      executionRejected = false;\n    } finally {\n      if (executionRejected) {\n        // The best we can do is to stop executing the queue, but reset the state so that\n        // execution can be resumed later if the caller so wishes.\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n      }\n    }\n  }\n\n  /**\n   * Worker that runs tasks off the queue until it is empty or the queue is suspended.\n   */\n  private final class QueueWorker implements Runnable {\n    @Override\n    public void run() {\n      try {\n        workOnQueue();\n      } catch (Error e) {\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n        throw e;\n        // The execution of a task has ended abnormally.\n        // We could have tasks left in the queue, so should perhaps try to restart a worker,\n        // but then the Error will get delayed if we are using a direct (same thread) executor.\n      }\n    }\n\n    private void workOnQueue() {\n      while (true) {\n        Runnable task = null;\n        synchronized (internalLock) {\n          // TODO(user): How should we handle interrupts and shutdowns?\n          if (suspensions == 0) {\n            task = queue.poll();\n          }\n          if (task == null) {\n            isWorkerRunning = false;\n            return;\n          }\n        }\n        try {\n          task.run();\n        } catch (RuntimeException e) {\n          log.log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n        }\n      }\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33579,"label":false,"oracleId":1498,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"SerializingExecutor","javadocTag":"@throws java.lang.IllegalStateException if the executor is not in a suspended state","methodJavadoc":"    /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */","methodSourceCode":"public void resume(){\n    synchronized (internalLock) {\n        Preconditions.checkState(suspensions > 0);\n        suspensions--;\n    }\n    startQueueWorker();\n}","classJavadoc":"/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.concurrent.Executor;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */\nfinal class SerializingExecutor implements Executor {\n  private static final Logger log =\n      Logger.getLogger(SerializingExecutor.class.getName());\n\n  /** Underlying executor that all submitted Runnable objects are run on. */\n  private final Executor executor;\n\n  @GuardedBy(\"internalLock\")\n  private final Deque<Runnable> queue = new ArrayDeque<Runnable>();\n  @GuardedBy(\"internalLock\")\n  private boolean isWorkerRunning = false;\n  @GuardedBy(\"internalLock\")\n  private int suspensions = 0;\n\n  private final Object internalLock = new Object();\n\n  public SerializingExecutor(Executor executor) {\n    this.executor = Preconditions.checkNotNull(executor);\n  }\n\n  /**\n   * Adds a task to the queue and makes sure a worker thread is running, unless the queue has been\n   * suspended.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #resume()} is\n   * made.\n   */\n  public void execute(Runnable task) {\n    synchronized (internalLock) {\n      queue.add(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Prepends a task to the front of the queue and makes sure a worker thread is running, unless the\n   * queue has been suspended.\n   */\n  public void executeFirst(Runnable task) {\n    synchronized (internalLock) {\n      queue.addFirst(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Suspends the running of tasks until {@link #resume()} is called. This can be called multiple\n   * times to increase the suspensions count and execution will not continue until {@link #resume}\n   * has been called the same number of times as {@code suspend} has been.\n   *\n   * <p>Any task that has already been pulled off the queue for execution will be completed\n   * before execution is suspended.\n   */\n  public void suspend() {\n    synchronized (internalLock) {\n      suspensions++;\n    }\n  }\n\n  /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */\n  public void resume() {\n    synchronized (internalLock) {\n      Preconditions.checkState(suspensions > 0);\n      suspensions--;\n    }\n    startQueueWorker();\n  }\n\n  private void startQueueWorker() {\n    synchronized (internalLock) {\n      // We sometimes try to start a queue worker without knowing if there is any work to do.\n      if (queue.peek() == null) {\n        return;\n      }\n      if (suspensions > 0) {\n        return;\n      }\n      if (isWorkerRunning) {\n        return;\n      }\n      isWorkerRunning = true;\n    }\n    boolean executionRejected = true;\n    try {\n      executor.execute(new QueueWorker());\n      executionRejected = false;\n    } finally {\n      if (executionRejected) {\n        // The best we can do is to stop executing the queue, but reset the state so that\n        // execution can be resumed later if the caller so wishes.\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n      }\n    }\n  }\n\n  /**\n   * Worker that runs tasks off the queue until it is empty or the queue is suspended.\n   */\n  private final class QueueWorker implements Runnable {\n    @Override\n    public void run() {\n      try {\n        workOnQueue();\n      } catch (Error e) {\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n        throw e;\n        // The execution of a task has ended abnormally.\n        // We could have tasks left in the queue, so should perhaps try to restart a worker,\n        // but then the Error will get delayed if we are using a direct (same thread) executor.\n      }\n    }\n\n    private void workOnQueue() {\n      while (true) {\n        Runnable task = null;\n        synchronized (internalLock) {\n          // TODO(user): How should we handle interrupts and shutdowns?\n          if (suspensions == 0) {\n            task = queue.poll();\n          }\n          if (task == null) {\n            isWorkerRunning = false;\n            return;\n          }\n        }\n        try {\n          task.run();\n        } catch (RuntimeException e) {\n          log.log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n        }\n      }\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33580,"label":false,"oracleId":1498,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"SerializingExecutor","javadocTag":"@throws java.lang.IllegalStateException if the executor is not in a suspended state","methodJavadoc":"    /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */","methodSourceCode":"public void resume(){\n    synchronized (internalLock) {\n        Preconditions.checkState(suspensions > 0);\n        suspensions--;\n    }\n    startQueueWorker();\n}","classJavadoc":"/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.concurrent.Executor;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */\nfinal class SerializingExecutor implements Executor {\n  private static final Logger log =\n      Logger.getLogger(SerializingExecutor.class.getName());\n\n  /** Underlying executor that all submitted Runnable objects are run on. */\n  private final Executor executor;\n\n  @GuardedBy(\"internalLock\")\n  private final Deque<Runnable> queue = new ArrayDeque<Runnable>();\n  @GuardedBy(\"internalLock\")\n  private boolean isWorkerRunning = false;\n  @GuardedBy(\"internalLock\")\n  private int suspensions = 0;\n\n  private final Object internalLock = new Object();\n\n  public SerializingExecutor(Executor executor) {\n    this.executor = Preconditions.checkNotNull(executor);\n  }\n\n  /**\n   * Adds a task to the queue and makes sure a worker thread is running, unless the queue has been\n   * suspended.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #resume()} is\n   * made.\n   */\n  public void execute(Runnable task) {\n    synchronized (internalLock) {\n      queue.add(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Prepends a task to the front of the queue and makes sure a worker thread is running, unless the\n   * queue has been suspended.\n   */\n  public void executeFirst(Runnable task) {\n    synchronized (internalLock) {\n      queue.addFirst(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Suspends the running of tasks until {@link #resume()} is called. This can be called multiple\n   * times to increase the suspensions count and execution will not continue until {@link #resume}\n   * has been called the same number of times as {@code suspend} has been.\n   *\n   * <p>Any task that has already been pulled off the queue for execution will be completed\n   * before execution is suspended.\n   */\n  public void suspend() {\n    synchronized (internalLock) {\n      suspensions++;\n    }\n  }\n\n  /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */\n  public void resume() {\n    synchronized (internalLock) {\n      Preconditions.checkState(suspensions > 0);\n      suspensions--;\n    }\n    startQueueWorker();\n  }\n\n  private void startQueueWorker() {\n    synchronized (internalLock) {\n      // We sometimes try to start a queue worker without knowing if there is any work to do.\n      if (queue.peek() == null) {\n        return;\n      }\n      if (suspensions > 0) {\n        return;\n      }\n      if (isWorkerRunning) {\n        return;\n      }\n      isWorkerRunning = true;\n    }\n    boolean executionRejected = true;\n    try {\n      executor.execute(new QueueWorker());\n      executionRejected = false;\n    } finally {\n      if (executionRejected) {\n        // The best we can do is to stop executing the queue, but reset the state so that\n        // execution can be resumed later if the caller so wishes.\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n      }\n    }\n  }\n\n  /**\n   * Worker that runs tasks off the queue until it is empty or the queue is suspended.\n   */\n  private final class QueueWorker implements Runnable {\n    @Override\n    public void run() {\n      try {\n        workOnQueue();\n      } catch (Error e) {\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n        throw e;\n        // The execution of a task has ended abnormally.\n        // We could have tasks left in the queue, so should perhaps try to restart a worker,\n        // but then the Error will get delayed if we are using a direct (same thread) executor.\n      }\n    }\n\n    private void workOnQueue() {\n      while (true) {\n        Runnable task = null;\n        synchronized (internalLock) {\n          // TODO(user): How should we handle interrupts and shutdowns?\n          if (suspensions == 0) {\n            task = queue.poll();\n          }\n          if (task == null) {\n            isWorkerRunning = false;\n            return;\n          }\n        }\n        try {\n          task.run();\n        } catch (RuntimeException e) {\n          log.log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n        }\n      }\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","SerializingExecutor"]},{"id":33581,"label":false,"oracleId":1498,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"SerializingExecutor","javadocTag":"@throws java.lang.IllegalStateException if the executor is not in a suspended state","methodJavadoc":"    /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */","methodSourceCode":"public void resume(){\n    synchronized (internalLock) {\n        Preconditions.checkState(suspensions > 0);\n        suspensions--;\n    }\n    startQueueWorker();\n}","classJavadoc":"/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.concurrent.Executor;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */\nfinal class SerializingExecutor implements Executor {\n  private static final Logger log =\n      Logger.getLogger(SerializingExecutor.class.getName());\n\n  /** Underlying executor that all submitted Runnable objects are run on. */\n  private final Executor executor;\n\n  @GuardedBy(\"internalLock\")\n  private final Deque<Runnable> queue = new ArrayDeque<Runnable>();\n  @GuardedBy(\"internalLock\")\n  private boolean isWorkerRunning = false;\n  @GuardedBy(\"internalLock\")\n  private int suspensions = 0;\n\n  private final Object internalLock = new Object();\n\n  public SerializingExecutor(Executor executor) {\n    this.executor = Preconditions.checkNotNull(executor);\n  }\n\n  /**\n   * Adds a task to the queue and makes sure a worker thread is running, unless the queue has been\n   * suspended.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #resume()} is\n   * made.\n   */\n  public void execute(Runnable task) {\n    synchronized (internalLock) {\n      queue.add(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Prepends a task to the front of the queue and makes sure a worker thread is running, unless the\n   * queue has been suspended.\n   */\n  public void executeFirst(Runnable task) {\n    synchronized (internalLock) {\n      queue.addFirst(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Suspends the running of tasks until {@link #resume()} is called. This can be called multiple\n   * times to increase the suspensions count and execution will not continue until {@link #resume}\n   * has been called the same number of times as {@code suspend} has been.\n   *\n   * <p>Any task that has already been pulled off the queue for execution will be completed\n   * before execution is suspended.\n   */\n  public void suspend() {\n    synchronized (internalLock) {\n      suspensions++;\n    }\n  }\n\n  /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */\n  public void resume() {\n    synchronized (internalLock) {\n      Preconditions.checkState(suspensions > 0);\n      suspensions--;\n    }\n    startQueueWorker();\n  }\n\n  private void startQueueWorker() {\n    synchronized (internalLock) {\n      // We sometimes try to start a queue worker without knowing if there is any work to do.\n      if (queue.peek() == null) {\n        return;\n      }\n      if (suspensions > 0) {\n        return;\n      }\n      if (isWorkerRunning) {\n        return;\n      }\n      isWorkerRunning = true;\n    }\n    boolean executionRejected = true;\n    try {\n      executor.execute(new QueueWorker());\n      executionRejected = false;\n    } finally {\n      if (executionRejected) {\n        // The best we can do is to stop executing the queue, but reset the state so that\n        // execution can be resumed later if the caller so wishes.\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n      }\n    }\n  }\n\n  /**\n   * Worker that runs tasks off the queue until it is empty or the queue is suspended.\n   */\n  private final class QueueWorker implements Runnable {\n    @Override\n    public void run() {\n      try {\n        workOnQueue();\n      } catch (Error e) {\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n        throw e;\n        // The execution of a task has ended abnormally.\n        // We could have tasks left in the queue, so should perhaps try to restart a worker,\n        // but then the Error will get delayed if we are using a direct (same thread) executor.\n      }\n    }\n\n    private void workOnQueue() {\n      while (true) {\n        Runnable task = null;\n        synchronized (internalLock) {\n          // TODO(user): How should we handle interrupts and shutdowns?\n          if (suspensions == 0) {\n            task = queue.poll();\n          }\n          if (task == null) {\n            isWorkerRunning = false;\n            return;\n          }\n        }\n        try {\n          task.run();\n        } catch (RuntimeException e) {\n          log.log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n        }\n      }\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33582,"label":true,"oracleId":1498,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"SerializingExecutor","javadocTag":"@throws java.lang.IllegalStateException if the executor is not in a suspended state","methodJavadoc":"    /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */","methodSourceCode":"public void resume(){\n    synchronized (internalLock) {\n        Preconditions.checkState(suspensions > 0);\n        suspensions--;\n    }\n    startQueueWorker();\n}","classJavadoc":"/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.concurrent.Executor;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */\nfinal class SerializingExecutor implements Executor {\n  private static final Logger log =\n      Logger.getLogger(SerializingExecutor.class.getName());\n\n  /** Underlying executor that all submitted Runnable objects are run on. */\n  private final Executor executor;\n\n  @GuardedBy(\"internalLock\")\n  private final Deque<Runnable> queue = new ArrayDeque<Runnable>();\n  @GuardedBy(\"internalLock\")\n  private boolean isWorkerRunning = false;\n  @GuardedBy(\"internalLock\")\n  private int suspensions = 0;\n\n  private final Object internalLock = new Object();\n\n  public SerializingExecutor(Executor executor) {\n    this.executor = Preconditions.checkNotNull(executor);\n  }\n\n  /**\n   * Adds a task to the queue and makes sure a worker thread is running, unless the queue has been\n   * suspended.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #resume()} is\n   * made.\n   */\n  public void execute(Runnable task) {\n    synchronized (internalLock) {\n      queue.add(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Prepends a task to the front of the queue and makes sure a worker thread is running, unless the\n   * queue has been suspended.\n   */\n  public void executeFirst(Runnable task) {\n    synchronized (internalLock) {\n      queue.addFirst(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Suspends the running of tasks until {@link #resume()} is called. This can be called multiple\n   * times to increase the suspensions count and execution will not continue until {@link #resume}\n   * has been called the same number of times as {@code suspend} has been.\n   *\n   * <p>Any task that has already been pulled off the queue for execution will be completed\n   * before execution is suspended.\n   */\n  public void suspend() {\n    synchronized (internalLock) {\n      suspensions++;\n    }\n  }\n\n  /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */\n  public void resume() {\n    synchronized (internalLock) {\n      Preconditions.checkState(suspensions > 0);\n      suspensions--;\n    }\n    startQueueWorker();\n  }\n\n  private void startQueueWorker() {\n    synchronized (internalLock) {\n      // We sometimes try to start a queue worker without knowing if there is any work to do.\n      if (queue.peek() == null) {\n        return;\n      }\n      if (suspensions > 0) {\n        return;\n      }\n      if (isWorkerRunning) {\n        return;\n      }\n      isWorkerRunning = true;\n    }\n    boolean executionRejected = true;\n    try {\n      executor.execute(new QueueWorker());\n      executionRejected = false;\n    } finally {\n      if (executionRejected) {\n        // The best we can do is to stop executing the queue, but reset the state so that\n        // execution can be resumed later if the caller so wishes.\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n      }\n    }\n  }\n\n  /**\n   * Worker that runs tasks off the queue until it is empty or the queue is suspended.\n   */\n  private final class QueueWorker implements Runnable {\n    @Override\n    public void run() {\n      try {\n        workOnQueue();\n      } catch (Error e) {\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n        throw e;\n        // The execution of a task has ended abnormally.\n        // We could have tasks left in the queue, so should perhaps try to restart a worker,\n        // but then the Error will get delayed if we are using a direct (same thread) executor.\n      }\n    }\n\n    private void workOnQueue() {\n      while (true) {\n        Runnable task = null;\n        synchronized (internalLock) {\n          // TODO(user): How should we handle interrupts and shutdowns?\n          if (suspensions == 0) {\n            task = queue.poll();\n          }\n          if (task == null) {\n            isWorkerRunning = false;\n            return;\n          }\n        }\n        try {\n          task.run();\n        } catch (RuntimeException e) {\n          log.log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n        }\n      }\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33583,"label":false,"oracleId":1498,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"SerializingExecutor","javadocTag":"@throws java.lang.IllegalStateException if the executor is not in a suspended state","methodJavadoc":"    /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */","methodSourceCode":"public void resume(){\n    synchronized (internalLock) {\n        Preconditions.checkState(suspensions > 0);\n        suspensions--;\n    }\n    startQueueWorker();\n}","classJavadoc":"/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.concurrent.Executor;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */\nfinal class SerializingExecutor implements Executor {\n  private static final Logger log =\n      Logger.getLogger(SerializingExecutor.class.getName());\n\n  /** Underlying executor that all submitted Runnable objects are run on. */\n  private final Executor executor;\n\n  @GuardedBy(\"internalLock\")\n  private final Deque<Runnable> queue = new ArrayDeque<Runnable>();\n  @GuardedBy(\"internalLock\")\n  private boolean isWorkerRunning = false;\n  @GuardedBy(\"internalLock\")\n  private int suspensions = 0;\n\n  private final Object internalLock = new Object();\n\n  public SerializingExecutor(Executor executor) {\n    this.executor = Preconditions.checkNotNull(executor);\n  }\n\n  /**\n   * Adds a task to the queue and makes sure a worker thread is running, unless the queue has been\n   * suspended.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #resume()} is\n   * made.\n   */\n  public void execute(Runnable task) {\n    synchronized (internalLock) {\n      queue.add(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Prepends a task to the front of the queue and makes sure a worker thread is running, unless the\n   * queue has been suspended.\n   */\n  public void executeFirst(Runnable task) {\n    synchronized (internalLock) {\n      queue.addFirst(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Suspends the running of tasks until {@link #resume()} is called. This can be called multiple\n   * times to increase the suspensions count and execution will not continue until {@link #resume}\n   * has been called the same number of times as {@code suspend} has been.\n   *\n   * <p>Any task that has already been pulled off the queue for execution will be completed\n   * before execution is suspended.\n   */\n  public void suspend() {\n    synchronized (internalLock) {\n      suspensions++;\n    }\n  }\n\n  /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */\n  public void resume() {\n    synchronized (internalLock) {\n      Preconditions.checkState(suspensions > 0);\n      suspensions--;\n    }\n    startQueueWorker();\n  }\n\n  private void startQueueWorker() {\n    synchronized (internalLock) {\n      // We sometimes try to start a queue worker without knowing if there is any work to do.\n      if (queue.peek() == null) {\n        return;\n      }\n      if (suspensions > 0) {\n        return;\n      }\n      if (isWorkerRunning) {\n        return;\n      }\n      isWorkerRunning = true;\n    }\n    boolean executionRejected = true;\n    try {\n      executor.execute(new QueueWorker());\n      executionRejected = false;\n    } finally {\n      if (executionRejected) {\n        // The best we can do is to stop executing the queue, but reset the state so that\n        // execution can be resumed later if the caller so wishes.\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n      }\n    }\n  }\n\n  /**\n   * Worker that runs tasks off the queue until it is empty or the queue is suspended.\n   */\n  private final class QueueWorker implements Runnable {\n    @Override\n    public void run() {\n      try {\n        workOnQueue();\n      } catch (Error e) {\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n        throw e;\n        // The execution of a task has ended abnormally.\n        // We could have tasks left in the queue, so should perhaps try to restart a worker,\n        // but then the Error will get delayed if we are using a direct (same thread) executor.\n      }\n    }\n\n    private void workOnQueue() {\n      while (true) {\n        Runnable task = null;\n        synchronized (internalLock) {\n          // TODO(user): How should we handle interrupts and shutdowns?\n          if (suspensions == 0) {\n            task = queue.poll();\n          }\n          if (task == null) {\n            isWorkerRunning = false;\n            return;\n          }\n        }\n        try {\n          task.run();\n        } catch (RuntimeException e) {\n          log.log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n        }\n      }\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33584,"label":false,"oracleId":1498,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"SerializingExecutor","javadocTag":"","methodJavadoc":"    /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */","methodSourceCode":"public void resume(){\n    synchronized (internalLock) {\n        Preconditions.checkState(suspensions > 0);\n        suspensions--;\n    }\n    startQueueWorker();\n}","classJavadoc":"/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.concurrent.Executor;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */\nfinal class SerializingExecutor implements Executor {\n  private static final Logger log =\n      Logger.getLogger(SerializingExecutor.class.getName());\n\n  /** Underlying executor that all submitted Runnable objects are run on. */\n  private final Executor executor;\n\n  @GuardedBy(\"internalLock\")\n  private final Deque<Runnable> queue = new ArrayDeque<Runnable>();\n  @GuardedBy(\"internalLock\")\n  private boolean isWorkerRunning = false;\n  @GuardedBy(\"internalLock\")\n  private int suspensions = 0;\n\n  private final Object internalLock = new Object();\n\n  public SerializingExecutor(Executor executor) {\n    this.executor = Preconditions.checkNotNull(executor);\n  }\n\n  /**\n   * Adds a task to the queue and makes sure a worker thread is running, unless the queue has been\n   * suspended.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #resume()} is\n   * made.\n   */\n  public void execute(Runnable task) {\n    synchronized (internalLock) {\n      queue.add(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Prepends a task to the front of the queue and makes sure a worker thread is running, unless the\n   * queue has been suspended.\n   */\n  public void executeFirst(Runnable task) {\n    synchronized (internalLock) {\n      queue.addFirst(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Suspends the running of tasks until {@link #resume()} is called. This can be called multiple\n   * times to increase the suspensions count and execution will not continue until {@link #resume}\n   * has been called the same number of times as {@code suspend} has been.\n   *\n   * <p>Any task that has already been pulled off the queue for execution will be completed\n   * before execution is suspended.\n   */\n  public void suspend() {\n    synchronized (internalLock) {\n      suspensions++;\n    }\n  }\n\n  /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */\n  public void resume() {\n    synchronized (internalLock) {\n      Preconditions.checkState(suspensions > 0);\n      suspensions--;\n    }\n    startQueueWorker();\n  }\n\n  private void startQueueWorker() {\n    synchronized (internalLock) {\n      // We sometimes try to start a queue worker without knowing if there is any work to do.\n      if (queue.peek() == null) {\n        return;\n      }\n      if (suspensions > 0) {\n        return;\n      }\n      if (isWorkerRunning) {\n        return;\n      }\n      isWorkerRunning = true;\n    }\n    boolean executionRejected = true;\n    try {\n      executor.execute(new QueueWorker());\n      executionRejected = false;\n    } finally {\n      if (executionRejected) {\n        // The best we can do is to stop executing the queue, but reset the state so that\n        // execution can be resumed later if the caller so wishes.\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n      }\n    }\n  }\n\n  /**\n   * Worker that runs tasks off the queue until it is empty or the queue is suspended.\n   */\n  private final class QueueWorker implements Runnable {\n    @Override\n    public void run() {\n      try {\n        workOnQueue();\n      } catch (Error e) {\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n        throw e;\n        // The execution of a task has ended abnormally.\n        // We could have tasks left in the queue, so should perhaps try to restart a worker,\n        // but then the Error will get delayed if we are using a direct (same thread) executor.\n      }\n    }\n\n    private void workOnQueue() {\n      while (true) {\n        Runnable task = null;\n        synchronized (internalLock) {\n          // TODO(user): How should we handle interrupts and shutdowns?\n          if (suspensions == 0) {\n            task = queue.poll();\n          }\n          if (task == null) {\n            isWorkerRunning = false;\n            return;\n          }\n        }\n        try {\n          task.run();\n        } catch (RuntimeException e) {\n          log.log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n        }\n      }\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33585,"label":false,"oracleId":1498,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"SerializingExecutor","javadocTag":"","methodJavadoc":"    /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */","methodSourceCode":"public void resume(){\n    synchronized (internalLock) {\n        Preconditions.checkState(suspensions > 0);\n        suspensions--;\n    }\n    startQueueWorker();\n}","classJavadoc":"/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.concurrent.Executor;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */\nfinal class SerializingExecutor implements Executor {\n  private static final Logger log =\n      Logger.getLogger(SerializingExecutor.class.getName());\n\n  /** Underlying executor that all submitted Runnable objects are run on. */\n  private final Executor executor;\n\n  @GuardedBy(\"internalLock\")\n  private final Deque<Runnable> queue = new ArrayDeque<Runnable>();\n  @GuardedBy(\"internalLock\")\n  private boolean isWorkerRunning = false;\n  @GuardedBy(\"internalLock\")\n  private int suspensions = 0;\n\n  private final Object internalLock = new Object();\n\n  public SerializingExecutor(Executor executor) {\n    this.executor = Preconditions.checkNotNull(executor);\n  }\n\n  /**\n   * Adds a task to the queue and makes sure a worker thread is running, unless the queue has been\n   * suspended.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #resume()} is\n   * made.\n   */\n  public void execute(Runnable task) {\n    synchronized (internalLock) {\n      queue.add(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Prepends a task to the front of the queue and makes sure a worker thread is running, unless the\n   * queue has been suspended.\n   */\n  public void executeFirst(Runnable task) {\n    synchronized (internalLock) {\n      queue.addFirst(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Suspends the running of tasks until {@link #resume()} is called. This can be called multiple\n   * times to increase the suspensions count and execution will not continue until {@link #resume}\n   * has been called the same number of times as {@code suspend} has been.\n   *\n   * <p>Any task that has already been pulled off the queue for execution will be completed\n   * before execution is suspended.\n   */\n  public void suspend() {\n    synchronized (internalLock) {\n      suspensions++;\n    }\n  }\n\n  /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */\n  public void resume() {\n    synchronized (internalLock) {\n      Preconditions.checkState(suspensions > 0);\n      suspensions--;\n    }\n    startQueueWorker();\n  }\n\n  private void startQueueWorker() {\n    synchronized (internalLock) {\n      // We sometimes try to start a queue worker without knowing if there is any work to do.\n      if (queue.peek() == null) {\n        return;\n      }\n      if (suspensions > 0) {\n        return;\n      }\n      if (isWorkerRunning) {\n        return;\n      }\n      isWorkerRunning = true;\n    }\n    boolean executionRejected = true;\n    try {\n      executor.execute(new QueueWorker());\n      executionRejected = false;\n    } finally {\n      if (executionRejected) {\n        // The best we can do is to stop executing the queue, but reset the state so that\n        // execution can be resumed later if the caller so wishes.\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n      }\n    }\n  }\n\n  /**\n   * Worker that runs tasks off the queue until it is empty or the queue is suspended.\n   */\n  private final class QueueWorker implements Runnable {\n    @Override\n    public void run() {\n      try {\n        workOnQueue();\n      } catch (Error e) {\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n        throw e;\n        // The execution of a task has ended abnormally.\n        // We could have tasks left in the queue, so should perhaps try to restart a worker,\n        // but then the Error will get delayed if we are using a direct (same thread) executor.\n      }\n    }\n\n    private void workOnQueue() {\n      while (true) {\n        Runnable task = null;\n        synchronized (internalLock) {\n          // TODO(user): How should we handle interrupts and shutdowns?\n          if (suspensions == 0) {\n            task = queue.poll();\n          }\n          if (task == null) {\n            isWorkerRunning = false;\n            return;\n          }\n        }\n        try {\n          task.run();\n        } catch (RuntimeException e) {\n          log.log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n        }\n      }\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","SerializingExecutor"]},{"id":33586,"label":false,"oracleId":1498,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"SerializingExecutor","javadocTag":"","methodJavadoc":"    /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */","methodSourceCode":"public void resume(){\n    synchronized (internalLock) {\n        Preconditions.checkState(suspensions > 0);\n        suspensions--;\n    }\n    startQueueWorker();\n}","classJavadoc":"/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.concurrent.Executor;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */\nfinal class SerializingExecutor implements Executor {\n  private static final Logger log =\n      Logger.getLogger(SerializingExecutor.class.getName());\n\n  /** Underlying executor that all submitted Runnable objects are run on. */\n  private final Executor executor;\n\n  @GuardedBy(\"internalLock\")\n  private final Deque<Runnable> queue = new ArrayDeque<Runnable>();\n  @GuardedBy(\"internalLock\")\n  private boolean isWorkerRunning = false;\n  @GuardedBy(\"internalLock\")\n  private int suspensions = 0;\n\n  private final Object internalLock = new Object();\n\n  public SerializingExecutor(Executor executor) {\n    this.executor = Preconditions.checkNotNull(executor);\n  }\n\n  /**\n   * Adds a task to the queue and makes sure a worker thread is running, unless the queue has been\n   * suspended.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #resume()} is\n   * made.\n   */\n  public void execute(Runnable task) {\n    synchronized (internalLock) {\n      queue.add(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Prepends a task to the front of the queue and makes sure a worker thread is running, unless the\n   * queue has been suspended.\n   */\n  public void executeFirst(Runnable task) {\n    synchronized (internalLock) {\n      queue.addFirst(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Suspends the running of tasks until {@link #resume()} is called. This can be called multiple\n   * times to increase the suspensions count and execution will not continue until {@link #resume}\n   * has been called the same number of times as {@code suspend} has been.\n   *\n   * <p>Any task that has already been pulled off the queue for execution will be completed\n   * before execution is suspended.\n   */\n  public void suspend() {\n    synchronized (internalLock) {\n      suspensions++;\n    }\n  }\n\n  /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */\n  public void resume() {\n    synchronized (internalLock) {\n      Preconditions.checkState(suspensions > 0);\n      suspensions--;\n    }\n    startQueueWorker();\n  }\n\n  private void startQueueWorker() {\n    synchronized (internalLock) {\n      // We sometimes try to start a queue worker without knowing if there is any work to do.\n      if (queue.peek() == null) {\n        return;\n      }\n      if (suspensions > 0) {\n        return;\n      }\n      if (isWorkerRunning) {\n        return;\n      }\n      isWorkerRunning = true;\n    }\n    boolean executionRejected = true;\n    try {\n      executor.execute(new QueueWorker());\n      executionRejected = false;\n    } finally {\n      if (executionRejected) {\n        // The best we can do is to stop executing the queue, but reset the state so that\n        // execution can be resumed later if the caller so wishes.\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n      }\n    }\n  }\n\n  /**\n   * Worker that runs tasks off the queue until it is empty or the queue is suspended.\n   */\n  private final class QueueWorker implements Runnable {\n    @Override\n    public void run() {\n      try {\n        workOnQueue();\n      } catch (Error e) {\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n        throw e;\n        // The execution of a task has ended abnormally.\n        // We could have tasks left in the queue, so should perhaps try to restart a worker,\n        // but then the Error will get delayed if we are using a direct (same thread) executor.\n      }\n    }\n\n    private void workOnQueue() {\n      while (true) {\n        Runnable task = null;\n        synchronized (internalLock) {\n          // TODO(user): How should we handle interrupts and shutdowns?\n          if (suspensions == 0) {\n            task = queue.poll();\n          }\n          if (task == null) {\n            isWorkerRunning = false;\n            return;\n          }\n        }\n        try {\n          task.run();\n        } catch (RuntimeException e) {\n          log.log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n        }\n      }\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33587,"label":true,"oracleId":1498,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"SerializingExecutor","javadocTag":"","methodJavadoc":"    /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */","methodSourceCode":"public void resume(){\n    synchronized (internalLock) {\n        Preconditions.checkState(suspensions > 0);\n        suspensions--;\n    }\n    startQueueWorker();\n}","classJavadoc":"/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.concurrent.Executor;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */\nfinal class SerializingExecutor implements Executor {\n  private static final Logger log =\n      Logger.getLogger(SerializingExecutor.class.getName());\n\n  /** Underlying executor that all submitted Runnable objects are run on. */\n  private final Executor executor;\n\n  @GuardedBy(\"internalLock\")\n  private final Deque<Runnable> queue = new ArrayDeque<Runnable>();\n  @GuardedBy(\"internalLock\")\n  private boolean isWorkerRunning = false;\n  @GuardedBy(\"internalLock\")\n  private int suspensions = 0;\n\n  private final Object internalLock = new Object();\n\n  public SerializingExecutor(Executor executor) {\n    this.executor = Preconditions.checkNotNull(executor);\n  }\n\n  /**\n   * Adds a task to the queue and makes sure a worker thread is running, unless the queue has been\n   * suspended.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #resume()} is\n   * made.\n   */\n  public void execute(Runnable task) {\n    synchronized (internalLock) {\n      queue.add(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Prepends a task to the front of the queue and makes sure a worker thread is running, unless the\n   * queue has been suspended.\n   */\n  public void executeFirst(Runnable task) {\n    synchronized (internalLock) {\n      queue.addFirst(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Suspends the running of tasks until {@link #resume()} is called. This can be called multiple\n   * times to increase the suspensions count and execution will not continue until {@link #resume}\n   * has been called the same number of times as {@code suspend} has been.\n   *\n   * <p>Any task that has already been pulled off the queue for execution will be completed\n   * before execution is suspended.\n   */\n  public void suspend() {\n    synchronized (internalLock) {\n      suspensions++;\n    }\n  }\n\n  /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */\n  public void resume() {\n    synchronized (internalLock) {\n      Preconditions.checkState(suspensions > 0);\n      suspensions--;\n    }\n    startQueueWorker();\n  }\n\n  private void startQueueWorker() {\n    synchronized (internalLock) {\n      // We sometimes try to start a queue worker without knowing if there is any work to do.\n      if (queue.peek() == null) {\n        return;\n      }\n      if (suspensions > 0) {\n        return;\n      }\n      if (isWorkerRunning) {\n        return;\n      }\n      isWorkerRunning = true;\n    }\n    boolean executionRejected = true;\n    try {\n      executor.execute(new QueueWorker());\n      executionRejected = false;\n    } finally {\n      if (executionRejected) {\n        // The best we can do is to stop executing the queue, but reset the state so that\n        // execution can be resumed later if the caller so wishes.\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n      }\n    }\n  }\n\n  /**\n   * Worker that runs tasks off the queue until it is empty or the queue is suspended.\n   */\n  private final class QueueWorker implements Runnable {\n    @Override\n    public void run() {\n      try {\n        workOnQueue();\n      } catch (Error e) {\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n        throw e;\n        // The execution of a task has ended abnormally.\n        // We could have tasks left in the queue, so should perhaps try to restart a worker,\n        // but then the Error will get delayed if we are using a direct (same thread) executor.\n      }\n    }\n\n    private void workOnQueue() {\n      while (true) {\n        Runnable task = null;\n        synchronized (internalLock) {\n          // TODO(user): How should we handle interrupts and shutdowns?\n          if (suspensions == 0) {\n            task = queue.poll();\n          }\n          if (task == null) {\n            isWorkerRunning = false;\n            return;\n          }\n        }\n        try {\n          task.run();\n        } catch (RuntimeException e) {\n          log.log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n        }\n      }\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33588,"label":false,"oracleId":1498,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"SerializingExecutor","javadocTag":"","methodJavadoc":"    /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */","methodSourceCode":"public void resume(){\n    synchronized (internalLock) {\n        Preconditions.checkState(suspensions > 0);\n        suspensions--;\n    }\n    startQueueWorker();\n}","classJavadoc":"/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.concurrent.Executor;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */\nfinal class SerializingExecutor implements Executor {\n  private static final Logger log =\n      Logger.getLogger(SerializingExecutor.class.getName());\n\n  /** Underlying executor that all submitted Runnable objects are run on. */\n  private final Executor executor;\n\n  @GuardedBy(\"internalLock\")\n  private final Deque<Runnable> queue = new ArrayDeque<Runnable>();\n  @GuardedBy(\"internalLock\")\n  private boolean isWorkerRunning = false;\n  @GuardedBy(\"internalLock\")\n  private int suspensions = 0;\n\n  private final Object internalLock = new Object();\n\n  public SerializingExecutor(Executor executor) {\n    this.executor = Preconditions.checkNotNull(executor);\n  }\n\n  /**\n   * Adds a task to the queue and makes sure a worker thread is running, unless the queue has been\n   * suspended.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #resume()} is\n   * made.\n   */\n  public void execute(Runnable task) {\n    synchronized (internalLock) {\n      queue.add(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Prepends a task to the front of the queue and makes sure a worker thread is running, unless the\n   * queue has been suspended.\n   */\n  public void executeFirst(Runnable task) {\n    synchronized (internalLock) {\n      queue.addFirst(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Suspends the running of tasks until {@link #resume()} is called. This can be called multiple\n   * times to increase the suspensions count and execution will not continue until {@link #resume}\n   * has been called the same number of times as {@code suspend} has been.\n   *\n   * <p>Any task that has already been pulled off the queue for execution will be completed\n   * before execution is suspended.\n   */\n  public void suspend() {\n    synchronized (internalLock) {\n      suspensions++;\n    }\n  }\n\n  /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */\n  public void resume() {\n    synchronized (internalLock) {\n      Preconditions.checkState(suspensions > 0);\n      suspensions--;\n    }\n    startQueueWorker();\n  }\n\n  private void startQueueWorker() {\n    synchronized (internalLock) {\n      // We sometimes try to start a queue worker without knowing if there is any work to do.\n      if (queue.peek() == null) {\n        return;\n      }\n      if (suspensions > 0) {\n        return;\n      }\n      if (isWorkerRunning) {\n        return;\n      }\n      isWorkerRunning = true;\n    }\n    boolean executionRejected = true;\n    try {\n      executor.execute(new QueueWorker());\n      executionRejected = false;\n    } finally {\n      if (executionRejected) {\n        // The best we can do is to stop executing the queue, but reset the state so that\n        // execution can be resumed later if the caller so wishes.\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n      }\n    }\n  }\n\n  /**\n   * Worker that runs tasks off the queue until it is empty or the queue is suspended.\n   */\n  private final class QueueWorker implements Runnable {\n    @Override\n    public void run() {\n      try {\n        workOnQueue();\n      } catch (Error e) {\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n        throw e;\n        // The execution of a task has ended abnormally.\n        // We could have tasks left in the queue, so should perhaps try to restart a worker,\n        // but then the Error will get delayed if we are using a direct (same thread) executor.\n      }\n    }\n\n    private void workOnQueue() {\n      while (true) {\n        Runnable task = null;\n        synchronized (internalLock) {\n          // TODO(user): How should we handle interrupts and shutdowns?\n          if (suspensions == 0) {\n            task = queue.poll();\n          }\n          if (task == null) {\n            isWorkerRunning = false;\n            return;\n          }\n        }\n        try {\n          task.run();\n        } catch (RuntimeException e) {\n          log.log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n        }\n      }\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33589,"label":false,"oracleId":1499,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AbstractCheckedFuture","javadocTag":"@throws X if an exception such as {@link InterruptedException}; {@link CancellationException};\n        or {@link ExecutionException} is thrown by the {@link #get()} method","methodJavadoc":"    /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */","methodSourceCode":"public V checkedGet() throws X{\n    try {\n        return get();\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw mapException(e);\n    } catch (CancellationException e) {\n        throw mapException(e);\n    } catch (ExecutionException e) {\n        throw mapException(e);\n    }\n}","classJavadoc":"/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.CancellationException;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */\n@Beta\npublic abstract class AbstractCheckedFuture<V, X extends Exception>\n    extends ForwardingListenableFuture.SimpleForwardingListenableFuture<V>\n    implements CheckedFuture<V, X> {\n  /**\n   * Constructs an {@code AbstractCheckedFuture} that wraps a delegate.\n   */\n  protected AbstractCheckedFuture(ListenableFuture<V> delegate) {\n    super(delegate);\n  }\n\n  /**\n   * Translates from an {@link InterruptedException},\n   * {@link CancellationException} or {@link ExecutionException} thrown by\n   * {@code get} to an exception of type {@code X} to be thrown by\n   * {@code checkedGet}. Subclasses must implement this method.\n   *\n   * <p>If {@code e} is an {@code InterruptedException}, the calling\n   * {@code checkedGet} method has already restored the interrupt after catching\n   * the exception. If an implementation of {@link #mapException(Exception)}\n   * wishes to swallow the interrupt, it can do so by calling\n   * {@link Thread#interrupted()}.\n   *\n   * <p>Subclasses may choose to throw, rather than return, a subclass of\n   * {@code RuntimeException} to allow creating a CheckedFuture that throws\n   * both checked and unchecked exceptions.\n   */\n  protected abstract X mapException(Exception e);\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */\n  @Override\n  public V checkedGet() throws X {\n    try {\n      return get();\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get(long, TimeUnit)} and maps that\n   * method's standard exceptions (excluding {@link TimeoutException}, which is\n   * propagated) to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   * @throws TimeoutException {@inheritDoc}\n   */\n  @Override\n  public V checkedGet(long timeout, TimeUnit unit) throws TimeoutException, X {\n    try {\n      return get(timeout, unit);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33590,"label":false,"oracleId":1499,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AbstractCheckedFuture","javadocTag":"@throws X if an exception such as {@link InterruptedException}; {@link CancellationException};\n        or {@link ExecutionException} is thrown by the {@link #get()} method","methodJavadoc":"    /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */","methodSourceCode":"public V checkedGet() throws X{\n    try {\n        return get();\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw mapException(e);\n    } catch (CancellationException e) {\n        throw mapException(e);\n    } catch (ExecutionException e) {\n        throw mapException(e);\n    }\n}","classJavadoc":"/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.CancellationException;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */\n@Beta\npublic abstract class AbstractCheckedFuture<V, X extends Exception>\n    extends ForwardingListenableFuture.SimpleForwardingListenableFuture<V>\n    implements CheckedFuture<V, X> {\n  /**\n   * Constructs an {@code AbstractCheckedFuture} that wraps a delegate.\n   */\n  protected AbstractCheckedFuture(ListenableFuture<V> delegate) {\n    super(delegate);\n  }\n\n  /**\n   * Translates from an {@link InterruptedException},\n   * {@link CancellationException} or {@link ExecutionException} thrown by\n   * {@code get} to an exception of type {@code X} to be thrown by\n   * {@code checkedGet}. Subclasses must implement this method.\n   *\n   * <p>If {@code e} is an {@code InterruptedException}, the calling\n   * {@code checkedGet} method has already restored the interrupt after catching\n   * the exception. If an implementation of {@link #mapException(Exception)}\n   * wishes to swallow the interrupt, it can do so by calling\n   * {@link Thread#interrupted()}.\n   *\n   * <p>Subclasses may choose to throw, rather than return, a subclass of\n   * {@code RuntimeException} to allow creating a CheckedFuture that throws\n   * both checked and unchecked exceptions.\n   */\n  protected abstract X mapException(Exception e);\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */\n  @Override\n  public V checkedGet() throws X {\n    try {\n      return get();\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get(long, TimeUnit)} and maps that\n   * method's standard exceptions (excluding {@link TimeoutException}, which is\n   * propagated) to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   * @throws TimeoutException {@inheritDoc}\n   */\n  @Override\n  public V checkedGet(long timeout, TimeUnit unit) throws TimeoutException, X {\n    try {\n      return get(timeout, unit);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AbstractCheckedFuture"]},{"id":33591,"label":false,"oracleId":1499,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AbstractCheckedFuture","javadocTag":"@throws X if an exception such as {@link InterruptedException}; {@link CancellationException};\n        or {@link ExecutionException} is thrown by the {@link #get()} method","methodJavadoc":"    /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */","methodSourceCode":"public V checkedGet() throws X{\n    try {\n        return get();\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw mapException(e);\n    } catch (CancellationException e) {\n        throw mapException(e);\n    } catch (ExecutionException e) {\n        throw mapException(e);\n    }\n}","classJavadoc":"/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.CancellationException;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */\n@Beta\npublic abstract class AbstractCheckedFuture<V, X extends Exception>\n    extends ForwardingListenableFuture.SimpleForwardingListenableFuture<V>\n    implements CheckedFuture<V, X> {\n  /**\n   * Constructs an {@code AbstractCheckedFuture} that wraps a delegate.\n   */\n  protected AbstractCheckedFuture(ListenableFuture<V> delegate) {\n    super(delegate);\n  }\n\n  /**\n   * Translates from an {@link InterruptedException},\n   * {@link CancellationException} or {@link ExecutionException} thrown by\n   * {@code get} to an exception of type {@code X} to be thrown by\n   * {@code checkedGet}. Subclasses must implement this method.\n   *\n   * <p>If {@code e} is an {@code InterruptedException}, the calling\n   * {@code checkedGet} method has already restored the interrupt after catching\n   * the exception. If an implementation of {@link #mapException(Exception)}\n   * wishes to swallow the interrupt, it can do so by calling\n   * {@link Thread#interrupted()}.\n   *\n   * <p>Subclasses may choose to throw, rather than return, a subclass of\n   * {@code RuntimeException} to allow creating a CheckedFuture that throws\n   * both checked and unchecked exceptions.\n   */\n  protected abstract X mapException(Exception e);\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */\n  @Override\n  public V checkedGet() throws X {\n    try {\n      return get();\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get(long, TimeUnit)} and maps that\n   * method's standard exceptions (excluding {@link TimeoutException}, which is\n   * propagated) to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   * @throws TimeoutException {@inheritDoc}\n   */\n  @Override\n  public V checkedGet(long timeout, TimeUnit unit) throws TimeoutException, X {\n    try {\n      return get(timeout, unit);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33592,"label":true,"oracleId":1499,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AbstractCheckedFuture","javadocTag":"@throws X if an exception such as {@link InterruptedException}; {@link CancellationException};\n        or {@link ExecutionException} is thrown by the {@link #get()} method","methodJavadoc":"    /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */","methodSourceCode":"public V checkedGet() throws X{\n    try {\n        return get();\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw mapException(e);\n    } catch (CancellationException e) {\n        throw mapException(e);\n    } catch (ExecutionException e) {\n        throw mapException(e);\n    }\n}","classJavadoc":"/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.CancellationException;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */\n@Beta\npublic abstract class AbstractCheckedFuture<V, X extends Exception>\n    extends ForwardingListenableFuture.SimpleForwardingListenableFuture<V>\n    implements CheckedFuture<V, X> {\n  /**\n   * Constructs an {@code AbstractCheckedFuture} that wraps a delegate.\n   */\n  protected AbstractCheckedFuture(ListenableFuture<V> delegate) {\n    super(delegate);\n  }\n\n  /**\n   * Translates from an {@link InterruptedException},\n   * {@link CancellationException} or {@link ExecutionException} thrown by\n   * {@code get} to an exception of type {@code X} to be thrown by\n   * {@code checkedGet}. Subclasses must implement this method.\n   *\n   * <p>If {@code e} is an {@code InterruptedException}, the calling\n   * {@code checkedGet} method has already restored the interrupt after catching\n   * the exception. If an implementation of {@link #mapException(Exception)}\n   * wishes to swallow the interrupt, it can do so by calling\n   * {@link Thread#interrupted()}.\n   *\n   * <p>Subclasses may choose to throw, rather than return, a subclass of\n   * {@code RuntimeException} to allow creating a CheckedFuture that throws\n   * both checked and unchecked exceptions.\n   */\n  protected abstract X mapException(Exception e);\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */\n  @Override\n  public V checkedGet() throws X {\n    try {\n      return get();\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get(long, TimeUnit)} and maps that\n   * method's standard exceptions (excluding {@link TimeoutException}, which is\n   * propagated) to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   * @throws TimeoutException {@inheritDoc}\n   */\n  @Override\n  public V checkedGet(long timeout, TimeUnit unit) throws TimeoutException, X {\n    try {\n      return get(timeout, unit);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33593,"label":false,"oracleId":1499,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AbstractCheckedFuture","javadocTag":"@throws X if an exception such as {@link InterruptedException}; {@link CancellationException};\n        or {@link ExecutionException} is thrown by the {@link #get()} method","methodJavadoc":"    /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */","methodSourceCode":"public V checkedGet() throws X{\n    try {\n        return get();\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw mapException(e);\n    } catch (CancellationException e) {\n        throw mapException(e);\n    } catch (ExecutionException e) {\n        throw mapException(e);\n    }\n}","classJavadoc":"/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.CancellationException;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */\n@Beta\npublic abstract class AbstractCheckedFuture<V, X extends Exception>\n    extends ForwardingListenableFuture.SimpleForwardingListenableFuture<V>\n    implements CheckedFuture<V, X> {\n  /**\n   * Constructs an {@code AbstractCheckedFuture} that wraps a delegate.\n   */\n  protected AbstractCheckedFuture(ListenableFuture<V> delegate) {\n    super(delegate);\n  }\n\n  /**\n   * Translates from an {@link InterruptedException},\n   * {@link CancellationException} or {@link ExecutionException} thrown by\n   * {@code get} to an exception of type {@code X} to be thrown by\n   * {@code checkedGet}. Subclasses must implement this method.\n   *\n   * <p>If {@code e} is an {@code InterruptedException}, the calling\n   * {@code checkedGet} method has already restored the interrupt after catching\n   * the exception. If an implementation of {@link #mapException(Exception)}\n   * wishes to swallow the interrupt, it can do so by calling\n   * {@link Thread#interrupted()}.\n   *\n   * <p>Subclasses may choose to throw, rather than return, a subclass of\n   * {@code RuntimeException} to allow creating a CheckedFuture that throws\n   * both checked and unchecked exceptions.\n   */\n  protected abstract X mapException(Exception e);\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */\n  @Override\n  public V checkedGet() throws X {\n    try {\n      return get();\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get(long, TimeUnit)} and maps that\n   * method's standard exceptions (excluding {@link TimeoutException}, which is\n   * propagated) to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   * @throws TimeoutException {@inheritDoc}\n   */\n  @Override\n  public V checkedGet(long timeout, TimeUnit unit) throws TimeoutException, X {\n    try {\n      return get(timeout, unit);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33594,"label":false,"oracleId":1499,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AbstractCheckedFuture","javadocTag":"@throws X if the {@link #get()} method throws either {@link InterruptedException}:\n        {@link CancellationException}: or {@link ExecutionException}","methodJavadoc":"    /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */","methodSourceCode":"public V checkedGet() throws X{\n    try {\n        return get();\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw mapException(e);\n    } catch (CancellationException e) {\n        throw mapException(e);\n    } catch (ExecutionException e) {\n        throw mapException(e);\n    }\n}","classJavadoc":"/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.CancellationException;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */\n@Beta\npublic abstract class AbstractCheckedFuture<V, X extends Exception>\n    extends ForwardingListenableFuture.SimpleForwardingListenableFuture<V>\n    implements CheckedFuture<V, X> {\n  /**\n   * Constructs an {@code AbstractCheckedFuture} that wraps a delegate.\n   */\n  protected AbstractCheckedFuture(ListenableFuture<V> delegate) {\n    super(delegate);\n  }\n\n  /**\n   * Translates from an {@link InterruptedException},\n   * {@link CancellationException} or {@link ExecutionException} thrown by\n   * {@code get} to an exception of type {@code X} to be thrown by\n   * {@code checkedGet}. Subclasses must implement this method.\n   *\n   * <p>If {@code e} is an {@code InterruptedException}, the calling\n   * {@code checkedGet} method has already restored the interrupt after catching\n   * the exception. If an implementation of {@link #mapException(Exception)}\n   * wishes to swallow the interrupt, it can do so by calling\n   * {@link Thread#interrupted()}.\n   *\n   * <p>Subclasses may choose to throw, rather than return, a subclass of\n   * {@code RuntimeException} to allow creating a CheckedFuture that throws\n   * both checked and unchecked exceptions.\n   */\n  protected abstract X mapException(Exception e);\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */\n  @Override\n  public V checkedGet() throws X {\n    try {\n      return get();\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get(long, TimeUnit)} and maps that\n   * method's standard exceptions (excluding {@link TimeoutException}, which is\n   * propagated) to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   * @throws TimeoutException {@inheritDoc}\n   */\n  @Override\n  public V checkedGet(long timeout, TimeUnit unit) throws TimeoutException, X {\n    try {\n      return get(timeout, unit);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33595,"label":false,"oracleId":1499,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AbstractCheckedFuture","javadocTag":"@throws X if the {@link #get()} method throws either {@link InterruptedException}:\n        {@link CancellationException}: or {@link ExecutionException}","methodJavadoc":"    /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */","methodSourceCode":"public V checkedGet() throws X{\n    try {\n        return get();\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw mapException(e);\n    } catch (CancellationException e) {\n        throw mapException(e);\n    } catch (ExecutionException e) {\n        throw mapException(e);\n    }\n}","classJavadoc":"/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.CancellationException;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */\n@Beta\npublic abstract class AbstractCheckedFuture<V, X extends Exception>\n    extends ForwardingListenableFuture.SimpleForwardingListenableFuture<V>\n    implements CheckedFuture<V, X> {\n  /**\n   * Constructs an {@code AbstractCheckedFuture} that wraps a delegate.\n   */\n  protected AbstractCheckedFuture(ListenableFuture<V> delegate) {\n    super(delegate);\n  }\n\n  /**\n   * Translates from an {@link InterruptedException},\n   * {@link CancellationException} or {@link ExecutionException} thrown by\n   * {@code get} to an exception of type {@code X} to be thrown by\n   * {@code checkedGet}. Subclasses must implement this method.\n   *\n   * <p>If {@code e} is an {@code InterruptedException}, the calling\n   * {@code checkedGet} method has already restored the interrupt after catching\n   * the exception. If an implementation of {@link #mapException(Exception)}\n   * wishes to swallow the interrupt, it can do so by calling\n   * {@link Thread#interrupted()}.\n   *\n   * <p>Subclasses may choose to throw, rather than return, a subclass of\n   * {@code RuntimeException} to allow creating a CheckedFuture that throws\n   * both checked and unchecked exceptions.\n   */\n  protected abstract X mapException(Exception e);\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */\n  @Override\n  public V checkedGet() throws X {\n    try {\n      return get();\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get(long, TimeUnit)} and maps that\n   * method's standard exceptions (excluding {@link TimeoutException}, which is\n   * propagated) to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   * @throws TimeoutException {@inheritDoc}\n   */\n  @Override\n  public V checkedGet(long timeout, TimeUnit unit) throws TimeoutException, X {\n    try {\n      return get(timeout, unit);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AbstractCheckedFuture"]},{"id":33596,"label":false,"oracleId":1499,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AbstractCheckedFuture","javadocTag":"@throws X if the {@link #get()} method throws either {@link InterruptedException}:\n        {@link CancellationException}: or {@link ExecutionException}","methodJavadoc":"    /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */","methodSourceCode":"public V checkedGet() throws X{\n    try {\n        return get();\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw mapException(e);\n    } catch (CancellationException e) {\n        throw mapException(e);\n    } catch (ExecutionException e) {\n        throw mapException(e);\n    }\n}","classJavadoc":"/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.CancellationException;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */\n@Beta\npublic abstract class AbstractCheckedFuture<V, X extends Exception>\n    extends ForwardingListenableFuture.SimpleForwardingListenableFuture<V>\n    implements CheckedFuture<V, X> {\n  /**\n   * Constructs an {@code AbstractCheckedFuture} that wraps a delegate.\n   */\n  protected AbstractCheckedFuture(ListenableFuture<V> delegate) {\n    super(delegate);\n  }\n\n  /**\n   * Translates from an {@link InterruptedException},\n   * {@link CancellationException} or {@link ExecutionException} thrown by\n   * {@code get} to an exception of type {@code X} to be thrown by\n   * {@code checkedGet}. Subclasses must implement this method.\n   *\n   * <p>If {@code e} is an {@code InterruptedException}, the calling\n   * {@code checkedGet} method has already restored the interrupt after catching\n   * the exception. If an implementation of {@link #mapException(Exception)}\n   * wishes to swallow the interrupt, it can do so by calling\n   * {@link Thread#interrupted()}.\n   *\n   * <p>Subclasses may choose to throw, rather than return, a subclass of\n   * {@code RuntimeException} to allow creating a CheckedFuture that throws\n   * both checked and unchecked exceptions.\n   */\n  protected abstract X mapException(Exception e);\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */\n  @Override\n  public V checkedGet() throws X {\n    try {\n      return get();\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get(long, TimeUnit)} and maps that\n   * method's standard exceptions (excluding {@link TimeoutException}, which is\n   * propagated) to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   * @throws TimeoutException {@inheritDoc}\n   */\n  @Override\n  public V checkedGet(long timeout, TimeUnit unit) throws TimeoutException, X {\n    try {\n      return get(timeout, unit);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33597,"label":true,"oracleId":1499,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AbstractCheckedFuture","javadocTag":"@throws X if the {@link #get()} method throws either {@link InterruptedException}:\n        {@link CancellationException}: or {@link ExecutionException}","methodJavadoc":"    /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */","methodSourceCode":"public V checkedGet() throws X{\n    try {\n        return get();\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw mapException(e);\n    } catch (CancellationException e) {\n        throw mapException(e);\n    } catch (ExecutionException e) {\n        throw mapException(e);\n    }\n}","classJavadoc":"/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.CancellationException;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */\n@Beta\npublic abstract class AbstractCheckedFuture<V, X extends Exception>\n    extends ForwardingListenableFuture.SimpleForwardingListenableFuture<V>\n    implements CheckedFuture<V, X> {\n  /**\n   * Constructs an {@code AbstractCheckedFuture} that wraps a delegate.\n   */\n  protected AbstractCheckedFuture(ListenableFuture<V> delegate) {\n    super(delegate);\n  }\n\n  /**\n   * Translates from an {@link InterruptedException},\n   * {@link CancellationException} or {@link ExecutionException} thrown by\n   * {@code get} to an exception of type {@code X} to be thrown by\n   * {@code checkedGet}. Subclasses must implement this method.\n   *\n   * <p>If {@code e} is an {@code InterruptedException}, the calling\n   * {@code checkedGet} method has already restored the interrupt after catching\n   * the exception. If an implementation of {@link #mapException(Exception)}\n   * wishes to swallow the interrupt, it can do so by calling\n   * {@link Thread#interrupted()}.\n   *\n   * <p>Subclasses may choose to throw, rather than return, a subclass of\n   * {@code RuntimeException} to allow creating a CheckedFuture that throws\n   * both checked and unchecked exceptions.\n   */\n  protected abstract X mapException(Exception e);\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */\n  @Override\n  public V checkedGet() throws X {\n    try {\n      return get();\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get(long, TimeUnit)} and maps that\n   * method's standard exceptions (excluding {@link TimeoutException}, which is\n   * propagated) to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   * @throws TimeoutException {@inheritDoc}\n   */\n  @Override\n  public V checkedGet(long timeout, TimeUnit unit) throws TimeoutException, X {\n    try {\n      return get(timeout, unit);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33598,"label":false,"oracleId":1499,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AbstractCheckedFuture","javadocTag":"@throws X if the {@link #get()} method throws either {@link InterruptedException}:\n        {@link CancellationException}: or {@link ExecutionException}","methodJavadoc":"    /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */","methodSourceCode":"public V checkedGet() throws X{\n    try {\n        return get();\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw mapException(e);\n    } catch (CancellationException e) {\n        throw mapException(e);\n    } catch (ExecutionException e) {\n        throw mapException(e);\n    }\n}","classJavadoc":"/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.CancellationException;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */\n@Beta\npublic abstract class AbstractCheckedFuture<V, X extends Exception>\n    extends ForwardingListenableFuture.SimpleForwardingListenableFuture<V>\n    implements CheckedFuture<V, X> {\n  /**\n   * Constructs an {@code AbstractCheckedFuture} that wraps a delegate.\n   */\n  protected AbstractCheckedFuture(ListenableFuture<V> delegate) {\n    super(delegate);\n  }\n\n  /**\n   * Translates from an {@link InterruptedException},\n   * {@link CancellationException} or {@link ExecutionException} thrown by\n   * {@code get} to an exception of type {@code X} to be thrown by\n   * {@code checkedGet}. Subclasses must implement this method.\n   *\n   * <p>If {@code e} is an {@code InterruptedException}, the calling\n   * {@code checkedGet} method has already restored the interrupt after catching\n   * the exception. If an implementation of {@link #mapException(Exception)}\n   * wishes to swallow the interrupt, it can do so by calling\n   * {@link Thread#interrupted()}.\n   *\n   * <p>Subclasses may choose to throw, rather than return, a subclass of\n   * {@code RuntimeException} to allow creating a CheckedFuture that throws\n   * both checked and unchecked exceptions.\n   */\n  protected abstract X mapException(Exception e);\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */\n  @Override\n  public V checkedGet() throws X {\n    try {\n      return get();\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get(long, TimeUnit)} and maps that\n   * method's standard exceptions (excluding {@link TimeoutException}, which is\n   * propagated) to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   * @throws TimeoutException {@inheritDoc}\n   */\n  @Override\n  public V checkedGet(long timeout, TimeUnit unit) throws TimeoutException, X {\n    try {\n      return get(timeout, unit);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33599,"label":false,"oracleId":1499,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AbstractCheckedFuture","javadocTag":"","methodJavadoc":"    /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */","methodSourceCode":"public V checkedGet() throws X{\n    try {\n        return get();\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw mapException(e);\n    } catch (CancellationException e) {\n        throw mapException(e);\n    } catch (ExecutionException e) {\n        throw mapException(e);\n    }\n}","classJavadoc":"/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.CancellationException;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */\n@Beta\npublic abstract class AbstractCheckedFuture<V, X extends Exception>\n    extends ForwardingListenableFuture.SimpleForwardingListenableFuture<V>\n    implements CheckedFuture<V, X> {\n  /**\n   * Constructs an {@code AbstractCheckedFuture} that wraps a delegate.\n   */\n  protected AbstractCheckedFuture(ListenableFuture<V> delegate) {\n    super(delegate);\n  }\n\n  /**\n   * Translates from an {@link InterruptedException},\n   * {@link CancellationException} or {@link ExecutionException} thrown by\n   * {@code get} to an exception of type {@code X} to be thrown by\n   * {@code checkedGet}. Subclasses must implement this method.\n   *\n   * <p>If {@code e} is an {@code InterruptedException}, the calling\n   * {@code checkedGet} method has already restored the interrupt after catching\n   * the exception. If an implementation of {@link #mapException(Exception)}\n   * wishes to swallow the interrupt, it can do so by calling\n   * {@link Thread#interrupted()}.\n   *\n   * <p>Subclasses may choose to throw, rather than return, a subclass of\n   * {@code RuntimeException} to allow creating a CheckedFuture that throws\n   * both checked and unchecked exceptions.\n   */\n  protected abstract X mapException(Exception e);\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */\n  @Override\n  public V checkedGet() throws X {\n    try {\n      return get();\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get(long, TimeUnit)} and maps that\n   * method's standard exceptions (excluding {@link TimeoutException}, which is\n   * propagated) to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   * @throws TimeoutException {@inheritDoc}\n   */\n  @Override\n  public V checkedGet(long timeout, TimeUnit unit) throws TimeoutException, X {\n    try {\n      return get(timeout, unit);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33600,"label":false,"oracleId":1499,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AbstractCheckedFuture","javadocTag":"","methodJavadoc":"    /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */","methodSourceCode":"public V checkedGet() throws X{\n    try {\n        return get();\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw mapException(e);\n    } catch (CancellationException e) {\n        throw mapException(e);\n    } catch (ExecutionException e) {\n        throw mapException(e);\n    }\n}","classJavadoc":"/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.CancellationException;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */\n@Beta\npublic abstract class AbstractCheckedFuture<V, X extends Exception>\n    extends ForwardingListenableFuture.SimpleForwardingListenableFuture<V>\n    implements CheckedFuture<V, X> {\n  /**\n   * Constructs an {@code AbstractCheckedFuture} that wraps a delegate.\n   */\n  protected AbstractCheckedFuture(ListenableFuture<V> delegate) {\n    super(delegate);\n  }\n\n  /**\n   * Translates from an {@link InterruptedException},\n   * {@link CancellationException} or {@link ExecutionException} thrown by\n   * {@code get} to an exception of type {@code X} to be thrown by\n   * {@code checkedGet}. Subclasses must implement this method.\n   *\n   * <p>If {@code e} is an {@code InterruptedException}, the calling\n   * {@code checkedGet} method has already restored the interrupt after catching\n   * the exception. If an implementation of {@link #mapException(Exception)}\n   * wishes to swallow the interrupt, it can do so by calling\n   * {@link Thread#interrupted()}.\n   *\n   * <p>Subclasses may choose to throw, rather than return, a subclass of\n   * {@code RuntimeException} to allow creating a CheckedFuture that throws\n   * both checked and unchecked exceptions.\n   */\n  protected abstract X mapException(Exception e);\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */\n  @Override\n  public V checkedGet() throws X {\n    try {\n      return get();\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get(long, TimeUnit)} and maps that\n   * method's standard exceptions (excluding {@link TimeoutException}, which is\n   * propagated) to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   * @throws TimeoutException {@inheritDoc}\n   */\n  @Override\n  public V checkedGet(long timeout, TimeUnit unit) throws TimeoutException, X {\n    try {\n      return get(timeout, unit);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AbstractCheckedFuture"]},{"id":33601,"label":false,"oracleId":1499,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AbstractCheckedFuture","javadocTag":"","methodJavadoc":"    /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */","methodSourceCode":"public V checkedGet() throws X{\n    try {\n        return get();\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw mapException(e);\n    } catch (CancellationException e) {\n        throw mapException(e);\n    } catch (ExecutionException e) {\n        throw mapException(e);\n    }\n}","classJavadoc":"/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.CancellationException;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */\n@Beta\npublic abstract class AbstractCheckedFuture<V, X extends Exception>\n    extends ForwardingListenableFuture.SimpleForwardingListenableFuture<V>\n    implements CheckedFuture<V, X> {\n  /**\n   * Constructs an {@code AbstractCheckedFuture} that wraps a delegate.\n   */\n  protected AbstractCheckedFuture(ListenableFuture<V> delegate) {\n    super(delegate);\n  }\n\n  /**\n   * Translates from an {@link InterruptedException},\n   * {@link CancellationException} or {@link ExecutionException} thrown by\n   * {@code get} to an exception of type {@code X} to be thrown by\n   * {@code checkedGet}. Subclasses must implement this method.\n   *\n   * <p>If {@code e} is an {@code InterruptedException}, the calling\n   * {@code checkedGet} method has already restored the interrupt after catching\n   * the exception. If an implementation of {@link #mapException(Exception)}\n   * wishes to swallow the interrupt, it can do so by calling\n   * {@link Thread#interrupted()}.\n   *\n   * <p>Subclasses may choose to throw, rather than return, a subclass of\n   * {@code RuntimeException} to allow creating a CheckedFuture that throws\n   * both checked and unchecked exceptions.\n   */\n  protected abstract X mapException(Exception e);\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */\n  @Override\n  public V checkedGet() throws X {\n    try {\n      return get();\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get(long, TimeUnit)} and maps that\n   * method's standard exceptions (excluding {@link TimeoutException}, which is\n   * propagated) to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   * @throws TimeoutException {@inheritDoc}\n   */\n  @Override\n  public V checkedGet(long timeout, TimeUnit unit) throws TimeoutException, X {\n    try {\n      return get(timeout, unit);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33602,"label":true,"oracleId":1499,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AbstractCheckedFuture","javadocTag":"","methodJavadoc":"    /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */","methodSourceCode":"public V checkedGet() throws X{\n    try {\n        return get();\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw mapException(e);\n    } catch (CancellationException e) {\n        throw mapException(e);\n    } catch (ExecutionException e) {\n        throw mapException(e);\n    }\n}","classJavadoc":"/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.CancellationException;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */\n@Beta\npublic abstract class AbstractCheckedFuture<V, X extends Exception>\n    extends ForwardingListenableFuture.SimpleForwardingListenableFuture<V>\n    implements CheckedFuture<V, X> {\n  /**\n   * Constructs an {@code AbstractCheckedFuture} that wraps a delegate.\n   */\n  protected AbstractCheckedFuture(ListenableFuture<V> delegate) {\n    super(delegate);\n  }\n\n  /**\n   * Translates from an {@link InterruptedException},\n   * {@link CancellationException} or {@link ExecutionException} thrown by\n   * {@code get} to an exception of type {@code X} to be thrown by\n   * {@code checkedGet}. Subclasses must implement this method.\n   *\n   * <p>If {@code e} is an {@code InterruptedException}, the calling\n   * {@code checkedGet} method has already restored the interrupt after catching\n   * the exception. If an implementation of {@link #mapException(Exception)}\n   * wishes to swallow the interrupt, it can do so by calling\n   * {@link Thread#interrupted()}.\n   *\n   * <p>Subclasses may choose to throw, rather than return, a subclass of\n   * {@code RuntimeException} to allow creating a CheckedFuture that throws\n   * both checked and unchecked exceptions.\n   */\n  protected abstract X mapException(Exception e);\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */\n  @Override\n  public V checkedGet() throws X {\n    try {\n      return get();\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get(long, TimeUnit)} and maps that\n   * method's standard exceptions (excluding {@link TimeoutException}, which is\n   * propagated) to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   * @throws TimeoutException {@inheritDoc}\n   */\n  @Override\n  public V checkedGet(long timeout, TimeUnit unit) throws TimeoutException, X {\n    try {\n      return get(timeout, unit);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33603,"label":false,"oracleId":1499,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AbstractCheckedFuture","javadocTag":"","methodJavadoc":"    /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */","methodSourceCode":"public V checkedGet() throws X{\n    try {\n        return get();\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw mapException(e);\n    } catch (CancellationException e) {\n        throw mapException(e);\n    } catch (ExecutionException e) {\n        throw mapException(e);\n    }\n}","classJavadoc":"/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.CancellationException;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */\n@Beta\npublic abstract class AbstractCheckedFuture<V, X extends Exception>\n    extends ForwardingListenableFuture.SimpleForwardingListenableFuture<V>\n    implements CheckedFuture<V, X> {\n  /**\n   * Constructs an {@code AbstractCheckedFuture} that wraps a delegate.\n   */\n  protected AbstractCheckedFuture(ListenableFuture<V> delegate) {\n    super(delegate);\n  }\n\n  /**\n   * Translates from an {@link InterruptedException},\n   * {@link CancellationException} or {@link ExecutionException} thrown by\n   * {@code get} to an exception of type {@code X} to be thrown by\n   * {@code checkedGet}. Subclasses must implement this method.\n   *\n   * <p>If {@code e} is an {@code InterruptedException}, the calling\n   * {@code checkedGet} method has already restored the interrupt after catching\n   * the exception. If an implementation of {@link #mapException(Exception)}\n   * wishes to swallow the interrupt, it can do so by calling\n   * {@link Thread#interrupted()}.\n   *\n   * <p>Subclasses may choose to throw, rather than return, a subclass of\n   * {@code RuntimeException} to allow creating a CheckedFuture that throws\n   * both checked and unchecked exceptions.\n   */\n  protected abstract X mapException(Exception e);\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */\n  @Override\n  public V checkedGet() throws X {\n    try {\n      return get();\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get(long, TimeUnit)} and maps that\n   * method's standard exceptions (excluding {@link TimeoutException}, which is\n   * propagated) to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   * @throws TimeoutException {@inheritDoc}\n   */\n  @Override\n  public V checkedGet(long timeout, TimeUnit unit) throws TimeoutException, X {\n    try {\n      return get(timeout, unit);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]},{"id":33604,"label":false,"oracleId":1499,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AbstractCheckedFuture","javadocTag":"@throws X if calling {@link #get()} results in an exception such as {@link InterruptedException}.\n        {@link CancellationException}. or {@link ExecutionException}","methodJavadoc":"    /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */","methodSourceCode":"public V checkedGet() throws X{\n    try {\n        return get();\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw mapException(e);\n    } catch (CancellationException e) {\n        throw mapException(e);\n    } catch (ExecutionException e) {\n        throw mapException(e);\n    }\n}","classJavadoc":"/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.CancellationException;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */\n@Beta\npublic abstract class AbstractCheckedFuture<V, X extends Exception>\n    extends ForwardingListenableFuture.SimpleForwardingListenableFuture<V>\n    implements CheckedFuture<V, X> {\n  /**\n   * Constructs an {@code AbstractCheckedFuture} that wraps a delegate.\n   */\n  protected AbstractCheckedFuture(ListenableFuture<V> delegate) {\n    super(delegate);\n  }\n\n  /**\n   * Translates from an {@link InterruptedException},\n   * {@link CancellationException} or {@link ExecutionException} thrown by\n   * {@code get} to an exception of type {@code X} to be thrown by\n   * {@code checkedGet}. Subclasses must implement this method.\n   *\n   * <p>If {@code e} is an {@code InterruptedException}, the calling\n   * {@code checkedGet} method has already restored the interrupt after catching\n   * the exception. If an implementation of {@link #mapException(Exception)}\n   * wishes to swallow the interrupt, it can do so by calling\n   * {@link Thread#interrupted()}.\n   *\n   * <p>Subclasses may choose to throw, rather than return, a subclass of\n   * {@code RuntimeException} to allow creating a CheckedFuture that throws\n   * both checked and unchecked exceptions.\n   */\n  protected abstract X mapException(Exception e);\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */\n  @Override\n  public V checkedGet() throws X {\n    try {\n      return get();\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get(long, TimeUnit)} and maps that\n   * method's standard exceptions (excluding {@link TimeoutException}, which is\n   * propagated) to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   * @throws TimeoutException {@inheritDoc}\n   */\n  @Override\n  public V checkedGet(long timeout, TimeUnit unit) throws TimeoutException, X {\n    try {\n      return get(timeout, unit);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CharEscaper","tokenClass":"Class","tokenInfo":["com.google.common.escape","CharEscaper"]},{"id":33605,"label":false,"oracleId":1499,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AbstractCheckedFuture","javadocTag":"@throws X if calling {@link #get()} results in an exception such as {@link InterruptedException}.\n        {@link CancellationException}. or {@link ExecutionException}","methodJavadoc":"    /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */","methodSourceCode":"public V checkedGet() throws X{\n    try {\n        return get();\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw mapException(e);\n    } catch (CancellationException e) {\n        throw mapException(e);\n    } catch (ExecutionException e) {\n        throw mapException(e);\n    }\n}","classJavadoc":"/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.CancellationException;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */\n@Beta\npublic abstract class AbstractCheckedFuture<V, X extends Exception>\n    extends ForwardingListenableFuture.SimpleForwardingListenableFuture<V>\n    implements CheckedFuture<V, X> {\n  /**\n   * Constructs an {@code AbstractCheckedFuture} that wraps a delegate.\n   */\n  protected AbstractCheckedFuture(ListenableFuture<V> delegate) {\n    super(delegate);\n  }\n\n  /**\n   * Translates from an {@link InterruptedException},\n   * {@link CancellationException} or {@link ExecutionException} thrown by\n   * {@code get} to an exception of type {@code X} to be thrown by\n   * {@code checkedGet}. Subclasses must implement this method.\n   *\n   * <p>If {@code e} is an {@code InterruptedException}, the calling\n   * {@code checkedGet} method has already restored the interrupt after catching\n   * the exception. If an implementation of {@link #mapException(Exception)}\n   * wishes to swallow the interrupt, it can do so by calling\n   * {@link Thread#interrupted()}.\n   *\n   * <p>Subclasses may choose to throw, rather than return, a subclass of\n   * {@code RuntimeException} to allow creating a CheckedFuture that throws\n   * both checked and unchecked exceptions.\n   */\n  protected abstract X mapException(Exception e);\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */\n  @Override\n  public V checkedGet() throws X {\n    try {\n      return get();\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get(long, TimeUnit)} and maps that\n   * method's standard exceptions (excluding {@link TimeoutException}, which is\n   * propagated) to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   * @throws TimeoutException {@inheritDoc}\n   */\n  @Override\n  public V checkedGet(long timeout, TimeUnit unit) throws TimeoutException, X {\n    try {\n      return get(timeout, unit);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"this","tokenClass":"This","tokenInfo":["com.google.common.util.concurrent","AbstractCheckedFuture"]},{"id":33606,"label":false,"oracleId":1499,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AbstractCheckedFuture","javadocTag":"@throws X if calling {@link #get()} results in an exception such as {@link InterruptedException}.\n        {@link CancellationException}. or {@link ExecutionException}","methodJavadoc":"    /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */","methodSourceCode":"public V checkedGet() throws X{\n    try {\n        return get();\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw mapException(e);\n    } catch (CancellationException e) {\n        throw mapException(e);\n    } catch (ExecutionException e) {\n        throw mapException(e);\n    }\n}","classJavadoc":"/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.CancellationException;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */\n@Beta\npublic abstract class AbstractCheckedFuture<V, X extends Exception>\n    extends ForwardingListenableFuture.SimpleForwardingListenableFuture<V>\n    implements CheckedFuture<V, X> {\n  /**\n   * Constructs an {@code AbstractCheckedFuture} that wraps a delegate.\n   */\n  protected AbstractCheckedFuture(ListenableFuture<V> delegate) {\n    super(delegate);\n  }\n\n  /**\n   * Translates from an {@link InterruptedException},\n   * {@link CancellationException} or {@link ExecutionException} thrown by\n   * {@code get} to an exception of type {@code X} to be thrown by\n   * {@code checkedGet}. Subclasses must implement this method.\n   *\n   * <p>If {@code e} is an {@code InterruptedException}, the calling\n   * {@code checkedGet} method has already restored the interrupt after catching\n   * the exception. If an implementation of {@link #mapException(Exception)}\n   * wishes to swallow the interrupt, it can do so by calling\n   * {@link Thread#interrupted()}.\n   *\n   * <p>Subclasses may choose to throw, rather than return, a subclass of\n   * {@code RuntimeException} to allow creating a CheckedFuture that throws\n   * both checked and unchecked exceptions.\n   */\n  protected abstract X mapException(Exception e);\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */\n  @Override\n  public V checkedGet() throws X {\n    try {\n      return get();\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get(long, TimeUnit)} and maps that\n   * method's standard exceptions (excluding {@link TimeoutException}, which is\n   * propagated) to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   * @throws TimeoutException {@inheritDoc}\n   */\n  @Override\n  public V checkedGet(long timeout, TimeUnit unit) throws TimeoutException, X {\n    try {\n      return get(timeout, unit);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"true","tokenClass":"TRUE","tokenInfo":[]},{"id":33607,"label":true,"oracleId":1499,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AbstractCheckedFuture","javadocTag":"@throws X if calling {@link #get()} results in an exception such as {@link InterruptedException}.\n        {@link CancellationException}. or {@link ExecutionException}","methodJavadoc":"    /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */","methodSourceCode":"public V checkedGet() throws X{\n    try {\n        return get();\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw mapException(e);\n    } catch (CancellationException e) {\n        throw mapException(e);\n    } catch (ExecutionException e) {\n        throw mapException(e);\n    }\n}","classJavadoc":"/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.CancellationException;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */\n@Beta\npublic abstract class AbstractCheckedFuture<V, X extends Exception>\n    extends ForwardingListenableFuture.SimpleForwardingListenableFuture<V>\n    implements CheckedFuture<V, X> {\n  /**\n   * Constructs an {@code AbstractCheckedFuture} that wraps a delegate.\n   */\n  protected AbstractCheckedFuture(ListenableFuture<V> delegate) {\n    super(delegate);\n  }\n\n  /**\n   * Translates from an {@link InterruptedException},\n   * {@link CancellationException} or {@link ExecutionException} thrown by\n   * {@code get} to an exception of type {@code X} to be thrown by\n   * {@code checkedGet}. Subclasses must implement this method.\n   *\n   * <p>If {@code e} is an {@code InterruptedException}, the calling\n   * {@code checkedGet} method has already restored the interrupt after catching\n   * the exception. If an implementation of {@link #mapException(Exception)}\n   * wishes to swallow the interrupt, it can do so by calling\n   * {@link Thread#interrupted()}.\n   *\n   * <p>Subclasses may choose to throw, rather than return, a subclass of\n   * {@code RuntimeException} to allow creating a CheckedFuture that throws\n   * both checked and unchecked exceptions.\n   */\n  protected abstract X mapException(Exception e);\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */\n  @Override\n  public V checkedGet() throws X {\n    try {\n      return get();\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get(long, TimeUnit)} and maps that\n   * method's standard exceptions (excluding {@link TimeoutException}, which is\n   * propagated) to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   * @throws TimeoutException {@inheritDoc}\n   */\n  @Override\n  public V checkedGet(long timeout, TimeUnit unit) throws TimeoutException, X {\n    try {\n      return get(timeout, unit);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":33608,"label":false,"oracleId":1499,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AbstractCheckedFuture","javadocTag":"@throws X if calling {@link #get()} results in an exception such as {@link InterruptedException}.\n        {@link CancellationException}. or {@link ExecutionException}","methodJavadoc":"    /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */","methodSourceCode":"public V checkedGet() throws X{\n    try {\n        return get();\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw mapException(e);\n    } catch (CancellationException e) {\n        throw mapException(e);\n    } catch (ExecutionException e) {\n        throw mapException(e);\n    }\n}","classJavadoc":"/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.CancellationException;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */\n@Beta\npublic abstract class AbstractCheckedFuture<V, X extends Exception>\n    extends ForwardingListenableFuture.SimpleForwardingListenableFuture<V>\n    implements CheckedFuture<V, X> {\n  /**\n   * Constructs an {@code AbstractCheckedFuture} that wraps a delegate.\n   */\n  protected AbstractCheckedFuture(ListenableFuture<V> delegate) {\n    super(delegate);\n  }\n\n  /**\n   * Translates from an {@link InterruptedException},\n   * {@link CancellationException} or {@link ExecutionException} thrown by\n   * {@code get} to an exception of type {@code X} to be thrown by\n   * {@code checkedGet}. Subclasses must implement this method.\n   *\n   * <p>If {@code e} is an {@code InterruptedException}, the calling\n   * {@code checkedGet} method has already restored the interrupt after catching\n   * the exception. If an implementation of {@link #mapException(Exception)}\n   * wishes to swallow the interrupt, it can do so by calling\n   * {@link Thread#interrupted()}.\n   *\n   * <p>Subclasses may choose to throw, rather than return, a subclass of\n   * {@code RuntimeException} to allow creating a CheckedFuture that throws\n   * both checked and unchecked exceptions.\n   */\n  protected abstract X mapException(Exception e);\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */\n  @Override\n  public V checkedGet() throws X {\n    try {\n      return get();\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get(long, TimeUnit)} and maps that\n   * method's standard exceptions (excluding {@link TimeoutException}, which is\n   * propagated) to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   * @throws TimeoutException {@inheritDoc}\n   */\n  @Override\n  public V checkedGet(long timeout, TimeUnit unit) throws TimeoutException, X {\n    try {\n      return get(timeout, unit);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]}]