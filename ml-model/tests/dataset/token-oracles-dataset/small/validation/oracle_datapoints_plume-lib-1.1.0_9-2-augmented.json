[ {
  "id" : 10912,
  "oracle" : ";",
  "oracleType" : "NORMAL_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "ArraysMDE",
  "javadocTag" : "@return true iff a does not contain duplicate elements",
  "methodJavadoc" : "    /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */",
  "methodSourceCode" : "public static /*@Pure*/\nboolean noDuplicates(char[] a){\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Character n = new Character(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}",
  "classJavadoc" : "/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Vector;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\nimport org.checkerframework.framework.qual.PolyAll;\n*/\n\n/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */\n@SuppressWarnings(\"interning\") // to do later\npublic final class ArraysMDE {\n  /** This class is a collecton of methods; it does not represent anything. */\n  private ArraysMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// min, max\n  ///\n\n  // Could also add linear-time orderStatistics if I liked.\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int min(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long min(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double min(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer min(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long min(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() < result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double min(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int max(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long max(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double max(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer max(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long max(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() > result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double max(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int[] min_max(int[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] {result_min, result_max};\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long[] min_max(long[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] {result_min, result_max};\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int element_range(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long element_range(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Returns the sum of an array of integers.\n   * @param a an array\n   * @return the sum of an array of integers\n   */\n  public static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of integers.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of integers\n   */\n  public static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of an array of doubles.\n   * @param a an array\n   * @return the sum of an array of doubles\n   */\n  public static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of doubles.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of doubles\n   */\n  public static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf\n  ///\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> type of the elements of the array\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt) {\n    if (elt == null) {\n      return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> the type of the elements\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   *    Identical to List.indexOf, but included for completeness.\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    return a.indexOf(elt);\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a.get(i))) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      /*@PolyNull*/ Object[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.size(); i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf, for finding subarrays\n  ///\n\n  // This is analogous to Common Lisp's \"search\" function.\n\n  // This implementation is very inefficient; I could use tricky Boyer-Moore\n  // search techniques if I liked, but it's not worth it to me yet.\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  // The signature on this method is unnecessarily strict because it\n  // requires that the component types be identical.  The signature should\n  // be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n  // @PolyAll qualifier does not yet take an argument.\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// mismatch\n  ///\n\n  // This is analogous to Common Lisp's \"mismatch\" function.\n\n  // Put it off until later; for now, use the simpler subarray function,\n  // which is a specialization of mismatch,\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray extraction\n  ///\n\n  // Note that the second argument is a length, not an end position.\n  // That's to avoid confusion over whether it would be the last included\n  // index or the first non-included index.\n\n  /**\n   * Return a subarray of the given array.\n   * @return a subarray of the given array\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ Object[] subarray(\n      /*@PolyAll*/ Object[] a, int startindex, int length) {\n    /*@PolyAll*/ Object[] result = new /*@PolyAll*/ Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a sublist of the given list.\n   * @param <T> type of the elements\n   * @param a the original list\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a sublist of the given list\n   */\n  /*@SideEffectFree*/\n  public static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ String[] subarray(\n      /*@PolyAll*/ String[] a, int startindex, int length) {\n    /*@PolyAll*/ String[] result = new /*@PolyAll*/ String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray testing\n  ///\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(\n      /*@PolyAll*/ Object[] a, /*@PolyNull*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(\n      /*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// concatenation\n  ///\n\n  // Concat used to return null if both arguments are null.  That is\n  // convenient for the implementer, but not so good for clients.\n\n  /**\n   * Call this method in order to suppress compiler warnings.\n   * @param <T> the base type of the result\n   * @param lst the list to convert to an array\n   * @return the result of lst.toArray, casted to a more precise type than Object[]\n   */\n  private static <T> T[] toTArray(List<T> lst) {\n    @SuppressWarnings(\"unchecked\")\n    T[] asArray = (T[]) lst.toArray();\n    return asArray;\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.size()];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        // System.arraycopy(b, 0, result, a.length, b.size());\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.length] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.length];\n\n        // System.arraycopy(a, 0, result, 0, a.size());\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        System.arraycopy(b, 0, result, a.size(), b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.size()];\n\n        // System.arraycopy(a, 0, result, 0, a.length);\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        // System.arraycopy(b, 0, result, a.length, b.length);\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.size()] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  // Note: PolyAll is not quite right.  Need to review.\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first array to concatenate\n   * @param b the second array to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static /*@PolyAll*/ String[] concat(\n      /*@PolyAll*/ String /*@Nullable*/ [] a, /*@PolyAll*/ String /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new String[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        /*@PolyAll*/ String[] result = new String[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static byte[] concat(byte /*@Nullable*/ [] a, byte /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new byte[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        byte[] result = new byte[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static boolean[] concat(boolean /*@Nullable*/ [] a, boolean /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new boolean[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        boolean[] result = new boolean[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static char[] concat(char /*@Nullable*/ [] a, char /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new char[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        char[] result = new char[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static double[] concat(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new double[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        double[] result = new double[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static float[] concat(float /*@Nullable*/ [] a, float /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new float[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        float[] result = new float[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static int[] concat(int /*@Nullable*/ [] a, int /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new int[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        int[] result = new int[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static long[] concat(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new long[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        long[] result = new long[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static short[] concat(short /*@Nullable*/ [] a, short /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new short[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        short[] result = new short[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Printing\n  ///\n\n  // This should be extended to all types, when I get around to it.  The\n  // methods are patterned after that of java.util.Vector (and use its\n  // output format).\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, each element is quoted like a Java String.\n   * @param a an array\n   * @return a string representation of the array, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, if quoted is true, then each element is quoted like a Java String.\n   * @param a an array\n   * @param quoted whether to quote the array elements\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        if (quoted && a[i] instanceof String) {\n          String elt = (String) a[i];\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava(elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(a[i]);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@Nullable*/ Collection<?> a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @param quoted whether to quote the collection elements that are Java strings\n   * @return a string representation of the list\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n      Iterator<?> itor = a.iterator();\n      sb.append(itor.next());\n      while (itor.hasNext()) {\n        sb.append(\", \");\n        Object elt = itor.next();\n        if (quoted && elt instanceof String) {\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava((String) elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(elt);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(int /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(long /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(double /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(float /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(boolean /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls the appropriate\n   * toString() method.  Only call this method if obj is a boolean, double,\n   * int, long, or Object array.\n   * @param obj an array\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@SideEffectFree*/\n  public static String toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n      return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n      return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n      return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n      return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n      return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n      return toString((List<?>) obj);\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls .length.\n   * Only call this method if obj is a boolean, double, int, long, or Object array.\n   * @param obj a list\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@Pure*/\n  public static int length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n      return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n      return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n      return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n      return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n      return ((List<?>) obj).size();\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Sortedness\n  ///\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Boolean n = Boolean.valueOf(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Byte n = new Byte(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Character n = new Character(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Float n = new Float(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Short n = new Short(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Integer n = new Integer(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space. Equality checking\n   * uses the .equals() method for java.lang.Double.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Double n = new Double(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Long n = new Long(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param <T> the type of the elements\n   * @param a a list\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static <T> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n      if (hs.contains(a.get(i))) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a.get(i));\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Arrays as partial functions of int->int\n  ///\n\n  /**\n   * Returns true if the array is a permutation of [0..a.length).\n   * @param a an array, representing a function\n   * @return true iff all elements of a are in [0..a.length) and a\n   * contains no duplicates.\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (array)\n  /*@Pure*/\n  public static boolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int n = a[i];\n      if (n < 0 || n >= a.length || see[n]) {\n        return false;\n      }\n      see[n] = true;\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff the array does not contain -1.\n   * @param a an array, representing a function\n   * @return true iff no element of a maps to -1\n   */\n  /*@Pure*/\n  public static boolean fn_is_total(int[] a) {\n    return indexOf(a, -1) == -1; // not found\n  }\n\n  /**\n   * Return an array [0..lenth).\n   * @param length the length of the result\n   * @return fresh array that is the identity function of the given length\n   */\n  public static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n      result[i] = i;\n    }\n    return result;\n  }\n\n  /**\n   * Requires that fn_is_permutation(a) holds.\n   * @param a the input permutation\n   * @return fresh array which is the inverse of the given permutation\n   * @see #fn_is_permutation(int[])\n   */\n  public static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n  }\n\n  /**\n   * Return the inverse of the given function, which is represented as an array.\n   * @param a an array representing a function from [0..a.length) to [0..arange);\n   *  each element of a is between 0 and arange inclusive\n   * @param arange length of the argument's range and the result's domain\n   * @return function from [0..arange) to [0..a.length) that is the inverse of a\n   * @throws IllegalArgumentException if a value of a is outside of arange\n   * @exception UnsupportedOperationException when the function is not invertible\n   */\n  public static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n      int ai = a[i];\n      if (ai < -1 || ai >= arange) {\n        throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n      }\n      // ai is either -1 or a valid index\n      if (ai >= 0) {\n        if (result[ai] != -1) {\n          throw new UnsupportedOperationException(\n              String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n        }\n        result[ai] = i;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the composition of the given two functions, all of which are\n   * represented as arrays.\n   * @param a function from [0..a.length) to [0..b.length)\n   * @param b function from [0..b.length) to range R\n   * @return function from [0..a.length) to range R that is the\n   * composition of a and b\n   */\n  public static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int inner = a[i];\n      if (inner == -1) {\n        result[i] = -1;\n      } else {\n        result[i] = b[inner];\n      }\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set operations, such as subset, unions, and intersections\n  ///\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Long(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Long elt = new Long(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Double(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Double elt = new Double(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(bigger[i]);\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      if (!setBigger.contains(smaller[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array comparators\n  ///\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLexical implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer,\n     * depending on whether the first argument is less than,\n     * equal to, or greater than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLexical implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class DoubleArrayComparatorLexical\n      implements Comparator<double[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(double[] a1, double[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int result = Double.compare(a1[i], a2[i]);\n        if (result != 0) {\n          return (result);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * Strings).\n   */\n  public static final class StringArrayComparatorLexical\n      implements Comparator<String[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) String[], @PolyAll(2) String[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ String[] a1, /*@PolyAll*/ String[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int tmp = 0;\n        if ((a1[i] == null) && (a2[i] == null)) {\n          tmp = 0;\n        } else if (a1[i] == null) {\n          tmp = -1;\n        } else if (a2[i] == null) {\n          tmp = 1;\n        } else {\n          tmp = a1[i].compareTo(a2[i]);\n        }\n        if (tmp != 0) {\n          return (tmp);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLexical<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLexical\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLengthFirst\n      implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLengthFirst\n      implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int lendiff = a1.length - a2.length;\n      if (lendiff != 0) {\n        return lendiff;\n      }\n      long tmp;\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLengthFirst<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLengthFirst\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// nullness\n  ///\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(/*@PolyAll*/ Object[] a) {\n    if (a.length == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(/*@PolyAll*/ Object[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (!(a[i] == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n      if (!(a.get(i) == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// javadoc hacks\n  ///\n\n  // Without this, the Javadoc mentions of \"java.util.Vector\", are not links\n  // in the generated HTML.\n  // \"private static Vector v;\" doesn't work, nor does\n  // \"static { new java.util.Vector(); }\", nor does \"private Vector v\".\n  // Yuck!\n  public Vector<?> javadocLossage;\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "a", "", "char[]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "", "char[]", "public boolean equals(Object);" ], [ "toString", "", "char[]", "public String toString()" ], [ "hashCode", "", "char[]", "public native int hashCode()" ], [ "getClass", "", "char[]", "public final native Class getClass();" ], [ "clone", "", "char[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "javadocLossage", "plume", "ArraysMDE", "public Vector<?> javadocLossage;" ], [ "length", "", "char[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10912,
  "oracle" : ";",
  "oracleType" : "NORMAL_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "ArraysMDE",
  "javadocTag" : "",
  "methodJavadoc" : "    /**\n     * Return true iff a does not contain duplicate elements,\n     * using O(n) time and O(n) space.\n     * \n     * @param a an array\n     */",
  "methodSourceCode" : "public static /*@Pure*/\nboolean noDuplicates(char[] a){\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Character n = new Character(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}",
  "classJavadoc" : "/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Vector;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\nimport org.checkerframework.framework.qual.PolyAll;\n*/\n\n/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */\n@SuppressWarnings(\"interning\") // to do later\npublic final class ArraysMDE {\n  /** This class is a collecton of methods; it does not represent anything. */\n  private ArraysMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// min, max\n  ///\n\n  // Could also add linear-time orderStatistics if I liked.\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int min(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long min(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double min(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer min(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long min(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() < result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double min(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int max(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long max(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double max(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer max(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long max(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() > result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double max(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int[] min_max(int[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] {result_min, result_max};\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long[] min_max(long[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] {result_min, result_max};\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int element_range(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long element_range(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Returns the sum of an array of integers.\n   * @param a an array\n   * @return the sum of an array of integers\n   */\n  public static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of integers.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of integers\n   */\n  public static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of an array of doubles.\n   * @param a an array\n   * @return the sum of an array of doubles\n   */\n  public static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of doubles.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of doubles\n   */\n  public static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf\n  ///\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> type of the elements of the array\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt) {\n    if (elt == null) {\n      return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> the type of the elements\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   *    Identical to List.indexOf, but included for completeness.\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    return a.indexOf(elt);\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a.get(i))) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      /*@PolyNull*/ Object[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.size(); i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf, for finding subarrays\n  ///\n\n  // This is analogous to Common Lisp's \"search\" function.\n\n  // This implementation is very inefficient; I could use tricky Boyer-Moore\n  // search techniques if I liked, but it's not worth it to me yet.\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  // The signature on this method is unnecessarily strict because it\n  // requires that the component types be identical.  The signature should\n  // be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n  // @PolyAll qualifier does not yet take an argument.\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// mismatch\n  ///\n\n  // This is analogous to Common Lisp's \"mismatch\" function.\n\n  // Put it off until later; for now, use the simpler subarray function,\n  // which is a specialization of mismatch,\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray extraction\n  ///\n\n  // Note that the second argument is a length, not an end position.\n  // That's to avoid confusion over whether it would be the last included\n  // index or the first non-included index.\n\n  /**\n   * Return a subarray of the given array.\n   * @return a subarray of the given array\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ Object[] subarray(\n      /*@PolyAll*/ Object[] a, int startindex, int length) {\n    /*@PolyAll*/ Object[] result = new /*@PolyAll*/ Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a sublist of the given list.\n   * @param <T> type of the elements\n   * @param a the original list\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a sublist of the given list\n   */\n  /*@SideEffectFree*/\n  public static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ String[] subarray(\n      /*@PolyAll*/ String[] a, int startindex, int length) {\n    /*@PolyAll*/ String[] result = new /*@PolyAll*/ String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray testing\n  ///\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(\n      /*@PolyAll*/ Object[] a, /*@PolyNull*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(\n      /*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// concatenation\n  ///\n\n  // Concat used to return null if both arguments are null.  That is\n  // convenient for the implementer, but not so good for clients.\n\n  /**\n   * Call this method in order to suppress compiler warnings.\n   * @param <T> the base type of the result\n   * @param lst the list to convert to an array\n   * @return the result of lst.toArray, casted to a more precise type than Object[]\n   */\n  private static <T> T[] toTArray(List<T> lst) {\n    @SuppressWarnings(\"unchecked\")\n    T[] asArray = (T[]) lst.toArray();\n    return asArray;\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.size()];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        // System.arraycopy(b, 0, result, a.length, b.size());\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.length] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.length];\n\n        // System.arraycopy(a, 0, result, 0, a.size());\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        System.arraycopy(b, 0, result, a.size(), b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.size()];\n\n        // System.arraycopy(a, 0, result, 0, a.length);\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        // System.arraycopy(b, 0, result, a.length, b.length);\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.size()] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  // Note: PolyAll is not quite right.  Need to review.\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first array to concatenate\n   * @param b the second array to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static /*@PolyAll*/ String[] concat(\n      /*@PolyAll*/ String /*@Nullable*/ [] a, /*@PolyAll*/ String /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new String[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        /*@PolyAll*/ String[] result = new String[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static byte[] concat(byte /*@Nullable*/ [] a, byte /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new byte[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        byte[] result = new byte[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static boolean[] concat(boolean /*@Nullable*/ [] a, boolean /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new boolean[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        boolean[] result = new boolean[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static char[] concat(char /*@Nullable*/ [] a, char /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new char[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        char[] result = new char[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static double[] concat(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new double[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        double[] result = new double[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static float[] concat(float /*@Nullable*/ [] a, float /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new float[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        float[] result = new float[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static int[] concat(int /*@Nullable*/ [] a, int /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new int[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        int[] result = new int[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static long[] concat(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new long[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        long[] result = new long[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static short[] concat(short /*@Nullable*/ [] a, short /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new short[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        short[] result = new short[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Printing\n  ///\n\n  // This should be extended to all types, when I get around to it.  The\n  // methods are patterned after that of java.util.Vector (and use its\n  // output format).\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, each element is quoted like a Java String.\n   * @param a an array\n   * @return a string representation of the array, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, if quoted is true, then each element is quoted like a Java String.\n   * @param a an array\n   * @param quoted whether to quote the array elements\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        if (quoted && a[i] instanceof String) {\n          String elt = (String) a[i];\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava(elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(a[i]);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@Nullable*/ Collection<?> a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @param quoted whether to quote the collection elements that are Java strings\n   * @return a string representation of the list\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n      Iterator<?> itor = a.iterator();\n      sb.append(itor.next());\n      while (itor.hasNext()) {\n        sb.append(\", \");\n        Object elt = itor.next();\n        if (quoted && elt instanceof String) {\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava((String) elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(elt);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(int /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(long /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(double /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(float /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(boolean /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls the appropriate\n   * toString() method.  Only call this method if obj is a boolean, double,\n   * int, long, or Object array.\n   * @param obj an array\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@SideEffectFree*/\n  public static String toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n      return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n      return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n      return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n      return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n      return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n      return toString((List<?>) obj);\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls .length.\n   * Only call this method if obj is a boolean, double, int, long, or Object array.\n   * @param obj a list\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@Pure*/\n  public static int length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n      return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n      return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n      return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n      return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n      return ((List<?>) obj).size();\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Sortedness\n  ///\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Boolean n = Boolean.valueOf(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Byte n = new Byte(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Character n = new Character(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Float n = new Float(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Short n = new Short(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Integer n = new Integer(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space. Equality checking\n   * uses the .equals() method for java.lang.Double.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Double n = new Double(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Long n = new Long(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param <T> the type of the elements\n   * @param a a list\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static <T> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n      if (hs.contains(a.get(i))) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a.get(i));\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Arrays as partial functions of int->int\n  ///\n\n  /**\n   * Returns true if the array is a permutation of [0..a.length).\n   * @param a an array, representing a function\n   * @return true iff all elements of a are in [0..a.length) and a\n   * contains no duplicates.\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (array)\n  /*@Pure*/\n  public static boolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int n = a[i];\n      if (n < 0 || n >= a.length || see[n]) {\n        return false;\n      }\n      see[n] = true;\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff the array does not contain -1.\n   * @param a an array, representing a function\n   * @return true iff no element of a maps to -1\n   */\n  /*@Pure*/\n  public static boolean fn_is_total(int[] a) {\n    return indexOf(a, -1) == -1; // not found\n  }\n\n  /**\n   * Return an array [0..lenth).\n   * @param length the length of the result\n   * @return fresh array that is the identity function of the given length\n   */\n  public static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n      result[i] = i;\n    }\n    return result;\n  }\n\n  /**\n   * Requires that fn_is_permutation(a) holds.\n   * @param a the input permutation\n   * @return fresh array which is the inverse of the given permutation\n   * @see #fn_is_permutation(int[])\n   */\n  public static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n  }\n\n  /**\n   * Return the inverse of the given function, which is represented as an array.\n   * @param a an array representing a function from [0..a.length) to [0..arange);\n   *  each element of a is between 0 and arange inclusive\n   * @param arange length of the argument's range and the result's domain\n   * @return function from [0..arange) to [0..a.length) that is the inverse of a\n   * @throws IllegalArgumentException if a value of a is outside of arange\n   * @exception UnsupportedOperationException when the function is not invertible\n   */\n  public static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n      int ai = a[i];\n      if (ai < -1 || ai >= arange) {\n        throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n      }\n      // ai is either -1 or a valid index\n      if (ai >= 0) {\n        if (result[ai] != -1) {\n          throw new UnsupportedOperationException(\n              String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n        }\n        result[ai] = i;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the composition of the given two functions, all of which are\n   * represented as arrays.\n   * @param a function from [0..a.length) to [0..b.length)\n   * @param b function from [0..b.length) to range R\n   * @return function from [0..a.length) to range R that is the\n   * composition of a and b\n   */\n  public static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int inner = a[i];\n      if (inner == -1) {\n        result[i] = -1;\n      } else {\n        result[i] = b[inner];\n      }\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set operations, such as subset, unions, and intersections\n  ///\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Long(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Long elt = new Long(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Double(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Double elt = new Double(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(bigger[i]);\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      if (!setBigger.contains(smaller[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array comparators\n  ///\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLexical implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer,\n     * depending on whether the first argument is less than,\n     * equal to, or greater than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLexical implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class DoubleArrayComparatorLexical\n      implements Comparator<double[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(double[] a1, double[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int result = Double.compare(a1[i], a2[i]);\n        if (result != 0) {\n          return (result);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * Strings).\n   */\n  public static final class StringArrayComparatorLexical\n      implements Comparator<String[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) String[], @PolyAll(2) String[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ String[] a1, /*@PolyAll*/ String[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int tmp = 0;\n        if ((a1[i] == null) && (a2[i] == null)) {\n          tmp = 0;\n        } else if (a1[i] == null) {\n          tmp = -1;\n        } else if (a2[i] == null) {\n          tmp = 1;\n        } else {\n          tmp = a1[i].compareTo(a2[i]);\n        }\n        if (tmp != 0) {\n          return (tmp);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLexical<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLexical\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLengthFirst\n      implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLengthFirst\n      implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int lendiff = a1.length - a2.length;\n      if (lendiff != 0) {\n        return lendiff;\n      }\n      long tmp;\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLengthFirst<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLengthFirst\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// nullness\n  ///\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(/*@PolyAll*/ Object[] a) {\n    if (a.length == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(/*@PolyAll*/ Object[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (!(a[i] == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n      if (!(a.get(i) == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// javadoc hacks\n  ///\n\n  // Without this, the Javadoc mentions of \"java.util.Vector\", are not links\n  // in the generated HTML.\n  // \"private static Vector v;\" doesn't work, nor does\n  // \"static { new java.util.Vector(); }\", nor does \"private Vector v\".\n  // Yuck!\n  public Vector<?> javadocLossage;\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "a", "", "char[]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "", "char[]", "public boolean equals(Object);" ], [ "toString", "", "char[]", "public String toString()" ], [ "hashCode", "", "char[]", "public native int hashCode()" ], [ "getClass", "", "char[]", "public final native Class getClass();" ], [ "clone", "", "char[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "javadocLossage", "plume", "ArraysMDE", "public Vector<?> javadocLossage;" ], [ "length", "", "char[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10912,
  "oracle" : ";",
  "oracleType" : "NORMAL_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "ArraysMDE",
  "javadocTag" : "",
  "methodJavadoc" : "",
  "methodSourceCode" : "public static /*@Pure*/\nboolean noDuplicates(char[] a){\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Character n = new Character(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}",
  "classJavadoc" : "/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Vector;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\nimport org.checkerframework.framework.qual.PolyAll;\n*/\n\n/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */\n@SuppressWarnings(\"interning\") // to do later\npublic final class ArraysMDE {\n  /** This class is a collecton of methods; it does not represent anything. */\n  private ArraysMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// min, max\n  ///\n\n  // Could also add linear-time orderStatistics if I liked.\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int min(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long min(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double min(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer min(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long min(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() < result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double min(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int max(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long max(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double max(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer max(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long max(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() > result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double max(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int[] min_max(int[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] {result_min, result_max};\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long[] min_max(long[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] {result_min, result_max};\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int element_range(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long element_range(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Returns the sum of an array of integers.\n   * @param a an array\n   * @return the sum of an array of integers\n   */\n  public static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of integers.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of integers\n   */\n  public static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of an array of doubles.\n   * @param a an array\n   * @return the sum of an array of doubles\n   */\n  public static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of doubles.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of doubles\n   */\n  public static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf\n  ///\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> type of the elements of the array\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt) {\n    if (elt == null) {\n      return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> the type of the elements\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   *    Identical to List.indexOf, but included for completeness.\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    return a.indexOf(elt);\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a.get(i))) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      /*@PolyNull*/ Object[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.size(); i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf, for finding subarrays\n  ///\n\n  // This is analogous to Common Lisp's \"search\" function.\n\n  // This implementation is very inefficient; I could use tricky Boyer-Moore\n  // search techniques if I liked, but it's not worth it to me yet.\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  // The signature on this method is unnecessarily strict because it\n  // requires that the component types be identical.  The signature should\n  // be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n  // @PolyAll qualifier does not yet take an argument.\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// mismatch\n  ///\n\n  // This is analogous to Common Lisp's \"mismatch\" function.\n\n  // Put it off until later; for now, use the simpler subarray function,\n  // which is a specialization of mismatch,\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray extraction\n  ///\n\n  // Note that the second argument is a length, not an end position.\n  // That's to avoid confusion over whether it would be the last included\n  // index or the first non-included index.\n\n  /**\n   * Return a subarray of the given array.\n   * @return a subarray of the given array\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ Object[] subarray(\n      /*@PolyAll*/ Object[] a, int startindex, int length) {\n    /*@PolyAll*/ Object[] result = new /*@PolyAll*/ Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a sublist of the given list.\n   * @param <T> type of the elements\n   * @param a the original list\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a sublist of the given list\n   */\n  /*@SideEffectFree*/\n  public static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ String[] subarray(\n      /*@PolyAll*/ String[] a, int startindex, int length) {\n    /*@PolyAll*/ String[] result = new /*@PolyAll*/ String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray testing\n  ///\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(\n      /*@PolyAll*/ Object[] a, /*@PolyNull*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(\n      /*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// concatenation\n  ///\n\n  // Concat used to return null if both arguments are null.  That is\n  // convenient for the implementer, but not so good for clients.\n\n  /**\n   * Call this method in order to suppress compiler warnings.\n   * @param <T> the base type of the result\n   * @param lst the list to convert to an array\n   * @return the result of lst.toArray, casted to a more precise type than Object[]\n   */\n  private static <T> T[] toTArray(List<T> lst) {\n    @SuppressWarnings(\"unchecked\")\n    T[] asArray = (T[]) lst.toArray();\n    return asArray;\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.size()];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        // System.arraycopy(b, 0, result, a.length, b.size());\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.length] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.length];\n\n        // System.arraycopy(a, 0, result, 0, a.size());\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        System.arraycopy(b, 0, result, a.size(), b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.size()];\n\n        // System.arraycopy(a, 0, result, 0, a.length);\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        // System.arraycopy(b, 0, result, a.length, b.length);\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.size()] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  // Note: PolyAll is not quite right.  Need to review.\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first array to concatenate\n   * @param b the second array to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static /*@PolyAll*/ String[] concat(\n      /*@PolyAll*/ String /*@Nullable*/ [] a, /*@PolyAll*/ String /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new String[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        /*@PolyAll*/ String[] result = new String[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static byte[] concat(byte /*@Nullable*/ [] a, byte /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new byte[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        byte[] result = new byte[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static boolean[] concat(boolean /*@Nullable*/ [] a, boolean /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new boolean[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        boolean[] result = new boolean[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static char[] concat(char /*@Nullable*/ [] a, char /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new char[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        char[] result = new char[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static double[] concat(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new double[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        double[] result = new double[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static float[] concat(float /*@Nullable*/ [] a, float /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new float[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        float[] result = new float[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static int[] concat(int /*@Nullable*/ [] a, int /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new int[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        int[] result = new int[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static long[] concat(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new long[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        long[] result = new long[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static short[] concat(short /*@Nullable*/ [] a, short /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new short[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        short[] result = new short[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Printing\n  ///\n\n  // This should be extended to all types, when I get around to it.  The\n  // methods are patterned after that of java.util.Vector (and use its\n  // output format).\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, each element is quoted like a Java String.\n   * @param a an array\n   * @return a string representation of the array, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, if quoted is true, then each element is quoted like a Java String.\n   * @param a an array\n   * @param quoted whether to quote the array elements\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        if (quoted && a[i] instanceof String) {\n          String elt = (String) a[i];\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava(elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(a[i]);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@Nullable*/ Collection<?> a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @param quoted whether to quote the collection elements that are Java strings\n   * @return a string representation of the list\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n      Iterator<?> itor = a.iterator();\n      sb.append(itor.next());\n      while (itor.hasNext()) {\n        sb.append(\", \");\n        Object elt = itor.next();\n        if (quoted && elt instanceof String) {\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava((String) elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(elt);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(int /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(long /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(double /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(float /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(boolean /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls the appropriate\n   * toString() method.  Only call this method if obj is a boolean, double,\n   * int, long, or Object array.\n   * @param obj an array\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@SideEffectFree*/\n  public static String toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n      return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n      return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n      return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n      return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n      return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n      return toString((List<?>) obj);\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls .length.\n   * Only call this method if obj is a boolean, double, int, long, or Object array.\n   * @param obj a list\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@Pure*/\n  public static int length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n      return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n      return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n      return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n      return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n      return ((List<?>) obj).size();\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Sortedness\n  ///\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Boolean n = Boolean.valueOf(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Byte n = new Byte(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Character n = new Character(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Float n = new Float(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Short n = new Short(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Integer n = new Integer(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space. Equality checking\n   * uses the .equals() method for java.lang.Double.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Double n = new Double(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Long n = new Long(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param <T> the type of the elements\n   * @param a a list\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static <T> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n      if (hs.contains(a.get(i))) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a.get(i));\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Arrays as partial functions of int->int\n  ///\n\n  /**\n   * Returns true if the array is a permutation of [0..a.length).\n   * @param a an array, representing a function\n   * @return true iff all elements of a are in [0..a.length) and a\n   * contains no duplicates.\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (array)\n  /*@Pure*/\n  public static boolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int n = a[i];\n      if (n < 0 || n >= a.length || see[n]) {\n        return false;\n      }\n      see[n] = true;\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff the array does not contain -1.\n   * @param a an array, representing a function\n   * @return true iff no element of a maps to -1\n   */\n  /*@Pure*/\n  public static boolean fn_is_total(int[] a) {\n    return indexOf(a, -1) == -1; // not found\n  }\n\n  /**\n   * Return an array [0..lenth).\n   * @param length the length of the result\n   * @return fresh array that is the identity function of the given length\n   */\n  public static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n      result[i] = i;\n    }\n    return result;\n  }\n\n  /**\n   * Requires that fn_is_permutation(a) holds.\n   * @param a the input permutation\n   * @return fresh array which is the inverse of the given permutation\n   * @see #fn_is_permutation(int[])\n   */\n  public static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n  }\n\n  /**\n   * Return the inverse of the given function, which is represented as an array.\n   * @param a an array representing a function from [0..a.length) to [0..arange);\n   *  each element of a is between 0 and arange inclusive\n   * @param arange length of the argument's range and the result's domain\n   * @return function from [0..arange) to [0..a.length) that is the inverse of a\n   * @throws IllegalArgumentException if a value of a is outside of arange\n   * @exception UnsupportedOperationException when the function is not invertible\n   */\n  public static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n      int ai = a[i];\n      if (ai < -1 || ai >= arange) {\n        throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n      }\n      // ai is either -1 or a valid index\n      if (ai >= 0) {\n        if (result[ai] != -1) {\n          throw new UnsupportedOperationException(\n              String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n        }\n        result[ai] = i;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the composition of the given two functions, all of which are\n   * represented as arrays.\n   * @param a function from [0..a.length) to [0..b.length)\n   * @param b function from [0..b.length) to range R\n   * @return function from [0..a.length) to range R that is the\n   * composition of a and b\n   */\n  public static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int inner = a[i];\n      if (inner == -1) {\n        result[i] = -1;\n      } else {\n        result[i] = b[inner];\n      }\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set operations, such as subset, unions, and intersections\n  ///\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Long(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Long elt = new Long(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Double(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Double elt = new Double(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(bigger[i]);\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      if (!setBigger.contains(smaller[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array comparators\n  ///\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLexical implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer,\n     * depending on whether the first argument is less than,\n     * equal to, or greater than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLexical implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class DoubleArrayComparatorLexical\n      implements Comparator<double[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(double[] a1, double[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int result = Double.compare(a1[i], a2[i]);\n        if (result != 0) {\n          return (result);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * Strings).\n   */\n  public static final class StringArrayComparatorLexical\n      implements Comparator<String[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) String[], @PolyAll(2) String[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ String[] a1, /*@PolyAll*/ String[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int tmp = 0;\n        if ((a1[i] == null) && (a2[i] == null)) {\n          tmp = 0;\n        } else if (a1[i] == null) {\n          tmp = -1;\n        } else if (a2[i] == null) {\n          tmp = 1;\n        } else {\n          tmp = a1[i].compareTo(a2[i]);\n        }\n        if (tmp != 0) {\n          return (tmp);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLexical<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLexical\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLengthFirst\n      implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLengthFirst\n      implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int lendiff = a1.length - a2.length;\n      if (lendiff != 0) {\n        return lendiff;\n      }\n      long tmp;\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLengthFirst<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLengthFirst\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// nullness\n  ///\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(/*@PolyAll*/ Object[] a) {\n    if (a.length == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(/*@PolyAll*/ Object[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (!(a[i] == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n      if (!(a.get(i) == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// javadoc hacks\n  ///\n\n  // Without this, the Javadoc mentions of \"java.util.Vector\", are not links\n  // in the generated HTML.\n  // \"private static Vector v;\" doesn't work, nor does\n  // \"static { new java.util.Vector(); }\", nor does \"private Vector v\".\n  // Yuck!\n  public Vector<?> javadocLossage;\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "a", "", "char[]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "", "char[]", "public boolean equals(Object);" ], [ "toString", "", "char[]", "public String toString()" ], [ "hashCode", "", "char[]", "public native int hashCode()" ], [ "getClass", "", "char[]", "public final native Class getClass();" ], [ "clone", "", "char[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "javadocLossage", "plume", "ArraysMDE", "public Vector<?> javadocLossage;" ], [ "length", "", "char[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10912,
  "oracle" : ";",
  "oracleType" : "NORMAL_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "ArraysMDE",
  "javadocTag" : "@return true if a does not contain any repeated elements.",
  "methodJavadoc" : "    /**\n     * Return true iff a does not contain duplicate elements,\n     * using O(n) time and O(n) space.\n     * \n     * @param a an array\n     * @return true if a does not contain any repeated elements.\n     */",
  "methodSourceCode" : "public static /*@Pure*/\nboolean noDuplicates(char[] a);",
  "classJavadoc" : "/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Vector;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\nimport org.checkerframework.framework.qual.PolyAll;\n*/\n\n/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */\n@SuppressWarnings(\"interning\") // to do later\npublic final class ArraysMDE {\n  /** This class is a collecton of methods; it does not represent anything. */\n  private ArraysMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// min, max\n  ///\n\n  // Could also add linear-time orderStatistics if I liked.\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int min(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long min(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double min(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer min(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long min(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() < result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double min(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int max(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long max(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double max(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer max(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long max(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() > result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double max(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int[] min_max(int[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] {result_min, result_max};\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long[] min_max(long[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] {result_min, result_max};\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int element_range(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long element_range(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Returns the sum of an array of integers.\n   * @param a an array\n   * @return the sum of an array of integers\n   */\n  public static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of integers.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of integers\n   */\n  public static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of an array of doubles.\n   * @param a an array\n   * @return the sum of an array of doubles\n   */\n  public static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of doubles.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of doubles\n   */\n  public static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf\n  ///\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> type of the elements of the array\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt) {\n    if (elt == null) {\n      return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> the type of the elements\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   *    Identical to List.indexOf, but included for completeness.\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    return a.indexOf(elt);\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a.get(i))) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      /*@PolyNull*/ Object[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.size(); i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf, for finding subarrays\n  ///\n\n  // This is analogous to Common Lisp's \"search\" function.\n\n  // This implementation is very inefficient; I could use tricky Boyer-Moore\n  // search techniques if I liked, but it's not worth it to me yet.\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  // The signature on this method is unnecessarily strict because it\n  // requires that the component types be identical.  The signature should\n  // be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n  // @PolyAll qualifier does not yet take an argument.\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// mismatch\n  ///\n\n  // This is analogous to Common Lisp's \"mismatch\" function.\n\n  // Put it off until later; for now, use the simpler subarray function,\n  // which is a specialization of mismatch,\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray extraction\n  ///\n\n  // Note that the second argument is a length, not an end position.\n  // That's to avoid confusion over whether it would be the last included\n  // index or the first non-included index.\n\n  /**\n   * Return a subarray of the given array.\n   * @return a subarray of the given array\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ Object[] subarray(\n      /*@PolyAll*/ Object[] a, int startindex, int length) {\n    /*@PolyAll*/ Object[] result = new /*@PolyAll*/ Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a sublist of the given list.\n   * @param <T> type of the elements\n   * @param a the original list\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a sublist of the given list\n   */\n  /*@SideEffectFree*/\n  public static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ String[] subarray(\n      /*@PolyAll*/ String[] a, int startindex, int length) {\n    /*@PolyAll*/ String[] result = new /*@PolyAll*/ String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray testing\n  ///\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(\n      /*@PolyAll*/ Object[] a, /*@PolyNull*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(\n      /*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// concatenation\n  ///\n\n  // Concat used to return null if both arguments are null.  That is\n  // convenient for the implementer, but not so good for clients.\n\n  /**\n   * Call this method in order to suppress compiler warnings.\n   * @param <T> the base type of the result\n   * @param lst the list to convert to an array\n   * @return the result of lst.toArray, casted to a more precise type than Object[]\n   */\n  private static <T> T[] toTArray(List<T> lst) {\n    @SuppressWarnings(\"unchecked\")\n    T[] asArray = (T[]) lst.toArray();\n    return asArray;\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.size()];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        // System.arraycopy(b, 0, result, a.length, b.size());\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.length] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.length];\n\n        // System.arraycopy(a, 0, result, 0, a.size());\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        System.arraycopy(b, 0, result, a.size(), b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.size()];\n\n        // System.arraycopy(a, 0, result, 0, a.length);\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        // System.arraycopy(b, 0, result, a.length, b.length);\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.size()] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  // Note: PolyAll is not quite right.  Need to review.\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first array to concatenate\n   * @param b the second array to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static /*@PolyAll*/ String[] concat(\n      /*@PolyAll*/ String /*@Nullable*/ [] a, /*@PolyAll*/ String /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new String[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        /*@PolyAll*/ String[] result = new String[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static byte[] concat(byte /*@Nullable*/ [] a, byte /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new byte[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        byte[] result = new byte[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static boolean[] concat(boolean /*@Nullable*/ [] a, boolean /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new boolean[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        boolean[] result = new boolean[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static char[] concat(char /*@Nullable*/ [] a, char /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new char[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        char[] result = new char[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static double[] concat(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new double[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        double[] result = new double[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static float[] concat(float /*@Nullable*/ [] a, float /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new float[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        float[] result = new float[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static int[] concat(int /*@Nullable*/ [] a, int /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new int[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        int[] result = new int[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static long[] concat(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new long[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        long[] result = new long[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static short[] concat(short /*@Nullable*/ [] a, short /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new short[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        short[] result = new short[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Printing\n  ///\n\n  // This should be extended to all types, when I get around to it.  The\n  // methods are patterned after that of java.util.Vector (and use its\n  // output format).\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, each element is quoted like a Java String.\n   * @param a an array\n   * @return a string representation of the array, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, if quoted is true, then each element is quoted like a Java String.\n   * @param a an array\n   * @param quoted whether to quote the array elements\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        if (quoted && a[i] instanceof String) {\n          String elt = (String) a[i];\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava(elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(a[i]);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@Nullable*/ Collection<?> a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @param quoted whether to quote the collection elements that are Java strings\n   * @return a string representation of the list\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n      Iterator<?> itor = a.iterator();\n      sb.append(itor.next());\n      while (itor.hasNext()) {\n        sb.append(\", \");\n        Object elt = itor.next();\n        if (quoted && elt instanceof String) {\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava((String) elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(elt);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(int /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(long /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(double /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(float /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(boolean /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls the appropriate\n   * toString() method.  Only call this method if obj is a boolean, double,\n   * int, long, or Object array.\n   * @param obj an array\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@SideEffectFree*/\n  public static String toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n      return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n      return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n      return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n      return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n      return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n      return toString((List<?>) obj);\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls .length.\n   * Only call this method if obj is a boolean, double, int, long, or Object array.\n   * @param obj a list\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@Pure*/\n  public static int length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n      return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n      return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n      return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n      return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n      return ((List<?>) obj).size();\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Sortedness\n  ///\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Boolean n = Boolean.valueOf(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Byte n = new Byte(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Character n = new Character(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Float n = new Float(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Short n = new Short(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Integer n = new Integer(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space. Equality checking\n   * uses the .equals() method for java.lang.Double.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Double n = new Double(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Long n = new Long(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param <T> the type of the elements\n   * @param a a list\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static <T> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n      if (hs.contains(a.get(i))) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a.get(i));\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Arrays as partial functions of int->int\n  ///\n\n  /**\n   * Returns true if the array is a permutation of [0..a.length).\n   * @param a an array, representing a function\n   * @return true iff all elements of a are in [0..a.length) and a\n   * contains no duplicates.\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (array)\n  /*@Pure*/\n  public static boolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int n = a[i];\n      if (n < 0 || n >= a.length || see[n]) {\n        return false;\n      }\n      see[n] = true;\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff the array does not contain -1.\n   * @param a an array, representing a function\n   * @return true iff no element of a maps to -1\n   */\n  /*@Pure*/\n  public static boolean fn_is_total(int[] a) {\n    return indexOf(a, -1) == -1; // not found\n  }\n\n  /**\n   * Return an array [0..lenth).\n   * @param length the length of the result\n   * @return fresh array that is the identity function of the given length\n   */\n  public static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n      result[i] = i;\n    }\n    return result;\n  }\n\n  /**\n   * Requires that fn_is_permutation(a) holds.\n   * @param a the input permutation\n   * @return fresh array which is the inverse of the given permutation\n   * @see #fn_is_permutation(int[])\n   */\n  public static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n  }\n\n  /**\n   * Return the inverse of the given function, which is represented as an array.\n   * @param a an array representing a function from [0..a.length) to [0..arange);\n   *  each element of a is between 0 and arange inclusive\n   * @param arange length of the argument's range and the result's domain\n   * @return function from [0..arange) to [0..a.length) that is the inverse of a\n   * @throws IllegalArgumentException if a value of a is outside of arange\n   * @exception UnsupportedOperationException when the function is not invertible\n   */\n  public static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n      int ai = a[i];\n      if (ai < -1 || ai >= arange) {\n        throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n      }\n      // ai is either -1 or a valid index\n      if (ai >= 0) {\n        if (result[ai] != -1) {\n          throw new UnsupportedOperationException(\n              String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n        }\n        result[ai] = i;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the composition of the given two functions, all of which are\n   * represented as arrays.\n   * @param a function from [0..a.length) to [0..b.length)\n   * @param b function from [0..b.length) to range R\n   * @return function from [0..a.length) to range R that is the\n   * composition of a and b\n   */\n  public static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int inner = a[i];\n      if (inner == -1) {\n        result[i] = -1;\n      } else {\n        result[i] = b[inner];\n      }\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set operations, such as subset, unions, and intersections\n  ///\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Long(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Long elt = new Long(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Double(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Double elt = new Double(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(bigger[i]);\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      if (!setBigger.contains(smaller[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array comparators\n  ///\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLexical implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer,\n     * depending on whether the first argument is less than,\n     * equal to, or greater than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLexical implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class DoubleArrayComparatorLexical\n      implements Comparator<double[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(double[] a1, double[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int result = Double.compare(a1[i], a2[i]);\n        if (result != 0) {\n          return (result);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * Strings).\n   */\n  public static final class StringArrayComparatorLexical\n      implements Comparator<String[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) String[], @PolyAll(2) String[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ String[] a1, /*@PolyAll*/ String[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int tmp = 0;\n        if ((a1[i] == null) && (a2[i] == null)) {\n          tmp = 0;\n        } else if (a1[i] == null) {\n          tmp = -1;\n        } else if (a2[i] == null) {\n          tmp = 1;\n        } else {\n          tmp = a1[i].compareTo(a2[i]);\n        }\n        if (tmp != 0) {\n          return (tmp);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLexical<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLexical\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLengthFirst\n      implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLengthFirst\n      implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int lendiff = a1.length - a2.length;\n      if (lendiff != 0) {\n        return lendiff;\n      }\n      long tmp;\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLengthFirst<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLengthFirst\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// nullness\n  ///\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(/*@PolyAll*/ Object[] a) {\n    if (a.length == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(/*@PolyAll*/ Object[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (!(a[i] == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n      if (!(a.get(i) == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// javadoc hacks\n  ///\n\n  // Without this, the Javadoc mentions of \"java.util.Vector\", are not links\n  // in the generated HTML.\n  // \"private static Vector v;\" doesn't work, nor does\n  // \"static { new java.util.Vector(); }\", nor does \"private Vector v\".\n  // Yuck!\n  public Vector<?> javadocLossage;\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "a", "", "char[]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "", "char[]", "public boolean equals(Object);" ], [ "toString", "", "char[]", "public String toString()" ], [ "hashCode", "", "char[]", "public native int hashCode()" ], [ "getClass", "", "char[]", "public final native Class getClass();" ], [ "clone", "", "char[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "javadocLossage", "plume", "ArraysMDE", "public Vector<?> javadocLossage;" ], [ "length", "", "char[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10912,
  "oracle" : ";",
  "oracleType" : "NORMAL_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "ArraysMDE",
  "javadocTag" : "",
  "methodJavadoc" : "    /**\n     * Return true iff a does not contain duplicate elements,\n     * using O(n) time and O(n) space.\n     * \n     * @param a an array\n     */",
  "methodSourceCode" : "public static /*@Pure*/\nboolean noDuplicates(char[] a);",
  "classJavadoc" : "/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Vector;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\nimport org.checkerframework.framework.qual.PolyAll;\n*/\n\n/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */\n@SuppressWarnings(\"interning\") // to do later\npublic final class ArraysMDE {\n  /** This class is a collecton of methods; it does not represent anything. */\n  private ArraysMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// min, max\n  ///\n\n  // Could also add linear-time orderStatistics if I liked.\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int min(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long min(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double min(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer min(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long min(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() < result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double min(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int max(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long max(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double max(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer max(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long max(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() > result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double max(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int[] min_max(int[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] {result_min, result_max};\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long[] min_max(long[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] {result_min, result_max};\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int element_range(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long element_range(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Returns the sum of an array of integers.\n   * @param a an array\n   * @return the sum of an array of integers\n   */\n  public static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of integers.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of integers\n   */\n  public static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of an array of doubles.\n   * @param a an array\n   * @return the sum of an array of doubles\n   */\n  public static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of doubles.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of doubles\n   */\n  public static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf\n  ///\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> type of the elements of the array\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt) {\n    if (elt == null) {\n      return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> the type of the elements\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   *    Identical to List.indexOf, but included for completeness.\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    return a.indexOf(elt);\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a.get(i))) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      /*@PolyNull*/ Object[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.size(); i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf, for finding subarrays\n  ///\n\n  // This is analogous to Common Lisp's \"search\" function.\n\n  // This implementation is very inefficient; I could use tricky Boyer-Moore\n  // search techniques if I liked, but it's not worth it to me yet.\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  // The signature on this method is unnecessarily strict because it\n  // requires that the component types be identical.  The signature should\n  // be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n  // @PolyAll qualifier does not yet take an argument.\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// mismatch\n  ///\n\n  // This is analogous to Common Lisp's \"mismatch\" function.\n\n  // Put it off until later; for now, use the simpler subarray function,\n  // which is a specialization of mismatch,\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray extraction\n  ///\n\n  // Note that the second argument is a length, not an end position.\n  // That's to avoid confusion over whether it would be the last included\n  // index or the first non-included index.\n\n  /**\n   * Return a subarray of the given array.\n   * @return a subarray of the given array\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ Object[] subarray(\n      /*@PolyAll*/ Object[] a, int startindex, int length) {\n    /*@PolyAll*/ Object[] result = new /*@PolyAll*/ Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a sublist of the given list.\n   * @param <T> type of the elements\n   * @param a the original list\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a sublist of the given list\n   */\n  /*@SideEffectFree*/\n  public static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ String[] subarray(\n      /*@PolyAll*/ String[] a, int startindex, int length) {\n    /*@PolyAll*/ String[] result = new /*@PolyAll*/ String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray testing\n  ///\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(\n      /*@PolyAll*/ Object[] a, /*@PolyNull*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(\n      /*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// concatenation\n  ///\n\n  // Concat used to return null if both arguments are null.  That is\n  // convenient for the implementer, but not so good for clients.\n\n  /**\n   * Call this method in order to suppress compiler warnings.\n   * @param <T> the base type of the result\n   * @param lst the list to convert to an array\n   * @return the result of lst.toArray, casted to a more precise type than Object[]\n   */\n  private static <T> T[] toTArray(List<T> lst) {\n    @SuppressWarnings(\"unchecked\")\n    T[] asArray = (T[]) lst.toArray();\n    return asArray;\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.size()];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        // System.arraycopy(b, 0, result, a.length, b.size());\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.length] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.length];\n\n        // System.arraycopy(a, 0, result, 0, a.size());\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        System.arraycopy(b, 0, result, a.size(), b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.size()];\n\n        // System.arraycopy(a, 0, result, 0, a.length);\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        // System.arraycopy(b, 0, result, a.length, b.length);\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.size()] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  // Note: PolyAll is not quite right.  Need to review.\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first array to concatenate\n   * @param b the second array to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static /*@PolyAll*/ String[] concat(\n      /*@PolyAll*/ String /*@Nullable*/ [] a, /*@PolyAll*/ String /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new String[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        /*@PolyAll*/ String[] result = new String[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static byte[] concat(byte /*@Nullable*/ [] a, byte /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new byte[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        byte[] result = new byte[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static boolean[] concat(boolean /*@Nullable*/ [] a, boolean /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new boolean[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        boolean[] result = new boolean[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static char[] concat(char /*@Nullable*/ [] a, char /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new char[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        char[] result = new char[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static double[] concat(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new double[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        double[] result = new double[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static float[] concat(float /*@Nullable*/ [] a, float /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new float[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        float[] result = new float[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static int[] concat(int /*@Nullable*/ [] a, int /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new int[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        int[] result = new int[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static long[] concat(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new long[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        long[] result = new long[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static short[] concat(short /*@Nullable*/ [] a, short /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new short[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        short[] result = new short[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Printing\n  ///\n\n  // This should be extended to all types, when I get around to it.  The\n  // methods are patterned after that of java.util.Vector (and use its\n  // output format).\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, each element is quoted like a Java String.\n   * @param a an array\n   * @return a string representation of the array, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, if quoted is true, then each element is quoted like a Java String.\n   * @param a an array\n   * @param quoted whether to quote the array elements\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        if (quoted && a[i] instanceof String) {\n          String elt = (String) a[i];\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava(elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(a[i]);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@Nullable*/ Collection<?> a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @param quoted whether to quote the collection elements that are Java strings\n   * @return a string representation of the list\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n      Iterator<?> itor = a.iterator();\n      sb.append(itor.next());\n      while (itor.hasNext()) {\n        sb.append(\", \");\n        Object elt = itor.next();\n        if (quoted && elt instanceof String) {\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava((String) elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(elt);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(int /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(long /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(double /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(float /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(boolean /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls the appropriate\n   * toString() method.  Only call this method if obj is a boolean, double,\n   * int, long, or Object array.\n   * @param obj an array\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@SideEffectFree*/\n  public static String toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n      return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n      return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n      return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n      return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n      return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n      return toString((List<?>) obj);\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls .length.\n   * Only call this method if obj is a boolean, double, int, long, or Object array.\n   * @param obj a list\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@Pure*/\n  public static int length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n      return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n      return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n      return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n      return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n      return ((List<?>) obj).size();\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Sortedness\n  ///\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Boolean n = Boolean.valueOf(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Byte n = new Byte(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Character n = new Character(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Float n = new Float(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Short n = new Short(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Integer n = new Integer(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space. Equality checking\n   * uses the .equals() method for java.lang.Double.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Double n = new Double(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Long n = new Long(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param <T> the type of the elements\n   * @param a a list\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static <T> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n      if (hs.contains(a.get(i))) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a.get(i));\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Arrays as partial functions of int->int\n  ///\n\n  /**\n   * Returns true if the array is a permutation of [0..a.length).\n   * @param a an array, representing a function\n   * @return true iff all elements of a are in [0..a.length) and a\n   * contains no duplicates.\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (array)\n  /*@Pure*/\n  public static boolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int n = a[i];\n      if (n < 0 || n >= a.length || see[n]) {\n        return false;\n      }\n      see[n] = true;\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff the array does not contain -1.\n   * @param a an array, representing a function\n   * @return true iff no element of a maps to -1\n   */\n  /*@Pure*/\n  public static boolean fn_is_total(int[] a) {\n    return indexOf(a, -1) == -1; // not found\n  }\n\n  /**\n   * Return an array [0..lenth).\n   * @param length the length of the result\n   * @return fresh array that is the identity function of the given length\n   */\n  public static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n      result[i] = i;\n    }\n    return result;\n  }\n\n  /**\n   * Requires that fn_is_permutation(a) holds.\n   * @param a the input permutation\n   * @return fresh array which is the inverse of the given permutation\n   * @see #fn_is_permutation(int[])\n   */\n  public static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n  }\n\n  /**\n   * Return the inverse of the given function, which is represented as an array.\n   * @param a an array representing a function from [0..a.length) to [0..arange);\n   *  each element of a is between 0 and arange inclusive\n   * @param arange length of the argument's range and the result's domain\n   * @return function from [0..arange) to [0..a.length) that is the inverse of a\n   * @throws IllegalArgumentException if a value of a is outside of arange\n   * @exception UnsupportedOperationException when the function is not invertible\n   */\n  public static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n      int ai = a[i];\n      if (ai < -1 || ai >= arange) {\n        throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n      }\n      // ai is either -1 or a valid index\n      if (ai >= 0) {\n        if (result[ai] != -1) {\n          throw new UnsupportedOperationException(\n              String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n        }\n        result[ai] = i;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the composition of the given two functions, all of which are\n   * represented as arrays.\n   * @param a function from [0..a.length) to [0..b.length)\n   * @param b function from [0..b.length) to range R\n   * @return function from [0..a.length) to range R that is the\n   * composition of a and b\n   */\n  public static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int inner = a[i];\n      if (inner == -1) {\n        result[i] = -1;\n      } else {\n        result[i] = b[inner];\n      }\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set operations, such as subset, unions, and intersections\n  ///\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Long(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Long elt = new Long(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Double(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Double elt = new Double(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(bigger[i]);\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      if (!setBigger.contains(smaller[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array comparators\n  ///\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLexical implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer,\n     * depending on whether the first argument is less than,\n     * equal to, or greater than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLexical implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class DoubleArrayComparatorLexical\n      implements Comparator<double[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(double[] a1, double[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int result = Double.compare(a1[i], a2[i]);\n        if (result != 0) {\n          return (result);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * Strings).\n   */\n  public static final class StringArrayComparatorLexical\n      implements Comparator<String[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) String[], @PolyAll(2) String[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ String[] a1, /*@PolyAll*/ String[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int tmp = 0;\n        if ((a1[i] == null) && (a2[i] == null)) {\n          tmp = 0;\n        } else if (a1[i] == null) {\n          tmp = -1;\n        } else if (a2[i] == null) {\n          tmp = 1;\n        } else {\n          tmp = a1[i].compareTo(a2[i]);\n        }\n        if (tmp != 0) {\n          return (tmp);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLexical<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLexical\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLengthFirst\n      implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLengthFirst\n      implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int lendiff = a1.length - a2.length;\n      if (lendiff != 0) {\n        return lendiff;\n      }\n      long tmp;\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLengthFirst<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLengthFirst\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// nullness\n  ///\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(/*@PolyAll*/ Object[] a) {\n    if (a.length == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(/*@PolyAll*/ Object[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (!(a[i] == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n      if (!(a.get(i) == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// javadoc hacks\n  ///\n\n  // Without this, the Javadoc mentions of \"java.util.Vector\", are not links\n  // in the generated HTML.\n  // \"private static Vector v;\" doesn't work, nor does\n  // \"static { new java.util.Vector(); }\", nor does \"private Vector v\".\n  // Yuck!\n  public Vector<?> javadocLossage;\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "a", "", "char[]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "", "char[]", "public boolean equals(Object);" ], [ "toString", "", "char[]", "public String toString()" ], [ "hashCode", "", "char[]", "public native int hashCode()" ], [ "getClass", "", "char[]", "public final native Class getClass();" ], [ "clone", "", "char[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "javadocLossage", "plume", "ArraysMDE", "public Vector<?> javadocLossage;" ], [ "length", "", "char[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10912,
  "oracle" : ";",
  "oracleType" : "NORMAL_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "ArraysMDE",
  "javadocTag" : "",
  "methodJavadoc" : "",
  "methodSourceCode" : "public static /*@Pure*/\nboolean noDuplicates(char[] a);",
  "classJavadoc" : "/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Vector;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\nimport org.checkerframework.framework.qual.PolyAll;\n*/\n\n/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */\n@SuppressWarnings(\"interning\") // to do later\npublic final class ArraysMDE {\n  /** This class is a collecton of methods; it does not represent anything. */\n  private ArraysMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// min, max\n  ///\n\n  // Could also add linear-time orderStatistics if I liked.\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int min(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long min(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double min(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer min(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long min(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() < result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double min(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int max(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long max(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double max(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer max(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long max(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() > result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double max(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int[] min_max(int[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] {result_min, result_max};\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long[] min_max(long[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] {result_min, result_max};\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int element_range(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long element_range(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Returns the sum of an array of integers.\n   * @param a an array\n   * @return the sum of an array of integers\n   */\n  public static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of integers.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of integers\n   */\n  public static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of an array of doubles.\n   * @param a an array\n   * @return the sum of an array of doubles\n   */\n  public static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of doubles.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of doubles\n   */\n  public static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf\n  ///\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> type of the elements of the array\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt) {\n    if (elt == null) {\n      return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> the type of the elements\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   *    Identical to List.indexOf, but included for completeness.\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    return a.indexOf(elt);\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a.get(i))) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      /*@PolyNull*/ Object[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.size(); i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf, for finding subarrays\n  ///\n\n  // This is analogous to Common Lisp's \"search\" function.\n\n  // This implementation is very inefficient; I could use tricky Boyer-Moore\n  // search techniques if I liked, but it's not worth it to me yet.\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  // The signature on this method is unnecessarily strict because it\n  // requires that the component types be identical.  The signature should\n  // be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n  // @PolyAll qualifier does not yet take an argument.\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// mismatch\n  ///\n\n  // This is analogous to Common Lisp's \"mismatch\" function.\n\n  // Put it off until later; for now, use the simpler subarray function,\n  // which is a specialization of mismatch,\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray extraction\n  ///\n\n  // Note that the second argument is a length, not an end position.\n  // That's to avoid confusion over whether it would be the last included\n  // index or the first non-included index.\n\n  /**\n   * Return a subarray of the given array.\n   * @return a subarray of the given array\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ Object[] subarray(\n      /*@PolyAll*/ Object[] a, int startindex, int length) {\n    /*@PolyAll*/ Object[] result = new /*@PolyAll*/ Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a sublist of the given list.\n   * @param <T> type of the elements\n   * @param a the original list\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a sublist of the given list\n   */\n  /*@SideEffectFree*/\n  public static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ String[] subarray(\n      /*@PolyAll*/ String[] a, int startindex, int length) {\n    /*@PolyAll*/ String[] result = new /*@PolyAll*/ String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray testing\n  ///\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(\n      /*@PolyAll*/ Object[] a, /*@PolyNull*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(\n      /*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// concatenation\n  ///\n\n  // Concat used to return null if both arguments are null.  That is\n  // convenient for the implementer, but not so good for clients.\n\n  /**\n   * Call this method in order to suppress compiler warnings.\n   * @param <T> the base type of the result\n   * @param lst the list to convert to an array\n   * @return the result of lst.toArray, casted to a more precise type than Object[]\n   */\n  private static <T> T[] toTArray(List<T> lst) {\n    @SuppressWarnings(\"unchecked\")\n    T[] asArray = (T[]) lst.toArray();\n    return asArray;\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.size()];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        // System.arraycopy(b, 0, result, a.length, b.size());\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.length] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.length];\n\n        // System.arraycopy(a, 0, result, 0, a.size());\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        System.arraycopy(b, 0, result, a.size(), b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.size()];\n\n        // System.arraycopy(a, 0, result, 0, a.length);\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        // System.arraycopy(b, 0, result, a.length, b.length);\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.size()] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  // Note: PolyAll is not quite right.  Need to review.\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first array to concatenate\n   * @param b the second array to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static /*@PolyAll*/ String[] concat(\n      /*@PolyAll*/ String /*@Nullable*/ [] a, /*@PolyAll*/ String /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new String[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        /*@PolyAll*/ String[] result = new String[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static byte[] concat(byte /*@Nullable*/ [] a, byte /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new byte[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        byte[] result = new byte[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static boolean[] concat(boolean /*@Nullable*/ [] a, boolean /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new boolean[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        boolean[] result = new boolean[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static char[] concat(char /*@Nullable*/ [] a, char /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new char[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        char[] result = new char[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static double[] concat(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new double[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        double[] result = new double[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static float[] concat(float /*@Nullable*/ [] a, float /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new float[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        float[] result = new float[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static int[] concat(int /*@Nullable*/ [] a, int /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new int[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        int[] result = new int[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static long[] concat(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new long[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        long[] result = new long[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static short[] concat(short /*@Nullable*/ [] a, short /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new short[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        short[] result = new short[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Printing\n  ///\n\n  // This should be extended to all types, when I get around to it.  The\n  // methods are patterned after that of java.util.Vector (and use its\n  // output format).\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, each element is quoted like a Java String.\n   * @param a an array\n   * @return a string representation of the array, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, if quoted is true, then each element is quoted like a Java String.\n   * @param a an array\n   * @param quoted whether to quote the array elements\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        if (quoted && a[i] instanceof String) {\n          String elt = (String) a[i];\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava(elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(a[i]);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@Nullable*/ Collection<?> a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @param quoted whether to quote the collection elements that are Java strings\n   * @return a string representation of the list\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n      Iterator<?> itor = a.iterator();\n      sb.append(itor.next());\n      while (itor.hasNext()) {\n        sb.append(\", \");\n        Object elt = itor.next();\n        if (quoted && elt instanceof String) {\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava((String) elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(elt);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(int /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(long /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(double /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(float /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(boolean /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls the appropriate\n   * toString() method.  Only call this method if obj is a boolean, double,\n   * int, long, or Object array.\n   * @param obj an array\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@SideEffectFree*/\n  public static String toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n      return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n      return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n      return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n      return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n      return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n      return toString((List<?>) obj);\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls .length.\n   * Only call this method if obj is a boolean, double, int, long, or Object array.\n   * @param obj a list\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@Pure*/\n  public static int length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n      return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n      return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n      return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n      return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n      return ((List<?>) obj).size();\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Sortedness\n  ///\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Boolean n = Boolean.valueOf(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Byte n = new Byte(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Character n = new Character(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Float n = new Float(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Short n = new Short(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Integer n = new Integer(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space. Equality checking\n   * uses the .equals() method for java.lang.Double.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Double n = new Double(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Long n = new Long(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param <T> the type of the elements\n   * @param a a list\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static <T> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n      if (hs.contains(a.get(i))) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a.get(i));\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Arrays as partial functions of int->int\n  ///\n\n  /**\n   * Returns true if the array is a permutation of [0..a.length).\n   * @param a an array, representing a function\n   * @return true iff all elements of a are in [0..a.length) and a\n   * contains no duplicates.\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (array)\n  /*@Pure*/\n  public static boolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int n = a[i];\n      if (n < 0 || n >= a.length || see[n]) {\n        return false;\n      }\n      see[n] = true;\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff the array does not contain -1.\n   * @param a an array, representing a function\n   * @return true iff no element of a maps to -1\n   */\n  /*@Pure*/\n  public static boolean fn_is_total(int[] a) {\n    return indexOf(a, -1) == -1; // not found\n  }\n\n  /**\n   * Return an array [0..lenth).\n   * @param length the length of the result\n   * @return fresh array that is the identity function of the given length\n   */\n  public static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n      result[i] = i;\n    }\n    return result;\n  }\n\n  /**\n   * Requires that fn_is_permutation(a) holds.\n   * @param a the input permutation\n   * @return fresh array which is the inverse of the given permutation\n   * @see #fn_is_permutation(int[])\n   */\n  public static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n  }\n\n  /**\n   * Return the inverse of the given function, which is represented as an array.\n   * @param a an array representing a function from [0..a.length) to [0..arange);\n   *  each element of a is between 0 and arange inclusive\n   * @param arange length of the argument's range and the result's domain\n   * @return function from [0..arange) to [0..a.length) that is the inverse of a\n   * @throws IllegalArgumentException if a value of a is outside of arange\n   * @exception UnsupportedOperationException when the function is not invertible\n   */\n  public static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n      int ai = a[i];\n      if (ai < -1 || ai >= arange) {\n        throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n      }\n      // ai is either -1 or a valid index\n      if (ai >= 0) {\n        if (result[ai] != -1) {\n          throw new UnsupportedOperationException(\n              String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n        }\n        result[ai] = i;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the composition of the given two functions, all of which are\n   * represented as arrays.\n   * @param a function from [0..a.length) to [0..b.length)\n   * @param b function from [0..b.length) to range R\n   * @return function from [0..a.length) to range R that is the\n   * composition of a and b\n   */\n  public static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int inner = a[i];\n      if (inner == -1) {\n        result[i] = -1;\n      } else {\n        result[i] = b[inner];\n      }\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set operations, such as subset, unions, and intersections\n  ///\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Long(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Long elt = new Long(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Double(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Double elt = new Double(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(bigger[i]);\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      if (!setBigger.contains(smaller[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array comparators\n  ///\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLexical implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer,\n     * depending on whether the first argument is less than,\n     * equal to, or greater than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLexical implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class DoubleArrayComparatorLexical\n      implements Comparator<double[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(double[] a1, double[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int result = Double.compare(a1[i], a2[i]);\n        if (result != 0) {\n          return (result);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * Strings).\n   */\n  public static final class StringArrayComparatorLexical\n      implements Comparator<String[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) String[], @PolyAll(2) String[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ String[] a1, /*@PolyAll*/ String[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int tmp = 0;\n        if ((a1[i] == null) && (a2[i] == null)) {\n          tmp = 0;\n        } else if (a1[i] == null) {\n          tmp = -1;\n        } else if (a2[i] == null) {\n          tmp = 1;\n        } else {\n          tmp = a1[i].compareTo(a2[i]);\n        }\n        if (tmp != 0) {\n          return (tmp);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLexical<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLexical\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLengthFirst\n      implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLengthFirst\n      implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int lendiff = a1.length - a2.length;\n      if (lendiff != 0) {\n        return lendiff;\n      }\n      long tmp;\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLengthFirst<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLengthFirst\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// nullness\n  ///\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(/*@PolyAll*/ Object[] a) {\n    if (a.length == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(/*@PolyAll*/ Object[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (!(a[i] == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n      if (!(a.get(i) == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// javadoc hacks\n  ///\n\n  // Without this, the Javadoc mentions of \"java.util.Vector\", are not links\n  // in the generated HTML.\n  // \"private static Vector v;\" doesn't work, nor does\n  // \"static { new java.util.Vector(); }\", nor does \"private Vector v\".\n  // Yuck!\n  public Vector<?> javadocLossage;\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "a", "", "char[]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "", "char[]", "public boolean equals(Object);" ], [ "toString", "", "char[]", "public String toString()" ], [ "hashCode", "", "char[]", "public native int hashCode()" ], [ "getClass", "", "char[]", "public final native Class getClass();" ], [ "clone", "", "char[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "javadocLossage", "plume", "ArraysMDE", "public Vector<?> javadocLossage;" ], [ "length", "", "char[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10912,
  "oracle" : ";",
  "oracleType" : "NORMAL_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "ArraysMDE",
  "javadocTag" : "@return true if array a does not contain duplicate values",
  "methodJavadoc" : "    /**\n     * Return true iff a does not contain duplicate elements,\n     * using O(n) time and O(n) space.\n     * \n     * @param a an array\n     * @return true if array a does not contain duplicate values\n     */",
  "methodSourceCode" : "public static /*@Pure*/\nboolean noDuplicates(char[] a){\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Character n = new Character(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}",
  "classJavadoc" : "/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Vector;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\nimport org.checkerframework.framework.qual.PolyAll;\n*/\n\n/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */\n@SuppressWarnings(\"interning\") // to do later\npublic final class ArraysMDE {\n  /** This class is a collecton of methods; it does not represent anything. */\n  private ArraysMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// min, max\n  ///\n\n  // Could also add linear-time orderStatistics if I liked.\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int min(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long min(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double min(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer min(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long min(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() < result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double min(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int max(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long max(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double max(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer max(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long max(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() > result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double max(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int[] min_max(int[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] {result_min, result_max};\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long[] min_max(long[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] {result_min, result_max};\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int element_range(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long element_range(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Returns the sum of an array of integers.\n   * @param a an array\n   * @return the sum of an array of integers\n   */\n  public static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of integers.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of integers\n   */\n  public static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of an array of doubles.\n   * @param a an array\n   * @return the sum of an array of doubles\n   */\n  public static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of doubles.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of doubles\n   */\n  public static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf\n  ///\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> type of the elements of the array\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt) {\n    if (elt == null) {\n      return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> the type of the elements\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   *    Identical to List.indexOf, but included for completeness.\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    return a.indexOf(elt);\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a.get(i))) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      /*@PolyNull*/ Object[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.size(); i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf, for finding subarrays\n  ///\n\n  // This is analogous to Common Lisp's \"search\" function.\n\n  // This implementation is very inefficient; I could use tricky Boyer-Moore\n  // search techniques if I liked, but it's not worth it to me yet.\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  // The signature on this method is unnecessarily strict because it\n  // requires that the component types be identical.  The signature should\n  // be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n  // @PolyAll qualifier does not yet take an argument.\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// mismatch\n  ///\n\n  // This is analogous to Common Lisp's \"mismatch\" function.\n\n  // Put it off until later; for now, use the simpler subarray function,\n  // which is a specialization of mismatch,\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray extraction\n  ///\n\n  // Note that the second argument is a length, not an end position.\n  // That's to avoid confusion over whether it would be the last included\n  // index or the first non-included index.\n\n  /**\n   * Return a subarray of the given array.\n   * @return a subarray of the given array\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ Object[] subarray(\n      /*@PolyAll*/ Object[] a, int startindex, int length) {\n    /*@PolyAll*/ Object[] result = new /*@PolyAll*/ Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a sublist of the given list.\n   * @param <T> type of the elements\n   * @param a the original list\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a sublist of the given list\n   */\n  /*@SideEffectFree*/\n  public static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ String[] subarray(\n      /*@PolyAll*/ String[] a, int startindex, int length) {\n    /*@PolyAll*/ String[] result = new /*@PolyAll*/ String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray testing\n  ///\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(\n      /*@PolyAll*/ Object[] a, /*@PolyNull*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(\n      /*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// concatenation\n  ///\n\n  // Concat used to return null if both arguments are null.  That is\n  // convenient for the implementer, but not so good for clients.\n\n  /**\n   * Call this method in order to suppress compiler warnings.\n   * @param <T> the base type of the result\n   * @param lst the list to convert to an array\n   * @return the result of lst.toArray, casted to a more precise type than Object[]\n   */\n  private static <T> T[] toTArray(List<T> lst) {\n    @SuppressWarnings(\"unchecked\")\n    T[] asArray = (T[]) lst.toArray();\n    return asArray;\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.size()];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        // System.arraycopy(b, 0, result, a.length, b.size());\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.length] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.length];\n\n        // System.arraycopy(a, 0, result, 0, a.size());\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        System.arraycopy(b, 0, result, a.size(), b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.size()];\n\n        // System.arraycopy(a, 0, result, 0, a.length);\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        // System.arraycopy(b, 0, result, a.length, b.length);\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.size()] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  // Note: PolyAll is not quite right.  Need to review.\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first array to concatenate\n   * @param b the second array to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static /*@PolyAll*/ String[] concat(\n      /*@PolyAll*/ String /*@Nullable*/ [] a, /*@PolyAll*/ String /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new String[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        /*@PolyAll*/ String[] result = new String[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static byte[] concat(byte /*@Nullable*/ [] a, byte /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new byte[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        byte[] result = new byte[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static boolean[] concat(boolean /*@Nullable*/ [] a, boolean /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new boolean[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        boolean[] result = new boolean[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static char[] concat(char /*@Nullable*/ [] a, char /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new char[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        char[] result = new char[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static double[] concat(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new double[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        double[] result = new double[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static float[] concat(float /*@Nullable*/ [] a, float /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new float[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        float[] result = new float[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static int[] concat(int /*@Nullable*/ [] a, int /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new int[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        int[] result = new int[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static long[] concat(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new long[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        long[] result = new long[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static short[] concat(short /*@Nullable*/ [] a, short /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new short[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        short[] result = new short[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Printing\n  ///\n\n  // This should be extended to all types, when I get around to it.  The\n  // methods are patterned after that of java.util.Vector (and use its\n  // output format).\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, each element is quoted like a Java String.\n   * @param a an array\n   * @return a string representation of the array, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, if quoted is true, then each element is quoted like a Java String.\n   * @param a an array\n   * @param quoted whether to quote the array elements\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        if (quoted && a[i] instanceof String) {\n          String elt = (String) a[i];\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava(elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(a[i]);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@Nullable*/ Collection<?> a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @param quoted whether to quote the collection elements that are Java strings\n   * @return a string representation of the list\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n      Iterator<?> itor = a.iterator();\n      sb.append(itor.next());\n      while (itor.hasNext()) {\n        sb.append(\", \");\n        Object elt = itor.next();\n        if (quoted && elt instanceof String) {\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava((String) elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(elt);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(int /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(long /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(double /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(float /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(boolean /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls the appropriate\n   * toString() method.  Only call this method if obj is a boolean, double,\n   * int, long, or Object array.\n   * @param obj an array\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@SideEffectFree*/\n  public static String toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n      return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n      return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n      return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n      return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n      return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n      return toString((List<?>) obj);\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls .length.\n   * Only call this method if obj is a boolean, double, int, long, or Object array.\n   * @param obj a list\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@Pure*/\n  public static int length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n      return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n      return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n      return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n      return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n      return ((List<?>) obj).size();\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Sortedness\n  ///\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Boolean n = Boolean.valueOf(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Byte n = new Byte(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Character n = new Character(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Float n = new Float(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Short n = new Short(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Integer n = new Integer(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space. Equality checking\n   * uses the .equals() method for java.lang.Double.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Double n = new Double(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Long n = new Long(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param <T> the type of the elements\n   * @param a a list\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static <T> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n      if (hs.contains(a.get(i))) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a.get(i));\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Arrays as partial functions of int->int\n  ///\n\n  /**\n   * Returns true if the array is a permutation of [0..a.length).\n   * @param a an array, representing a function\n   * @return true iff all elements of a are in [0..a.length) and a\n   * contains no duplicates.\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (array)\n  /*@Pure*/\n  public static boolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int n = a[i];\n      if (n < 0 || n >= a.length || see[n]) {\n        return false;\n      }\n      see[n] = true;\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff the array does not contain -1.\n   * @param a an array, representing a function\n   * @return true iff no element of a maps to -1\n   */\n  /*@Pure*/\n  public static boolean fn_is_total(int[] a) {\n    return indexOf(a, -1) == -1; // not found\n  }\n\n  /**\n   * Return an array [0..lenth).\n   * @param length the length of the result\n   * @return fresh array that is the identity function of the given length\n   */\n  public static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n      result[i] = i;\n    }\n    return result;\n  }\n\n  /**\n   * Requires that fn_is_permutation(a) holds.\n   * @param a the input permutation\n   * @return fresh array which is the inverse of the given permutation\n   * @see #fn_is_permutation(int[])\n   */\n  public static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n  }\n\n  /**\n   * Return the inverse of the given function, which is represented as an array.\n   * @param a an array representing a function from [0..a.length) to [0..arange);\n   *  each element of a is between 0 and arange inclusive\n   * @param arange length of the argument's range and the result's domain\n   * @return function from [0..arange) to [0..a.length) that is the inverse of a\n   * @throws IllegalArgumentException if a value of a is outside of arange\n   * @exception UnsupportedOperationException when the function is not invertible\n   */\n  public static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n      int ai = a[i];\n      if (ai < -1 || ai >= arange) {\n        throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n      }\n      // ai is either -1 or a valid index\n      if (ai >= 0) {\n        if (result[ai] != -1) {\n          throw new UnsupportedOperationException(\n              String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n        }\n        result[ai] = i;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the composition of the given two functions, all of which are\n   * represented as arrays.\n   * @param a function from [0..a.length) to [0..b.length)\n   * @param b function from [0..b.length) to range R\n   * @return function from [0..a.length) to range R that is the\n   * composition of a and b\n   */\n  public static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int inner = a[i];\n      if (inner == -1) {\n        result[i] = -1;\n      } else {\n        result[i] = b[inner];\n      }\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set operations, such as subset, unions, and intersections\n  ///\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Long(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Long elt = new Long(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Double(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Double elt = new Double(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(bigger[i]);\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      if (!setBigger.contains(smaller[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array comparators\n  ///\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLexical implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer,\n     * depending on whether the first argument is less than,\n     * equal to, or greater than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLexical implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class DoubleArrayComparatorLexical\n      implements Comparator<double[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(double[] a1, double[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int result = Double.compare(a1[i], a2[i]);\n        if (result != 0) {\n          return (result);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * Strings).\n   */\n  public static final class StringArrayComparatorLexical\n      implements Comparator<String[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) String[], @PolyAll(2) String[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ String[] a1, /*@PolyAll*/ String[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int tmp = 0;\n        if ((a1[i] == null) && (a2[i] == null)) {\n          tmp = 0;\n        } else if (a1[i] == null) {\n          tmp = -1;\n        } else if (a2[i] == null) {\n          tmp = 1;\n        } else {\n          tmp = a1[i].compareTo(a2[i]);\n        }\n        if (tmp != 0) {\n          return (tmp);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLexical<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLexical\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLengthFirst\n      implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLengthFirst\n      implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int lendiff = a1.length - a2.length;\n      if (lendiff != 0) {\n        return lendiff;\n      }\n      long tmp;\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLengthFirst<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLengthFirst\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// nullness\n  ///\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(/*@PolyAll*/ Object[] a) {\n    if (a.length == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(/*@PolyAll*/ Object[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (!(a[i] == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n      if (!(a.get(i) == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// javadoc hacks\n  ///\n\n  // Without this, the Javadoc mentions of \"java.util.Vector\", are not links\n  // in the generated HTML.\n  // \"private static Vector v;\" doesn't work, nor does\n  // \"static { new java.util.Vector(); }\", nor does \"private Vector v\".\n  // Yuck!\n  public Vector<?> javadocLossage;\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "a", "", "char[]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "", "char[]", "public boolean equals(Object);" ], [ "toString", "", "char[]", "public String toString()" ], [ "hashCode", "", "char[]", "public native int hashCode()" ], [ "getClass", "", "char[]", "public final native Class getClass();" ], [ "clone", "", "char[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "javadocLossage", "plume", "ArraysMDE", "public Vector<?> javadocLossage;" ], [ "length", "", "char[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10912,
  "oracle" : ";",
  "oracleType" : "NORMAL_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "ArraysMDE",
  "javadocTag" : "@return true if a does not have any elements that appear more than once",
  "methodJavadoc" : "    /**\n     * Return true iff a does not contain duplicate elements,\n     * using O(n) time and O(n) space.\n     * \n     * @param a an array\n     * @return true if a does not have any elements that appear more than once\n     */",
  "methodSourceCode" : "public static /*@Pure*/\nboolean noDuplicates(char[] a);",
  "classJavadoc" : "/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Vector;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\nimport org.checkerframework.framework.qual.PolyAll;\n*/\n\n/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */\n@SuppressWarnings(\"interning\") // to do later\npublic final class ArraysMDE {\n  /** This class is a collecton of methods; it does not represent anything. */\n  private ArraysMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// min, max\n  ///\n\n  // Could also add linear-time orderStatistics if I liked.\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int min(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long min(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double min(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer min(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long min(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() < result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double min(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int max(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long max(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double max(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer max(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long max(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() > result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double max(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int[] min_max(int[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] {result_min, result_max};\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long[] min_max(long[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] {result_min, result_max};\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int element_range(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long element_range(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Returns the sum of an array of integers.\n   * @param a an array\n   * @return the sum of an array of integers\n   */\n  public static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of integers.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of integers\n   */\n  public static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of an array of doubles.\n   * @param a an array\n   * @return the sum of an array of doubles\n   */\n  public static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of doubles.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of doubles\n   */\n  public static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf\n  ///\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> type of the elements of the array\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt) {\n    if (elt == null) {\n      return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> the type of the elements\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   *    Identical to List.indexOf, but included for completeness.\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    return a.indexOf(elt);\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a.get(i))) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      /*@PolyNull*/ Object[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.size(); i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf, for finding subarrays\n  ///\n\n  // This is analogous to Common Lisp's \"search\" function.\n\n  // This implementation is very inefficient; I could use tricky Boyer-Moore\n  // search techniques if I liked, but it's not worth it to me yet.\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  // The signature on this method is unnecessarily strict because it\n  // requires that the component types be identical.  The signature should\n  // be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n  // @PolyAll qualifier does not yet take an argument.\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// mismatch\n  ///\n\n  // This is analogous to Common Lisp's \"mismatch\" function.\n\n  // Put it off until later; for now, use the simpler subarray function,\n  // which is a specialization of mismatch,\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray extraction\n  ///\n\n  // Note that the second argument is a length, not an end position.\n  // That's to avoid confusion over whether it would be the last included\n  // index or the first non-included index.\n\n  /**\n   * Return a subarray of the given array.\n   * @return a subarray of the given array\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ Object[] subarray(\n      /*@PolyAll*/ Object[] a, int startindex, int length) {\n    /*@PolyAll*/ Object[] result = new /*@PolyAll*/ Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a sublist of the given list.\n   * @param <T> type of the elements\n   * @param a the original list\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a sublist of the given list\n   */\n  /*@SideEffectFree*/\n  public static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ String[] subarray(\n      /*@PolyAll*/ String[] a, int startindex, int length) {\n    /*@PolyAll*/ String[] result = new /*@PolyAll*/ String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray testing\n  ///\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(\n      /*@PolyAll*/ Object[] a, /*@PolyNull*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(\n      /*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// concatenation\n  ///\n\n  // Concat used to return null if both arguments are null.  That is\n  // convenient for the implementer, but not so good for clients.\n\n  /**\n   * Call this method in order to suppress compiler warnings.\n   * @param <T> the base type of the result\n   * @param lst the list to convert to an array\n   * @return the result of lst.toArray, casted to a more precise type than Object[]\n   */\n  private static <T> T[] toTArray(List<T> lst) {\n    @SuppressWarnings(\"unchecked\")\n    T[] asArray = (T[]) lst.toArray();\n    return asArray;\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.size()];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        // System.arraycopy(b, 0, result, a.length, b.size());\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.length] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.length];\n\n        // System.arraycopy(a, 0, result, 0, a.size());\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        System.arraycopy(b, 0, result, a.size(), b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.size()];\n\n        // System.arraycopy(a, 0, result, 0, a.length);\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        // System.arraycopy(b, 0, result, a.length, b.length);\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.size()] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  // Note: PolyAll is not quite right.  Need to review.\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first array to concatenate\n   * @param b the second array to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static /*@PolyAll*/ String[] concat(\n      /*@PolyAll*/ String /*@Nullable*/ [] a, /*@PolyAll*/ String /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new String[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        /*@PolyAll*/ String[] result = new String[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static byte[] concat(byte /*@Nullable*/ [] a, byte /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new byte[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        byte[] result = new byte[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static boolean[] concat(boolean /*@Nullable*/ [] a, boolean /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new boolean[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        boolean[] result = new boolean[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static char[] concat(char /*@Nullable*/ [] a, char /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new char[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        char[] result = new char[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static double[] concat(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new double[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        double[] result = new double[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static float[] concat(float /*@Nullable*/ [] a, float /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new float[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        float[] result = new float[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static int[] concat(int /*@Nullable*/ [] a, int /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new int[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        int[] result = new int[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static long[] concat(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new long[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        long[] result = new long[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static short[] concat(short /*@Nullable*/ [] a, short /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new short[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        short[] result = new short[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Printing\n  ///\n\n  // This should be extended to all types, when I get around to it.  The\n  // methods are patterned after that of java.util.Vector (and use its\n  // output format).\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, each element is quoted like a Java String.\n   * @param a an array\n   * @return a string representation of the array, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, if quoted is true, then each element is quoted like a Java String.\n   * @param a an array\n   * @param quoted whether to quote the array elements\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        if (quoted && a[i] instanceof String) {\n          String elt = (String) a[i];\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava(elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(a[i]);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@Nullable*/ Collection<?> a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @param quoted whether to quote the collection elements that are Java strings\n   * @return a string representation of the list\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n      Iterator<?> itor = a.iterator();\n      sb.append(itor.next());\n      while (itor.hasNext()) {\n        sb.append(\", \");\n        Object elt = itor.next();\n        if (quoted && elt instanceof String) {\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava((String) elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(elt);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(int /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(long /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(double /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(float /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(boolean /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls the appropriate\n   * toString() method.  Only call this method if obj is a boolean, double,\n   * int, long, or Object array.\n   * @param obj an array\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@SideEffectFree*/\n  public static String toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n      return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n      return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n      return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n      return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n      return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n      return toString((List<?>) obj);\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls .length.\n   * Only call this method if obj is a boolean, double, int, long, or Object array.\n   * @param obj a list\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@Pure*/\n  public static int length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n      return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n      return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n      return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n      return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n      return ((List<?>) obj).size();\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Sortedness\n  ///\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Boolean n = Boolean.valueOf(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Byte n = new Byte(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Character n = new Character(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Float n = new Float(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Short n = new Short(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Integer n = new Integer(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space. Equality checking\n   * uses the .equals() method for java.lang.Double.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Double n = new Double(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Long n = new Long(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param <T> the type of the elements\n   * @param a a list\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static <T> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n      if (hs.contains(a.get(i))) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a.get(i));\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Arrays as partial functions of int->int\n  ///\n\n  /**\n   * Returns true if the array is a permutation of [0..a.length).\n   * @param a an array, representing a function\n   * @return true iff all elements of a are in [0..a.length) and a\n   * contains no duplicates.\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (array)\n  /*@Pure*/\n  public static boolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int n = a[i];\n      if (n < 0 || n >= a.length || see[n]) {\n        return false;\n      }\n      see[n] = true;\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff the array does not contain -1.\n   * @param a an array, representing a function\n   * @return true iff no element of a maps to -1\n   */\n  /*@Pure*/\n  public static boolean fn_is_total(int[] a) {\n    return indexOf(a, -1) == -1; // not found\n  }\n\n  /**\n   * Return an array [0..lenth).\n   * @param length the length of the result\n   * @return fresh array that is the identity function of the given length\n   */\n  public static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n      result[i] = i;\n    }\n    return result;\n  }\n\n  /**\n   * Requires that fn_is_permutation(a) holds.\n   * @param a the input permutation\n   * @return fresh array which is the inverse of the given permutation\n   * @see #fn_is_permutation(int[])\n   */\n  public static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n  }\n\n  /**\n   * Return the inverse of the given function, which is represented as an array.\n   * @param a an array representing a function from [0..a.length) to [0..arange);\n   *  each element of a is between 0 and arange inclusive\n   * @param arange length of the argument's range and the result's domain\n   * @return function from [0..arange) to [0..a.length) that is the inverse of a\n   * @throws IllegalArgumentException if a value of a is outside of arange\n   * @exception UnsupportedOperationException when the function is not invertible\n   */\n  public static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n      int ai = a[i];\n      if (ai < -1 || ai >= arange) {\n        throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n      }\n      // ai is either -1 or a valid index\n      if (ai >= 0) {\n        if (result[ai] != -1) {\n          throw new UnsupportedOperationException(\n              String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n        }\n        result[ai] = i;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the composition of the given two functions, all of which are\n   * represented as arrays.\n   * @param a function from [0..a.length) to [0..b.length)\n   * @param b function from [0..b.length) to range R\n   * @return function from [0..a.length) to range R that is the\n   * composition of a and b\n   */\n  public static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int inner = a[i];\n      if (inner == -1) {\n        result[i] = -1;\n      } else {\n        result[i] = b[inner];\n      }\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set operations, such as subset, unions, and intersections\n  ///\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Long(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Long elt = new Long(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Double(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Double elt = new Double(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(bigger[i]);\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      if (!setBigger.contains(smaller[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array comparators\n  ///\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLexical implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer,\n     * depending on whether the first argument is less than,\n     * equal to, or greater than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLexical implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class DoubleArrayComparatorLexical\n      implements Comparator<double[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(double[] a1, double[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int result = Double.compare(a1[i], a2[i]);\n        if (result != 0) {\n          return (result);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * Strings).\n   */\n  public static final class StringArrayComparatorLexical\n      implements Comparator<String[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) String[], @PolyAll(2) String[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ String[] a1, /*@PolyAll*/ String[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int tmp = 0;\n        if ((a1[i] == null) && (a2[i] == null)) {\n          tmp = 0;\n        } else if (a1[i] == null) {\n          tmp = -1;\n        } else if (a2[i] == null) {\n          tmp = 1;\n        } else {\n          tmp = a1[i].compareTo(a2[i]);\n        }\n        if (tmp != 0) {\n          return (tmp);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLexical<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLexical\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLengthFirst\n      implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLengthFirst\n      implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int lendiff = a1.length - a2.length;\n      if (lendiff != 0) {\n        return lendiff;\n      }\n      long tmp;\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLengthFirst<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLengthFirst\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// nullness\n  ///\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(/*@PolyAll*/ Object[] a) {\n    if (a.length == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(/*@PolyAll*/ Object[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (!(a[i] == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n      if (!(a.get(i) == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// javadoc hacks\n  ///\n\n  // Without this, the Javadoc mentions of \"java.util.Vector\", are not links\n  // in the generated HTML.\n  // \"private static Vector v;\" doesn't work, nor does\n  // \"static { new java.util.Vector(); }\", nor does \"private Vector v\".\n  // Yuck!\n  public Vector<?> javadocLossage;\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "a", "", "char[]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "", "char[]", "public boolean equals(Object);" ], [ "toString", "", "char[]", "public String toString()" ], [ "hashCode", "", "char[]", "public native int hashCode()" ], [ "getClass", "", "char[]", "public final native Class getClass();" ], [ "clone", "", "char[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "javadocLossage", "plume", "ArraysMDE", "public Vector<?> javadocLossage;" ], [ "length", "", "char[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10912,
  "oracle" : ";",
  "oracleType" : "NORMAL_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "ArraysMDE",
  "javadocTag" : "@return true if array a does not have any duplicate elements",
  "methodJavadoc" : "    /**\n     * Return true iff a does not contain duplicate elements,\n     * using O(n) time and O(n) space.\n     * \n     * @param a an array\n     * @return true if array a does not have any duplicate elements\n     */",
  "methodSourceCode" : "public static /*@Pure*/\nboolean noDuplicates(char[] a){\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Character n = new Character(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}",
  "classJavadoc" : "/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Vector;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\nimport org.checkerframework.framework.qual.PolyAll;\n*/\n\n/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */\n@SuppressWarnings(\"interning\") // to do later\npublic final class ArraysMDE {\n  /** This class is a collecton of methods; it does not represent anything. */\n  private ArraysMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// min, max\n  ///\n\n  // Could also add linear-time orderStatistics if I liked.\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int min(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long min(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double min(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer min(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long min(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() < result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double min(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int max(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long max(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double max(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer max(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long max(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() > result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double max(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int[] min_max(int[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] {result_min, result_max};\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long[] min_max(long[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] {result_min, result_max};\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int element_range(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long element_range(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Returns the sum of an array of integers.\n   * @param a an array\n   * @return the sum of an array of integers\n   */\n  public static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of integers.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of integers\n   */\n  public static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of an array of doubles.\n   * @param a an array\n   * @return the sum of an array of doubles\n   */\n  public static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of doubles.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of doubles\n   */\n  public static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf\n  ///\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> type of the elements of the array\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt) {\n    if (elt == null) {\n      return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> the type of the elements\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   *    Identical to List.indexOf, but included for completeness.\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    return a.indexOf(elt);\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a.get(i))) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      /*@PolyNull*/ Object[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.size(); i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf, for finding subarrays\n  ///\n\n  // This is analogous to Common Lisp's \"search\" function.\n\n  // This implementation is very inefficient; I could use tricky Boyer-Moore\n  // search techniques if I liked, but it's not worth it to me yet.\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  // The signature on this method is unnecessarily strict because it\n  // requires that the component types be identical.  The signature should\n  // be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n  // @PolyAll qualifier does not yet take an argument.\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// mismatch\n  ///\n\n  // This is analogous to Common Lisp's \"mismatch\" function.\n\n  // Put it off until later; for now, use the simpler subarray function,\n  // which is a specialization of mismatch,\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray extraction\n  ///\n\n  // Note that the second argument is a length, not an end position.\n  // That's to avoid confusion over whether it would be the last included\n  // index or the first non-included index.\n\n  /**\n   * Return a subarray of the given array.\n   * @return a subarray of the given array\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ Object[] subarray(\n      /*@PolyAll*/ Object[] a, int startindex, int length) {\n    /*@PolyAll*/ Object[] result = new /*@PolyAll*/ Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a sublist of the given list.\n   * @param <T> type of the elements\n   * @param a the original list\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a sublist of the given list\n   */\n  /*@SideEffectFree*/\n  public static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ String[] subarray(\n      /*@PolyAll*/ String[] a, int startindex, int length) {\n    /*@PolyAll*/ String[] result = new /*@PolyAll*/ String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray testing\n  ///\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(\n      /*@PolyAll*/ Object[] a, /*@PolyNull*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(\n      /*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// concatenation\n  ///\n\n  // Concat used to return null if both arguments are null.  That is\n  // convenient for the implementer, but not so good for clients.\n\n  /**\n   * Call this method in order to suppress compiler warnings.\n   * @param <T> the base type of the result\n   * @param lst the list to convert to an array\n   * @return the result of lst.toArray, casted to a more precise type than Object[]\n   */\n  private static <T> T[] toTArray(List<T> lst) {\n    @SuppressWarnings(\"unchecked\")\n    T[] asArray = (T[]) lst.toArray();\n    return asArray;\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.size()];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        // System.arraycopy(b, 0, result, a.length, b.size());\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.length] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.length];\n\n        // System.arraycopy(a, 0, result, 0, a.size());\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        System.arraycopy(b, 0, result, a.size(), b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.size()];\n\n        // System.arraycopy(a, 0, result, 0, a.length);\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        // System.arraycopy(b, 0, result, a.length, b.length);\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.size()] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  // Note: PolyAll is not quite right.  Need to review.\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first array to concatenate\n   * @param b the second array to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static /*@PolyAll*/ String[] concat(\n      /*@PolyAll*/ String /*@Nullable*/ [] a, /*@PolyAll*/ String /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new String[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        /*@PolyAll*/ String[] result = new String[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static byte[] concat(byte /*@Nullable*/ [] a, byte /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new byte[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        byte[] result = new byte[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static boolean[] concat(boolean /*@Nullable*/ [] a, boolean /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new boolean[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        boolean[] result = new boolean[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static char[] concat(char /*@Nullable*/ [] a, char /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new char[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        char[] result = new char[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static double[] concat(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new double[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        double[] result = new double[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static float[] concat(float /*@Nullable*/ [] a, float /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new float[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        float[] result = new float[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static int[] concat(int /*@Nullable*/ [] a, int /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new int[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        int[] result = new int[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static long[] concat(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new long[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        long[] result = new long[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static short[] concat(short /*@Nullable*/ [] a, short /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new short[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        short[] result = new short[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Printing\n  ///\n\n  // This should be extended to all types, when I get around to it.  The\n  // methods are patterned after that of java.util.Vector (and use its\n  // output format).\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, each element is quoted like a Java String.\n   * @param a an array\n   * @return a string representation of the array, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, if quoted is true, then each element is quoted like a Java String.\n   * @param a an array\n   * @param quoted whether to quote the array elements\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        if (quoted && a[i] instanceof String) {\n          String elt = (String) a[i];\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava(elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(a[i]);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@Nullable*/ Collection<?> a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @param quoted whether to quote the collection elements that are Java strings\n   * @return a string representation of the list\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n      Iterator<?> itor = a.iterator();\n      sb.append(itor.next());\n      while (itor.hasNext()) {\n        sb.append(\", \");\n        Object elt = itor.next();\n        if (quoted && elt instanceof String) {\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava((String) elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(elt);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(int /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(long /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(double /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(float /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(boolean /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls the appropriate\n   * toString() method.  Only call this method if obj is a boolean, double,\n   * int, long, or Object array.\n   * @param obj an array\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@SideEffectFree*/\n  public static String toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n      return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n      return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n      return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n      return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n      return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n      return toString((List<?>) obj);\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls .length.\n   * Only call this method if obj is a boolean, double, int, long, or Object array.\n   * @param obj a list\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@Pure*/\n  public static int length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n      return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n      return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n      return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n      return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n      return ((List<?>) obj).size();\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Sortedness\n  ///\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Boolean n = Boolean.valueOf(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Byte n = new Byte(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Character n = new Character(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Float n = new Float(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Short n = new Short(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Integer n = new Integer(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space. Equality checking\n   * uses the .equals() method for java.lang.Double.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Double n = new Double(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Long n = new Long(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param <T> the type of the elements\n   * @param a a list\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static <T> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n      if (hs.contains(a.get(i))) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a.get(i));\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Arrays as partial functions of int->int\n  ///\n\n  /**\n   * Returns true if the array is a permutation of [0..a.length).\n   * @param a an array, representing a function\n   * @return true iff all elements of a are in [0..a.length) and a\n   * contains no duplicates.\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (array)\n  /*@Pure*/\n  public static boolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int n = a[i];\n      if (n < 0 || n >= a.length || see[n]) {\n        return false;\n      }\n      see[n] = true;\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff the array does not contain -1.\n   * @param a an array, representing a function\n   * @return true iff no element of a maps to -1\n   */\n  /*@Pure*/\n  public static boolean fn_is_total(int[] a) {\n    return indexOf(a, -1) == -1; // not found\n  }\n\n  /**\n   * Return an array [0..lenth).\n   * @param length the length of the result\n   * @return fresh array that is the identity function of the given length\n   */\n  public static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n      result[i] = i;\n    }\n    return result;\n  }\n\n  /**\n   * Requires that fn_is_permutation(a) holds.\n   * @param a the input permutation\n   * @return fresh array which is the inverse of the given permutation\n   * @see #fn_is_permutation(int[])\n   */\n  public static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n  }\n\n  /**\n   * Return the inverse of the given function, which is represented as an array.\n   * @param a an array representing a function from [0..a.length) to [0..arange);\n   *  each element of a is between 0 and arange inclusive\n   * @param arange length of the argument's range and the result's domain\n   * @return function from [0..arange) to [0..a.length) that is the inverse of a\n   * @throws IllegalArgumentException if a value of a is outside of arange\n   * @exception UnsupportedOperationException when the function is not invertible\n   */\n  public static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n      int ai = a[i];\n      if (ai < -1 || ai >= arange) {\n        throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n      }\n      // ai is either -1 or a valid index\n      if (ai >= 0) {\n        if (result[ai] != -1) {\n          throw new UnsupportedOperationException(\n              String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n        }\n        result[ai] = i;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the composition of the given two functions, all of which are\n   * represented as arrays.\n   * @param a function from [0..a.length) to [0..b.length)\n   * @param b function from [0..b.length) to range R\n   * @return function from [0..a.length) to range R that is the\n   * composition of a and b\n   */\n  public static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int inner = a[i];\n      if (inner == -1) {\n        result[i] = -1;\n      } else {\n        result[i] = b[inner];\n      }\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set operations, such as subset, unions, and intersections\n  ///\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Long(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Long elt = new Long(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Double(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Double elt = new Double(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(bigger[i]);\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      if (!setBigger.contains(smaller[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array comparators\n  ///\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLexical implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer,\n     * depending on whether the first argument is less than,\n     * equal to, or greater than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLexical implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class DoubleArrayComparatorLexical\n      implements Comparator<double[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(double[] a1, double[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int result = Double.compare(a1[i], a2[i]);\n        if (result != 0) {\n          return (result);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * Strings).\n   */\n  public static final class StringArrayComparatorLexical\n      implements Comparator<String[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) String[], @PolyAll(2) String[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ String[] a1, /*@PolyAll*/ String[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int tmp = 0;\n        if ((a1[i] == null) && (a2[i] == null)) {\n          tmp = 0;\n        } else if (a1[i] == null) {\n          tmp = -1;\n        } else if (a2[i] == null) {\n          tmp = 1;\n        } else {\n          tmp = a1[i].compareTo(a2[i]);\n        }\n        if (tmp != 0) {\n          return (tmp);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLexical<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLexical\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLengthFirst\n      implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLengthFirst\n      implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int lendiff = a1.length - a2.length;\n      if (lendiff != 0) {\n        return lendiff;\n      }\n      long tmp;\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLengthFirst<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLengthFirst\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// nullness\n  ///\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(/*@PolyAll*/ Object[] a) {\n    if (a.length == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(/*@PolyAll*/ Object[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (!(a[i] == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n      if (!(a.get(i) == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// javadoc hacks\n  ///\n\n  // Without this, the Javadoc mentions of \"java.util.Vector\", are not links\n  // in the generated HTML.\n  // \"private static Vector v;\" doesn't work, nor does\n  // \"static { new java.util.Vector(); }\", nor does \"private Vector v\".\n  // Yuck!\n  public Vector<?> javadocLossage;\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "a", "", "char[]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "", "char[]", "public boolean equals(Object);" ], [ "toString", "", "char[]", "public String toString()" ], [ "hashCode", "", "char[]", "public native int hashCode()" ], [ "getClass", "", "char[]", "public final native Class getClass();" ], [ "clone", "", "char[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "javadocLossage", "plume", "ArraysMDE", "public Vector<?> javadocLossage;" ], [ "length", "", "char[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10912,
  "oracle" : ";",
  "oracleType" : "NORMAL_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "ArraysMDE",
  "javadocTag" : "@return true if there are no duplicate elements in array a",
  "methodJavadoc" : "    /**\n     * Return true iff a does not contain duplicate elements,\n     * using O(n) time and O(n) space.\n     * \n     * @param a an array\n     * @return true if there are no duplicate elements in array a\n     */",
  "methodSourceCode" : "public static /*@Pure*/\nboolean noDuplicates(char[] a);",
  "classJavadoc" : "/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Vector;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\nimport org.checkerframework.framework.qual.PolyAll;\n*/\n\n/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */\n@SuppressWarnings(\"interning\") // to do later\npublic final class ArraysMDE {\n  /** This class is a collecton of methods; it does not represent anything. */\n  private ArraysMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// min, max\n  ///\n\n  // Could also add linear-time orderStatistics if I liked.\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int min(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long min(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double min(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer min(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long min(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() < result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double min(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int max(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long max(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double max(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer max(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long max(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() > result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double max(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int[] min_max(int[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] {result_min, result_max};\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long[] min_max(long[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] {result_min, result_max};\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int element_range(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long element_range(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Returns the sum of an array of integers.\n   * @param a an array\n   * @return the sum of an array of integers\n   */\n  public static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of integers.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of integers\n   */\n  public static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of an array of doubles.\n   * @param a an array\n   * @return the sum of an array of doubles\n   */\n  public static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of doubles.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of doubles\n   */\n  public static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf\n  ///\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> type of the elements of the array\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt) {\n    if (elt == null) {\n      return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> the type of the elements\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   *    Identical to List.indexOf, but included for completeness.\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    return a.indexOf(elt);\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a.get(i))) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      /*@PolyNull*/ Object[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.size(); i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf, for finding subarrays\n  ///\n\n  // This is analogous to Common Lisp's \"search\" function.\n\n  // This implementation is very inefficient; I could use tricky Boyer-Moore\n  // search techniques if I liked, but it's not worth it to me yet.\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  // The signature on this method is unnecessarily strict because it\n  // requires that the component types be identical.  The signature should\n  // be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n  // @PolyAll qualifier does not yet take an argument.\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// mismatch\n  ///\n\n  // This is analogous to Common Lisp's \"mismatch\" function.\n\n  // Put it off until later; for now, use the simpler subarray function,\n  // which is a specialization of mismatch,\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray extraction\n  ///\n\n  // Note that the second argument is a length, not an end position.\n  // That's to avoid confusion over whether it would be the last included\n  // index or the first non-included index.\n\n  /**\n   * Return a subarray of the given array.\n   * @return a subarray of the given array\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ Object[] subarray(\n      /*@PolyAll*/ Object[] a, int startindex, int length) {\n    /*@PolyAll*/ Object[] result = new /*@PolyAll*/ Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a sublist of the given list.\n   * @param <T> type of the elements\n   * @param a the original list\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a sublist of the given list\n   */\n  /*@SideEffectFree*/\n  public static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ String[] subarray(\n      /*@PolyAll*/ String[] a, int startindex, int length) {\n    /*@PolyAll*/ String[] result = new /*@PolyAll*/ String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray testing\n  ///\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(\n      /*@PolyAll*/ Object[] a, /*@PolyNull*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(\n      /*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// concatenation\n  ///\n\n  // Concat used to return null if both arguments are null.  That is\n  // convenient for the implementer, but not so good for clients.\n\n  /**\n   * Call this method in order to suppress compiler warnings.\n   * @param <T> the base type of the result\n   * @param lst the list to convert to an array\n   * @return the result of lst.toArray, casted to a more precise type than Object[]\n   */\n  private static <T> T[] toTArray(List<T> lst) {\n    @SuppressWarnings(\"unchecked\")\n    T[] asArray = (T[]) lst.toArray();\n    return asArray;\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.size()];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        // System.arraycopy(b, 0, result, a.length, b.size());\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.length] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.length];\n\n        // System.arraycopy(a, 0, result, 0, a.size());\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        System.arraycopy(b, 0, result, a.size(), b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.size()];\n\n        // System.arraycopy(a, 0, result, 0, a.length);\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        // System.arraycopy(b, 0, result, a.length, b.length);\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.size()] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  // Note: PolyAll is not quite right.  Need to review.\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first array to concatenate\n   * @param b the second array to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static /*@PolyAll*/ String[] concat(\n      /*@PolyAll*/ String /*@Nullable*/ [] a, /*@PolyAll*/ String /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new String[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        /*@PolyAll*/ String[] result = new String[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static byte[] concat(byte /*@Nullable*/ [] a, byte /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new byte[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        byte[] result = new byte[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static boolean[] concat(boolean /*@Nullable*/ [] a, boolean /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new boolean[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        boolean[] result = new boolean[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static char[] concat(char /*@Nullable*/ [] a, char /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new char[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        char[] result = new char[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static double[] concat(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new double[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        double[] result = new double[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static float[] concat(float /*@Nullable*/ [] a, float /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new float[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        float[] result = new float[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static int[] concat(int /*@Nullable*/ [] a, int /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new int[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        int[] result = new int[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static long[] concat(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new long[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        long[] result = new long[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static short[] concat(short /*@Nullable*/ [] a, short /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new short[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        short[] result = new short[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Printing\n  ///\n\n  // This should be extended to all types, when I get around to it.  The\n  // methods are patterned after that of java.util.Vector (and use its\n  // output format).\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, each element is quoted like a Java String.\n   * @param a an array\n   * @return a string representation of the array, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, if quoted is true, then each element is quoted like a Java String.\n   * @param a an array\n   * @param quoted whether to quote the array elements\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        if (quoted && a[i] instanceof String) {\n          String elt = (String) a[i];\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava(elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(a[i]);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@Nullable*/ Collection<?> a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @param quoted whether to quote the collection elements that are Java strings\n   * @return a string representation of the list\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n      Iterator<?> itor = a.iterator();\n      sb.append(itor.next());\n      while (itor.hasNext()) {\n        sb.append(\", \");\n        Object elt = itor.next();\n        if (quoted && elt instanceof String) {\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava((String) elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(elt);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(int /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(long /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(double /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(float /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(boolean /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls the appropriate\n   * toString() method.  Only call this method if obj is a boolean, double,\n   * int, long, or Object array.\n   * @param obj an array\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@SideEffectFree*/\n  public static String toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n      return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n      return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n      return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n      return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n      return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n      return toString((List<?>) obj);\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls .length.\n   * Only call this method if obj is a boolean, double, int, long, or Object array.\n   * @param obj a list\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@Pure*/\n  public static int length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n      return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n      return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n      return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n      return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n      return ((List<?>) obj).size();\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Sortedness\n  ///\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Boolean n = Boolean.valueOf(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Byte n = new Byte(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Character n = new Character(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Float n = new Float(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Short n = new Short(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Integer n = new Integer(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space. Equality checking\n   * uses the .equals() method for java.lang.Double.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Double n = new Double(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Long n = new Long(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param <T> the type of the elements\n   * @param a a list\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static <T> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n      if (hs.contains(a.get(i))) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a.get(i));\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Arrays as partial functions of int->int\n  ///\n\n  /**\n   * Returns true if the array is a permutation of [0..a.length).\n   * @param a an array, representing a function\n   * @return true iff all elements of a are in [0..a.length) and a\n   * contains no duplicates.\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (array)\n  /*@Pure*/\n  public static boolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int n = a[i];\n      if (n < 0 || n >= a.length || see[n]) {\n        return false;\n      }\n      see[n] = true;\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff the array does not contain -1.\n   * @param a an array, representing a function\n   * @return true iff no element of a maps to -1\n   */\n  /*@Pure*/\n  public static boolean fn_is_total(int[] a) {\n    return indexOf(a, -1) == -1; // not found\n  }\n\n  /**\n   * Return an array [0..lenth).\n   * @param length the length of the result\n   * @return fresh array that is the identity function of the given length\n   */\n  public static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n      result[i] = i;\n    }\n    return result;\n  }\n\n  /**\n   * Requires that fn_is_permutation(a) holds.\n   * @param a the input permutation\n   * @return fresh array which is the inverse of the given permutation\n   * @see #fn_is_permutation(int[])\n   */\n  public static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n  }\n\n  /**\n   * Return the inverse of the given function, which is represented as an array.\n   * @param a an array representing a function from [0..a.length) to [0..arange);\n   *  each element of a is between 0 and arange inclusive\n   * @param arange length of the argument's range and the result's domain\n   * @return function from [0..arange) to [0..a.length) that is the inverse of a\n   * @throws IllegalArgumentException if a value of a is outside of arange\n   * @exception UnsupportedOperationException when the function is not invertible\n   */\n  public static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n      int ai = a[i];\n      if (ai < -1 || ai >= arange) {\n        throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n      }\n      // ai is either -1 or a valid index\n      if (ai >= 0) {\n        if (result[ai] != -1) {\n          throw new UnsupportedOperationException(\n              String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n        }\n        result[ai] = i;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the composition of the given two functions, all of which are\n   * represented as arrays.\n   * @param a function from [0..a.length) to [0..b.length)\n   * @param b function from [0..b.length) to range R\n   * @return function from [0..a.length) to range R that is the\n   * composition of a and b\n   */\n  public static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int inner = a[i];\n      if (inner == -1) {\n        result[i] = -1;\n      } else {\n        result[i] = b[inner];\n      }\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set operations, such as subset, unions, and intersections\n  ///\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Long(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Long elt = new Long(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Double(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Double elt = new Double(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(bigger[i]);\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      if (!setBigger.contains(smaller[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array comparators\n  ///\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLexical implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer,\n     * depending on whether the first argument is less than,\n     * equal to, or greater than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLexical implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class DoubleArrayComparatorLexical\n      implements Comparator<double[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(double[] a1, double[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int result = Double.compare(a1[i], a2[i]);\n        if (result != 0) {\n          return (result);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * Strings).\n   */\n  public static final class StringArrayComparatorLexical\n      implements Comparator<String[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) String[], @PolyAll(2) String[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ String[] a1, /*@PolyAll*/ String[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int tmp = 0;\n        if ((a1[i] == null) && (a2[i] == null)) {\n          tmp = 0;\n        } else if (a1[i] == null) {\n          tmp = -1;\n        } else if (a2[i] == null) {\n          tmp = 1;\n        } else {\n          tmp = a1[i].compareTo(a2[i]);\n        }\n        if (tmp != 0) {\n          return (tmp);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLexical<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLexical\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLengthFirst\n      implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLengthFirst\n      implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int lendiff = a1.length - a2.length;\n      if (lendiff != 0) {\n        return lendiff;\n      }\n      long tmp;\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLengthFirst<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLengthFirst\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// nullness\n  ///\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(/*@PolyAll*/ Object[] a) {\n    if (a.length == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(/*@PolyAll*/ Object[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (!(a[i] == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n      if (!(a.get(i) == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// javadoc hacks\n  ///\n\n  // Without this, the Javadoc mentions of \"java.util.Vector\", are not links\n  // in the generated HTML.\n  // \"private static Vector v;\" doesn't work, nor does\n  // \"static { new java.util.Vector(); }\", nor does \"private Vector v\".\n  // Yuck!\n  public Vector<?> javadocLossage;\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "a", "", "char[]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "", "char[]", "public boolean equals(Object);" ], [ "toString", "", "char[]", "public String toString()" ], [ "hashCode", "", "char[]", "public native int hashCode()" ], [ "getClass", "", "char[]", "public final native Class getClass();" ], [ "clone", "", "char[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "javadocLossage", "plume", "ArraysMDE", "public Vector<?> javadocLossage;" ], [ "length", "", "char[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10893,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "ArraysMDE",
  "javadocTag" : "@param a an array",
  "methodJavadoc" : "    /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */",
  "methodSourceCode" : "public static /*@SideEffectFree*/\nString toString(int[] a){\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}",
  "classJavadoc" : "/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Vector;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\nimport org.checkerframework.framework.qual.PolyAll;\n*/\n\n/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */\n@SuppressWarnings(\"interning\") // to do later\npublic final class ArraysMDE {\n  /** This class is a collecton of methods; it does not represent anything. */\n  private ArraysMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// min, max\n  ///\n\n  // Could also add linear-time orderStatistics if I liked.\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int min(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long min(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double min(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer min(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long min(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() < result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double min(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int max(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long max(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double max(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer max(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long max(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() > result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double max(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int[] min_max(int[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] {result_min, result_max};\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long[] min_max(long[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] {result_min, result_max};\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int element_range(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long element_range(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Returns the sum of an array of integers.\n   * @param a an array\n   * @return the sum of an array of integers\n   */\n  public static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of integers.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of integers\n   */\n  public static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of an array of doubles.\n   * @param a an array\n   * @return the sum of an array of doubles\n   */\n  public static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of doubles.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of doubles\n   */\n  public static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf\n  ///\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> type of the elements of the array\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt) {\n    if (elt == null) {\n      return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> the type of the elements\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   *    Identical to List.indexOf, but included for completeness.\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    return a.indexOf(elt);\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a.get(i))) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      /*@PolyNull*/ Object[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.size(); i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf, for finding subarrays\n  ///\n\n  // This is analogous to Common Lisp's \"search\" function.\n\n  // This implementation is very inefficient; I could use tricky Boyer-Moore\n  // search techniques if I liked, but it's not worth it to me yet.\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  // The signature on this method is unnecessarily strict because it\n  // requires that the component types be identical.  The signature should\n  // be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n  // @PolyAll qualifier does not yet take an argument.\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// mismatch\n  ///\n\n  // This is analogous to Common Lisp's \"mismatch\" function.\n\n  // Put it off until later; for now, use the simpler subarray function,\n  // which is a specialization of mismatch,\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray extraction\n  ///\n\n  // Note that the second argument is a length, not an end position.\n  // That's to avoid confusion over whether it would be the last included\n  // index or the first non-included index.\n\n  /**\n   * Return a subarray of the given array.\n   * @return a subarray of the given array\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ Object[] subarray(\n      /*@PolyAll*/ Object[] a, int startindex, int length) {\n    /*@PolyAll*/ Object[] result = new /*@PolyAll*/ Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a sublist of the given list.\n   * @param <T> type of the elements\n   * @param a the original list\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a sublist of the given list\n   */\n  /*@SideEffectFree*/\n  public static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ String[] subarray(\n      /*@PolyAll*/ String[] a, int startindex, int length) {\n    /*@PolyAll*/ String[] result = new /*@PolyAll*/ String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray testing\n  ///\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(\n      /*@PolyAll*/ Object[] a, /*@PolyNull*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(\n      /*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// concatenation\n  ///\n\n  // Concat used to return null if both arguments are null.  That is\n  // convenient for the implementer, but not so good for clients.\n\n  /**\n   * Call this method in order to suppress compiler warnings.\n   * @param <T> the base type of the result\n   * @param lst the list to convert to an array\n   * @return the result of lst.toArray, casted to a more precise type than Object[]\n   */\n  private static <T> T[] toTArray(List<T> lst) {\n    @SuppressWarnings(\"unchecked\")\n    T[] asArray = (T[]) lst.toArray();\n    return asArray;\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.size()];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        // System.arraycopy(b, 0, result, a.length, b.size());\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.length] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.length];\n\n        // System.arraycopy(a, 0, result, 0, a.size());\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        System.arraycopy(b, 0, result, a.size(), b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.size()];\n\n        // System.arraycopy(a, 0, result, 0, a.length);\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        // System.arraycopy(b, 0, result, a.length, b.length);\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.size()] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  // Note: PolyAll is not quite right.  Need to review.\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first array to concatenate\n   * @param b the second array to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static /*@PolyAll*/ String[] concat(\n      /*@PolyAll*/ String /*@Nullable*/ [] a, /*@PolyAll*/ String /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new String[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        /*@PolyAll*/ String[] result = new String[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static byte[] concat(byte /*@Nullable*/ [] a, byte /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new byte[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        byte[] result = new byte[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static boolean[] concat(boolean /*@Nullable*/ [] a, boolean /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new boolean[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        boolean[] result = new boolean[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static char[] concat(char /*@Nullable*/ [] a, char /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new char[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        char[] result = new char[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static double[] concat(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new double[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        double[] result = new double[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static float[] concat(float /*@Nullable*/ [] a, float /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new float[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        float[] result = new float[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static int[] concat(int /*@Nullable*/ [] a, int /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new int[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        int[] result = new int[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static long[] concat(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new long[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        long[] result = new long[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static short[] concat(short /*@Nullable*/ [] a, short /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new short[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        short[] result = new short[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Printing\n  ///\n\n  // This should be extended to all types, when I get around to it.  The\n  // methods are patterned after that of java.util.Vector (and use its\n  // output format).\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, each element is quoted like a Java String.\n   * @param a an array\n   * @return a string representation of the array, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, if quoted is true, then each element is quoted like a Java String.\n   * @param a an array\n   * @param quoted whether to quote the array elements\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        if (quoted && a[i] instanceof String) {\n          String elt = (String) a[i];\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava(elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(a[i]);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@Nullable*/ Collection<?> a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @param quoted whether to quote the collection elements that are Java strings\n   * @return a string representation of the list\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n      Iterator<?> itor = a.iterator();\n      sb.append(itor.next());\n      while (itor.hasNext()) {\n        sb.append(\", \");\n        Object elt = itor.next();\n        if (quoted && elt instanceof String) {\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava((String) elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(elt);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(int /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(long /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(double /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(float /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(boolean /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls the appropriate\n   * toString() method.  Only call this method if obj is a boolean, double,\n   * int, long, or Object array.\n   * @param obj an array\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@SideEffectFree*/\n  public static String toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n      return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n      return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n      return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n      return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n      return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n      return toString((List<?>) obj);\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls .length.\n   * Only call this method if obj is a boolean, double, int, long, or Object array.\n   * @param obj a list\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@Pure*/\n  public static int length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n      return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n      return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n      return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n      return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n      return ((List<?>) obj).size();\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Sortedness\n  ///\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Boolean n = Boolean.valueOf(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Byte n = new Byte(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Character n = new Character(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Float n = new Float(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Short n = new Short(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Integer n = new Integer(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space. Equality checking\n   * uses the .equals() method for java.lang.Double.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Double n = new Double(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Long n = new Long(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param <T> the type of the elements\n   * @param a a list\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static <T> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n      if (hs.contains(a.get(i))) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a.get(i));\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Arrays as partial functions of int->int\n  ///\n\n  /**\n   * Returns true if the array is a permutation of [0..a.length).\n   * @param a an array, representing a function\n   * @return true iff all elements of a are in [0..a.length) and a\n   * contains no duplicates.\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (array)\n  /*@Pure*/\n  public static boolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int n = a[i];\n      if (n < 0 || n >= a.length || see[n]) {\n        return false;\n      }\n      see[n] = true;\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff the array does not contain -1.\n   * @param a an array, representing a function\n   * @return true iff no element of a maps to -1\n   */\n  /*@Pure*/\n  public static boolean fn_is_total(int[] a) {\n    return indexOf(a, -1) == -1; // not found\n  }\n\n  /**\n   * Return an array [0..lenth).\n   * @param length the length of the result\n   * @return fresh array that is the identity function of the given length\n   */\n  public static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n      result[i] = i;\n    }\n    return result;\n  }\n\n  /**\n   * Requires that fn_is_permutation(a) holds.\n   * @param a the input permutation\n   * @return fresh array which is the inverse of the given permutation\n   * @see #fn_is_permutation(int[])\n   */\n  public static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n  }\n\n  /**\n   * Return the inverse of the given function, which is represented as an array.\n   * @param a an array representing a function from [0..a.length) to [0..arange);\n   *  each element of a is between 0 and arange inclusive\n   * @param arange length of the argument's range and the result's domain\n   * @return function from [0..arange) to [0..a.length) that is the inverse of a\n   * @throws IllegalArgumentException if a value of a is outside of arange\n   * @exception UnsupportedOperationException when the function is not invertible\n   */\n  public static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n      int ai = a[i];\n      if (ai < -1 || ai >= arange) {\n        throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n      }\n      // ai is either -1 or a valid index\n      if (ai >= 0) {\n        if (result[ai] != -1) {\n          throw new UnsupportedOperationException(\n              String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n        }\n        result[ai] = i;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the composition of the given two functions, all of which are\n   * represented as arrays.\n   * @param a function from [0..a.length) to [0..b.length)\n   * @param b function from [0..b.length) to range R\n   * @return function from [0..a.length) to range R that is the\n   * composition of a and b\n   */\n  public static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int inner = a[i];\n      if (inner == -1) {\n        result[i] = -1;\n      } else {\n        result[i] = b[inner];\n      }\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set operations, such as subset, unions, and intersections\n  ///\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Long(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Long elt = new Long(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Double(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Double elt = new Double(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(bigger[i]);\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      if (!setBigger.contains(smaller[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array comparators\n  ///\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLexical implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer,\n     * depending on whether the first argument is less than,\n     * equal to, or greater than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLexical implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class DoubleArrayComparatorLexical\n      implements Comparator<double[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(double[] a1, double[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int result = Double.compare(a1[i], a2[i]);\n        if (result != 0) {\n          return (result);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * Strings).\n   */\n  public static final class StringArrayComparatorLexical\n      implements Comparator<String[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) String[], @PolyAll(2) String[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ String[] a1, /*@PolyAll*/ String[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int tmp = 0;\n        if ((a1[i] == null) && (a2[i] == null)) {\n          tmp = 0;\n        } else if (a1[i] == null) {\n          tmp = -1;\n        } else if (a2[i] == null) {\n          tmp = 1;\n        } else {\n          tmp = a1[i].compareTo(a2[i]);\n        }\n        if (tmp != 0) {\n          return (tmp);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLexical<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLexical\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLengthFirst\n      implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLengthFirst\n      implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int lendiff = a1.length - a2.length;\n      if (lendiff != 0) {\n        return lendiff;\n      }\n      long tmp;\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLengthFirst<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLengthFirst\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// nullness\n  ///\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(/*@PolyAll*/ Object[] a) {\n    if (a.length == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(/*@PolyAll*/ Object[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (!(a[i] == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n      if (!(a.get(i) == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// javadoc hacks\n  ///\n\n  // Without this, the Javadoc mentions of \"java.util.Vector\", are not links\n  // in the generated HTML.\n  // \"private static Vector v;\" doesn't work, nor does\n  // \"static { new java.util.Vector(); }\", nor does \"private Vector v\".\n  // Yuck!\n  public Vector<?> javadocLossage;\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "a", "", "int[]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "", "int[]", "public boolean equals(Object);" ], [ "toString", "", "int[]", "public String toString()" ], [ "hashCode", "", "int[]", "public native int hashCode()" ], [ "getClass", "", "int[]", "public final native Class getClass();" ], [ "clone", "", "int[]", "public T[] clone();" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "length", "java.lang", "String", "public int length()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "javadocLossage", "plume", "ArraysMDE", "public Vector<?> javadocLossage;" ], [ "length", "", "int[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10893,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "ArraysMDE",
  "javadocTag" : "",
  "methodJavadoc" : "    /**\n     * Return a string representation of the array.\n     * The representation is patterned after that of java.util.Vector.\n     * \n     * @return a string representation of the array\n     * @see java.util.Vector#toString\n     */",
  "methodSourceCode" : "public static /*@SideEffectFree*/\nString toString(int[] a){\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}",
  "classJavadoc" : "/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Vector;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\nimport org.checkerframework.framework.qual.PolyAll;\n*/\n\n/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */\n@SuppressWarnings(\"interning\") // to do later\npublic final class ArraysMDE {\n  /** This class is a collecton of methods; it does not represent anything. */\n  private ArraysMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// min, max\n  ///\n\n  // Could also add linear-time orderStatistics if I liked.\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int min(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long min(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double min(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer min(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long min(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() < result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double min(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int max(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long max(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double max(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer max(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long max(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() > result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double max(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int[] min_max(int[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] {result_min, result_max};\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long[] min_max(long[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] {result_min, result_max};\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int element_range(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long element_range(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Returns the sum of an array of integers.\n   * @param a an array\n   * @return the sum of an array of integers\n   */\n  public static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of integers.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of integers\n   */\n  public static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of an array of doubles.\n   * @param a an array\n   * @return the sum of an array of doubles\n   */\n  public static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of doubles.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of doubles\n   */\n  public static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf\n  ///\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> type of the elements of the array\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt) {\n    if (elt == null) {\n      return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> the type of the elements\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   *    Identical to List.indexOf, but included for completeness.\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    return a.indexOf(elt);\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a.get(i))) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      /*@PolyNull*/ Object[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.size(); i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf, for finding subarrays\n  ///\n\n  // This is analogous to Common Lisp's \"search\" function.\n\n  // This implementation is very inefficient; I could use tricky Boyer-Moore\n  // search techniques if I liked, but it's not worth it to me yet.\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  // The signature on this method is unnecessarily strict because it\n  // requires that the component types be identical.  The signature should\n  // be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n  // @PolyAll qualifier does not yet take an argument.\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// mismatch\n  ///\n\n  // This is analogous to Common Lisp's \"mismatch\" function.\n\n  // Put it off until later; for now, use the simpler subarray function,\n  // which is a specialization of mismatch,\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray extraction\n  ///\n\n  // Note that the second argument is a length, not an end position.\n  // That's to avoid confusion over whether it would be the last included\n  // index or the first non-included index.\n\n  /**\n   * Return a subarray of the given array.\n   * @return a subarray of the given array\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ Object[] subarray(\n      /*@PolyAll*/ Object[] a, int startindex, int length) {\n    /*@PolyAll*/ Object[] result = new /*@PolyAll*/ Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a sublist of the given list.\n   * @param <T> type of the elements\n   * @param a the original list\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a sublist of the given list\n   */\n  /*@SideEffectFree*/\n  public static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ String[] subarray(\n      /*@PolyAll*/ String[] a, int startindex, int length) {\n    /*@PolyAll*/ String[] result = new /*@PolyAll*/ String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray testing\n  ///\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(\n      /*@PolyAll*/ Object[] a, /*@PolyNull*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(\n      /*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// concatenation\n  ///\n\n  // Concat used to return null if both arguments are null.  That is\n  // convenient for the implementer, but not so good for clients.\n\n  /**\n   * Call this method in order to suppress compiler warnings.\n   * @param <T> the base type of the result\n   * @param lst the list to convert to an array\n   * @return the result of lst.toArray, casted to a more precise type than Object[]\n   */\n  private static <T> T[] toTArray(List<T> lst) {\n    @SuppressWarnings(\"unchecked\")\n    T[] asArray = (T[]) lst.toArray();\n    return asArray;\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.size()];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        // System.arraycopy(b, 0, result, a.length, b.size());\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.length] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.length];\n\n        // System.arraycopy(a, 0, result, 0, a.size());\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        System.arraycopy(b, 0, result, a.size(), b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.size()];\n\n        // System.arraycopy(a, 0, result, 0, a.length);\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        // System.arraycopy(b, 0, result, a.length, b.length);\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.size()] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  // Note: PolyAll is not quite right.  Need to review.\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first array to concatenate\n   * @param b the second array to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static /*@PolyAll*/ String[] concat(\n      /*@PolyAll*/ String /*@Nullable*/ [] a, /*@PolyAll*/ String /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new String[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        /*@PolyAll*/ String[] result = new String[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static byte[] concat(byte /*@Nullable*/ [] a, byte /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new byte[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        byte[] result = new byte[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static boolean[] concat(boolean /*@Nullable*/ [] a, boolean /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new boolean[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        boolean[] result = new boolean[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static char[] concat(char /*@Nullable*/ [] a, char /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new char[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        char[] result = new char[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static double[] concat(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new double[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        double[] result = new double[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static float[] concat(float /*@Nullable*/ [] a, float /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new float[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        float[] result = new float[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static int[] concat(int /*@Nullable*/ [] a, int /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new int[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        int[] result = new int[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static long[] concat(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new long[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        long[] result = new long[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static short[] concat(short /*@Nullable*/ [] a, short /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new short[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        short[] result = new short[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Printing\n  ///\n\n  // This should be extended to all types, when I get around to it.  The\n  // methods are patterned after that of java.util.Vector (and use its\n  // output format).\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, each element is quoted like a Java String.\n   * @param a an array\n   * @return a string representation of the array, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, if quoted is true, then each element is quoted like a Java String.\n   * @param a an array\n   * @param quoted whether to quote the array elements\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        if (quoted && a[i] instanceof String) {\n          String elt = (String) a[i];\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava(elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(a[i]);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@Nullable*/ Collection<?> a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @param quoted whether to quote the collection elements that are Java strings\n   * @return a string representation of the list\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n      Iterator<?> itor = a.iterator();\n      sb.append(itor.next());\n      while (itor.hasNext()) {\n        sb.append(\", \");\n        Object elt = itor.next();\n        if (quoted && elt instanceof String) {\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava((String) elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(elt);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(int /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(long /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(double /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(float /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(boolean /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls the appropriate\n   * toString() method.  Only call this method if obj is a boolean, double,\n   * int, long, or Object array.\n   * @param obj an array\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@SideEffectFree*/\n  public static String toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n      return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n      return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n      return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n      return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n      return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n      return toString((List<?>) obj);\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls .length.\n   * Only call this method if obj is a boolean, double, int, long, or Object array.\n   * @param obj a list\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@Pure*/\n  public static int length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n      return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n      return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n      return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n      return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n      return ((List<?>) obj).size();\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Sortedness\n  ///\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Boolean n = Boolean.valueOf(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Byte n = new Byte(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Character n = new Character(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Float n = new Float(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Short n = new Short(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Integer n = new Integer(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space. Equality checking\n   * uses the .equals() method for java.lang.Double.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Double n = new Double(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Long n = new Long(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param <T> the type of the elements\n   * @param a a list\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static <T> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n      if (hs.contains(a.get(i))) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a.get(i));\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Arrays as partial functions of int->int\n  ///\n\n  /**\n   * Returns true if the array is a permutation of [0..a.length).\n   * @param a an array, representing a function\n   * @return true iff all elements of a are in [0..a.length) and a\n   * contains no duplicates.\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (array)\n  /*@Pure*/\n  public static boolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int n = a[i];\n      if (n < 0 || n >= a.length || see[n]) {\n        return false;\n      }\n      see[n] = true;\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff the array does not contain -1.\n   * @param a an array, representing a function\n   * @return true iff no element of a maps to -1\n   */\n  /*@Pure*/\n  public static boolean fn_is_total(int[] a) {\n    return indexOf(a, -1) == -1; // not found\n  }\n\n  /**\n   * Return an array [0..lenth).\n   * @param length the length of the result\n   * @return fresh array that is the identity function of the given length\n   */\n  public static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n      result[i] = i;\n    }\n    return result;\n  }\n\n  /**\n   * Requires that fn_is_permutation(a) holds.\n   * @param a the input permutation\n   * @return fresh array which is the inverse of the given permutation\n   * @see #fn_is_permutation(int[])\n   */\n  public static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n  }\n\n  /**\n   * Return the inverse of the given function, which is represented as an array.\n   * @param a an array representing a function from [0..a.length) to [0..arange);\n   *  each element of a is between 0 and arange inclusive\n   * @param arange length of the argument's range and the result's domain\n   * @return function from [0..arange) to [0..a.length) that is the inverse of a\n   * @throws IllegalArgumentException if a value of a is outside of arange\n   * @exception UnsupportedOperationException when the function is not invertible\n   */\n  public static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n      int ai = a[i];\n      if (ai < -1 || ai >= arange) {\n        throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n      }\n      // ai is either -1 or a valid index\n      if (ai >= 0) {\n        if (result[ai] != -1) {\n          throw new UnsupportedOperationException(\n              String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n        }\n        result[ai] = i;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the composition of the given two functions, all of which are\n   * represented as arrays.\n   * @param a function from [0..a.length) to [0..b.length)\n   * @param b function from [0..b.length) to range R\n   * @return function from [0..a.length) to range R that is the\n   * composition of a and b\n   */\n  public static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int inner = a[i];\n      if (inner == -1) {\n        result[i] = -1;\n      } else {\n        result[i] = b[inner];\n      }\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set operations, such as subset, unions, and intersections\n  ///\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Long(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Long elt = new Long(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Double(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Double elt = new Double(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(bigger[i]);\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      if (!setBigger.contains(smaller[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array comparators\n  ///\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLexical implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer,\n     * depending on whether the first argument is less than,\n     * equal to, or greater than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLexical implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class DoubleArrayComparatorLexical\n      implements Comparator<double[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(double[] a1, double[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int result = Double.compare(a1[i], a2[i]);\n        if (result != 0) {\n          return (result);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * Strings).\n   */\n  public static final class StringArrayComparatorLexical\n      implements Comparator<String[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) String[], @PolyAll(2) String[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ String[] a1, /*@PolyAll*/ String[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int tmp = 0;\n        if ((a1[i] == null) && (a2[i] == null)) {\n          tmp = 0;\n        } else if (a1[i] == null) {\n          tmp = -1;\n        } else if (a2[i] == null) {\n          tmp = 1;\n        } else {\n          tmp = a1[i].compareTo(a2[i]);\n        }\n        if (tmp != 0) {\n          return (tmp);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLexical<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLexical\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLengthFirst\n      implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLengthFirst\n      implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int lendiff = a1.length - a2.length;\n      if (lendiff != 0) {\n        return lendiff;\n      }\n      long tmp;\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLengthFirst<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLengthFirst\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// nullness\n  ///\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(/*@PolyAll*/ Object[] a) {\n    if (a.length == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(/*@PolyAll*/ Object[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (!(a[i] == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n      if (!(a.get(i) == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// javadoc hacks\n  ///\n\n  // Without this, the Javadoc mentions of \"java.util.Vector\", are not links\n  // in the generated HTML.\n  // \"private static Vector v;\" doesn't work, nor does\n  // \"static { new java.util.Vector(); }\", nor does \"private Vector v\".\n  // Yuck!\n  public Vector<?> javadocLossage;\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "a", "", "int[]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "", "int[]", "public boolean equals(Object);" ], [ "toString", "", "int[]", "public String toString()" ], [ "hashCode", "", "int[]", "public native int hashCode()" ], [ "getClass", "", "int[]", "public final native Class getClass();" ], [ "clone", "", "int[]", "public T[] clone();" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "length", "java.lang", "String", "public int length()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "javadocLossage", "plume", "ArraysMDE", "public Vector<?> javadocLossage;" ], [ "length", "", "int[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10893,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "ArraysMDE",
  "javadocTag" : "",
  "methodJavadoc" : "",
  "methodSourceCode" : "public static /*@SideEffectFree*/\nString toString(int[] a){\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}",
  "classJavadoc" : "/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Vector;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\nimport org.checkerframework.framework.qual.PolyAll;\n*/\n\n/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */\n@SuppressWarnings(\"interning\") // to do later\npublic final class ArraysMDE {\n  /** This class is a collecton of methods; it does not represent anything. */\n  private ArraysMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// min, max\n  ///\n\n  // Could also add linear-time orderStatistics if I liked.\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int min(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long min(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double min(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer min(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long min(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() < result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double min(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int max(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long max(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double max(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer max(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long max(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() > result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double max(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int[] min_max(int[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] {result_min, result_max};\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long[] min_max(long[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] {result_min, result_max};\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int element_range(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long element_range(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Returns the sum of an array of integers.\n   * @param a an array\n   * @return the sum of an array of integers\n   */\n  public static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of integers.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of integers\n   */\n  public static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of an array of doubles.\n   * @param a an array\n   * @return the sum of an array of doubles\n   */\n  public static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of doubles.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of doubles\n   */\n  public static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf\n  ///\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> type of the elements of the array\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt) {\n    if (elt == null) {\n      return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> the type of the elements\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   *    Identical to List.indexOf, but included for completeness.\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    return a.indexOf(elt);\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a.get(i))) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      /*@PolyNull*/ Object[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.size(); i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf, for finding subarrays\n  ///\n\n  // This is analogous to Common Lisp's \"search\" function.\n\n  // This implementation is very inefficient; I could use tricky Boyer-Moore\n  // search techniques if I liked, but it's not worth it to me yet.\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  // The signature on this method is unnecessarily strict because it\n  // requires that the component types be identical.  The signature should\n  // be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n  // @PolyAll qualifier does not yet take an argument.\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// mismatch\n  ///\n\n  // This is analogous to Common Lisp's \"mismatch\" function.\n\n  // Put it off until later; for now, use the simpler subarray function,\n  // which is a specialization of mismatch,\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray extraction\n  ///\n\n  // Note that the second argument is a length, not an end position.\n  // That's to avoid confusion over whether it would be the last included\n  // index or the first non-included index.\n\n  /**\n   * Return a subarray of the given array.\n   * @return a subarray of the given array\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ Object[] subarray(\n      /*@PolyAll*/ Object[] a, int startindex, int length) {\n    /*@PolyAll*/ Object[] result = new /*@PolyAll*/ Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a sublist of the given list.\n   * @param <T> type of the elements\n   * @param a the original list\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a sublist of the given list\n   */\n  /*@SideEffectFree*/\n  public static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ String[] subarray(\n      /*@PolyAll*/ String[] a, int startindex, int length) {\n    /*@PolyAll*/ String[] result = new /*@PolyAll*/ String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray testing\n  ///\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(\n      /*@PolyAll*/ Object[] a, /*@PolyNull*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(\n      /*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// concatenation\n  ///\n\n  // Concat used to return null if both arguments are null.  That is\n  // convenient for the implementer, but not so good for clients.\n\n  /**\n   * Call this method in order to suppress compiler warnings.\n   * @param <T> the base type of the result\n   * @param lst the list to convert to an array\n   * @return the result of lst.toArray, casted to a more precise type than Object[]\n   */\n  private static <T> T[] toTArray(List<T> lst) {\n    @SuppressWarnings(\"unchecked\")\n    T[] asArray = (T[]) lst.toArray();\n    return asArray;\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.size()];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        // System.arraycopy(b, 0, result, a.length, b.size());\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.length] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.length];\n\n        // System.arraycopy(a, 0, result, 0, a.size());\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        System.arraycopy(b, 0, result, a.size(), b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.size()];\n\n        // System.arraycopy(a, 0, result, 0, a.length);\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        // System.arraycopy(b, 0, result, a.length, b.length);\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.size()] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  // Note: PolyAll is not quite right.  Need to review.\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first array to concatenate\n   * @param b the second array to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static /*@PolyAll*/ String[] concat(\n      /*@PolyAll*/ String /*@Nullable*/ [] a, /*@PolyAll*/ String /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new String[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        /*@PolyAll*/ String[] result = new String[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static byte[] concat(byte /*@Nullable*/ [] a, byte /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new byte[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        byte[] result = new byte[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static boolean[] concat(boolean /*@Nullable*/ [] a, boolean /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new boolean[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        boolean[] result = new boolean[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static char[] concat(char /*@Nullable*/ [] a, char /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new char[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        char[] result = new char[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static double[] concat(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new double[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        double[] result = new double[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static float[] concat(float /*@Nullable*/ [] a, float /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new float[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        float[] result = new float[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static int[] concat(int /*@Nullable*/ [] a, int /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new int[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        int[] result = new int[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static long[] concat(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new long[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        long[] result = new long[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static short[] concat(short /*@Nullable*/ [] a, short /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new short[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        short[] result = new short[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Printing\n  ///\n\n  // This should be extended to all types, when I get around to it.  The\n  // methods are patterned after that of java.util.Vector (and use its\n  // output format).\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, each element is quoted like a Java String.\n   * @param a an array\n   * @return a string representation of the array, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, if quoted is true, then each element is quoted like a Java String.\n   * @param a an array\n   * @param quoted whether to quote the array elements\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        if (quoted && a[i] instanceof String) {\n          String elt = (String) a[i];\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava(elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(a[i]);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@Nullable*/ Collection<?> a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @param quoted whether to quote the collection elements that are Java strings\n   * @return a string representation of the list\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n      Iterator<?> itor = a.iterator();\n      sb.append(itor.next());\n      while (itor.hasNext()) {\n        sb.append(\", \");\n        Object elt = itor.next();\n        if (quoted && elt instanceof String) {\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava((String) elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(elt);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(int /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(long /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(double /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(float /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(boolean /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls the appropriate\n   * toString() method.  Only call this method if obj is a boolean, double,\n   * int, long, or Object array.\n   * @param obj an array\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@SideEffectFree*/\n  public static String toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n      return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n      return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n      return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n      return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n      return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n      return toString((List<?>) obj);\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls .length.\n   * Only call this method if obj is a boolean, double, int, long, or Object array.\n   * @param obj a list\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@Pure*/\n  public static int length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n      return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n      return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n      return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n      return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n      return ((List<?>) obj).size();\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Sortedness\n  ///\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Boolean n = Boolean.valueOf(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Byte n = new Byte(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Character n = new Character(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Float n = new Float(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Short n = new Short(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Integer n = new Integer(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space. Equality checking\n   * uses the .equals() method for java.lang.Double.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Double n = new Double(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Long n = new Long(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param <T> the type of the elements\n   * @param a a list\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static <T> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n      if (hs.contains(a.get(i))) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a.get(i));\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Arrays as partial functions of int->int\n  ///\n\n  /**\n   * Returns true if the array is a permutation of [0..a.length).\n   * @param a an array, representing a function\n   * @return true iff all elements of a are in [0..a.length) and a\n   * contains no duplicates.\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (array)\n  /*@Pure*/\n  public static boolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int n = a[i];\n      if (n < 0 || n >= a.length || see[n]) {\n        return false;\n      }\n      see[n] = true;\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff the array does not contain -1.\n   * @param a an array, representing a function\n   * @return true iff no element of a maps to -1\n   */\n  /*@Pure*/\n  public static boolean fn_is_total(int[] a) {\n    return indexOf(a, -1) == -1; // not found\n  }\n\n  /**\n   * Return an array [0..lenth).\n   * @param length the length of the result\n   * @return fresh array that is the identity function of the given length\n   */\n  public static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n      result[i] = i;\n    }\n    return result;\n  }\n\n  /**\n   * Requires that fn_is_permutation(a) holds.\n   * @param a the input permutation\n   * @return fresh array which is the inverse of the given permutation\n   * @see #fn_is_permutation(int[])\n   */\n  public static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n  }\n\n  /**\n   * Return the inverse of the given function, which is represented as an array.\n   * @param a an array representing a function from [0..a.length) to [0..arange);\n   *  each element of a is between 0 and arange inclusive\n   * @param arange length of the argument's range and the result's domain\n   * @return function from [0..arange) to [0..a.length) that is the inverse of a\n   * @throws IllegalArgumentException if a value of a is outside of arange\n   * @exception UnsupportedOperationException when the function is not invertible\n   */\n  public static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n      int ai = a[i];\n      if (ai < -1 || ai >= arange) {\n        throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n      }\n      // ai is either -1 or a valid index\n      if (ai >= 0) {\n        if (result[ai] != -1) {\n          throw new UnsupportedOperationException(\n              String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n        }\n        result[ai] = i;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the composition of the given two functions, all of which are\n   * represented as arrays.\n   * @param a function from [0..a.length) to [0..b.length)\n   * @param b function from [0..b.length) to range R\n   * @return function from [0..a.length) to range R that is the\n   * composition of a and b\n   */\n  public static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int inner = a[i];\n      if (inner == -1) {\n        result[i] = -1;\n      } else {\n        result[i] = b[inner];\n      }\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set operations, such as subset, unions, and intersections\n  ///\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Long(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Long elt = new Long(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Double(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Double elt = new Double(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(bigger[i]);\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      if (!setBigger.contains(smaller[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array comparators\n  ///\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLexical implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer,\n     * depending on whether the first argument is less than,\n     * equal to, or greater than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLexical implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class DoubleArrayComparatorLexical\n      implements Comparator<double[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(double[] a1, double[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int result = Double.compare(a1[i], a2[i]);\n        if (result != 0) {\n          return (result);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * Strings).\n   */\n  public static final class StringArrayComparatorLexical\n      implements Comparator<String[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) String[], @PolyAll(2) String[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ String[] a1, /*@PolyAll*/ String[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int tmp = 0;\n        if ((a1[i] == null) && (a2[i] == null)) {\n          tmp = 0;\n        } else if (a1[i] == null) {\n          tmp = -1;\n        } else if (a2[i] == null) {\n          tmp = 1;\n        } else {\n          tmp = a1[i].compareTo(a2[i]);\n        }\n        if (tmp != 0) {\n          return (tmp);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLexical<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLexical\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLengthFirst\n      implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLengthFirst\n      implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int lendiff = a1.length - a2.length;\n      if (lendiff != 0) {\n        return lendiff;\n      }\n      long tmp;\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLengthFirst<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLengthFirst\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// nullness\n  ///\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(/*@PolyAll*/ Object[] a) {\n    if (a.length == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(/*@PolyAll*/ Object[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (!(a[i] == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n      if (!(a.get(i) == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// javadoc hacks\n  ///\n\n  // Without this, the Javadoc mentions of \"java.util.Vector\", are not links\n  // in the generated HTML.\n  // \"private static Vector v;\" doesn't work, nor does\n  // \"static { new java.util.Vector(); }\", nor does \"private Vector v\".\n  // Yuck!\n  public Vector<?> javadocLossage;\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "a", "", "int[]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "", "int[]", "public boolean equals(Object);" ], [ "toString", "", "int[]", "public String toString()" ], [ "hashCode", "", "int[]", "public native int hashCode()" ], [ "getClass", "", "int[]", "public final native Class getClass();" ], [ "clone", "", "int[]", "public T[] clone();" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "length", "java.lang", "String", "public int length()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "javadocLossage", "plume", "ArraysMDE", "public Vector<?> javadocLossage;" ], [ "length", "", "int[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10893,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "ArraysMDE",
  "javadocTag" : "@param a a series.",
  "methodJavadoc" : "    /**\n     * Return a string representation of the array.\n     * The representation is patterned after that of java.util.Vector.\n     * \n     * @param a a series.\n     * @return a string representation of the array\n     * @see java.util.Vector#toString\n     */",
  "methodSourceCode" : "public static /*@SideEffectFree*/\nString toString(int[] a);",
  "classJavadoc" : "/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Vector;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\nimport org.checkerframework.framework.qual.PolyAll;\n*/\n\n/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */\n@SuppressWarnings(\"interning\") // to do later\npublic final class ArraysMDE {\n  /** This class is a collecton of methods; it does not represent anything. */\n  private ArraysMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// min, max\n  ///\n\n  // Could also add linear-time orderStatistics if I liked.\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int min(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long min(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double min(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer min(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long min(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() < result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double min(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int max(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long max(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double max(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer max(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long max(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() > result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double max(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int[] min_max(int[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] {result_min, result_max};\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long[] min_max(long[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] {result_min, result_max};\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int element_range(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long element_range(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Returns the sum of an array of integers.\n   * @param a an array\n   * @return the sum of an array of integers\n   */\n  public static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of integers.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of integers\n   */\n  public static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of an array of doubles.\n   * @param a an array\n   * @return the sum of an array of doubles\n   */\n  public static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of doubles.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of doubles\n   */\n  public static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf\n  ///\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> type of the elements of the array\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt) {\n    if (elt == null) {\n      return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> the type of the elements\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   *    Identical to List.indexOf, but included for completeness.\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    return a.indexOf(elt);\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a.get(i))) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      /*@PolyNull*/ Object[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.size(); i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf, for finding subarrays\n  ///\n\n  // This is analogous to Common Lisp's \"search\" function.\n\n  // This implementation is very inefficient; I could use tricky Boyer-Moore\n  // search techniques if I liked, but it's not worth it to me yet.\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  // The signature on this method is unnecessarily strict because it\n  // requires that the component types be identical.  The signature should\n  // be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n  // @PolyAll qualifier does not yet take an argument.\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// mismatch\n  ///\n\n  // This is analogous to Common Lisp's \"mismatch\" function.\n\n  // Put it off until later; for now, use the simpler subarray function,\n  // which is a specialization of mismatch,\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray extraction\n  ///\n\n  // Note that the second argument is a length, not an end position.\n  // That's to avoid confusion over whether it would be the last included\n  // index or the first non-included index.\n\n  /**\n   * Return a subarray of the given array.\n   * @return a subarray of the given array\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ Object[] subarray(\n      /*@PolyAll*/ Object[] a, int startindex, int length) {\n    /*@PolyAll*/ Object[] result = new /*@PolyAll*/ Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a sublist of the given list.\n   * @param <T> type of the elements\n   * @param a the original list\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a sublist of the given list\n   */\n  /*@SideEffectFree*/\n  public static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ String[] subarray(\n      /*@PolyAll*/ String[] a, int startindex, int length) {\n    /*@PolyAll*/ String[] result = new /*@PolyAll*/ String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray testing\n  ///\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(\n      /*@PolyAll*/ Object[] a, /*@PolyNull*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(\n      /*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// concatenation\n  ///\n\n  // Concat used to return null if both arguments are null.  That is\n  // convenient for the implementer, but not so good for clients.\n\n  /**\n   * Call this method in order to suppress compiler warnings.\n   * @param <T> the base type of the result\n   * @param lst the list to convert to an array\n   * @return the result of lst.toArray, casted to a more precise type than Object[]\n   */\n  private static <T> T[] toTArray(List<T> lst) {\n    @SuppressWarnings(\"unchecked\")\n    T[] asArray = (T[]) lst.toArray();\n    return asArray;\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.size()];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        // System.arraycopy(b, 0, result, a.length, b.size());\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.length] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.length];\n\n        // System.arraycopy(a, 0, result, 0, a.size());\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        System.arraycopy(b, 0, result, a.size(), b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.size()];\n\n        // System.arraycopy(a, 0, result, 0, a.length);\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        // System.arraycopy(b, 0, result, a.length, b.length);\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.size()] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  // Note: PolyAll is not quite right.  Need to review.\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first array to concatenate\n   * @param b the second array to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static /*@PolyAll*/ String[] concat(\n      /*@PolyAll*/ String /*@Nullable*/ [] a, /*@PolyAll*/ String /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new String[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        /*@PolyAll*/ String[] result = new String[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static byte[] concat(byte /*@Nullable*/ [] a, byte /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new byte[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        byte[] result = new byte[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static boolean[] concat(boolean /*@Nullable*/ [] a, boolean /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new boolean[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        boolean[] result = new boolean[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static char[] concat(char /*@Nullable*/ [] a, char /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new char[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        char[] result = new char[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static double[] concat(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new double[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        double[] result = new double[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static float[] concat(float /*@Nullable*/ [] a, float /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new float[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        float[] result = new float[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static int[] concat(int /*@Nullable*/ [] a, int /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new int[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        int[] result = new int[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static long[] concat(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new long[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        long[] result = new long[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static short[] concat(short /*@Nullable*/ [] a, short /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new short[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        short[] result = new short[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Printing\n  ///\n\n  // This should be extended to all types, when I get around to it.  The\n  // methods are patterned after that of java.util.Vector (and use its\n  // output format).\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, each element is quoted like a Java String.\n   * @param a an array\n   * @return a string representation of the array, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, if quoted is true, then each element is quoted like a Java String.\n   * @param a an array\n   * @param quoted whether to quote the array elements\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        if (quoted && a[i] instanceof String) {\n          String elt = (String) a[i];\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava(elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(a[i]);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@Nullable*/ Collection<?> a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @param quoted whether to quote the collection elements that are Java strings\n   * @return a string representation of the list\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n      Iterator<?> itor = a.iterator();\n      sb.append(itor.next());\n      while (itor.hasNext()) {\n        sb.append(\", \");\n        Object elt = itor.next();\n        if (quoted && elt instanceof String) {\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava((String) elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(elt);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(int /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(long /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(double /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(float /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(boolean /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls the appropriate\n   * toString() method.  Only call this method if obj is a boolean, double,\n   * int, long, or Object array.\n   * @param obj an array\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@SideEffectFree*/\n  public static String toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n      return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n      return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n      return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n      return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n      return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n      return toString((List<?>) obj);\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls .length.\n   * Only call this method if obj is a boolean, double, int, long, or Object array.\n   * @param obj a list\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@Pure*/\n  public static int length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n      return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n      return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n      return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n      return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n      return ((List<?>) obj).size();\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Sortedness\n  ///\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Boolean n = Boolean.valueOf(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Byte n = new Byte(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Character n = new Character(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Float n = new Float(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Short n = new Short(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Integer n = new Integer(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space. Equality checking\n   * uses the .equals() method for java.lang.Double.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Double n = new Double(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Long n = new Long(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param <T> the type of the elements\n   * @param a a list\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static <T> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n      if (hs.contains(a.get(i))) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a.get(i));\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Arrays as partial functions of int->int\n  ///\n\n  /**\n   * Returns true if the array is a permutation of [0..a.length).\n   * @param a an array, representing a function\n   * @return true iff all elements of a are in [0..a.length) and a\n   * contains no duplicates.\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (array)\n  /*@Pure*/\n  public static boolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int n = a[i];\n      if (n < 0 || n >= a.length || see[n]) {\n        return false;\n      }\n      see[n] = true;\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff the array does not contain -1.\n   * @param a an array, representing a function\n   * @return true iff no element of a maps to -1\n   */\n  /*@Pure*/\n  public static boolean fn_is_total(int[] a) {\n    return indexOf(a, -1) == -1; // not found\n  }\n\n  /**\n   * Return an array [0..lenth).\n   * @param length the length of the result\n   * @return fresh array that is the identity function of the given length\n   */\n  public static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n      result[i] = i;\n    }\n    return result;\n  }\n\n  /**\n   * Requires that fn_is_permutation(a) holds.\n   * @param a the input permutation\n   * @return fresh array which is the inverse of the given permutation\n   * @see #fn_is_permutation(int[])\n   */\n  public static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n  }\n\n  /**\n   * Return the inverse of the given function, which is represented as an array.\n   * @param a an array representing a function from [0..a.length) to [0..arange);\n   *  each element of a is between 0 and arange inclusive\n   * @param arange length of the argument's range and the result's domain\n   * @return function from [0..arange) to [0..a.length) that is the inverse of a\n   * @throws IllegalArgumentException if a value of a is outside of arange\n   * @exception UnsupportedOperationException when the function is not invertible\n   */\n  public static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n      int ai = a[i];\n      if (ai < -1 || ai >= arange) {\n        throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n      }\n      // ai is either -1 or a valid index\n      if (ai >= 0) {\n        if (result[ai] != -1) {\n          throw new UnsupportedOperationException(\n              String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n        }\n        result[ai] = i;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the composition of the given two functions, all of which are\n   * represented as arrays.\n   * @param a function from [0..a.length) to [0..b.length)\n   * @param b function from [0..b.length) to range R\n   * @return function from [0..a.length) to range R that is the\n   * composition of a and b\n   */\n  public static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int inner = a[i];\n      if (inner == -1) {\n        result[i] = -1;\n      } else {\n        result[i] = b[inner];\n      }\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set operations, such as subset, unions, and intersections\n  ///\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Long(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Long elt = new Long(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Double(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Double elt = new Double(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(bigger[i]);\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      if (!setBigger.contains(smaller[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array comparators\n  ///\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLexical implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer,\n     * depending on whether the first argument is less than,\n     * equal to, or greater than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLexical implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class DoubleArrayComparatorLexical\n      implements Comparator<double[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(double[] a1, double[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int result = Double.compare(a1[i], a2[i]);\n        if (result != 0) {\n          return (result);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * Strings).\n   */\n  public static final class StringArrayComparatorLexical\n      implements Comparator<String[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) String[], @PolyAll(2) String[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ String[] a1, /*@PolyAll*/ String[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int tmp = 0;\n        if ((a1[i] == null) && (a2[i] == null)) {\n          tmp = 0;\n        } else if (a1[i] == null) {\n          tmp = -1;\n        } else if (a2[i] == null) {\n          tmp = 1;\n        } else {\n          tmp = a1[i].compareTo(a2[i]);\n        }\n        if (tmp != 0) {\n          return (tmp);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLexical<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLexical\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLengthFirst\n      implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLengthFirst\n      implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int lendiff = a1.length - a2.length;\n      if (lendiff != 0) {\n        return lendiff;\n      }\n      long tmp;\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLengthFirst<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLengthFirst\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// nullness\n  ///\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(/*@PolyAll*/ Object[] a) {\n    if (a.length == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(/*@PolyAll*/ Object[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (!(a[i] == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n      if (!(a.get(i) == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// javadoc hacks\n  ///\n\n  // Without this, the Javadoc mentions of \"java.util.Vector\", are not links\n  // in the generated HTML.\n  // \"private static Vector v;\" doesn't work, nor does\n  // \"static { new java.util.Vector(); }\", nor does \"private Vector v\".\n  // Yuck!\n  public Vector<?> javadocLossage;\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "a", "", "int[]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "", "int[]", "public boolean equals(Object);" ], [ "toString", "", "int[]", "public String toString()" ], [ "hashCode", "", "int[]", "public native int hashCode()" ], [ "getClass", "", "int[]", "public final native Class getClass();" ], [ "clone", "", "int[]", "public T[] clone();" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "length", "java.lang", "String", "public int length()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "javadocLossage", "plume", "ArraysMDE", "public Vector<?> javadocLossage;" ], [ "length", "", "int[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10893,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "ArraysMDE",
  "javadocTag" : "",
  "methodJavadoc" : "    /**\n     * Return a string representation of the array.\n     * The representation is patterned after that of java.util.Vector.\n     * \n     * @return a string representation of the array\n     * @see java.util.Vector#toString\n     */",
  "methodSourceCode" : "public static /*@SideEffectFree*/\nString toString(int[] a);",
  "classJavadoc" : "/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Vector;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\nimport org.checkerframework.framework.qual.PolyAll;\n*/\n\n/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */\n@SuppressWarnings(\"interning\") // to do later\npublic final class ArraysMDE {\n  /** This class is a collecton of methods; it does not represent anything. */\n  private ArraysMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// min, max\n  ///\n\n  // Could also add linear-time orderStatistics if I liked.\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int min(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long min(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double min(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer min(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long min(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() < result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double min(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int max(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long max(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double max(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer max(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long max(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() > result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double max(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int[] min_max(int[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] {result_min, result_max};\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long[] min_max(long[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] {result_min, result_max};\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int element_range(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long element_range(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Returns the sum of an array of integers.\n   * @param a an array\n   * @return the sum of an array of integers\n   */\n  public static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of integers.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of integers\n   */\n  public static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of an array of doubles.\n   * @param a an array\n   * @return the sum of an array of doubles\n   */\n  public static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of doubles.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of doubles\n   */\n  public static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf\n  ///\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> type of the elements of the array\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt) {\n    if (elt == null) {\n      return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> the type of the elements\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   *    Identical to List.indexOf, but included for completeness.\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    return a.indexOf(elt);\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a.get(i))) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      /*@PolyNull*/ Object[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.size(); i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf, for finding subarrays\n  ///\n\n  // This is analogous to Common Lisp's \"search\" function.\n\n  // This implementation is very inefficient; I could use tricky Boyer-Moore\n  // search techniques if I liked, but it's not worth it to me yet.\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  // The signature on this method is unnecessarily strict because it\n  // requires that the component types be identical.  The signature should\n  // be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n  // @PolyAll qualifier does not yet take an argument.\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// mismatch\n  ///\n\n  // This is analogous to Common Lisp's \"mismatch\" function.\n\n  // Put it off until later; for now, use the simpler subarray function,\n  // which is a specialization of mismatch,\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray extraction\n  ///\n\n  // Note that the second argument is a length, not an end position.\n  // That's to avoid confusion over whether it would be the last included\n  // index or the first non-included index.\n\n  /**\n   * Return a subarray of the given array.\n   * @return a subarray of the given array\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ Object[] subarray(\n      /*@PolyAll*/ Object[] a, int startindex, int length) {\n    /*@PolyAll*/ Object[] result = new /*@PolyAll*/ Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a sublist of the given list.\n   * @param <T> type of the elements\n   * @param a the original list\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a sublist of the given list\n   */\n  /*@SideEffectFree*/\n  public static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ String[] subarray(\n      /*@PolyAll*/ String[] a, int startindex, int length) {\n    /*@PolyAll*/ String[] result = new /*@PolyAll*/ String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray testing\n  ///\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(\n      /*@PolyAll*/ Object[] a, /*@PolyNull*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(\n      /*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// concatenation\n  ///\n\n  // Concat used to return null if both arguments are null.  That is\n  // convenient for the implementer, but not so good for clients.\n\n  /**\n   * Call this method in order to suppress compiler warnings.\n   * @param <T> the base type of the result\n   * @param lst the list to convert to an array\n   * @return the result of lst.toArray, casted to a more precise type than Object[]\n   */\n  private static <T> T[] toTArray(List<T> lst) {\n    @SuppressWarnings(\"unchecked\")\n    T[] asArray = (T[]) lst.toArray();\n    return asArray;\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.size()];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        // System.arraycopy(b, 0, result, a.length, b.size());\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.length] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.length];\n\n        // System.arraycopy(a, 0, result, 0, a.size());\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        System.arraycopy(b, 0, result, a.size(), b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.size()];\n\n        // System.arraycopy(a, 0, result, 0, a.length);\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        // System.arraycopy(b, 0, result, a.length, b.length);\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.size()] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  // Note: PolyAll is not quite right.  Need to review.\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first array to concatenate\n   * @param b the second array to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static /*@PolyAll*/ String[] concat(\n      /*@PolyAll*/ String /*@Nullable*/ [] a, /*@PolyAll*/ String /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new String[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        /*@PolyAll*/ String[] result = new String[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static byte[] concat(byte /*@Nullable*/ [] a, byte /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new byte[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        byte[] result = new byte[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static boolean[] concat(boolean /*@Nullable*/ [] a, boolean /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new boolean[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        boolean[] result = new boolean[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static char[] concat(char /*@Nullable*/ [] a, char /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new char[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        char[] result = new char[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static double[] concat(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new double[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        double[] result = new double[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static float[] concat(float /*@Nullable*/ [] a, float /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new float[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        float[] result = new float[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static int[] concat(int /*@Nullable*/ [] a, int /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new int[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        int[] result = new int[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static long[] concat(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new long[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        long[] result = new long[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static short[] concat(short /*@Nullable*/ [] a, short /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new short[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        short[] result = new short[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Printing\n  ///\n\n  // This should be extended to all types, when I get around to it.  The\n  // methods are patterned after that of java.util.Vector (and use its\n  // output format).\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, each element is quoted like a Java String.\n   * @param a an array\n   * @return a string representation of the array, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, if quoted is true, then each element is quoted like a Java String.\n   * @param a an array\n   * @param quoted whether to quote the array elements\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        if (quoted && a[i] instanceof String) {\n          String elt = (String) a[i];\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava(elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(a[i]);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@Nullable*/ Collection<?> a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @param quoted whether to quote the collection elements that are Java strings\n   * @return a string representation of the list\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n      Iterator<?> itor = a.iterator();\n      sb.append(itor.next());\n      while (itor.hasNext()) {\n        sb.append(\", \");\n        Object elt = itor.next();\n        if (quoted && elt instanceof String) {\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava((String) elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(elt);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(int /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(long /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(double /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(float /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(boolean /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls the appropriate\n   * toString() method.  Only call this method if obj is a boolean, double,\n   * int, long, or Object array.\n   * @param obj an array\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@SideEffectFree*/\n  public static String toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n      return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n      return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n      return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n      return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n      return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n      return toString((List<?>) obj);\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls .length.\n   * Only call this method if obj is a boolean, double, int, long, or Object array.\n   * @param obj a list\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@Pure*/\n  public static int length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n      return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n      return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n      return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n      return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n      return ((List<?>) obj).size();\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Sortedness\n  ///\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Boolean n = Boolean.valueOf(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Byte n = new Byte(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Character n = new Character(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Float n = new Float(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Short n = new Short(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Integer n = new Integer(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space. Equality checking\n   * uses the .equals() method for java.lang.Double.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Double n = new Double(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Long n = new Long(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param <T> the type of the elements\n   * @param a a list\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static <T> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n      if (hs.contains(a.get(i))) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a.get(i));\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Arrays as partial functions of int->int\n  ///\n\n  /**\n   * Returns true if the array is a permutation of [0..a.length).\n   * @param a an array, representing a function\n   * @return true iff all elements of a are in [0..a.length) and a\n   * contains no duplicates.\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (array)\n  /*@Pure*/\n  public static boolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int n = a[i];\n      if (n < 0 || n >= a.length || see[n]) {\n        return false;\n      }\n      see[n] = true;\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff the array does not contain -1.\n   * @param a an array, representing a function\n   * @return true iff no element of a maps to -1\n   */\n  /*@Pure*/\n  public static boolean fn_is_total(int[] a) {\n    return indexOf(a, -1) == -1; // not found\n  }\n\n  /**\n   * Return an array [0..lenth).\n   * @param length the length of the result\n   * @return fresh array that is the identity function of the given length\n   */\n  public static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n      result[i] = i;\n    }\n    return result;\n  }\n\n  /**\n   * Requires that fn_is_permutation(a) holds.\n   * @param a the input permutation\n   * @return fresh array which is the inverse of the given permutation\n   * @see #fn_is_permutation(int[])\n   */\n  public static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n  }\n\n  /**\n   * Return the inverse of the given function, which is represented as an array.\n   * @param a an array representing a function from [0..a.length) to [0..arange);\n   *  each element of a is between 0 and arange inclusive\n   * @param arange length of the argument's range and the result's domain\n   * @return function from [0..arange) to [0..a.length) that is the inverse of a\n   * @throws IllegalArgumentException if a value of a is outside of arange\n   * @exception UnsupportedOperationException when the function is not invertible\n   */\n  public static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n      int ai = a[i];\n      if (ai < -1 || ai >= arange) {\n        throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n      }\n      // ai is either -1 or a valid index\n      if (ai >= 0) {\n        if (result[ai] != -1) {\n          throw new UnsupportedOperationException(\n              String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n        }\n        result[ai] = i;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the composition of the given two functions, all of which are\n   * represented as arrays.\n   * @param a function from [0..a.length) to [0..b.length)\n   * @param b function from [0..b.length) to range R\n   * @return function from [0..a.length) to range R that is the\n   * composition of a and b\n   */\n  public static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int inner = a[i];\n      if (inner == -1) {\n        result[i] = -1;\n      } else {\n        result[i] = b[inner];\n      }\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set operations, such as subset, unions, and intersections\n  ///\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Long(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Long elt = new Long(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Double(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Double elt = new Double(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(bigger[i]);\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      if (!setBigger.contains(smaller[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array comparators\n  ///\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLexical implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer,\n     * depending on whether the first argument is less than,\n     * equal to, or greater than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLexical implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class DoubleArrayComparatorLexical\n      implements Comparator<double[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(double[] a1, double[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int result = Double.compare(a1[i], a2[i]);\n        if (result != 0) {\n          return (result);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * Strings).\n   */\n  public static final class StringArrayComparatorLexical\n      implements Comparator<String[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) String[], @PolyAll(2) String[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ String[] a1, /*@PolyAll*/ String[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int tmp = 0;\n        if ((a1[i] == null) && (a2[i] == null)) {\n          tmp = 0;\n        } else if (a1[i] == null) {\n          tmp = -1;\n        } else if (a2[i] == null) {\n          tmp = 1;\n        } else {\n          tmp = a1[i].compareTo(a2[i]);\n        }\n        if (tmp != 0) {\n          return (tmp);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLexical<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLexical\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLengthFirst\n      implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLengthFirst\n      implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int lendiff = a1.length - a2.length;\n      if (lendiff != 0) {\n        return lendiff;\n      }\n      long tmp;\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLengthFirst<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLengthFirst\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// nullness\n  ///\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(/*@PolyAll*/ Object[] a) {\n    if (a.length == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(/*@PolyAll*/ Object[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (!(a[i] == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n      if (!(a.get(i) == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// javadoc hacks\n  ///\n\n  // Without this, the Javadoc mentions of \"java.util.Vector\", are not links\n  // in the generated HTML.\n  // \"private static Vector v;\" doesn't work, nor does\n  // \"static { new java.util.Vector(); }\", nor does \"private Vector v\".\n  // Yuck!\n  public Vector<?> javadocLossage;\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "a", "", "int[]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "", "int[]", "public boolean equals(Object);" ], [ "toString", "", "int[]", "public String toString()" ], [ "hashCode", "", "int[]", "public native int hashCode()" ], [ "getClass", "", "int[]", "public final native Class getClass();" ], [ "clone", "", "int[]", "public T[] clone();" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "length", "java.lang", "String", "public int length()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "javadocLossage", "plume", "ArraysMDE", "public Vector<?> javadocLossage;" ], [ "length", "", "int[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10893,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "ArraysMDE",
  "javadocTag" : "",
  "methodJavadoc" : "",
  "methodSourceCode" : "public static /*@SideEffectFree*/\nString toString(int[] a);",
  "classJavadoc" : "/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Vector;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\nimport org.checkerframework.framework.qual.PolyAll;\n*/\n\n/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */\n@SuppressWarnings(\"interning\") // to do later\npublic final class ArraysMDE {\n  /** This class is a collecton of methods; it does not represent anything. */\n  private ArraysMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// min, max\n  ///\n\n  // Could also add linear-time orderStatistics if I liked.\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int min(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long min(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double min(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer min(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long min(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() < result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double min(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int max(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long max(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double max(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer max(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long max(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() > result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double max(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int[] min_max(int[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] {result_min, result_max};\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long[] min_max(long[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] {result_min, result_max};\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int element_range(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long element_range(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Returns the sum of an array of integers.\n   * @param a an array\n   * @return the sum of an array of integers\n   */\n  public static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of integers.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of integers\n   */\n  public static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of an array of doubles.\n   * @param a an array\n   * @return the sum of an array of doubles\n   */\n  public static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of doubles.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of doubles\n   */\n  public static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf\n  ///\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> type of the elements of the array\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt) {\n    if (elt == null) {\n      return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> the type of the elements\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   *    Identical to List.indexOf, but included for completeness.\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    return a.indexOf(elt);\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a.get(i))) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      /*@PolyNull*/ Object[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.size(); i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf, for finding subarrays\n  ///\n\n  // This is analogous to Common Lisp's \"search\" function.\n\n  // This implementation is very inefficient; I could use tricky Boyer-Moore\n  // search techniques if I liked, but it's not worth it to me yet.\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  // The signature on this method is unnecessarily strict because it\n  // requires that the component types be identical.  The signature should\n  // be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n  // @PolyAll qualifier does not yet take an argument.\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// mismatch\n  ///\n\n  // This is analogous to Common Lisp's \"mismatch\" function.\n\n  // Put it off until later; for now, use the simpler subarray function,\n  // which is a specialization of mismatch,\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray extraction\n  ///\n\n  // Note that the second argument is a length, not an end position.\n  // That's to avoid confusion over whether it would be the last included\n  // index or the first non-included index.\n\n  /**\n   * Return a subarray of the given array.\n   * @return a subarray of the given array\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ Object[] subarray(\n      /*@PolyAll*/ Object[] a, int startindex, int length) {\n    /*@PolyAll*/ Object[] result = new /*@PolyAll*/ Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a sublist of the given list.\n   * @param <T> type of the elements\n   * @param a the original list\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a sublist of the given list\n   */\n  /*@SideEffectFree*/\n  public static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ String[] subarray(\n      /*@PolyAll*/ String[] a, int startindex, int length) {\n    /*@PolyAll*/ String[] result = new /*@PolyAll*/ String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray testing\n  ///\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(\n      /*@PolyAll*/ Object[] a, /*@PolyNull*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(\n      /*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// concatenation\n  ///\n\n  // Concat used to return null if both arguments are null.  That is\n  // convenient for the implementer, but not so good for clients.\n\n  /**\n   * Call this method in order to suppress compiler warnings.\n   * @param <T> the base type of the result\n   * @param lst the list to convert to an array\n   * @return the result of lst.toArray, casted to a more precise type than Object[]\n   */\n  private static <T> T[] toTArray(List<T> lst) {\n    @SuppressWarnings(\"unchecked\")\n    T[] asArray = (T[]) lst.toArray();\n    return asArray;\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.size()];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        // System.arraycopy(b, 0, result, a.length, b.size());\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.length] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.length];\n\n        // System.arraycopy(a, 0, result, 0, a.size());\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        System.arraycopy(b, 0, result, a.size(), b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.size()];\n\n        // System.arraycopy(a, 0, result, 0, a.length);\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        // System.arraycopy(b, 0, result, a.length, b.length);\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.size()] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  // Note: PolyAll is not quite right.  Need to review.\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first array to concatenate\n   * @param b the second array to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static /*@PolyAll*/ String[] concat(\n      /*@PolyAll*/ String /*@Nullable*/ [] a, /*@PolyAll*/ String /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new String[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        /*@PolyAll*/ String[] result = new String[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static byte[] concat(byte /*@Nullable*/ [] a, byte /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new byte[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        byte[] result = new byte[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static boolean[] concat(boolean /*@Nullable*/ [] a, boolean /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new boolean[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        boolean[] result = new boolean[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static char[] concat(char /*@Nullable*/ [] a, char /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new char[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        char[] result = new char[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static double[] concat(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new double[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        double[] result = new double[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static float[] concat(float /*@Nullable*/ [] a, float /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new float[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        float[] result = new float[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static int[] concat(int /*@Nullable*/ [] a, int /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new int[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        int[] result = new int[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static long[] concat(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new long[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        long[] result = new long[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static short[] concat(short /*@Nullable*/ [] a, short /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new short[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        short[] result = new short[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Printing\n  ///\n\n  // This should be extended to all types, when I get around to it.  The\n  // methods are patterned after that of java.util.Vector (and use its\n  // output format).\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, each element is quoted like a Java String.\n   * @param a an array\n   * @return a string representation of the array, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, if quoted is true, then each element is quoted like a Java String.\n   * @param a an array\n   * @param quoted whether to quote the array elements\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        if (quoted && a[i] instanceof String) {\n          String elt = (String) a[i];\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava(elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(a[i]);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@Nullable*/ Collection<?> a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @param quoted whether to quote the collection elements that are Java strings\n   * @return a string representation of the list\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n      Iterator<?> itor = a.iterator();\n      sb.append(itor.next());\n      while (itor.hasNext()) {\n        sb.append(\", \");\n        Object elt = itor.next();\n        if (quoted && elt instanceof String) {\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava((String) elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(elt);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(int /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(long /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(double /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(float /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(boolean /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls the appropriate\n   * toString() method.  Only call this method if obj is a boolean, double,\n   * int, long, or Object array.\n   * @param obj an array\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@SideEffectFree*/\n  public static String toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n      return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n      return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n      return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n      return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n      return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n      return toString((List<?>) obj);\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls .length.\n   * Only call this method if obj is a boolean, double, int, long, or Object array.\n   * @param obj a list\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@Pure*/\n  public static int length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n      return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n      return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n      return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n      return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n      return ((List<?>) obj).size();\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Sortedness\n  ///\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Boolean n = Boolean.valueOf(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Byte n = new Byte(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Character n = new Character(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Float n = new Float(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Short n = new Short(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Integer n = new Integer(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space. Equality checking\n   * uses the .equals() method for java.lang.Double.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Double n = new Double(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Long n = new Long(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param <T> the type of the elements\n   * @param a a list\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static <T> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n      if (hs.contains(a.get(i))) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a.get(i));\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Arrays as partial functions of int->int\n  ///\n\n  /**\n   * Returns true if the array is a permutation of [0..a.length).\n   * @param a an array, representing a function\n   * @return true iff all elements of a are in [0..a.length) and a\n   * contains no duplicates.\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (array)\n  /*@Pure*/\n  public static boolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int n = a[i];\n      if (n < 0 || n >= a.length || see[n]) {\n        return false;\n      }\n      see[n] = true;\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff the array does not contain -1.\n   * @param a an array, representing a function\n   * @return true iff no element of a maps to -1\n   */\n  /*@Pure*/\n  public static boolean fn_is_total(int[] a) {\n    return indexOf(a, -1) == -1; // not found\n  }\n\n  /**\n   * Return an array [0..lenth).\n   * @param length the length of the result\n   * @return fresh array that is the identity function of the given length\n   */\n  public static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n      result[i] = i;\n    }\n    return result;\n  }\n\n  /**\n   * Requires that fn_is_permutation(a) holds.\n   * @param a the input permutation\n   * @return fresh array which is the inverse of the given permutation\n   * @see #fn_is_permutation(int[])\n   */\n  public static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n  }\n\n  /**\n   * Return the inverse of the given function, which is represented as an array.\n   * @param a an array representing a function from [0..a.length) to [0..arange);\n   *  each element of a is between 0 and arange inclusive\n   * @param arange length of the argument's range and the result's domain\n   * @return function from [0..arange) to [0..a.length) that is the inverse of a\n   * @throws IllegalArgumentException if a value of a is outside of arange\n   * @exception UnsupportedOperationException when the function is not invertible\n   */\n  public static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n      int ai = a[i];\n      if (ai < -1 || ai >= arange) {\n        throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n      }\n      // ai is either -1 or a valid index\n      if (ai >= 0) {\n        if (result[ai] != -1) {\n          throw new UnsupportedOperationException(\n              String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n        }\n        result[ai] = i;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the composition of the given two functions, all of which are\n   * represented as arrays.\n   * @param a function from [0..a.length) to [0..b.length)\n   * @param b function from [0..b.length) to range R\n   * @return function from [0..a.length) to range R that is the\n   * composition of a and b\n   */\n  public static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int inner = a[i];\n      if (inner == -1) {\n        result[i] = -1;\n      } else {\n        result[i] = b[inner];\n      }\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set operations, such as subset, unions, and intersections\n  ///\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Long(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Long elt = new Long(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Double(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Double elt = new Double(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(bigger[i]);\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      if (!setBigger.contains(smaller[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array comparators\n  ///\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLexical implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer,\n     * depending on whether the first argument is less than,\n     * equal to, or greater than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLexical implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class DoubleArrayComparatorLexical\n      implements Comparator<double[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(double[] a1, double[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int result = Double.compare(a1[i], a2[i]);\n        if (result != 0) {\n          return (result);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * Strings).\n   */\n  public static final class StringArrayComparatorLexical\n      implements Comparator<String[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) String[], @PolyAll(2) String[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ String[] a1, /*@PolyAll*/ String[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int tmp = 0;\n        if ((a1[i] == null) && (a2[i] == null)) {\n          tmp = 0;\n        } else if (a1[i] == null) {\n          tmp = -1;\n        } else if (a2[i] == null) {\n          tmp = 1;\n        } else {\n          tmp = a1[i].compareTo(a2[i]);\n        }\n        if (tmp != 0) {\n          return (tmp);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLexical<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLexical\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLengthFirst\n      implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLengthFirst\n      implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int lendiff = a1.length - a2.length;\n      if (lendiff != 0) {\n        return lendiff;\n      }\n      long tmp;\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLengthFirst<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLengthFirst\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// nullness\n  ///\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(/*@PolyAll*/ Object[] a) {\n    if (a.length == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(/*@PolyAll*/ Object[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (!(a[i] == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n      if (!(a.get(i) == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// javadoc hacks\n  ///\n\n  // Without this, the Javadoc mentions of \"java.util.Vector\", are not links\n  // in the generated HTML.\n  // \"private static Vector v;\" doesn't work, nor does\n  // \"static { new java.util.Vector(); }\", nor does \"private Vector v\".\n  // Yuck!\n  public Vector<?> javadocLossage;\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "a", "", "int[]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "", "int[]", "public boolean equals(Object);" ], [ "toString", "", "int[]", "public String toString()" ], [ "hashCode", "", "int[]", "public native int hashCode()" ], [ "getClass", "", "int[]", "public final native Class getClass();" ], [ "clone", "", "int[]", "public T[] clone();" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "length", "java.lang", "String", "public int length()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "javadocLossage", "plume", "ArraysMDE", "public Vector<?> javadocLossage;" ], [ "length", "", "int[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10893,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "ArraysMDE",
  "javadocTag" : "@param a a group.",
  "methodJavadoc" : "    /**\n     * Return a string representation of the array.\n     * The representation is patterned after that of java.util.Vector.\n     * \n     * @param a a group.\n     * @return a string representation of the array\n     * @see java.util.Vector#toString\n     */",
  "methodSourceCode" : "public static /*@SideEffectFree*/\nString toString(int[] a){\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}",
  "classJavadoc" : "/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Vector;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\nimport org.checkerframework.framework.qual.PolyAll;\n*/\n\n/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */\n@SuppressWarnings(\"interning\") // to do later\npublic final class ArraysMDE {\n  /** This class is a collecton of methods; it does not represent anything. */\n  private ArraysMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// min, max\n  ///\n\n  // Could also add linear-time orderStatistics if I liked.\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int min(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long min(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double min(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer min(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long min(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() < result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double min(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int max(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long max(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double max(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer max(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long max(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() > result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double max(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int[] min_max(int[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] {result_min, result_max};\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long[] min_max(long[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] {result_min, result_max};\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int element_range(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long element_range(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Returns the sum of an array of integers.\n   * @param a an array\n   * @return the sum of an array of integers\n   */\n  public static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of integers.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of integers\n   */\n  public static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of an array of doubles.\n   * @param a an array\n   * @return the sum of an array of doubles\n   */\n  public static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of doubles.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of doubles\n   */\n  public static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf\n  ///\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> type of the elements of the array\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt) {\n    if (elt == null) {\n      return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> the type of the elements\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   *    Identical to List.indexOf, but included for completeness.\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    return a.indexOf(elt);\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a.get(i))) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      /*@PolyNull*/ Object[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.size(); i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf, for finding subarrays\n  ///\n\n  // This is analogous to Common Lisp's \"search\" function.\n\n  // This implementation is very inefficient; I could use tricky Boyer-Moore\n  // search techniques if I liked, but it's not worth it to me yet.\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  // The signature on this method is unnecessarily strict because it\n  // requires that the component types be identical.  The signature should\n  // be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n  // @PolyAll qualifier does not yet take an argument.\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// mismatch\n  ///\n\n  // This is analogous to Common Lisp's \"mismatch\" function.\n\n  // Put it off until later; for now, use the simpler subarray function,\n  // which is a specialization of mismatch,\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray extraction\n  ///\n\n  // Note that the second argument is a length, not an end position.\n  // That's to avoid confusion over whether it would be the last included\n  // index or the first non-included index.\n\n  /**\n   * Return a subarray of the given array.\n   * @return a subarray of the given array\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ Object[] subarray(\n      /*@PolyAll*/ Object[] a, int startindex, int length) {\n    /*@PolyAll*/ Object[] result = new /*@PolyAll*/ Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a sublist of the given list.\n   * @param <T> type of the elements\n   * @param a the original list\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a sublist of the given list\n   */\n  /*@SideEffectFree*/\n  public static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ String[] subarray(\n      /*@PolyAll*/ String[] a, int startindex, int length) {\n    /*@PolyAll*/ String[] result = new /*@PolyAll*/ String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray testing\n  ///\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(\n      /*@PolyAll*/ Object[] a, /*@PolyNull*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(\n      /*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// concatenation\n  ///\n\n  // Concat used to return null if both arguments are null.  That is\n  // convenient for the implementer, but not so good for clients.\n\n  /**\n   * Call this method in order to suppress compiler warnings.\n   * @param <T> the base type of the result\n   * @param lst the list to convert to an array\n   * @return the result of lst.toArray, casted to a more precise type than Object[]\n   */\n  private static <T> T[] toTArray(List<T> lst) {\n    @SuppressWarnings(\"unchecked\")\n    T[] asArray = (T[]) lst.toArray();\n    return asArray;\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.size()];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        // System.arraycopy(b, 0, result, a.length, b.size());\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.length] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.length];\n\n        // System.arraycopy(a, 0, result, 0, a.size());\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        System.arraycopy(b, 0, result, a.size(), b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.size()];\n\n        // System.arraycopy(a, 0, result, 0, a.length);\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        // System.arraycopy(b, 0, result, a.length, b.length);\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.size()] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  // Note: PolyAll is not quite right.  Need to review.\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first array to concatenate\n   * @param b the second array to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static /*@PolyAll*/ String[] concat(\n      /*@PolyAll*/ String /*@Nullable*/ [] a, /*@PolyAll*/ String /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new String[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        /*@PolyAll*/ String[] result = new String[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static byte[] concat(byte /*@Nullable*/ [] a, byte /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new byte[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        byte[] result = new byte[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static boolean[] concat(boolean /*@Nullable*/ [] a, boolean /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new boolean[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        boolean[] result = new boolean[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static char[] concat(char /*@Nullable*/ [] a, char /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new char[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        char[] result = new char[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static double[] concat(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new double[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        double[] result = new double[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static float[] concat(float /*@Nullable*/ [] a, float /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new float[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        float[] result = new float[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static int[] concat(int /*@Nullable*/ [] a, int /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new int[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        int[] result = new int[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static long[] concat(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new long[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        long[] result = new long[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static short[] concat(short /*@Nullable*/ [] a, short /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new short[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        short[] result = new short[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Printing\n  ///\n\n  // This should be extended to all types, when I get around to it.  The\n  // methods are patterned after that of java.util.Vector (and use its\n  // output format).\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, each element is quoted like a Java String.\n   * @param a an array\n   * @return a string representation of the array, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, if quoted is true, then each element is quoted like a Java String.\n   * @param a an array\n   * @param quoted whether to quote the array elements\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        if (quoted && a[i] instanceof String) {\n          String elt = (String) a[i];\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava(elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(a[i]);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@Nullable*/ Collection<?> a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @param quoted whether to quote the collection elements that are Java strings\n   * @return a string representation of the list\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n      Iterator<?> itor = a.iterator();\n      sb.append(itor.next());\n      while (itor.hasNext()) {\n        sb.append(\", \");\n        Object elt = itor.next();\n        if (quoted && elt instanceof String) {\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava((String) elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(elt);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(int /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(long /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(double /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(float /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(boolean /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls the appropriate\n   * toString() method.  Only call this method if obj is a boolean, double,\n   * int, long, or Object array.\n   * @param obj an array\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@SideEffectFree*/\n  public static String toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n      return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n      return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n      return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n      return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n      return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n      return toString((List<?>) obj);\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls .length.\n   * Only call this method if obj is a boolean, double, int, long, or Object array.\n   * @param obj a list\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@Pure*/\n  public static int length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n      return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n      return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n      return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n      return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n      return ((List<?>) obj).size();\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Sortedness\n  ///\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Boolean n = Boolean.valueOf(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Byte n = new Byte(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Character n = new Character(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Float n = new Float(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Short n = new Short(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Integer n = new Integer(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space. Equality checking\n   * uses the .equals() method for java.lang.Double.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Double n = new Double(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Long n = new Long(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param <T> the type of the elements\n   * @param a a list\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static <T> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n      if (hs.contains(a.get(i))) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a.get(i));\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Arrays as partial functions of int->int\n  ///\n\n  /**\n   * Returns true if the array is a permutation of [0..a.length).\n   * @param a an array, representing a function\n   * @return true iff all elements of a are in [0..a.length) and a\n   * contains no duplicates.\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (array)\n  /*@Pure*/\n  public static boolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int n = a[i];\n      if (n < 0 || n >= a.length || see[n]) {\n        return false;\n      }\n      see[n] = true;\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff the array does not contain -1.\n   * @param a an array, representing a function\n   * @return true iff no element of a maps to -1\n   */\n  /*@Pure*/\n  public static boolean fn_is_total(int[] a) {\n    return indexOf(a, -1) == -1; // not found\n  }\n\n  /**\n   * Return an array [0..lenth).\n   * @param length the length of the result\n   * @return fresh array that is the identity function of the given length\n   */\n  public static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n      result[i] = i;\n    }\n    return result;\n  }\n\n  /**\n   * Requires that fn_is_permutation(a) holds.\n   * @param a the input permutation\n   * @return fresh array which is the inverse of the given permutation\n   * @see #fn_is_permutation(int[])\n   */\n  public static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n  }\n\n  /**\n   * Return the inverse of the given function, which is represented as an array.\n   * @param a an array representing a function from [0..a.length) to [0..arange);\n   *  each element of a is between 0 and arange inclusive\n   * @param arange length of the argument's range and the result's domain\n   * @return function from [0..arange) to [0..a.length) that is the inverse of a\n   * @throws IllegalArgumentException if a value of a is outside of arange\n   * @exception UnsupportedOperationException when the function is not invertible\n   */\n  public static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n      int ai = a[i];\n      if (ai < -1 || ai >= arange) {\n        throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n      }\n      // ai is either -1 or a valid index\n      if (ai >= 0) {\n        if (result[ai] != -1) {\n          throw new UnsupportedOperationException(\n              String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n        }\n        result[ai] = i;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the composition of the given two functions, all of which are\n   * represented as arrays.\n   * @param a function from [0..a.length) to [0..b.length)\n   * @param b function from [0..b.length) to range R\n   * @return function from [0..a.length) to range R that is the\n   * composition of a and b\n   */\n  public static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int inner = a[i];\n      if (inner == -1) {\n        result[i] = -1;\n      } else {\n        result[i] = b[inner];\n      }\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set operations, such as subset, unions, and intersections\n  ///\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Long(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Long elt = new Long(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Double(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Double elt = new Double(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(bigger[i]);\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      if (!setBigger.contains(smaller[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array comparators\n  ///\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLexical implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer,\n     * depending on whether the first argument is less than,\n     * equal to, or greater than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLexical implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class DoubleArrayComparatorLexical\n      implements Comparator<double[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(double[] a1, double[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int result = Double.compare(a1[i], a2[i]);\n        if (result != 0) {\n          return (result);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * Strings).\n   */\n  public static final class StringArrayComparatorLexical\n      implements Comparator<String[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) String[], @PolyAll(2) String[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ String[] a1, /*@PolyAll*/ String[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int tmp = 0;\n        if ((a1[i] == null) && (a2[i] == null)) {\n          tmp = 0;\n        } else if (a1[i] == null) {\n          tmp = -1;\n        } else if (a2[i] == null) {\n          tmp = 1;\n        } else {\n          tmp = a1[i].compareTo(a2[i]);\n        }\n        if (tmp != 0) {\n          return (tmp);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLexical<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLexical\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLengthFirst\n      implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLengthFirst\n      implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int lendiff = a1.length - a2.length;\n      if (lendiff != 0) {\n        return lendiff;\n      }\n      long tmp;\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLengthFirst<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLengthFirst\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// nullness\n  ///\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(/*@PolyAll*/ Object[] a) {\n    if (a.length == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(/*@PolyAll*/ Object[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (!(a[i] == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n      if (!(a.get(i) == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// javadoc hacks\n  ///\n\n  // Without this, the Javadoc mentions of \"java.util.Vector\", are not links\n  // in the generated HTML.\n  // \"private static Vector v;\" doesn't work, nor does\n  // \"static { new java.util.Vector(); }\", nor does \"private Vector v\".\n  // Yuck!\n  public Vector<?> javadocLossage;\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "a", "", "int[]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "", "int[]", "public boolean equals(Object);" ], [ "toString", "", "int[]", "public String toString()" ], [ "hashCode", "", "int[]", "public native int hashCode()" ], [ "getClass", "", "int[]", "public final native Class getClass();" ], [ "clone", "", "int[]", "public T[] clone();" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "length", "java.lang", "String", "public int length()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "javadocLossage", "plume", "ArraysMDE", "public Vector<?> javadocLossage;" ], [ "length", "", "int[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10893,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "ArraysMDE",
  "javadocTag" : "@param a a set",
  "methodJavadoc" : "    /**\n     * Return a string representation of the array.\n     * The representation is patterned after that of java.util.Vector.\n     * \n     * @param a a set\n     * @return a string representation of the array\n     * @see java.util.Vector#toString\n     */",
  "methodSourceCode" : "public static /*@SideEffectFree*/\nString toString(int[] a);",
  "classJavadoc" : "/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Vector;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\nimport org.checkerframework.framework.qual.PolyAll;\n*/\n\n/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */\n@SuppressWarnings(\"interning\") // to do later\npublic final class ArraysMDE {\n  /** This class is a collecton of methods; it does not represent anything. */\n  private ArraysMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// min, max\n  ///\n\n  // Could also add linear-time orderStatistics if I liked.\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int min(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long min(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double min(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer min(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long min(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() < result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double min(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int max(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long max(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double max(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer max(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long max(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() > result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double max(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int[] min_max(int[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] {result_min, result_max};\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long[] min_max(long[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] {result_min, result_max};\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int element_range(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long element_range(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Returns the sum of an array of integers.\n   * @param a an array\n   * @return the sum of an array of integers\n   */\n  public static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of integers.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of integers\n   */\n  public static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of an array of doubles.\n   * @param a an array\n   * @return the sum of an array of doubles\n   */\n  public static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of doubles.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of doubles\n   */\n  public static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf\n  ///\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> type of the elements of the array\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt) {\n    if (elt == null) {\n      return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> the type of the elements\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   *    Identical to List.indexOf, but included for completeness.\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    return a.indexOf(elt);\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a.get(i))) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      /*@PolyNull*/ Object[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.size(); i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf, for finding subarrays\n  ///\n\n  // This is analogous to Common Lisp's \"search\" function.\n\n  // This implementation is very inefficient; I could use tricky Boyer-Moore\n  // search techniques if I liked, but it's not worth it to me yet.\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  // The signature on this method is unnecessarily strict because it\n  // requires that the component types be identical.  The signature should\n  // be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n  // @PolyAll qualifier does not yet take an argument.\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// mismatch\n  ///\n\n  // This is analogous to Common Lisp's \"mismatch\" function.\n\n  // Put it off until later; for now, use the simpler subarray function,\n  // which is a specialization of mismatch,\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray extraction\n  ///\n\n  // Note that the second argument is a length, not an end position.\n  // That's to avoid confusion over whether it would be the last included\n  // index or the first non-included index.\n\n  /**\n   * Return a subarray of the given array.\n   * @return a subarray of the given array\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ Object[] subarray(\n      /*@PolyAll*/ Object[] a, int startindex, int length) {\n    /*@PolyAll*/ Object[] result = new /*@PolyAll*/ Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a sublist of the given list.\n   * @param <T> type of the elements\n   * @param a the original list\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a sublist of the given list\n   */\n  /*@SideEffectFree*/\n  public static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ String[] subarray(\n      /*@PolyAll*/ String[] a, int startindex, int length) {\n    /*@PolyAll*/ String[] result = new /*@PolyAll*/ String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray testing\n  ///\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(\n      /*@PolyAll*/ Object[] a, /*@PolyNull*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(\n      /*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// concatenation\n  ///\n\n  // Concat used to return null if both arguments are null.  That is\n  // convenient for the implementer, but not so good for clients.\n\n  /**\n   * Call this method in order to suppress compiler warnings.\n   * @param <T> the base type of the result\n   * @param lst the list to convert to an array\n   * @return the result of lst.toArray, casted to a more precise type than Object[]\n   */\n  private static <T> T[] toTArray(List<T> lst) {\n    @SuppressWarnings(\"unchecked\")\n    T[] asArray = (T[]) lst.toArray();\n    return asArray;\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.size()];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        // System.arraycopy(b, 0, result, a.length, b.size());\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.length] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.length];\n\n        // System.arraycopy(a, 0, result, 0, a.size());\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        System.arraycopy(b, 0, result, a.size(), b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.size()];\n\n        // System.arraycopy(a, 0, result, 0, a.length);\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        // System.arraycopy(b, 0, result, a.length, b.length);\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.size()] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  // Note: PolyAll is not quite right.  Need to review.\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first array to concatenate\n   * @param b the second array to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static /*@PolyAll*/ String[] concat(\n      /*@PolyAll*/ String /*@Nullable*/ [] a, /*@PolyAll*/ String /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new String[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        /*@PolyAll*/ String[] result = new String[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static byte[] concat(byte /*@Nullable*/ [] a, byte /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new byte[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        byte[] result = new byte[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static boolean[] concat(boolean /*@Nullable*/ [] a, boolean /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new boolean[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        boolean[] result = new boolean[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static char[] concat(char /*@Nullable*/ [] a, char /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new char[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        char[] result = new char[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static double[] concat(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new double[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        double[] result = new double[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static float[] concat(float /*@Nullable*/ [] a, float /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new float[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        float[] result = new float[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static int[] concat(int /*@Nullable*/ [] a, int /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new int[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        int[] result = new int[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static long[] concat(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new long[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        long[] result = new long[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static short[] concat(short /*@Nullable*/ [] a, short /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new short[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        short[] result = new short[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Printing\n  ///\n\n  // This should be extended to all types, when I get around to it.  The\n  // methods are patterned after that of java.util.Vector (and use its\n  // output format).\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, each element is quoted like a Java String.\n   * @param a an array\n   * @return a string representation of the array, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, if quoted is true, then each element is quoted like a Java String.\n   * @param a an array\n   * @param quoted whether to quote the array elements\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        if (quoted && a[i] instanceof String) {\n          String elt = (String) a[i];\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava(elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(a[i]);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@Nullable*/ Collection<?> a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @param quoted whether to quote the collection elements that are Java strings\n   * @return a string representation of the list\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n      Iterator<?> itor = a.iterator();\n      sb.append(itor.next());\n      while (itor.hasNext()) {\n        sb.append(\", \");\n        Object elt = itor.next();\n        if (quoted && elt instanceof String) {\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava((String) elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(elt);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(int /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(long /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(double /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(float /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(boolean /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls the appropriate\n   * toString() method.  Only call this method if obj is a boolean, double,\n   * int, long, or Object array.\n   * @param obj an array\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@SideEffectFree*/\n  public static String toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n      return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n      return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n      return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n      return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n      return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n      return toString((List<?>) obj);\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls .length.\n   * Only call this method if obj is a boolean, double, int, long, or Object array.\n   * @param obj a list\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@Pure*/\n  public static int length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n      return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n      return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n      return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n      return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n      return ((List<?>) obj).size();\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Sortedness\n  ///\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Boolean n = Boolean.valueOf(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Byte n = new Byte(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Character n = new Character(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Float n = new Float(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Short n = new Short(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Integer n = new Integer(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space. Equality checking\n   * uses the .equals() method for java.lang.Double.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Double n = new Double(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Long n = new Long(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param <T> the type of the elements\n   * @param a a list\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static <T> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n      if (hs.contains(a.get(i))) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a.get(i));\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Arrays as partial functions of int->int\n  ///\n\n  /**\n   * Returns true if the array is a permutation of [0..a.length).\n   * @param a an array, representing a function\n   * @return true iff all elements of a are in [0..a.length) and a\n   * contains no duplicates.\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (array)\n  /*@Pure*/\n  public static boolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int n = a[i];\n      if (n < 0 || n >= a.length || see[n]) {\n        return false;\n      }\n      see[n] = true;\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff the array does not contain -1.\n   * @param a an array, representing a function\n   * @return true iff no element of a maps to -1\n   */\n  /*@Pure*/\n  public static boolean fn_is_total(int[] a) {\n    return indexOf(a, -1) == -1; // not found\n  }\n\n  /**\n   * Return an array [0..lenth).\n   * @param length the length of the result\n   * @return fresh array that is the identity function of the given length\n   */\n  public static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n      result[i] = i;\n    }\n    return result;\n  }\n\n  /**\n   * Requires that fn_is_permutation(a) holds.\n   * @param a the input permutation\n   * @return fresh array which is the inverse of the given permutation\n   * @see #fn_is_permutation(int[])\n   */\n  public static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n  }\n\n  /**\n   * Return the inverse of the given function, which is represented as an array.\n   * @param a an array representing a function from [0..a.length) to [0..arange);\n   *  each element of a is between 0 and arange inclusive\n   * @param arange length of the argument's range and the result's domain\n   * @return function from [0..arange) to [0..a.length) that is the inverse of a\n   * @throws IllegalArgumentException if a value of a is outside of arange\n   * @exception UnsupportedOperationException when the function is not invertible\n   */\n  public static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n      int ai = a[i];\n      if (ai < -1 || ai >= arange) {\n        throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n      }\n      // ai is either -1 or a valid index\n      if (ai >= 0) {\n        if (result[ai] != -1) {\n          throw new UnsupportedOperationException(\n              String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n        }\n        result[ai] = i;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the composition of the given two functions, all of which are\n   * represented as arrays.\n   * @param a function from [0..a.length) to [0..b.length)\n   * @param b function from [0..b.length) to range R\n   * @return function from [0..a.length) to range R that is the\n   * composition of a and b\n   */\n  public static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int inner = a[i];\n      if (inner == -1) {\n        result[i] = -1;\n      } else {\n        result[i] = b[inner];\n      }\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set operations, such as subset, unions, and intersections\n  ///\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Long(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Long elt = new Long(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Double(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Double elt = new Double(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(bigger[i]);\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      if (!setBigger.contains(smaller[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array comparators\n  ///\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLexical implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer,\n     * depending on whether the first argument is less than,\n     * equal to, or greater than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLexical implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class DoubleArrayComparatorLexical\n      implements Comparator<double[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(double[] a1, double[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int result = Double.compare(a1[i], a2[i]);\n        if (result != 0) {\n          return (result);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * Strings).\n   */\n  public static final class StringArrayComparatorLexical\n      implements Comparator<String[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) String[], @PolyAll(2) String[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ String[] a1, /*@PolyAll*/ String[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int tmp = 0;\n        if ((a1[i] == null) && (a2[i] == null)) {\n          tmp = 0;\n        } else if (a1[i] == null) {\n          tmp = -1;\n        } else if (a2[i] == null) {\n          tmp = 1;\n        } else {\n          tmp = a1[i].compareTo(a2[i]);\n        }\n        if (tmp != 0) {\n          return (tmp);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLexical<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLexical\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLengthFirst\n      implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLengthFirst\n      implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int lendiff = a1.length - a2.length;\n      if (lendiff != 0) {\n        return lendiff;\n      }\n      long tmp;\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLengthFirst<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLengthFirst\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// nullness\n  ///\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(/*@PolyAll*/ Object[] a) {\n    if (a.length == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(/*@PolyAll*/ Object[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (!(a[i] == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n      if (!(a.get(i) == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// javadoc hacks\n  ///\n\n  // Without this, the Javadoc mentions of \"java.util.Vector\", are not links\n  // in the generated HTML.\n  // \"private static Vector v;\" doesn't work, nor does\n  // \"static { new java.util.Vector(); }\", nor does \"private Vector v\".\n  // Yuck!\n  public Vector<?> javadocLossage;\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "a", "", "int[]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "", "int[]", "public boolean equals(Object);" ], [ "toString", "", "int[]", "public String toString()" ], [ "hashCode", "", "int[]", "public native int hashCode()" ], [ "getClass", "", "int[]", "public final native Class getClass();" ], [ "clone", "", "int[]", "public T[] clone();" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "length", "java.lang", "String", "public int length()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "javadocLossage", "plume", "ArraysMDE", "public Vector<?> javadocLossage;" ], [ "length", "", "int[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10893,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "ArraysMDE",
  "javadocTag" : "@param a a list",
  "methodJavadoc" : "    /**\n     * Return a string representation of the array.\n     * The representation is patterned after that of java.util.Vector.\n     * \n     * @param a a list\n     * @return a string representation of the array\n     * @see java.util.Vector#toString\n     */",
  "methodSourceCode" : "public static /*@SideEffectFree*/\nString toString(int[] a){\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}",
  "classJavadoc" : "/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Vector;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\nimport org.checkerframework.framework.qual.PolyAll;\n*/\n\n/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */\n@SuppressWarnings(\"interning\") // to do later\npublic final class ArraysMDE {\n  /** This class is a collecton of methods; it does not represent anything. */\n  private ArraysMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// min, max\n  ///\n\n  // Could also add linear-time orderStatistics if I liked.\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int min(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long min(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double min(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer min(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long min(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() < result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double min(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int max(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long max(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double max(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer max(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long max(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() > result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double max(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int[] min_max(int[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] {result_min, result_max};\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long[] min_max(long[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] {result_min, result_max};\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int element_range(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long element_range(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Returns the sum of an array of integers.\n   * @param a an array\n   * @return the sum of an array of integers\n   */\n  public static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of integers.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of integers\n   */\n  public static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of an array of doubles.\n   * @param a an array\n   * @return the sum of an array of doubles\n   */\n  public static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of doubles.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of doubles\n   */\n  public static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf\n  ///\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> type of the elements of the array\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt) {\n    if (elt == null) {\n      return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> the type of the elements\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   *    Identical to List.indexOf, but included for completeness.\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    return a.indexOf(elt);\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a.get(i))) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      /*@PolyNull*/ Object[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.size(); i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf, for finding subarrays\n  ///\n\n  // This is analogous to Common Lisp's \"search\" function.\n\n  // This implementation is very inefficient; I could use tricky Boyer-Moore\n  // search techniques if I liked, but it's not worth it to me yet.\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  // The signature on this method is unnecessarily strict because it\n  // requires that the component types be identical.  The signature should\n  // be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n  // @PolyAll qualifier does not yet take an argument.\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// mismatch\n  ///\n\n  // This is analogous to Common Lisp's \"mismatch\" function.\n\n  // Put it off until later; for now, use the simpler subarray function,\n  // which is a specialization of mismatch,\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray extraction\n  ///\n\n  // Note that the second argument is a length, not an end position.\n  // That's to avoid confusion over whether it would be the last included\n  // index or the first non-included index.\n\n  /**\n   * Return a subarray of the given array.\n   * @return a subarray of the given array\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ Object[] subarray(\n      /*@PolyAll*/ Object[] a, int startindex, int length) {\n    /*@PolyAll*/ Object[] result = new /*@PolyAll*/ Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a sublist of the given list.\n   * @param <T> type of the elements\n   * @param a the original list\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a sublist of the given list\n   */\n  /*@SideEffectFree*/\n  public static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ String[] subarray(\n      /*@PolyAll*/ String[] a, int startindex, int length) {\n    /*@PolyAll*/ String[] result = new /*@PolyAll*/ String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray testing\n  ///\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(\n      /*@PolyAll*/ Object[] a, /*@PolyNull*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(\n      /*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// concatenation\n  ///\n\n  // Concat used to return null if both arguments are null.  That is\n  // convenient for the implementer, but not so good for clients.\n\n  /**\n   * Call this method in order to suppress compiler warnings.\n   * @param <T> the base type of the result\n   * @param lst the list to convert to an array\n   * @return the result of lst.toArray, casted to a more precise type than Object[]\n   */\n  private static <T> T[] toTArray(List<T> lst) {\n    @SuppressWarnings(\"unchecked\")\n    T[] asArray = (T[]) lst.toArray();\n    return asArray;\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.size()];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        // System.arraycopy(b, 0, result, a.length, b.size());\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.length] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.length];\n\n        // System.arraycopy(a, 0, result, 0, a.size());\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        System.arraycopy(b, 0, result, a.size(), b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.size()];\n\n        // System.arraycopy(a, 0, result, 0, a.length);\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        // System.arraycopy(b, 0, result, a.length, b.length);\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.size()] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  // Note: PolyAll is not quite right.  Need to review.\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first array to concatenate\n   * @param b the second array to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static /*@PolyAll*/ String[] concat(\n      /*@PolyAll*/ String /*@Nullable*/ [] a, /*@PolyAll*/ String /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new String[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        /*@PolyAll*/ String[] result = new String[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static byte[] concat(byte /*@Nullable*/ [] a, byte /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new byte[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        byte[] result = new byte[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static boolean[] concat(boolean /*@Nullable*/ [] a, boolean /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new boolean[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        boolean[] result = new boolean[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static char[] concat(char /*@Nullable*/ [] a, char /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new char[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        char[] result = new char[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static double[] concat(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new double[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        double[] result = new double[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static float[] concat(float /*@Nullable*/ [] a, float /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new float[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        float[] result = new float[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static int[] concat(int /*@Nullable*/ [] a, int /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new int[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        int[] result = new int[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static long[] concat(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new long[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        long[] result = new long[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static short[] concat(short /*@Nullable*/ [] a, short /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new short[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        short[] result = new short[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Printing\n  ///\n\n  // This should be extended to all types, when I get around to it.  The\n  // methods are patterned after that of java.util.Vector (and use its\n  // output format).\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, each element is quoted like a Java String.\n   * @param a an array\n   * @return a string representation of the array, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, if quoted is true, then each element is quoted like a Java String.\n   * @param a an array\n   * @param quoted whether to quote the array elements\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        if (quoted && a[i] instanceof String) {\n          String elt = (String) a[i];\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava(elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(a[i]);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@Nullable*/ Collection<?> a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @param quoted whether to quote the collection elements that are Java strings\n   * @return a string representation of the list\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n      Iterator<?> itor = a.iterator();\n      sb.append(itor.next());\n      while (itor.hasNext()) {\n        sb.append(\", \");\n        Object elt = itor.next();\n        if (quoted && elt instanceof String) {\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava((String) elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(elt);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(int /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(long /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(double /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(float /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(boolean /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls the appropriate\n   * toString() method.  Only call this method if obj is a boolean, double,\n   * int, long, or Object array.\n   * @param obj an array\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@SideEffectFree*/\n  public static String toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n      return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n      return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n      return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n      return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n      return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n      return toString((List<?>) obj);\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls .length.\n   * Only call this method if obj is a boolean, double, int, long, or Object array.\n   * @param obj a list\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@Pure*/\n  public static int length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n      return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n      return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n      return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n      return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n      return ((List<?>) obj).size();\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Sortedness\n  ///\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Boolean n = Boolean.valueOf(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Byte n = new Byte(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Character n = new Character(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Float n = new Float(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Short n = new Short(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Integer n = new Integer(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space. Equality checking\n   * uses the .equals() method for java.lang.Double.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Double n = new Double(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Long n = new Long(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param <T> the type of the elements\n   * @param a a list\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static <T> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n      if (hs.contains(a.get(i))) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a.get(i));\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Arrays as partial functions of int->int\n  ///\n\n  /**\n   * Returns true if the array is a permutation of [0..a.length).\n   * @param a an array, representing a function\n   * @return true iff all elements of a are in [0..a.length) and a\n   * contains no duplicates.\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (array)\n  /*@Pure*/\n  public static boolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int n = a[i];\n      if (n < 0 || n >= a.length || see[n]) {\n        return false;\n      }\n      see[n] = true;\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff the array does not contain -1.\n   * @param a an array, representing a function\n   * @return true iff no element of a maps to -1\n   */\n  /*@Pure*/\n  public static boolean fn_is_total(int[] a) {\n    return indexOf(a, -1) == -1; // not found\n  }\n\n  /**\n   * Return an array [0..lenth).\n   * @param length the length of the result\n   * @return fresh array that is the identity function of the given length\n   */\n  public static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n      result[i] = i;\n    }\n    return result;\n  }\n\n  /**\n   * Requires that fn_is_permutation(a) holds.\n   * @param a the input permutation\n   * @return fresh array which is the inverse of the given permutation\n   * @see #fn_is_permutation(int[])\n   */\n  public static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n  }\n\n  /**\n   * Return the inverse of the given function, which is represented as an array.\n   * @param a an array representing a function from [0..a.length) to [0..arange);\n   *  each element of a is between 0 and arange inclusive\n   * @param arange length of the argument's range and the result's domain\n   * @return function from [0..arange) to [0..a.length) that is the inverse of a\n   * @throws IllegalArgumentException if a value of a is outside of arange\n   * @exception UnsupportedOperationException when the function is not invertible\n   */\n  public static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n      int ai = a[i];\n      if (ai < -1 || ai >= arange) {\n        throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n      }\n      // ai is either -1 or a valid index\n      if (ai >= 0) {\n        if (result[ai] != -1) {\n          throw new UnsupportedOperationException(\n              String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n        }\n        result[ai] = i;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the composition of the given two functions, all of which are\n   * represented as arrays.\n   * @param a function from [0..a.length) to [0..b.length)\n   * @param b function from [0..b.length) to range R\n   * @return function from [0..a.length) to range R that is the\n   * composition of a and b\n   */\n  public static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int inner = a[i];\n      if (inner == -1) {\n        result[i] = -1;\n      } else {\n        result[i] = b[inner];\n      }\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set operations, such as subset, unions, and intersections\n  ///\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Long(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Long elt = new Long(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Double(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Double elt = new Double(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(bigger[i]);\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      if (!setBigger.contains(smaller[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array comparators\n  ///\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLexical implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer,\n     * depending on whether the first argument is less than,\n     * equal to, or greater than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLexical implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class DoubleArrayComparatorLexical\n      implements Comparator<double[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(double[] a1, double[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int result = Double.compare(a1[i], a2[i]);\n        if (result != 0) {\n          return (result);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * Strings).\n   */\n  public static final class StringArrayComparatorLexical\n      implements Comparator<String[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) String[], @PolyAll(2) String[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ String[] a1, /*@PolyAll*/ String[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int tmp = 0;\n        if ((a1[i] == null) && (a2[i] == null)) {\n          tmp = 0;\n        } else if (a1[i] == null) {\n          tmp = -1;\n        } else if (a2[i] == null) {\n          tmp = 1;\n        } else {\n          tmp = a1[i].compareTo(a2[i]);\n        }\n        if (tmp != 0) {\n          return (tmp);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLexical<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLexical\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLengthFirst\n      implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLengthFirst\n      implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int lendiff = a1.length - a2.length;\n      if (lendiff != 0) {\n        return lendiff;\n      }\n      long tmp;\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLengthFirst<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLengthFirst\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// nullness\n  ///\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(/*@PolyAll*/ Object[] a) {\n    if (a.length == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(/*@PolyAll*/ Object[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (!(a[i] == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n      if (!(a.get(i) == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// javadoc hacks\n  ///\n\n  // Without this, the Javadoc mentions of \"java.util.Vector\", are not links\n  // in the generated HTML.\n  // \"private static Vector v;\" doesn't work, nor does\n  // \"static { new java.util.Vector(); }\", nor does \"private Vector v\".\n  // Yuck!\n  public Vector<?> javadocLossage;\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "a", "", "int[]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "", "int[]", "public boolean equals(Object);" ], [ "toString", "", "int[]", "public String toString()" ], [ "hashCode", "", "int[]", "public native int hashCode()" ], [ "getClass", "", "int[]", "public final native Class getClass();" ], [ "clone", "", "int[]", "public T[] clone();" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "length", "java.lang", "String", "public int length()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "javadocLossage", "plume", "ArraysMDE", "public Vector<?> javadocLossage;" ], [ "length", "", "int[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10893,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "ArraysMDE",
  "javadocTag" : "@param a a collection",
  "methodJavadoc" : "    /**\n     * Return a string representation of the array.\n     * The representation is patterned after that of java.util.Vector.\n     * \n     * @param a a collection\n     * @return a string representation of the array\n     * @see java.util.Vector#toString\n     */",
  "methodSourceCode" : "public static /*@SideEffectFree*/\nString toString(int[] a);",
  "classJavadoc" : "/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Vector;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\nimport org.checkerframework.framework.qual.PolyAll;\n*/\n\n/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */\n@SuppressWarnings(\"interning\") // to do later\npublic final class ArraysMDE {\n  /** This class is a collecton of methods; it does not represent anything. */\n  private ArraysMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// min, max\n  ///\n\n  // Could also add linear-time orderStatistics if I liked.\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int min(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long min(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double min(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer min(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long min(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() < result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double min(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int max(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long max(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double max(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer max(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long max(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() > result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double max(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int[] min_max(int[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] {result_min, result_max};\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long[] min_max(long[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] {result_min, result_max};\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int element_range(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long element_range(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Returns the sum of an array of integers.\n   * @param a an array\n   * @return the sum of an array of integers\n   */\n  public static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of integers.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of integers\n   */\n  public static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of an array of doubles.\n   * @param a an array\n   * @return the sum of an array of doubles\n   */\n  public static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of doubles.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of doubles\n   */\n  public static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf\n  ///\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> type of the elements of the array\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt) {\n    if (elt == null) {\n      return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> the type of the elements\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   *    Identical to List.indexOf, but included for completeness.\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    return a.indexOf(elt);\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a.get(i))) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      /*@PolyNull*/ Object[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.size(); i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf, for finding subarrays\n  ///\n\n  // This is analogous to Common Lisp's \"search\" function.\n\n  // This implementation is very inefficient; I could use tricky Boyer-Moore\n  // search techniques if I liked, but it's not worth it to me yet.\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  // The signature on this method is unnecessarily strict because it\n  // requires that the component types be identical.  The signature should\n  // be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n  // @PolyAll qualifier does not yet take an argument.\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// mismatch\n  ///\n\n  // This is analogous to Common Lisp's \"mismatch\" function.\n\n  // Put it off until later; for now, use the simpler subarray function,\n  // which is a specialization of mismatch,\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray extraction\n  ///\n\n  // Note that the second argument is a length, not an end position.\n  // That's to avoid confusion over whether it would be the last included\n  // index or the first non-included index.\n\n  /**\n   * Return a subarray of the given array.\n   * @return a subarray of the given array\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ Object[] subarray(\n      /*@PolyAll*/ Object[] a, int startindex, int length) {\n    /*@PolyAll*/ Object[] result = new /*@PolyAll*/ Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a sublist of the given list.\n   * @param <T> type of the elements\n   * @param a the original list\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a sublist of the given list\n   */\n  /*@SideEffectFree*/\n  public static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ String[] subarray(\n      /*@PolyAll*/ String[] a, int startindex, int length) {\n    /*@PolyAll*/ String[] result = new /*@PolyAll*/ String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray testing\n  ///\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(\n      /*@PolyAll*/ Object[] a, /*@PolyNull*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(\n      /*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// concatenation\n  ///\n\n  // Concat used to return null if both arguments are null.  That is\n  // convenient for the implementer, but not so good for clients.\n\n  /**\n   * Call this method in order to suppress compiler warnings.\n   * @param <T> the base type of the result\n   * @param lst the list to convert to an array\n   * @return the result of lst.toArray, casted to a more precise type than Object[]\n   */\n  private static <T> T[] toTArray(List<T> lst) {\n    @SuppressWarnings(\"unchecked\")\n    T[] asArray = (T[]) lst.toArray();\n    return asArray;\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.size()];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        // System.arraycopy(b, 0, result, a.length, b.size());\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.length] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.length];\n\n        // System.arraycopy(a, 0, result, 0, a.size());\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        System.arraycopy(b, 0, result, a.size(), b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.size()];\n\n        // System.arraycopy(a, 0, result, 0, a.length);\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        // System.arraycopy(b, 0, result, a.length, b.length);\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.size()] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  // Note: PolyAll is not quite right.  Need to review.\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first array to concatenate\n   * @param b the second array to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static /*@PolyAll*/ String[] concat(\n      /*@PolyAll*/ String /*@Nullable*/ [] a, /*@PolyAll*/ String /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new String[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        /*@PolyAll*/ String[] result = new String[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static byte[] concat(byte /*@Nullable*/ [] a, byte /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new byte[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        byte[] result = new byte[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static boolean[] concat(boolean /*@Nullable*/ [] a, boolean /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new boolean[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        boolean[] result = new boolean[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static char[] concat(char /*@Nullable*/ [] a, char /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new char[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        char[] result = new char[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static double[] concat(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new double[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        double[] result = new double[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static float[] concat(float /*@Nullable*/ [] a, float /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new float[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        float[] result = new float[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static int[] concat(int /*@Nullable*/ [] a, int /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new int[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        int[] result = new int[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static long[] concat(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new long[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        long[] result = new long[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static short[] concat(short /*@Nullable*/ [] a, short /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new short[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        short[] result = new short[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Printing\n  ///\n\n  // This should be extended to all types, when I get around to it.  The\n  // methods are patterned after that of java.util.Vector (and use its\n  // output format).\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, each element is quoted like a Java String.\n   * @param a an array\n   * @return a string representation of the array, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, if quoted is true, then each element is quoted like a Java String.\n   * @param a an array\n   * @param quoted whether to quote the array elements\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        if (quoted && a[i] instanceof String) {\n          String elt = (String) a[i];\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava(elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(a[i]);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@Nullable*/ Collection<?> a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @param quoted whether to quote the collection elements that are Java strings\n   * @return a string representation of the list\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n      Iterator<?> itor = a.iterator();\n      sb.append(itor.next());\n      while (itor.hasNext()) {\n        sb.append(\", \");\n        Object elt = itor.next();\n        if (quoted && elt instanceof String) {\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava((String) elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(elt);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(int /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(long /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(double /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(float /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(boolean /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls the appropriate\n   * toString() method.  Only call this method if obj is a boolean, double,\n   * int, long, or Object array.\n   * @param obj an array\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@SideEffectFree*/\n  public static String toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n      return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n      return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n      return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n      return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n      return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n      return toString((List<?>) obj);\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls .length.\n   * Only call this method if obj is a boolean, double, int, long, or Object array.\n   * @param obj a list\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@Pure*/\n  public static int length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n      return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n      return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n      return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n      return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n      return ((List<?>) obj).size();\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Sortedness\n  ///\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Boolean n = Boolean.valueOf(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Byte n = new Byte(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Character n = new Character(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Float n = new Float(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Short n = new Short(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Integer n = new Integer(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space. Equality checking\n   * uses the .equals() method for java.lang.Double.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Double n = new Double(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Long n = new Long(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param <T> the type of the elements\n   * @param a a list\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static <T> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n      if (hs.contains(a.get(i))) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a.get(i));\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Arrays as partial functions of int->int\n  ///\n\n  /**\n   * Returns true if the array is a permutation of [0..a.length).\n   * @param a an array, representing a function\n   * @return true iff all elements of a are in [0..a.length) and a\n   * contains no duplicates.\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (array)\n  /*@Pure*/\n  public static boolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int n = a[i];\n      if (n < 0 || n >= a.length || see[n]) {\n        return false;\n      }\n      see[n] = true;\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff the array does not contain -1.\n   * @param a an array, representing a function\n   * @return true iff no element of a maps to -1\n   */\n  /*@Pure*/\n  public static boolean fn_is_total(int[] a) {\n    return indexOf(a, -1) == -1; // not found\n  }\n\n  /**\n   * Return an array [0..lenth).\n   * @param length the length of the result\n   * @return fresh array that is the identity function of the given length\n   */\n  public static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n      result[i] = i;\n    }\n    return result;\n  }\n\n  /**\n   * Requires that fn_is_permutation(a) holds.\n   * @param a the input permutation\n   * @return fresh array which is the inverse of the given permutation\n   * @see #fn_is_permutation(int[])\n   */\n  public static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n  }\n\n  /**\n   * Return the inverse of the given function, which is represented as an array.\n   * @param a an array representing a function from [0..a.length) to [0..arange);\n   *  each element of a is between 0 and arange inclusive\n   * @param arange length of the argument's range and the result's domain\n   * @return function from [0..arange) to [0..a.length) that is the inverse of a\n   * @throws IllegalArgumentException if a value of a is outside of arange\n   * @exception UnsupportedOperationException when the function is not invertible\n   */\n  public static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n      int ai = a[i];\n      if (ai < -1 || ai >= arange) {\n        throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n      }\n      // ai is either -1 or a valid index\n      if (ai >= 0) {\n        if (result[ai] != -1) {\n          throw new UnsupportedOperationException(\n              String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n        }\n        result[ai] = i;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the composition of the given two functions, all of which are\n   * represented as arrays.\n   * @param a function from [0..a.length) to [0..b.length)\n   * @param b function from [0..b.length) to range R\n   * @return function from [0..a.length) to range R that is the\n   * composition of a and b\n   */\n  public static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int inner = a[i];\n      if (inner == -1) {\n        result[i] = -1;\n      } else {\n        result[i] = b[inner];\n      }\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set operations, such as subset, unions, and intersections\n  ///\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Long(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Long elt = new Long(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Double(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Double elt = new Double(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(bigger[i]);\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      if (!setBigger.contains(smaller[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array comparators\n  ///\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLexical implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer,\n     * depending on whether the first argument is less than,\n     * equal to, or greater than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLexical implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class DoubleArrayComparatorLexical\n      implements Comparator<double[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(double[] a1, double[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int result = Double.compare(a1[i], a2[i]);\n        if (result != 0) {\n          return (result);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * Strings).\n   */\n  public static final class StringArrayComparatorLexical\n      implements Comparator<String[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) String[], @PolyAll(2) String[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ String[] a1, /*@PolyAll*/ String[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int tmp = 0;\n        if ((a1[i] == null) && (a2[i] == null)) {\n          tmp = 0;\n        } else if (a1[i] == null) {\n          tmp = -1;\n        } else if (a2[i] == null) {\n          tmp = 1;\n        } else {\n          tmp = a1[i].compareTo(a2[i]);\n        }\n        if (tmp != 0) {\n          return (tmp);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLexical<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLexical\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLengthFirst\n      implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLengthFirst\n      implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int lendiff = a1.length - a2.length;\n      if (lendiff != 0) {\n        return lendiff;\n      }\n      long tmp;\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLengthFirst<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLengthFirst\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// nullness\n  ///\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(/*@PolyAll*/ Object[] a) {\n    if (a.length == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(/*@PolyAll*/ Object[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (!(a[i] == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n      if (!(a.get(i) == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// javadoc hacks\n  ///\n\n  // Without this, the Javadoc mentions of \"java.util.Vector\", are not links\n  // in the generated HTML.\n  // \"private static Vector v;\" doesn't work, nor does\n  // \"static { new java.util.Vector(); }\", nor does \"private Vector v\".\n  // Yuck!\n  public Vector<?> javadocLossage;\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "a", "", "int[]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "", "int[]", "public boolean equals(Object);" ], [ "toString", "", "int[]", "public String toString()" ], [ "hashCode", "", "int[]", "public native int hashCode()" ], [ "getClass", "", "int[]", "public final native Class getClass();" ], [ "clone", "", "int[]", "public T[] clone();" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "length", "java.lang", "String", "public int length()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "javadocLossage", "plume", "ArraysMDE", "public Vector<?> javadocLossage;" ], [ "length", "", "int[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
} ]