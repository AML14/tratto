[{"id":53058661,"label":true,"oracleId":1400,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDoubleArray","javadocTag":"@return the previous value","methodJavadoc":"    /**\n   * Atomically sets the element at position {@code i} to the given value\n   * and returns the old value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndSet(int i, double newValue){\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(longs.getAndSet(i, next));\n}","classJavadoc":"/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea with assistance from members of JCP JSR-166\n * Expert Group and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDoubleArray.java?revision=1.5\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongArray instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongArray;\n\n/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDoubleArray implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  // Making this non-final is the lesser evil according to Effective\n  // Java 2nd Edition Item 76: Write readObject methods defensively.\n  private transient AtomicLongArray longs;\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} of the given length,\n   * with all elements initially zero.\n   *\n   * @param length the length of the array\n   */\n  public AtomicDoubleArray(int length) {\n    this.longs = new AtomicLongArray(length);\n  }\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} with the same length\n   * as, and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @throws NullPointerException if array is null\n   */\n  public AtomicDoubleArray(double[] array) {\n    final int len = array.length;\n    long[] longArray = new long[len];\n    for (int i = 0; i < len; i++) {\n      longArray[i] = doubleToRawLongBits(array[i]);\n    }\n    this.longs = new AtomicLongArray(longArray);\n  }\n\n  /**\n   * Returns the length of the array.\n   *\n   * @return the length of the array\n   */\n  public final int length() {\n    return longs.length();\n  }\n\n  /**\n   * Gets the current value at position {@code i}.\n   *\n   * @param i the index\n   * @return the current value\n   */\n  public final double get(int i) {\n    return longBitsToDouble(longs.get(i));\n  }\n\n  /**\n   * Sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void set(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    longs.set(i, next);\n  }\n\n  /**\n   * Eventually sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void lazySet(int i, double newValue) {\n    set(i, newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // longs.lazySet(i, next);\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given value\n   * and returns the old value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(longs.getAndSet(i, next));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful. False return indicates that\n   * the actual value was not equal to the expected value.\n   */\n  public final boolean compareAndSet(int i, double expect, double update) {\n    return longs.compareAndSet(i,\n                               doubleToRawLongBits(expect),\n                               doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful\n   */\n  public final boolean weakCompareAndSet(int i, double expect, double update) {\n    return longs.weakCompareAndSet(i,\n                                   doubleToRawLongBits(expect),\n                                   doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public double addAndGet(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current values of array.\n   * @return the String representation of the current values of array\n   */\n  public String toString() {\n    int iMax = length() - 1;\n    if (iMax == -1) {\n      return \"[]\";\n    }\n\n    // Double.toString(Math.PI).length() == 17\n    StringBuilder b = new StringBuilder((17 + 2) * (iMax + 1));\n    b.append('[');\n    for (int i = 0;; i++) {\n      b.append(longBitsToDouble(longs.get(i)));\n      if (i == iMax) {\n        return b.append(']').toString();\n      }\n      b.append(',').append(' ');\n    }\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The length of the array is emitted (int), followed by all\n   *             of its elements (each a {@code double}) in the proper order.\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    // Write out array length\n    int length = length();\n    s.writeInt(length);\n\n    // Write out all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      s.writeDouble(get(i));\n    }\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    // Read in array length and allocate array\n    int length = s.readInt();\n    this.longs = new AtomicLongArray(length);\n\n    // Read in all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      set(i, s.readDouble());\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53059121,"label":true,"oracleId":1401,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDoubleArray","javadocTag":"@param i the index","methodJavadoc":"    /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful. False return indicates that\n   * the actual value was not equal to the expected value.\n   */","methodSourceCode":"public final boolean compareAndSet(int i, double expect, double update){\n    return longs.compareAndSet(i, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea with assistance from members of JCP JSR-166\n * Expert Group and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDoubleArray.java?revision=1.5\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongArray instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongArray;\n\n/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDoubleArray implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  // Making this non-final is the lesser evil according to Effective\n  // Java 2nd Edition Item 76: Write readObject methods defensively.\n  private transient AtomicLongArray longs;\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} of the given length,\n   * with all elements initially zero.\n   *\n   * @param length the length of the array\n   */\n  public AtomicDoubleArray(int length) {\n    this.longs = new AtomicLongArray(length);\n  }\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} with the same length\n   * as, and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @throws NullPointerException if array is null\n   */\n  public AtomicDoubleArray(double[] array) {\n    final int len = array.length;\n    long[] longArray = new long[len];\n    for (int i = 0; i < len; i++) {\n      longArray[i] = doubleToRawLongBits(array[i]);\n    }\n    this.longs = new AtomicLongArray(longArray);\n  }\n\n  /**\n   * Returns the length of the array.\n   *\n   * @return the length of the array\n   */\n  public final int length() {\n    return longs.length();\n  }\n\n  /**\n   * Gets the current value at position {@code i}.\n   *\n   * @param i the index\n   * @return the current value\n   */\n  public final double get(int i) {\n    return longBitsToDouble(longs.get(i));\n  }\n\n  /**\n   * Sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void set(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    longs.set(i, next);\n  }\n\n  /**\n   * Eventually sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void lazySet(int i, double newValue) {\n    set(i, newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // longs.lazySet(i, next);\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given value\n   * and returns the old value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(longs.getAndSet(i, next));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful. False return indicates that\n   * the actual value was not equal to the expected value.\n   */\n  public final boolean compareAndSet(int i, double expect, double update) {\n    return longs.compareAndSet(i,\n                               doubleToRawLongBits(expect),\n                               doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful\n   */\n  public final boolean weakCompareAndSet(int i, double expect, double update) {\n    return longs.weakCompareAndSet(i,\n                                   doubleToRawLongBits(expect),\n                                   doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public double addAndGet(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current values of array.\n   * @return the String representation of the current values of array\n   */\n  public String toString() {\n    int iMax = length() - 1;\n    if (iMax == -1) {\n      return \"[]\";\n    }\n\n    // Double.toString(Math.PI).length() == 17\n    StringBuilder b = new StringBuilder((17 + 2) * (iMax + 1));\n    b.append('[');\n    for (int i = 0;; i++) {\n      b.append(longBitsToDouble(longs.get(i)));\n      if (i == iMax) {\n        return b.append(']').toString();\n      }\n      b.append(',').append(' ');\n    }\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The length of the array is emitted (int), followed by all\n   *             of its elements (each a {@code double}) in the proper order.\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    // Write out array length\n    int length = length();\n    s.writeInt(length);\n\n    // Write out all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      s.writeDouble(get(i));\n    }\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    // Read in array length and allocate array\n    int length = s.readInt();\n    this.longs = new AtomicLongArray(length);\n\n    // Read in all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      set(i, s.readDouble());\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53059581,"label":true,"oracleId":1402,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDoubleArray","javadocTag":"@param expect the expected value","methodJavadoc":"    /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful. False return indicates that\n   * the actual value was not equal to the expected value.\n   */","methodSourceCode":"public final boolean compareAndSet(int i, double expect, double update){\n    return longs.compareAndSet(i, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea with assistance from members of JCP JSR-166\n * Expert Group and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDoubleArray.java?revision=1.5\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongArray instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongArray;\n\n/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDoubleArray implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  // Making this non-final is the lesser evil according to Effective\n  // Java 2nd Edition Item 76: Write readObject methods defensively.\n  private transient AtomicLongArray longs;\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} of the given length,\n   * with all elements initially zero.\n   *\n   * @param length the length of the array\n   */\n  public AtomicDoubleArray(int length) {\n    this.longs = new AtomicLongArray(length);\n  }\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} with the same length\n   * as, and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @throws NullPointerException if array is null\n   */\n  public AtomicDoubleArray(double[] array) {\n    final int len = array.length;\n    long[] longArray = new long[len];\n    for (int i = 0; i < len; i++) {\n      longArray[i] = doubleToRawLongBits(array[i]);\n    }\n    this.longs = new AtomicLongArray(longArray);\n  }\n\n  /**\n   * Returns the length of the array.\n   *\n   * @return the length of the array\n   */\n  public final int length() {\n    return longs.length();\n  }\n\n  /**\n   * Gets the current value at position {@code i}.\n   *\n   * @param i the index\n   * @return the current value\n   */\n  public final double get(int i) {\n    return longBitsToDouble(longs.get(i));\n  }\n\n  /**\n   * Sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void set(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    longs.set(i, next);\n  }\n\n  /**\n   * Eventually sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void lazySet(int i, double newValue) {\n    set(i, newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // longs.lazySet(i, next);\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given value\n   * and returns the old value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(longs.getAndSet(i, next));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful. False return indicates that\n   * the actual value was not equal to the expected value.\n   */\n  public final boolean compareAndSet(int i, double expect, double update) {\n    return longs.compareAndSet(i,\n                               doubleToRawLongBits(expect),\n                               doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful\n   */\n  public final boolean weakCompareAndSet(int i, double expect, double update) {\n    return longs.weakCompareAndSet(i,\n                                   doubleToRawLongBits(expect),\n                                   doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public double addAndGet(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current values of array.\n   * @return the String representation of the current values of array\n   */\n  public String toString() {\n    int iMax = length() - 1;\n    if (iMax == -1) {\n      return \"[]\";\n    }\n\n    // Double.toString(Math.PI).length() == 17\n    StringBuilder b = new StringBuilder((17 + 2) * (iMax + 1));\n    b.append('[');\n    for (int i = 0;; i++) {\n      b.append(longBitsToDouble(longs.get(i)));\n      if (i == iMax) {\n        return b.append(']').toString();\n      }\n      b.append(',').append(' ');\n    }\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The length of the array is emitted (int), followed by all\n   *             of its elements (each a {@code double}) in the proper order.\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    // Write out array length\n    int length = length();\n    s.writeInt(length);\n\n    // Write out all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      s.writeDouble(get(i));\n    }\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    // Read in array length and allocate array\n    int length = s.readInt();\n    this.longs = new AtomicLongArray(length);\n\n    // Read in all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      set(i, s.readDouble());\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53060041,"label":true,"oracleId":1403,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDoubleArray","javadocTag":"@param update the new value","methodJavadoc":"    /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful. False return indicates that\n   * the actual value was not equal to the expected value.\n   */","methodSourceCode":"public final boolean compareAndSet(int i, double expect, double update){\n    return longs.compareAndSet(i, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea with assistance from members of JCP JSR-166\n * Expert Group and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDoubleArray.java?revision=1.5\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongArray instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongArray;\n\n/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDoubleArray implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  // Making this non-final is the lesser evil according to Effective\n  // Java 2nd Edition Item 76: Write readObject methods defensively.\n  private transient AtomicLongArray longs;\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} of the given length,\n   * with all elements initially zero.\n   *\n   * @param length the length of the array\n   */\n  public AtomicDoubleArray(int length) {\n    this.longs = new AtomicLongArray(length);\n  }\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} with the same length\n   * as, and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @throws NullPointerException if array is null\n   */\n  public AtomicDoubleArray(double[] array) {\n    final int len = array.length;\n    long[] longArray = new long[len];\n    for (int i = 0; i < len; i++) {\n      longArray[i] = doubleToRawLongBits(array[i]);\n    }\n    this.longs = new AtomicLongArray(longArray);\n  }\n\n  /**\n   * Returns the length of the array.\n   *\n   * @return the length of the array\n   */\n  public final int length() {\n    return longs.length();\n  }\n\n  /**\n   * Gets the current value at position {@code i}.\n   *\n   * @param i the index\n   * @return the current value\n   */\n  public final double get(int i) {\n    return longBitsToDouble(longs.get(i));\n  }\n\n  /**\n   * Sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void set(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    longs.set(i, next);\n  }\n\n  /**\n   * Eventually sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void lazySet(int i, double newValue) {\n    set(i, newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // longs.lazySet(i, next);\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given value\n   * and returns the old value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(longs.getAndSet(i, next));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful. False return indicates that\n   * the actual value was not equal to the expected value.\n   */\n  public final boolean compareAndSet(int i, double expect, double update) {\n    return longs.compareAndSet(i,\n                               doubleToRawLongBits(expect),\n                               doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful\n   */\n  public final boolean weakCompareAndSet(int i, double expect, double update) {\n    return longs.weakCompareAndSet(i,\n                                   doubleToRawLongBits(expect),\n                                   doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public double addAndGet(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current values of array.\n   * @return the String representation of the current values of array\n   */\n  public String toString() {\n    int iMax = length() - 1;\n    if (iMax == -1) {\n      return \"[]\";\n    }\n\n    // Double.toString(Math.PI).length() == 17\n    StringBuilder b = new StringBuilder((17 + 2) * (iMax + 1));\n    b.append('[');\n    for (int i = 0;; i++) {\n      b.append(longBitsToDouble(longs.get(i)));\n      if (i == iMax) {\n        return b.append(']').toString();\n      }\n      b.append(',').append(' ');\n    }\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The length of the array is emitted (int), followed by all\n   *             of its elements (each a {@code double}) in the proper order.\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    // Write out array length\n    int length = length();\n    s.writeInt(length);\n\n    // Write out all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      s.writeDouble(get(i));\n    }\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    // Read in array length and allocate array\n    int length = s.readInt();\n    this.longs = new AtomicLongArray(length);\n\n    // Read in all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      set(i, s.readDouble());\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53060502,"label":true,"oracleId":1404,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDoubleArray","javadocTag":"@return true if successful. False return indicates that\nthe actual value was not equal to the expected value.","methodJavadoc":"    /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful. False return indicates that\n   * the actual value was not equal to the expected value.\n   */","methodSourceCode":"public final boolean compareAndSet(int i, double expect, double update){\n    return longs.compareAndSet(i, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea with assistance from members of JCP JSR-166\n * Expert Group and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDoubleArray.java?revision=1.5\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongArray instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongArray;\n\n/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDoubleArray implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  // Making this non-final is the lesser evil according to Effective\n  // Java 2nd Edition Item 76: Write readObject methods defensively.\n  private transient AtomicLongArray longs;\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} of the given length,\n   * with all elements initially zero.\n   *\n   * @param length the length of the array\n   */\n  public AtomicDoubleArray(int length) {\n    this.longs = new AtomicLongArray(length);\n  }\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} with the same length\n   * as, and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @throws NullPointerException if array is null\n   */\n  public AtomicDoubleArray(double[] array) {\n    final int len = array.length;\n    long[] longArray = new long[len];\n    for (int i = 0; i < len; i++) {\n      longArray[i] = doubleToRawLongBits(array[i]);\n    }\n    this.longs = new AtomicLongArray(longArray);\n  }\n\n  /**\n   * Returns the length of the array.\n   *\n   * @return the length of the array\n   */\n  public final int length() {\n    return longs.length();\n  }\n\n  /**\n   * Gets the current value at position {@code i}.\n   *\n   * @param i the index\n   * @return the current value\n   */\n  public final double get(int i) {\n    return longBitsToDouble(longs.get(i));\n  }\n\n  /**\n   * Sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void set(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    longs.set(i, next);\n  }\n\n  /**\n   * Eventually sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void lazySet(int i, double newValue) {\n    set(i, newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // longs.lazySet(i, next);\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given value\n   * and returns the old value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(longs.getAndSet(i, next));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful. False return indicates that\n   * the actual value was not equal to the expected value.\n   */\n  public final boolean compareAndSet(int i, double expect, double update) {\n    return longs.compareAndSet(i,\n                               doubleToRawLongBits(expect),\n                               doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful\n   */\n  public final boolean weakCompareAndSet(int i, double expect, double update) {\n    return longs.weakCompareAndSet(i,\n                                   doubleToRawLongBits(expect),\n                                   doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public double addAndGet(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current values of array.\n   * @return the String representation of the current values of array\n   */\n  public String toString() {\n    int iMax = length() - 1;\n    if (iMax == -1) {\n      return \"[]\";\n    }\n\n    // Double.toString(Math.PI).length() == 17\n    StringBuilder b = new StringBuilder((17 + 2) * (iMax + 1));\n    b.append('[');\n    for (int i = 0;; i++) {\n      b.append(longBitsToDouble(longs.get(i)));\n      if (i == iMax) {\n        return b.append(']').toString();\n      }\n      b.append(',').append(' ');\n    }\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The length of the array is emitted (int), followed by all\n   *             of its elements (each a {@code double}) in the proper order.\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    // Write out array length\n    int length = length();\n    s.writeInt(length);\n\n    // Write out all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      s.writeDouble(get(i));\n    }\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    // Read in array length and allocate array\n    int length = s.readInt();\n    this.longs = new AtomicLongArray(length);\n\n    // Read in all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      set(i, s.readDouble());\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53060962,"label":true,"oracleId":1405,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDoubleArray","javadocTag":"@param i the index","methodJavadoc":"    /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(int i, double expect, double update){\n    return longs.weakCompareAndSet(i, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea with assistance from members of JCP JSR-166\n * Expert Group and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDoubleArray.java?revision=1.5\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongArray instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongArray;\n\n/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDoubleArray implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  // Making this non-final is the lesser evil according to Effective\n  // Java 2nd Edition Item 76: Write readObject methods defensively.\n  private transient AtomicLongArray longs;\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} of the given length,\n   * with all elements initially zero.\n   *\n   * @param length the length of the array\n   */\n  public AtomicDoubleArray(int length) {\n    this.longs = new AtomicLongArray(length);\n  }\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} with the same length\n   * as, and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @throws NullPointerException if array is null\n   */\n  public AtomicDoubleArray(double[] array) {\n    final int len = array.length;\n    long[] longArray = new long[len];\n    for (int i = 0; i < len; i++) {\n      longArray[i] = doubleToRawLongBits(array[i]);\n    }\n    this.longs = new AtomicLongArray(longArray);\n  }\n\n  /**\n   * Returns the length of the array.\n   *\n   * @return the length of the array\n   */\n  public final int length() {\n    return longs.length();\n  }\n\n  /**\n   * Gets the current value at position {@code i}.\n   *\n   * @param i the index\n   * @return the current value\n   */\n  public final double get(int i) {\n    return longBitsToDouble(longs.get(i));\n  }\n\n  /**\n   * Sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void set(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    longs.set(i, next);\n  }\n\n  /**\n   * Eventually sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void lazySet(int i, double newValue) {\n    set(i, newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // longs.lazySet(i, next);\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given value\n   * and returns the old value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(longs.getAndSet(i, next));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful. False return indicates that\n   * the actual value was not equal to the expected value.\n   */\n  public final boolean compareAndSet(int i, double expect, double update) {\n    return longs.compareAndSet(i,\n                               doubleToRawLongBits(expect),\n                               doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful\n   */\n  public final boolean weakCompareAndSet(int i, double expect, double update) {\n    return longs.weakCompareAndSet(i,\n                                   doubleToRawLongBits(expect),\n                                   doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public double addAndGet(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current values of array.\n   * @return the String representation of the current values of array\n   */\n  public String toString() {\n    int iMax = length() - 1;\n    if (iMax == -1) {\n      return \"[]\";\n    }\n\n    // Double.toString(Math.PI).length() == 17\n    StringBuilder b = new StringBuilder((17 + 2) * (iMax + 1));\n    b.append('[');\n    for (int i = 0;; i++) {\n      b.append(longBitsToDouble(longs.get(i)));\n      if (i == iMax) {\n        return b.append(']').toString();\n      }\n      b.append(',').append(' ');\n    }\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The length of the array is emitted (int), followed by all\n   *             of its elements (each a {@code double}) in the proper order.\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    // Write out array length\n    int length = length();\n    s.writeInt(length);\n\n    // Write out all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      s.writeDouble(get(i));\n    }\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    // Read in array length and allocate array\n    int length = s.readInt();\n    this.longs = new AtomicLongArray(length);\n\n    // Read in all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      set(i, s.readDouble());\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53061422,"label":true,"oracleId":1406,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDoubleArray","javadocTag":"@param expect the expected value","methodJavadoc":"    /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(int i, double expect, double update){\n    return longs.weakCompareAndSet(i, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea with assistance from members of JCP JSR-166\n * Expert Group and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDoubleArray.java?revision=1.5\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongArray instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongArray;\n\n/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDoubleArray implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  // Making this non-final is the lesser evil according to Effective\n  // Java 2nd Edition Item 76: Write readObject methods defensively.\n  private transient AtomicLongArray longs;\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} of the given length,\n   * with all elements initially zero.\n   *\n   * @param length the length of the array\n   */\n  public AtomicDoubleArray(int length) {\n    this.longs = new AtomicLongArray(length);\n  }\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} with the same length\n   * as, and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @throws NullPointerException if array is null\n   */\n  public AtomicDoubleArray(double[] array) {\n    final int len = array.length;\n    long[] longArray = new long[len];\n    for (int i = 0; i < len; i++) {\n      longArray[i] = doubleToRawLongBits(array[i]);\n    }\n    this.longs = new AtomicLongArray(longArray);\n  }\n\n  /**\n   * Returns the length of the array.\n   *\n   * @return the length of the array\n   */\n  public final int length() {\n    return longs.length();\n  }\n\n  /**\n   * Gets the current value at position {@code i}.\n   *\n   * @param i the index\n   * @return the current value\n   */\n  public final double get(int i) {\n    return longBitsToDouble(longs.get(i));\n  }\n\n  /**\n   * Sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void set(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    longs.set(i, next);\n  }\n\n  /**\n   * Eventually sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void lazySet(int i, double newValue) {\n    set(i, newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // longs.lazySet(i, next);\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given value\n   * and returns the old value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(longs.getAndSet(i, next));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful. False return indicates that\n   * the actual value was not equal to the expected value.\n   */\n  public final boolean compareAndSet(int i, double expect, double update) {\n    return longs.compareAndSet(i,\n                               doubleToRawLongBits(expect),\n                               doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful\n   */\n  public final boolean weakCompareAndSet(int i, double expect, double update) {\n    return longs.weakCompareAndSet(i,\n                                   doubleToRawLongBits(expect),\n                                   doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public double addAndGet(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current values of array.\n   * @return the String representation of the current values of array\n   */\n  public String toString() {\n    int iMax = length() - 1;\n    if (iMax == -1) {\n      return \"[]\";\n    }\n\n    // Double.toString(Math.PI).length() == 17\n    StringBuilder b = new StringBuilder((17 + 2) * (iMax + 1));\n    b.append('[');\n    for (int i = 0;; i++) {\n      b.append(longBitsToDouble(longs.get(i)));\n      if (i == iMax) {\n        return b.append(']').toString();\n      }\n      b.append(',').append(' ');\n    }\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The length of the array is emitted (int), followed by all\n   *             of its elements (each a {@code double}) in the proper order.\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    // Write out array length\n    int length = length();\n    s.writeInt(length);\n\n    // Write out all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      s.writeDouble(get(i));\n    }\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    // Read in array length and allocate array\n    int length = s.readInt();\n    this.longs = new AtomicLongArray(length);\n\n    // Read in all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      set(i, s.readDouble());\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53061882,"label":true,"oracleId":1407,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDoubleArray","javadocTag":"@param update the new value","methodJavadoc":"    /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(int i, double expect, double update){\n    return longs.weakCompareAndSet(i, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea with assistance from members of JCP JSR-166\n * Expert Group and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDoubleArray.java?revision=1.5\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongArray instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongArray;\n\n/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDoubleArray implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  // Making this non-final is the lesser evil according to Effective\n  // Java 2nd Edition Item 76: Write readObject methods defensively.\n  private transient AtomicLongArray longs;\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} of the given length,\n   * with all elements initially zero.\n   *\n   * @param length the length of the array\n   */\n  public AtomicDoubleArray(int length) {\n    this.longs = new AtomicLongArray(length);\n  }\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} with the same length\n   * as, and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @throws NullPointerException if array is null\n   */\n  public AtomicDoubleArray(double[] array) {\n    final int len = array.length;\n    long[] longArray = new long[len];\n    for (int i = 0; i < len; i++) {\n      longArray[i] = doubleToRawLongBits(array[i]);\n    }\n    this.longs = new AtomicLongArray(longArray);\n  }\n\n  /**\n   * Returns the length of the array.\n   *\n   * @return the length of the array\n   */\n  public final int length() {\n    return longs.length();\n  }\n\n  /**\n   * Gets the current value at position {@code i}.\n   *\n   * @param i the index\n   * @return the current value\n   */\n  public final double get(int i) {\n    return longBitsToDouble(longs.get(i));\n  }\n\n  /**\n   * Sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void set(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    longs.set(i, next);\n  }\n\n  /**\n   * Eventually sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void lazySet(int i, double newValue) {\n    set(i, newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // longs.lazySet(i, next);\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given value\n   * and returns the old value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(longs.getAndSet(i, next));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful. False return indicates that\n   * the actual value was not equal to the expected value.\n   */\n  public final boolean compareAndSet(int i, double expect, double update) {\n    return longs.compareAndSet(i,\n                               doubleToRawLongBits(expect),\n                               doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful\n   */\n  public final boolean weakCompareAndSet(int i, double expect, double update) {\n    return longs.weakCompareAndSet(i,\n                                   doubleToRawLongBits(expect),\n                                   doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public double addAndGet(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current values of array.\n   * @return the String representation of the current values of array\n   */\n  public String toString() {\n    int iMax = length() - 1;\n    if (iMax == -1) {\n      return \"[]\";\n    }\n\n    // Double.toString(Math.PI).length() == 17\n    StringBuilder b = new StringBuilder((17 + 2) * (iMax + 1));\n    b.append('[');\n    for (int i = 0;; i++) {\n      b.append(longBitsToDouble(longs.get(i)));\n      if (i == iMax) {\n        return b.append(']').toString();\n      }\n      b.append(',').append(' ');\n    }\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The length of the array is emitted (int), followed by all\n   *             of its elements (each a {@code double}) in the proper order.\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    // Write out array length\n    int length = length();\n    s.writeInt(length);\n\n    // Write out all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      s.writeDouble(get(i));\n    }\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    // Read in array length and allocate array\n    int length = s.readInt();\n    this.longs = new AtomicLongArray(length);\n\n    // Read in all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      set(i, s.readDouble());\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53062343,"label":true,"oracleId":1408,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDoubleArray","javadocTag":"@return true if successful","methodJavadoc":"    /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(int i, double expect, double update){\n    return longs.weakCompareAndSet(i, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea with assistance from members of JCP JSR-166\n * Expert Group and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDoubleArray.java?revision=1.5\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongArray instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongArray;\n\n/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDoubleArray implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  // Making this non-final is the lesser evil according to Effective\n  // Java 2nd Edition Item 76: Write readObject methods defensively.\n  private transient AtomicLongArray longs;\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} of the given length,\n   * with all elements initially zero.\n   *\n   * @param length the length of the array\n   */\n  public AtomicDoubleArray(int length) {\n    this.longs = new AtomicLongArray(length);\n  }\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} with the same length\n   * as, and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @throws NullPointerException if array is null\n   */\n  public AtomicDoubleArray(double[] array) {\n    final int len = array.length;\n    long[] longArray = new long[len];\n    for (int i = 0; i < len; i++) {\n      longArray[i] = doubleToRawLongBits(array[i]);\n    }\n    this.longs = new AtomicLongArray(longArray);\n  }\n\n  /**\n   * Returns the length of the array.\n   *\n   * @return the length of the array\n   */\n  public final int length() {\n    return longs.length();\n  }\n\n  /**\n   * Gets the current value at position {@code i}.\n   *\n   * @param i the index\n   * @return the current value\n   */\n  public final double get(int i) {\n    return longBitsToDouble(longs.get(i));\n  }\n\n  /**\n   * Sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void set(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    longs.set(i, next);\n  }\n\n  /**\n   * Eventually sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void lazySet(int i, double newValue) {\n    set(i, newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // longs.lazySet(i, next);\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given value\n   * and returns the old value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(longs.getAndSet(i, next));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful. False return indicates that\n   * the actual value was not equal to the expected value.\n   */\n  public final boolean compareAndSet(int i, double expect, double update) {\n    return longs.compareAndSet(i,\n                               doubleToRawLongBits(expect),\n                               doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful\n   */\n  public final boolean weakCompareAndSet(int i, double expect, double update) {\n    return longs.weakCompareAndSet(i,\n                                   doubleToRawLongBits(expect),\n                                   doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public double addAndGet(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current values of array.\n   * @return the String representation of the current values of array\n   */\n  public String toString() {\n    int iMax = length() - 1;\n    if (iMax == -1) {\n      return \"[]\";\n    }\n\n    // Double.toString(Math.PI).length() == 17\n    StringBuilder b = new StringBuilder((17 + 2) * (iMax + 1));\n    b.append('[');\n    for (int i = 0;; i++) {\n      b.append(longBitsToDouble(longs.get(i)));\n      if (i == iMax) {\n        return b.append(']').toString();\n      }\n      b.append(',').append(' ');\n    }\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The length of the array is emitted (int), followed by all\n   *             of its elements (each a {@code double}) in the proper order.\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    // Write out array length\n    int length = length();\n    s.writeInt(length);\n\n    // Write out all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      s.writeDouble(get(i));\n    }\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    // Read in array length and allocate array\n    int length = s.readInt();\n    this.longs = new AtomicLongArray(length);\n\n    // Read in all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      set(i, s.readDouble());\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53062802,"label":true,"oracleId":1409,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDoubleArray","javadocTag":"@param i the index","methodJavadoc":"    /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(int i, double delta){\n    while (true) {\n        long current = longs.get(i);\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (longs.compareAndSet(i, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea with assistance from members of JCP JSR-166\n * Expert Group and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDoubleArray.java?revision=1.5\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongArray instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongArray;\n\n/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDoubleArray implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  // Making this non-final is the lesser evil according to Effective\n  // Java 2nd Edition Item 76: Write readObject methods defensively.\n  private transient AtomicLongArray longs;\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} of the given length,\n   * with all elements initially zero.\n   *\n   * @param length the length of the array\n   */\n  public AtomicDoubleArray(int length) {\n    this.longs = new AtomicLongArray(length);\n  }\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} with the same length\n   * as, and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @throws NullPointerException if array is null\n   */\n  public AtomicDoubleArray(double[] array) {\n    final int len = array.length;\n    long[] longArray = new long[len];\n    for (int i = 0; i < len; i++) {\n      longArray[i] = doubleToRawLongBits(array[i]);\n    }\n    this.longs = new AtomicLongArray(longArray);\n  }\n\n  /**\n   * Returns the length of the array.\n   *\n   * @return the length of the array\n   */\n  public final int length() {\n    return longs.length();\n  }\n\n  /**\n   * Gets the current value at position {@code i}.\n   *\n   * @param i the index\n   * @return the current value\n   */\n  public final double get(int i) {\n    return longBitsToDouble(longs.get(i));\n  }\n\n  /**\n   * Sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void set(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    longs.set(i, next);\n  }\n\n  /**\n   * Eventually sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void lazySet(int i, double newValue) {\n    set(i, newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // longs.lazySet(i, next);\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given value\n   * and returns the old value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(longs.getAndSet(i, next));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful. False return indicates that\n   * the actual value was not equal to the expected value.\n   */\n  public final boolean compareAndSet(int i, double expect, double update) {\n    return longs.compareAndSet(i,\n                               doubleToRawLongBits(expect),\n                               doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful\n   */\n  public final boolean weakCompareAndSet(int i, double expect, double update) {\n    return longs.weakCompareAndSet(i,\n                                   doubleToRawLongBits(expect),\n                                   doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public double addAndGet(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current values of array.\n   * @return the String representation of the current values of array\n   */\n  public String toString() {\n    int iMax = length() - 1;\n    if (iMax == -1) {\n      return \"[]\";\n    }\n\n    // Double.toString(Math.PI).length() == 17\n    StringBuilder b = new StringBuilder((17 + 2) * (iMax + 1));\n    b.append('[');\n    for (int i = 0;; i++) {\n      b.append(longBitsToDouble(longs.get(i)));\n      if (i == iMax) {\n        return b.append(']').toString();\n      }\n      b.append(',').append(' ');\n    }\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The length of the array is emitted (int), followed by all\n   *             of its elements (each a {@code double}) in the proper order.\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    // Write out array length\n    int length = length();\n    s.writeInt(length);\n\n    // Write out all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      s.writeDouble(get(i));\n    }\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    // Read in array length and allocate array\n    int length = s.readInt();\n    this.longs = new AtomicLongArray(length);\n\n    // Read in all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      set(i, s.readDouble());\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53063261,"label":true,"oracleId":1410,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDoubleArray","javadocTag":"@param delta the value to add","methodJavadoc":"    /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(int i, double delta){\n    while (true) {\n        long current = longs.get(i);\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (longs.compareAndSet(i, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea with assistance from members of JCP JSR-166\n * Expert Group and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDoubleArray.java?revision=1.5\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongArray instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongArray;\n\n/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDoubleArray implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  // Making this non-final is the lesser evil according to Effective\n  // Java 2nd Edition Item 76: Write readObject methods defensively.\n  private transient AtomicLongArray longs;\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} of the given length,\n   * with all elements initially zero.\n   *\n   * @param length the length of the array\n   */\n  public AtomicDoubleArray(int length) {\n    this.longs = new AtomicLongArray(length);\n  }\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} with the same length\n   * as, and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @throws NullPointerException if array is null\n   */\n  public AtomicDoubleArray(double[] array) {\n    final int len = array.length;\n    long[] longArray = new long[len];\n    for (int i = 0; i < len; i++) {\n      longArray[i] = doubleToRawLongBits(array[i]);\n    }\n    this.longs = new AtomicLongArray(longArray);\n  }\n\n  /**\n   * Returns the length of the array.\n   *\n   * @return the length of the array\n   */\n  public final int length() {\n    return longs.length();\n  }\n\n  /**\n   * Gets the current value at position {@code i}.\n   *\n   * @param i the index\n   * @return the current value\n   */\n  public final double get(int i) {\n    return longBitsToDouble(longs.get(i));\n  }\n\n  /**\n   * Sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void set(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    longs.set(i, next);\n  }\n\n  /**\n   * Eventually sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void lazySet(int i, double newValue) {\n    set(i, newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // longs.lazySet(i, next);\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given value\n   * and returns the old value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(longs.getAndSet(i, next));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful. False return indicates that\n   * the actual value was not equal to the expected value.\n   */\n  public final boolean compareAndSet(int i, double expect, double update) {\n    return longs.compareAndSet(i,\n                               doubleToRawLongBits(expect),\n                               doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful\n   */\n  public final boolean weakCompareAndSet(int i, double expect, double update) {\n    return longs.weakCompareAndSet(i,\n                                   doubleToRawLongBits(expect),\n                                   doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public double addAndGet(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current values of array.\n   * @return the String representation of the current values of array\n   */\n  public String toString() {\n    int iMax = length() - 1;\n    if (iMax == -1) {\n      return \"[]\";\n    }\n\n    // Double.toString(Math.PI).length() == 17\n    StringBuilder b = new StringBuilder((17 + 2) * (iMax + 1));\n    b.append('[');\n    for (int i = 0;; i++) {\n      b.append(longBitsToDouble(longs.get(i)));\n      if (i == iMax) {\n        return b.append(']').toString();\n      }\n      b.append(',').append(' ');\n    }\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The length of the array is emitted (int), followed by all\n   *             of its elements (each a {@code double}) in the proper order.\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    // Write out array length\n    int length = length();\n    s.writeInt(length);\n\n    // Write out all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      s.writeDouble(get(i));\n    }\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    // Read in array length and allocate array\n    int length = s.readInt();\n    this.longs = new AtomicLongArray(length);\n\n    // Read in all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      set(i, s.readDouble());\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53063721,"label":true,"oracleId":1411,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDoubleArray","javadocTag":"@return the previous value","methodJavadoc":"    /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(int i, double delta){\n    while (true) {\n        long current = longs.get(i);\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (longs.compareAndSet(i, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea with assistance from members of JCP JSR-166\n * Expert Group and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDoubleArray.java?revision=1.5\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongArray instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongArray;\n\n/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDoubleArray implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  // Making this non-final is the lesser evil according to Effective\n  // Java 2nd Edition Item 76: Write readObject methods defensively.\n  private transient AtomicLongArray longs;\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} of the given length,\n   * with all elements initially zero.\n   *\n   * @param length the length of the array\n   */\n  public AtomicDoubleArray(int length) {\n    this.longs = new AtomicLongArray(length);\n  }\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} with the same length\n   * as, and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @throws NullPointerException if array is null\n   */\n  public AtomicDoubleArray(double[] array) {\n    final int len = array.length;\n    long[] longArray = new long[len];\n    for (int i = 0; i < len; i++) {\n      longArray[i] = doubleToRawLongBits(array[i]);\n    }\n    this.longs = new AtomicLongArray(longArray);\n  }\n\n  /**\n   * Returns the length of the array.\n   *\n   * @return the length of the array\n   */\n  public final int length() {\n    return longs.length();\n  }\n\n  /**\n   * Gets the current value at position {@code i}.\n   *\n   * @param i the index\n   * @return the current value\n   */\n  public final double get(int i) {\n    return longBitsToDouble(longs.get(i));\n  }\n\n  /**\n   * Sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void set(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    longs.set(i, next);\n  }\n\n  /**\n   * Eventually sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void lazySet(int i, double newValue) {\n    set(i, newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // longs.lazySet(i, next);\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given value\n   * and returns the old value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(longs.getAndSet(i, next));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful. False return indicates that\n   * the actual value was not equal to the expected value.\n   */\n  public final boolean compareAndSet(int i, double expect, double update) {\n    return longs.compareAndSet(i,\n                               doubleToRawLongBits(expect),\n                               doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful\n   */\n  public final boolean weakCompareAndSet(int i, double expect, double update) {\n    return longs.weakCompareAndSet(i,\n                                   doubleToRawLongBits(expect),\n                                   doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public double addAndGet(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current values of array.\n   * @return the String representation of the current values of array\n   */\n  public String toString() {\n    int iMax = length() - 1;\n    if (iMax == -1) {\n      return \"[]\";\n    }\n\n    // Double.toString(Math.PI).length() == 17\n    StringBuilder b = new StringBuilder((17 + 2) * (iMax + 1));\n    b.append('[');\n    for (int i = 0;; i++) {\n      b.append(longBitsToDouble(longs.get(i)));\n      if (i == iMax) {\n        return b.append(']').toString();\n      }\n      b.append(',').append(' ');\n    }\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The length of the array is emitted (int), followed by all\n   *             of its elements (each a {@code double}) in the proper order.\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    // Write out array length\n    int length = length();\n    s.writeInt(length);\n\n    // Write out all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      s.writeDouble(get(i));\n    }\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    // Read in array length and allocate array\n    int length = s.readInt();\n    this.longs = new AtomicLongArray(length);\n\n    // Read in all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      set(i, s.readDouble());\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53064180,"label":true,"oracleId":1412,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDoubleArray","javadocTag":"@param i the index","methodJavadoc":"    /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public double addAndGet(int i, double delta){\n    while (true) {\n        long current = longs.get(i);\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (longs.compareAndSet(i, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea with assistance from members of JCP JSR-166\n * Expert Group and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDoubleArray.java?revision=1.5\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongArray instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongArray;\n\n/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDoubleArray implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  // Making this non-final is the lesser evil according to Effective\n  // Java 2nd Edition Item 76: Write readObject methods defensively.\n  private transient AtomicLongArray longs;\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} of the given length,\n   * with all elements initially zero.\n   *\n   * @param length the length of the array\n   */\n  public AtomicDoubleArray(int length) {\n    this.longs = new AtomicLongArray(length);\n  }\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} with the same length\n   * as, and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @throws NullPointerException if array is null\n   */\n  public AtomicDoubleArray(double[] array) {\n    final int len = array.length;\n    long[] longArray = new long[len];\n    for (int i = 0; i < len; i++) {\n      longArray[i] = doubleToRawLongBits(array[i]);\n    }\n    this.longs = new AtomicLongArray(longArray);\n  }\n\n  /**\n   * Returns the length of the array.\n   *\n   * @return the length of the array\n   */\n  public final int length() {\n    return longs.length();\n  }\n\n  /**\n   * Gets the current value at position {@code i}.\n   *\n   * @param i the index\n   * @return the current value\n   */\n  public final double get(int i) {\n    return longBitsToDouble(longs.get(i));\n  }\n\n  /**\n   * Sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void set(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    longs.set(i, next);\n  }\n\n  /**\n   * Eventually sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void lazySet(int i, double newValue) {\n    set(i, newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // longs.lazySet(i, next);\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given value\n   * and returns the old value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(longs.getAndSet(i, next));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful. False return indicates that\n   * the actual value was not equal to the expected value.\n   */\n  public final boolean compareAndSet(int i, double expect, double update) {\n    return longs.compareAndSet(i,\n                               doubleToRawLongBits(expect),\n                               doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful\n   */\n  public final boolean weakCompareAndSet(int i, double expect, double update) {\n    return longs.weakCompareAndSet(i,\n                                   doubleToRawLongBits(expect),\n                                   doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public double addAndGet(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current values of array.\n   * @return the String representation of the current values of array\n   */\n  public String toString() {\n    int iMax = length() - 1;\n    if (iMax == -1) {\n      return \"[]\";\n    }\n\n    // Double.toString(Math.PI).length() == 17\n    StringBuilder b = new StringBuilder((17 + 2) * (iMax + 1));\n    b.append('[');\n    for (int i = 0;; i++) {\n      b.append(longBitsToDouble(longs.get(i)));\n      if (i == iMax) {\n        return b.append(']').toString();\n      }\n      b.append(',').append(' ');\n    }\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The length of the array is emitted (int), followed by all\n   *             of its elements (each a {@code double}) in the proper order.\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    // Write out array length\n    int length = length();\n    s.writeInt(length);\n\n    // Write out all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      s.writeDouble(get(i));\n    }\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    // Read in array length and allocate array\n    int length = s.readInt();\n    this.longs = new AtomicLongArray(length);\n\n    // Read in all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      set(i, s.readDouble());\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53064639,"label":true,"oracleId":1413,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDoubleArray","javadocTag":"@param delta the value to add","methodJavadoc":"    /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public double addAndGet(int i, double delta){\n    while (true) {\n        long current = longs.get(i);\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (longs.compareAndSet(i, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea with assistance from members of JCP JSR-166\n * Expert Group and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDoubleArray.java?revision=1.5\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongArray instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongArray;\n\n/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDoubleArray implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  // Making this non-final is the lesser evil according to Effective\n  // Java 2nd Edition Item 76: Write readObject methods defensively.\n  private transient AtomicLongArray longs;\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} of the given length,\n   * with all elements initially zero.\n   *\n   * @param length the length of the array\n   */\n  public AtomicDoubleArray(int length) {\n    this.longs = new AtomicLongArray(length);\n  }\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} with the same length\n   * as, and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @throws NullPointerException if array is null\n   */\n  public AtomicDoubleArray(double[] array) {\n    final int len = array.length;\n    long[] longArray = new long[len];\n    for (int i = 0; i < len; i++) {\n      longArray[i] = doubleToRawLongBits(array[i]);\n    }\n    this.longs = new AtomicLongArray(longArray);\n  }\n\n  /**\n   * Returns the length of the array.\n   *\n   * @return the length of the array\n   */\n  public final int length() {\n    return longs.length();\n  }\n\n  /**\n   * Gets the current value at position {@code i}.\n   *\n   * @param i the index\n   * @return the current value\n   */\n  public final double get(int i) {\n    return longBitsToDouble(longs.get(i));\n  }\n\n  /**\n   * Sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void set(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    longs.set(i, next);\n  }\n\n  /**\n   * Eventually sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void lazySet(int i, double newValue) {\n    set(i, newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // longs.lazySet(i, next);\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given value\n   * and returns the old value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(longs.getAndSet(i, next));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful. False return indicates that\n   * the actual value was not equal to the expected value.\n   */\n  public final boolean compareAndSet(int i, double expect, double update) {\n    return longs.compareAndSet(i,\n                               doubleToRawLongBits(expect),\n                               doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful\n   */\n  public final boolean weakCompareAndSet(int i, double expect, double update) {\n    return longs.weakCompareAndSet(i,\n                                   doubleToRawLongBits(expect),\n                                   doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public double addAndGet(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current values of array.\n   * @return the String representation of the current values of array\n   */\n  public String toString() {\n    int iMax = length() - 1;\n    if (iMax == -1) {\n      return \"[]\";\n    }\n\n    // Double.toString(Math.PI).length() == 17\n    StringBuilder b = new StringBuilder((17 + 2) * (iMax + 1));\n    b.append('[');\n    for (int i = 0;; i++) {\n      b.append(longBitsToDouble(longs.get(i)));\n      if (i == iMax) {\n        return b.append(']').toString();\n      }\n      b.append(',').append(' ');\n    }\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The length of the array is emitted (int), followed by all\n   *             of its elements (each a {@code double}) in the proper order.\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    // Write out array length\n    int length = length();\n    s.writeInt(length);\n\n    // Write out all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      s.writeDouble(get(i));\n    }\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    // Read in array length and allocate array\n    int length = s.readInt();\n    this.longs = new AtomicLongArray(length);\n\n    // Read in all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      set(i, s.readDouble());\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53065099,"label":true,"oracleId":1414,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDoubleArray","javadocTag":"@return the updated value","methodJavadoc":"    /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public double addAndGet(int i, double delta){\n    while (true) {\n        long current = longs.get(i);\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (longs.compareAndSet(i, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea with assistance from members of JCP JSR-166\n * Expert Group and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDoubleArray.java?revision=1.5\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongArray instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongArray;\n\n/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDoubleArray implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  // Making this non-final is the lesser evil according to Effective\n  // Java 2nd Edition Item 76: Write readObject methods defensively.\n  private transient AtomicLongArray longs;\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} of the given length,\n   * with all elements initially zero.\n   *\n   * @param length the length of the array\n   */\n  public AtomicDoubleArray(int length) {\n    this.longs = new AtomicLongArray(length);\n  }\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} with the same length\n   * as, and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @throws NullPointerException if array is null\n   */\n  public AtomicDoubleArray(double[] array) {\n    final int len = array.length;\n    long[] longArray = new long[len];\n    for (int i = 0; i < len; i++) {\n      longArray[i] = doubleToRawLongBits(array[i]);\n    }\n    this.longs = new AtomicLongArray(longArray);\n  }\n\n  /**\n   * Returns the length of the array.\n   *\n   * @return the length of the array\n   */\n  public final int length() {\n    return longs.length();\n  }\n\n  /**\n   * Gets the current value at position {@code i}.\n   *\n   * @param i the index\n   * @return the current value\n   */\n  public final double get(int i) {\n    return longBitsToDouble(longs.get(i));\n  }\n\n  /**\n   * Sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void set(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    longs.set(i, next);\n  }\n\n  /**\n   * Eventually sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void lazySet(int i, double newValue) {\n    set(i, newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // longs.lazySet(i, next);\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given value\n   * and returns the old value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(longs.getAndSet(i, next));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful. False return indicates that\n   * the actual value was not equal to the expected value.\n   */\n  public final boolean compareAndSet(int i, double expect, double update) {\n    return longs.compareAndSet(i,\n                               doubleToRawLongBits(expect),\n                               doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful\n   */\n  public final boolean weakCompareAndSet(int i, double expect, double update) {\n    return longs.weakCompareAndSet(i,\n                                   doubleToRawLongBits(expect),\n                                   doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public double addAndGet(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current values of array.\n   * @return the String representation of the current values of array\n   */\n  public String toString() {\n    int iMax = length() - 1;\n    if (iMax == -1) {\n      return \"[]\";\n    }\n\n    // Double.toString(Math.PI).length() == 17\n    StringBuilder b = new StringBuilder((17 + 2) * (iMax + 1));\n    b.append('[');\n    for (int i = 0;; i++) {\n      b.append(longBitsToDouble(longs.get(i)));\n      if (i == iMax) {\n        return b.append(']').toString();\n      }\n      b.append(',').append(' ');\n    }\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The length of the array is emitted (int), followed by all\n   *             of its elements (each a {@code double}) in the proper order.\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    // Write out array length\n    int length = length();\n    s.writeInt(length);\n\n    // Write out all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      s.writeDouble(get(i));\n    }\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    // Read in array length and allocate array\n    int length = s.readInt();\n    this.longs = new AtomicLongArray(length);\n\n    // Read in all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      set(i, s.readDouble());\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53065557,"label":true,"oracleId":1415,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDoubleArray","javadocTag":"@return the String representation of the current values of array","methodJavadoc":"    /**\n   * Returns the String representation of the current values of array.\n   * @return the String representation of the current values of array\n   */","methodSourceCode":"public String toString(){\n    int iMax = length() - 1;\n    if (iMax == -1) {\n        return \"[]\";\n    }\n    // Double.toString(Math.PI).length() == 17\n    StringBuilder b = new StringBuilder((17 + 2) * (iMax + 1));\n    b.append('[');\n    for (int i = 0; ; i++) {\n        b.append(longBitsToDouble(longs.get(i)));\n        if (i == iMax) {\n            return b.append(']').toString();\n        }\n        b.append(',').append(' ');\n    }\n}","classJavadoc":"/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea with assistance from members of JCP JSR-166\n * Expert Group and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDoubleArray.java?revision=1.5\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongArray instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongArray;\n\n/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDoubleArray implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  // Making this non-final is the lesser evil according to Effective\n  // Java 2nd Edition Item 76: Write readObject methods defensively.\n  private transient AtomicLongArray longs;\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} of the given length,\n   * with all elements initially zero.\n   *\n   * @param length the length of the array\n   */\n  public AtomicDoubleArray(int length) {\n    this.longs = new AtomicLongArray(length);\n  }\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} with the same length\n   * as, and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @throws NullPointerException if array is null\n   */\n  public AtomicDoubleArray(double[] array) {\n    final int len = array.length;\n    long[] longArray = new long[len];\n    for (int i = 0; i < len; i++) {\n      longArray[i] = doubleToRawLongBits(array[i]);\n    }\n    this.longs = new AtomicLongArray(longArray);\n  }\n\n  /**\n   * Returns the length of the array.\n   *\n   * @return the length of the array\n   */\n  public final int length() {\n    return longs.length();\n  }\n\n  /**\n   * Gets the current value at position {@code i}.\n   *\n   * @param i the index\n   * @return the current value\n   */\n  public final double get(int i) {\n    return longBitsToDouble(longs.get(i));\n  }\n\n  /**\n   * Sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void set(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    longs.set(i, next);\n  }\n\n  /**\n   * Eventually sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void lazySet(int i, double newValue) {\n    set(i, newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // longs.lazySet(i, next);\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given value\n   * and returns the old value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(longs.getAndSet(i, next));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful. False return indicates that\n   * the actual value was not equal to the expected value.\n   */\n  public final boolean compareAndSet(int i, double expect, double update) {\n    return longs.compareAndSet(i,\n                               doubleToRawLongBits(expect),\n                               doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful\n   */\n  public final boolean weakCompareAndSet(int i, double expect, double update) {\n    return longs.weakCompareAndSet(i,\n                                   doubleToRawLongBits(expect),\n                                   doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public double addAndGet(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current values of array.\n   * @return the String representation of the current values of array\n   */\n  public String toString() {\n    int iMax = length() - 1;\n    if (iMax == -1) {\n      return \"[]\";\n    }\n\n    // Double.toString(Math.PI).length() == 17\n    StringBuilder b = new StringBuilder((17 + 2) * (iMax + 1));\n    b.append('[');\n    for (int i = 0;; i++) {\n      b.append(longBitsToDouble(longs.get(i)));\n      if (i == iMax) {\n        return b.append(']').toString();\n      }\n      b.append(',').append(' ');\n    }\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The length of the array is emitted (int), followed by all\n   *             of its elements (each a {@code double}) in the proper order.\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    // Write out array length\n    int length = length();\n    s.writeInt(length);\n\n    // Write out all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      s.writeDouble(get(i));\n    }\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    // Read in array length and allocate array\n    int length = s.readInt();\n    this.longs = new AtomicLongArray(length);\n\n    // Read in all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      set(i, s.readDouble());\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53066014,"label":true,"oracleId":1416,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDoubleArray","javadocTag":"@param length the length of the array","methodJavadoc":"    /**\n   * Creates a new {@code AtomicDoubleArray} of the given length,\n   * with all elements initially zero.\n   *\n   * @param length the length of the array\n   */","methodSourceCode":"public AtomicDoubleArray(int length){\n    this.longs = new AtomicLongArray(length);\n}","classJavadoc":"/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea with assistance from members of JCP JSR-166\n * Expert Group and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDoubleArray.java?revision=1.5\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongArray instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongArray;\n\n/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDoubleArray implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  // Making this non-final is the lesser evil according to Effective\n  // Java 2nd Edition Item 76: Write readObject methods defensively.\n  private transient AtomicLongArray longs;\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} of the given length,\n   * with all elements initially zero.\n   *\n   * @param length the length of the array\n   */\n  public AtomicDoubleArray(int length) {\n    this.longs = new AtomicLongArray(length);\n  }\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} with the same length\n   * as, and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @throws NullPointerException if array is null\n   */\n  public AtomicDoubleArray(double[] array) {\n    final int len = array.length;\n    long[] longArray = new long[len];\n    for (int i = 0; i < len; i++) {\n      longArray[i] = doubleToRawLongBits(array[i]);\n    }\n    this.longs = new AtomicLongArray(longArray);\n  }\n\n  /**\n   * Returns the length of the array.\n   *\n   * @return the length of the array\n   */\n  public final int length() {\n    return longs.length();\n  }\n\n  /**\n   * Gets the current value at position {@code i}.\n   *\n   * @param i the index\n   * @return the current value\n   */\n  public final double get(int i) {\n    return longBitsToDouble(longs.get(i));\n  }\n\n  /**\n   * Sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void set(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    longs.set(i, next);\n  }\n\n  /**\n   * Eventually sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void lazySet(int i, double newValue) {\n    set(i, newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // longs.lazySet(i, next);\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given value\n   * and returns the old value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(longs.getAndSet(i, next));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful. False return indicates that\n   * the actual value was not equal to the expected value.\n   */\n  public final boolean compareAndSet(int i, double expect, double update) {\n    return longs.compareAndSet(i,\n                               doubleToRawLongBits(expect),\n                               doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful\n   */\n  public final boolean weakCompareAndSet(int i, double expect, double update) {\n    return longs.weakCompareAndSet(i,\n                                   doubleToRawLongBits(expect),\n                                   doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public double addAndGet(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current values of array.\n   * @return the String representation of the current values of array\n   */\n  public String toString() {\n    int iMax = length() - 1;\n    if (iMax == -1) {\n      return \"[]\";\n    }\n\n    // Double.toString(Math.PI).length() == 17\n    StringBuilder b = new StringBuilder((17 + 2) * (iMax + 1));\n    b.append('[');\n    for (int i = 0;; i++) {\n      b.append(longBitsToDouble(longs.get(i)));\n      if (i == iMax) {\n        return b.append(']').toString();\n      }\n      b.append(',').append(' ');\n    }\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The length of the array is emitted (int), followed by all\n   *             of its elements (each a {@code double}) in the proper order.\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    // Write out array length\n    int length = length();\n    s.writeInt(length);\n\n    // Write out all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      s.writeDouble(get(i));\n    }\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    // Read in array length and allocate array\n    int length = s.readInt();\n    this.longs = new AtomicLongArray(length);\n\n    // Read in all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      set(i, s.readDouble());\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53066471,"label":true,"oracleId":1417,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDoubleArray","javadocTag":"@param array the array to copy elements from","methodJavadoc":"    /**\n   * Creates a new {@code AtomicDoubleArray} with the same length\n   * as, and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @throws NullPointerException if array is null\n   */","methodSourceCode":"public AtomicDoubleArray(double[] array){\n    final int len = array.length;\n    long[] longArray = new long[len];\n    for (int i = 0; i < len; i++) {\n        longArray[i] = doubleToRawLongBits(array[i]);\n    }\n    this.longs = new AtomicLongArray(longArray);\n}","classJavadoc":"/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea with assistance from members of JCP JSR-166\n * Expert Group and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDoubleArray.java?revision=1.5\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongArray instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongArray;\n\n/**\n * A {@code double} array in which elements may be updated atomically.\n * See the {@link java.util.concurrent.atomic} package specification\n * for description of the properties of atomic variables.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDoubleArray implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  // Making this non-final is the lesser evil according to Effective\n  // Java 2nd Edition Item 76: Write readObject methods defensively.\n  private transient AtomicLongArray longs;\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} of the given length,\n   * with all elements initially zero.\n   *\n   * @param length the length of the array\n   */\n  public AtomicDoubleArray(int length) {\n    this.longs = new AtomicLongArray(length);\n  }\n\n  /**\n   * Creates a new {@code AtomicDoubleArray} with the same length\n   * as, and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @throws NullPointerException if array is null\n   */\n  public AtomicDoubleArray(double[] array) {\n    final int len = array.length;\n    long[] longArray = new long[len];\n    for (int i = 0; i < len; i++) {\n      longArray[i] = doubleToRawLongBits(array[i]);\n    }\n    this.longs = new AtomicLongArray(longArray);\n  }\n\n  /**\n   * Returns the length of the array.\n   *\n   * @return the length of the array\n   */\n  public final int length() {\n    return longs.length();\n  }\n\n  /**\n   * Gets the current value at position {@code i}.\n   *\n   * @param i the index\n   * @return the current value\n   */\n  public final double get(int i) {\n    return longBitsToDouble(longs.get(i));\n  }\n\n  /**\n   * Sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void set(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    longs.set(i, next);\n  }\n\n  /**\n   * Eventually sets the element at position {@code i} to the given value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   */\n  public final void lazySet(int i, double newValue) {\n    set(i, newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // longs.lazySet(i, next);\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given value\n   * and returns the old value.\n   *\n   * @param i the index\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(int i, double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(longs.getAndSet(i, next));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful. False return indicates that\n   * the actual value was not equal to the expected value.\n   */\n  public final boolean compareAndSet(int i, double expect, double update) {\n    return longs.compareAndSet(i,\n                               doubleToRawLongBits(expect),\n                               doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the element at position {@code i} to the given\n   * updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param i the index\n   * @param expect the expected value\n   * @param update the new value\n   * @return true if successful\n   */\n  public final boolean weakCompareAndSet(int i, double expect, double update) {\n    return longs.weakCompareAndSet(i,\n                                   doubleToRawLongBits(expect),\n                                   doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the element at index {@code i}.\n   *\n   * @param i the index\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public double addAndGet(int i, double delta) {\n    while (true) {\n      long current = longs.get(i);\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (longs.compareAndSet(i, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current values of array.\n   * @return the String representation of the current values of array\n   */\n  public String toString() {\n    int iMax = length() - 1;\n    if (iMax == -1) {\n      return \"[]\";\n    }\n\n    // Double.toString(Math.PI).length() == 17\n    StringBuilder b = new StringBuilder((17 + 2) * (iMax + 1));\n    b.append('[');\n    for (int i = 0;; i++) {\n      b.append(longBitsToDouble(longs.get(i)));\n      if (i == iMax) {\n        return b.append(']').toString();\n      }\n      b.append(',').append(' ');\n    }\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The length of the array is emitted (int), followed by all\n   *             of its elements (each a {@code double}) in the proper order.\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    // Write out array length\n    int length = length();\n    s.writeInt(length);\n\n    // Write out all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      s.writeDouble(get(i));\n    }\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    // Read in array length and allocate array\n    int length = s.readInt();\n    this.longs = new AtomicLongArray(length);\n\n    // Read in all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      set(i, s.readDouble());\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53066929,"label":true,"oracleId":1418,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"SimpleTimeLimiter","javadocTag":"@param executor the ExecutorService that will execute the method calls on\n    the target objects; for example, a {@link\n    Executors#newCachedThreadPool()}.","methodJavadoc":"    /**\n   * Constructs a TimeLimiter instance using the given executor service to\n   * execute proxied method calls.\n   * <p>\n   * <b>Warning:</b> using a bounded executor\n   * may be counterproductive!  If the thread pool fills up, any time callers\n   * spend waiting for a thread may count toward their time limit, and in\n   * this case the call may even time out before the target method is ever\n   * invoked.\n   *\n   * @param executor the ExecutorService that will execute the method calls on\n   *     the target objects; for example, a {@link\n   *     Executors#newCachedThreadPool()}.\n   */","methodSourceCode":"public SimpleTimeLimiter(ExecutorService executor){\n    this.executor = checkNotNull(executor);\n}","classJavadoc":"/**\n * A TimeLimiter that runs method calls in the background using an\n * {@link ExecutorService}.  If the time limit expires for a given method call,\n * the thread running the call will be interrupted.\n *\n * @author Kevin Bourrillion\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2006 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.collect.ObjectArrays;\nimport com.google.common.collect.Sets;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * A TimeLimiter that runs method calls in the background using an\n * {@link ExecutorService}.  If the time limit expires for a given method call,\n * the thread running the call will be interrupted.\n *\n * @author Kevin Bourrillion\n * @since 1.0\n */\n@Beta\npublic final class SimpleTimeLimiter implements TimeLimiter {\n\n  private final ExecutorService executor;\n\n  /**\n   * Constructs a TimeLimiter instance using the given executor service to\n   * execute proxied method calls.\n   * <p>\n   * <b>Warning:</b> using a bounded executor\n   * may be counterproductive!  If the thread pool fills up, any time callers\n   * spend waiting for a thread may count toward their time limit, and in\n   * this case the call may even time out before the target method is ever\n   * invoked.\n   *\n   * @param executor the ExecutorService that will execute the method calls on\n   *     the target objects; for example, a {@link\n   *     Executors#newCachedThreadPool()}.\n   */\n  public SimpleTimeLimiter(ExecutorService executor) {\n    this.executor = checkNotNull(executor);\n  }\n\n  /**\n   * Constructs a TimeLimiter instance using a {@link\n   * Executors#newCachedThreadPool()} to execute proxied method calls.\n   *\n   * <p><b>Warning:</b> using a bounded executor may be counterproductive! If\n   * the thread pool fills up, any time callers spend waiting for a thread may\n   * count toward their time limit, and in this case the call may even time out\n   * before the target method is ever invoked.\n   */\n  public SimpleTimeLimiter() {\n    this(Executors.newCachedThreadPool());\n  }\n\n  @Override\n  public <T> T newProxy(final T target, Class<T> interfaceType,\n      final long timeoutDuration, final TimeUnit timeoutUnit) {\n    checkNotNull(target);\n    checkNotNull(interfaceType);\n    checkNotNull(timeoutUnit);\n    checkArgument(timeoutDuration > 0, \"bad timeout: %s\", timeoutDuration);\n    checkArgument(interfaceType.isInterface(),\n        \"interfaceType must be an interface type\");\n\n    final Set<Method> interruptibleMethods\n        = findInterruptibleMethods(interfaceType);\n\n    InvocationHandler handler = new InvocationHandler() {\n      @Override\n      public Object invoke(Object obj, final Method method, final Object[] args)\n          throws Throwable {\n        Callable<Object> callable = new Callable<Object>() {\n          @Override\n          public Object call() throws Exception {\n            try {\n              return method.invoke(target, args);\n            } catch (InvocationTargetException e) {\n              throwCause(e, false);\n              throw new AssertionError(\"can't get here\");\n            }\n          }\n        };\n        return callWithTimeout(callable, timeoutDuration, timeoutUnit,\n            interruptibleMethods.contains(method));\n      }\n    };\n    return newProxy(interfaceType, handler);\n  }\n\n  // TODO: should this actually throw only ExecutionException?\n  @Override\n  public <T> T callWithTimeout(Callable<T> callable, long timeoutDuration,\n      TimeUnit timeoutUnit, boolean amInterruptible) throws Exception {\n    checkNotNull(callable);\n    checkNotNull(timeoutUnit);\n    checkArgument(timeoutDuration > 0, \"timeout must be positive: %s\",\n        timeoutDuration);\n    Future<T> future = executor.submit(callable);\n    try {\n      if (amInterruptible) {\n        try {\n          return future.get(timeoutDuration, timeoutUnit);\n        } catch (InterruptedException e) {\n          future.cancel(true);\n          throw e;\n        }\n      } else {\n        return Uninterruptibles.getUninterruptibly(future, \n            timeoutDuration, timeoutUnit);\n      }\n    } catch (ExecutionException e) {\n      throw throwCause(e, true);\n    } catch (TimeoutException e) {\n      future.cancel(true);\n      throw new UncheckedTimeoutException(e);\n    }\n  }\n\n  private static Exception throwCause(Exception e, boolean combineStackTraces)\n      throws Exception {\n    Throwable cause = e.getCause();\n    if (cause == null) {\n      throw e;\n    }\n    if (combineStackTraces) {\n      StackTraceElement[] combined = ObjectArrays.concat(cause.getStackTrace(),\n          e.getStackTrace(), StackTraceElement.class);\n      cause.setStackTrace(combined);\n    }\n    if (cause instanceof Exception) {\n      throw (Exception) cause;\n    }\n    if (cause instanceof Error) {\n      throw (Error) cause;\n    }\n    // The cause is a weird kind of Throwable, so throw the outer exception.\n    throw e;\n  }\n\n  private static Set<Method> findInterruptibleMethods(Class<?> interfaceType) {\n    Set<Method> set = Sets.newHashSet();\n    for (Method m : interfaceType.getMethods()) {\n      if (declaresInterruptedEx(m)) {\n        set.add(m);\n      }\n    }\n    return set;\n  }\n\n  private static boolean declaresInterruptedEx(Method method) {\n    for (Class<?> exType : method.getExceptionTypes()) {\n      // debate: == or isAssignableFrom?\n      if (exType == InterruptedException.class) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // TODO: replace with version in common.reflect if and when it's open-sourced\n  private static <T> T newProxy(\n      Class<T> interfaceType, InvocationHandler handler) {\n    Object object = Proxy.newProxyInstance(interfaceType.getClassLoader(),\n        new Class<?>[] { interfaceType }, handler);\n    return interfaceType.cast(object);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53067388,"label":true,"oracleId":1419,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"MoreExecutors","javadocTag":"@param executor the executor to modify to make sure it exits when the\n       application is finished","methodJavadoc":"    /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */","methodSourceCode":"public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit){\n    return new Application().getExitingExecutorService(executor, terminationTimeout, timeUnit);\n}","classJavadoc":"/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */","classSourceCode":"/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Queues;\nimport com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */\n@GwtCompatible(emulated = true)\npublic final class MoreExecutors {\n  private MoreExecutors() {}\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ExecutorService getExitingExecutorService(\n      ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ScheduledThreadPoolExecutor into a\n   * ScheduledExecutorService that exits when the application is complete.  It\n   * does so by using daemon threads and adding a shutdown hook to wait for\n   * their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingScheduledExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Add a shutdown hook to wait for thread completion in the given\n   * {@link ExecutorService service}.  This is useful if the given service uses\n   * daemon threads, and we want to keep the JVM from exiting immediately on\n   * shutdown, instead giving these daemon threads a chance to terminate\n   * normally.\n   * @param service ExecutorService which uses daemon threads\n   * @param terminationTimeout how long to wait for the executor to finish\n   *        before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static void addDelayedShutdownHook(\n      ExecutorService service, long terminationTimeout, TimeUnit timeUnit) {\n    new Application()\n        .addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n    return new Application().getExitingExecutorService(executor);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into a ScheduledExecutorService that\n   * exits when the application is complete.  It does so by using daemon threads\n   * and adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor) {\n    return new Application().getExitingScheduledExecutorService(executor);\n  }\n\n  /** Represents the current application to register shutdown hooks. */\n  @GwtIncompatible(\"TODO\")\n  @VisibleForTesting\n  static class Application {\n\n    final ExecutorService getExitingExecutorService(\n        ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ExecutorService service = Executors.unconfigurableExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ScheduledExecutorService service = Executors.unconfigurableScheduledExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final void addDelayedShutdownHook(\n        final ExecutorService service, final long terminationTimeout, final TimeUnit timeUnit) {\n      checkNotNull(service);\n      checkNotNull(timeUnit);\n      addShutdownHook(MoreExecutors.newThread(\"DelayedShutdownHook-for-\" + service, new Runnable() {\n        @Override\n        public void run() {\n          try {\n            // We'd like to log progress and failures that may arise in the\n            // following code, but unfortunately the behavior of logging\n            // is undefined in shutdown hooks.\n            // This is because the logging code installs a shutdown hook of its\n            // own. See Cleaner class inside {@link LogManager}.\n            service.shutdown();\n            service.awaitTermination(terminationTimeout, timeUnit);\n          } catch (InterruptedException ignored) {\n            // We're shutting down anyway, so just ignore.\n          }\n        }\n      }));\n    }\n\n    final ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n      return getExitingExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor) {\n      return getExitingScheduledExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    @VisibleForTesting void addShutdownHook(Thread hook) {\n      Runtime.getRuntime().addShutdownHook(hook);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static void useDaemonThreadFactory(ThreadPoolExecutor executor) {\n    executor.setThreadFactory(new ThreadFactoryBuilder()\n        .setDaemon(true)\n        .setThreadFactory(executor.getThreadFactory())\n        .build());\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}.  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 10.0 (<a href=\"https://github.com/google/guava/wiki/Compatibility\"\n   *        >mostly source-compatible</a> since 3.0)\n   * @deprecated Use {@link #directExecutor()} if you only require an {@link Executor} and\n   *     {@link #newDirectExecutorService()} if you need a {@link ListeningExecutorService}. This\n   *     method will be removed in August 2016.\n   */\n  @Deprecated\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService sameThreadExecutor() {\n    return new DirectExecutorService();\n  }\n\n  // See sameThreadExecutor javadoc for behavioral notes.\n  @GwtIncompatible(\"TODO\")\n  private static final class DirectExecutorService\n      extends AbstractListeningExecutorService {\n    /**\n     * Lock used whenever accessing the state variables\n     * (runningTasks, shutdown) of the executor\n     */\n    private final Object lock = new Object();\n\n    /*\n     * Conceptually, these two variables describe the executor being in\n     * one of three states:\n     *   - Active: shutdown == false\n     *   - Shutdown: runningTasks > 0 and shutdown == true\n     *   - Terminated: runningTasks == 0 and shutdown == true\n     */\n    @GuardedBy(\"lock\") private int runningTasks = 0;\n    @GuardedBy(\"lock\") private boolean shutdown = false;\n\n    @Override\n    public void execute(Runnable command) {\n      startTask();\n      try {\n        command.run();\n      } finally {\n        endTask();\n      }\n    }\n\n    @Override\n    public boolean isShutdown() {\n      synchronized (lock) {\n        return shutdown;\n      }\n    }\n\n    @Override\n    public void shutdown() {\n      synchronized (lock) {\n        shutdown = true;\n        if (runningTasks == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n\n    // See sameThreadExecutor javadoc for unusual behavior of this method.\n    @Override\n    public List<Runnable> shutdownNow() {\n      shutdown();\n      return Collections.emptyList();\n    }\n\n    @Override\n    public boolean isTerminated() {\n      synchronized (lock) {\n        return shutdown && runningTasks == 0;\n      }\n    }\n\n    @Override\n    public boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      long nanos = unit.toNanos(timeout);\n      synchronized (lock) {\n        for (;;) {\n          if (shutdown && runningTasks == 0) {\n            return true;\n          } else if (nanos <= 0) {\n            return false;\n          } else {\n            long now = System.nanoTime();\n            TimeUnit.NANOSECONDS.timedWait(lock, nanos);\n            nanos -= System.nanoTime() - now;  // subtract the actual time we waited\n          }\n        }\n      }\n    }\n\n    /**\n     * Checks if the executor has been shut down and increments the running\n     * task count.\n     *\n     * @throws RejectedExecutionException if the executor has been previously\n     *         shutdown\n     */\n    private void startTask() {\n      synchronized (lock) {\n        if (shutdown) {\n          throw new RejectedExecutionException(\"Executor already shutdown\");\n        }\n        runningTasks++;\n      }\n    }\n\n    /**\n     * Decrements the running task count.\n     */\n    private void endTask() {\n      synchronized (lock) {\n        int numRunning = --runningTasks;\n        if (numRunning == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 18.0 (present as MoreExecutors.sameThreadExecutor() since 10.0)\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService newDirectExecutorService() {\n    return new DirectExecutorService();\n  }\n\n  /**\n   * Returns an {@link Executor} that runs each task in the thread that invokes\n   * {@link Executor#execute execute}, as in {@link CallerRunsPolicy}.\n   *\n   * <p>This instance is equivalent to: <pre>   {@code\n   *   final class DirectExecutor implements Executor {\n   *     public void execute(Runnable r) {\n   *       r.run();\n   *     }\n   *   }}</pre>\n   *\n   * <p>This should be preferred to {@link #newDirectExecutorService()} because the implementing the\n   * {@link ExecutorService} subinterface necessitates significant performance overhead.\n   *\n   * @since 18.0\n   */\n  public static Executor directExecutor() {\n    return DirectExecutor.INSTANCE;\n  }\n\n  /** See {@link #directExecutor} for behavioral notes. */\n  private enum DirectExecutor implements Executor {\n    INSTANCE;\n    @Override public void execute(Runnable command) {\n      command.run();\n    }\n\n    @Override public String toString() {\n      return \"MoreExecutors.directExecutor()\";\n    }\n  }\n\n  /**\n   * Creates an {@link ExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code ListeningExecutorService}\n   * never calls the delegate's {@code submit}, {@code invokeAll}, and {@code\n   * invokeAny} methods, so any special handling of tasks must be implemented in\n   * the delegate's {@code execute} method or by wrapping the returned {@code\n   * ListeningExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningExecutorService}, it is returned untouched, and the rest of this\n   * documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService listeningDecorator(\n      ExecutorService delegate) {\n    return (delegate instanceof ListeningExecutorService)\n        ? (ListeningExecutorService) delegate\n        : (delegate instanceof ScheduledExecutorService)\n        ? new ScheduledListeningDecorator((ScheduledExecutorService) delegate)\n        : new ListeningDecorator(delegate);\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code\n   * ListeningScheduledExecutorService} never calls the delegate's {@code\n   * submit}, {@code invokeAll}, and {@code invokeAny} methods, so any special\n   * handling of tasks must be implemented in the delegate's {@code execute}\n   * method or by wrapping the returned {@code\n   * ListeningScheduledExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningScheduledExecutorService}, it is returned untouched, and the rest\n   * of this documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningScheduledExecutorService listeningDecorator(\n      ScheduledExecutorService delegate) {\n    return (delegate instanceof ListeningScheduledExecutorService)\n        ? (ListeningScheduledExecutorService) delegate\n        : new ScheduledListeningDecorator(delegate);\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static class ListeningDecorator\n      extends AbstractListeningExecutorService {\n    private final ExecutorService delegate;\n\n    ListeningDecorator(ExecutorService delegate) {\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public final boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      return delegate.awaitTermination(timeout, unit);\n    }\n\n    @Override\n    public final boolean isShutdown() {\n      return delegate.isShutdown();\n    }\n\n    @Override\n    public final boolean isTerminated() {\n      return delegate.isTerminated();\n    }\n\n    @Override\n    public final void shutdown() {\n      delegate.shutdown();\n    }\n\n    @Override\n    public final List<Runnable> shutdownNow() {\n      return delegate.shutdownNow();\n    }\n\n    @Override\n    public final void execute(Runnable command) {\n      delegate.execute(command);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static final class ScheduledListeningDecorator\n      extends ListeningDecorator implements ListeningScheduledExecutorService {\n    @SuppressWarnings(\"hiding\")\n    final ScheduledExecutorService delegate;\n\n    ScheduledListeningDecorator(ScheduledExecutorService delegate) {\n      super(delegate);\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> schedule(\n        Runnable command, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<Void> task =\n          TrustedListenableFutureTask.create(command, null);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public <V> ListenableScheduledFuture<V> schedule(\n        Callable<V> callable, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<V>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleAtFixedRate(\n        Runnable command, long initialDelay, long period, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleAtFixedRate(task, initialDelay, period, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleWithFixedDelay(\n        Runnable command, long initialDelay, long delay, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleWithFixedDelay(task, initialDelay, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    private static final class ListenableScheduledTask<V>\n        extends SimpleForwardingListenableFuture<V>\n        implements ListenableScheduledFuture<V> {\n\n      private final ScheduledFuture<?> scheduledDelegate;\n\n      public ListenableScheduledTask(\n          ListenableFuture<V> listenableDelegate,\n          ScheduledFuture<?> scheduledDelegate) {\n        super(listenableDelegate);\n        this.scheduledDelegate = scheduledDelegate;\n      }\n\n      @Override\n      public boolean cancel(boolean mayInterruptIfRunning) {\n        boolean cancelled = super.cancel(mayInterruptIfRunning);\n        if (cancelled) {\n          // Unless it is cancelled, the delegate may continue being scheduled\n          scheduledDelegate.cancel(mayInterruptIfRunning);\n\n          // TODO(user): Cancel \"this\" if \"scheduledDelegate\" is cancelled.\n        }\n        return cancelled;\n      }\n\n      @Override\n      public long getDelay(TimeUnit unit) {\n        return scheduledDelegate.getDelay(unit);\n      }\n\n      @Override\n      public int compareTo(Delayed other) {\n        return scheduledDelegate.compareTo(other);\n      }\n    }\n\n    @GwtIncompatible(\"TODO\")\n    private static final class NeverSuccessfulListenableFutureTask\n        extends AbstractFuture<Void>\n        implements Runnable {\n      private final Runnable delegate;\n\n      public NeverSuccessfulListenableFutureTask(Runnable delegate) {\n        this.delegate = checkNotNull(delegate);\n      }\n\n      @Override public void run() {\n        try {\n          delegate.run();\n        } catch (Throwable t) {\n          setException(t);\n          throw Throwables.propagate(t);\n        }\n      }\n    }\n  }\n\n  /*\n   * This following method is a modified version of one found in\n   * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/AbstractExecutorServiceTest.java?revision=1.30\n   * which contained the following notice:\n   *\n   * Written by Doug Lea with assistance from members of JCP JSR-166\n   * Expert Group and released to the public domain, as explained at\n   * http://creativecommons.org/publicdomain/zero/1.0/\n   * Other contributors include Andrew Wright, Jeffrey Hayes,\n   * Pat Fisher, Mike Judd.\n   */\n\n  /**\n   * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}\n   * implementations.\n   */ static <T> T invokeAnyImpl(ListeningExecutorService executorService,\n      Collection<? extends Callable<T>> tasks, boolean timed, long nanos)\n          throws InterruptedException, ExecutionException, TimeoutException {\n    checkNotNull(executorService);\n    int ntasks = tasks.size();\n    checkArgument(ntasks > 0);\n    List<Future<T>> futures = Lists.newArrayListWithCapacity(ntasks);\n    BlockingQueue<Future<T>> futureQueue = Queues.newLinkedBlockingQueue();\n\n    // For efficiency, especially in executors with limited\n    // parallelism, check to see if previously submitted tasks are\n    // done before submitting more of them. This interleaving\n    // plus the exception mechanics account for messiness of main\n    // loop.\n\n    try {\n      // Record exceptions so that if we fail to obtain any\n      // result, we can throw the last exception we got.\n      ExecutionException ee = null;\n      long lastTime = timed ? System.nanoTime() : 0;\n      Iterator<? extends Callable<T>> it = tasks.iterator();\n\n      futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n      --ntasks;\n      int active = 1;\n\n      for (;;) {\n        Future<T> f = futureQueue.poll();\n        if (f == null) {\n          if (ntasks > 0) {\n            --ntasks;\n            futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n            ++active;\n          } else if (active == 0) {\n            break;\n          } else if (timed) {\n            f = futureQueue.poll(nanos, TimeUnit.NANOSECONDS);\n            if (f == null) {\n              throw new TimeoutException();\n            }\n            long now = System.nanoTime();\n            nanos -= now - lastTime;\n            lastTime = now;\n          } else {\n            f = futureQueue.take();\n          }\n        }\n        if (f != null) {\n          --active;\n          try {\n            return f.get();\n          } catch (ExecutionException eex) {\n            ee = eex;\n          } catch (RuntimeException rex) {\n            ee = new ExecutionException(rex);\n          }\n        }\n      }\n\n      if (ee == null) {\n        ee = new ExecutionException(null);\n      }\n      throw ee;\n    } finally {\n      for (Future<T> f : futures) {\n        f.cancel(true);\n      }\n    }\n  }\n\n  /**\n   * Submits the task and adds a listener that adds the future to {@code queue} when it completes.\n   */\n  @GwtIncompatible(\"TODO\")\n  private static <T> ListenableFuture<T> submitAndAddQueueListener(\n      ListeningExecutorService executorService, Callable<T> task,\n      final BlockingQueue<Future<T>> queue) {\n    final ListenableFuture<T> future = executorService.submit(task);\n    future.addListener(new Runnable() {\n      @Override public void run() {\n        queue.add(future);\n      }\n    }, directExecutor());\n    return future;\n  }\n\n  /**\n   * Returns a default thread factory used to create new threads.\n   *\n   * <p>On AppEngine, returns {@code ThreadManager.currentRequestThreadFactory()}.\n   * Otherwise, returns {@link Executors#defaultThreadFactory()}.\n   *\n   * @since 14.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ThreadFactory platformThreadFactory() {\n    if (!isAppEngine()) {\n      return Executors.defaultThreadFactory();\n    }\n    try {\n      return (ThreadFactory) Class.forName(\"com.google.appengine.api.ThreadManager\")\n          .getMethod(\"currentRequestThreadFactory\")\n          .invoke(null);\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (ClassNotFoundException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (NoSuchMethodException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (InvocationTargetException e) {\n      throw Throwables.propagate(e.getCause());\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static boolean isAppEngine() {\n    if (System.getProperty(\"com.google.appengine.runtime.environment\") == null) {\n      return false;\n    }\n    try {\n      // If the current environment is null, we're not inside AppEngine.\n      return Class.forName(\"com.google.apphosting.api.ApiProxy\")\n          .getMethod(\"getCurrentEnvironment\")\n          .invoke(null) != null;\n    } catch (ClassNotFoundException e) {\n      // If ApiProxy doesn't exist, we're not on AppEngine at all.\n      return false;\n    } catch (InvocationTargetException e) {\n      // If ApiProxy throws an exception, we're not in a proper AppEngine environment.\n      return false;\n    } catch (IllegalAccessException e) {\n      // If the method isn't accessible, we're not on a supported version of AppEngine;\n      return false;\n    } catch (NoSuchMethodException e) {\n      // If the method doesn't exist, we're not on a supported version of AppEngine;\n      return false;\n    }\n  }\n\n  /**\n   * Creates a thread using {@link #platformThreadFactory}, and sets its name to {@code name}\n   * unless changing the name is forbidden by the security manager.\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Thread newThread(String name, Runnable runnable) {\n    checkNotNull(name);\n    checkNotNull(runnable);\n    Thread result = platformThreadFactory().newThread(runnable);\n    try {\n      result.setName(name);\n    } catch (SecurityException e) {\n      // OK if we can't set the name in this environment.\n    }\n    return result;\n  }\n\n  // TODO(lukes): provide overloads for ListeningExecutorService? ListeningScheduledExecutorService?\n  // TODO(lukes): provide overloads that take constant strings? Function<Runnable, String>s to\n  // calculate names?\n\n  /**\n   * Creates an {@link Executor} that renames the {@link Thread threads} that its tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param executor The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier) {\n    checkNotNull(executor);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try\n      return executor;\n    }\n    return new Executor() {\n      @Override public void execute(Runnable command) {\n        executor.execute(Callables.threadRenaming(command, nameSupplier));\n      }\n    };\n  }\n\n  /**\n   * Creates an {@link ExecutorService} that renames the {@link Thread threads} that its tasks run\n   * in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ExecutorService renamingDecorator(final ExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} that renames the {@link Thread threads} that its\n   * tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ScheduledExecutorService renamingDecorator(final ScheduledExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingScheduledExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Shuts down the given executor gradually, first disabling new submissions and later cancelling\n   * existing tasks.\n   *\n   * <p>The method takes the following steps:\n   * <ol>\n   *  <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n   *  <li>waits for half of the specified timeout.\n   *  <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n   *  pending tasks and interrupting running tasks.\n   *  <li>waits for the other half of the specified timeout.\n   * </ol>\n   *\n   * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n   * ExecutorService#shutdownNow()} and returns.\n   *\n   * @param service the {@code ExecutorService} to shut down\n   * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n   * @param unit the time unit of the timeout argument\n   * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n   *     the call timed out or was interrupted\n   * @since 17.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static boolean shutdownAndAwaitTermination(\n      ExecutorService service, long timeout, TimeUnit unit) {\n    checkNotNull(unit);\n    // Disable new tasks from being submitted\n    service.shutdown();\n    try {\n      long halfTimeoutNanos = TimeUnit.NANOSECONDS.convert(timeout, unit) / 2;\n      // Wait for half the duration of the timeout for existing tasks to terminate\n      if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {\n        // Cancel currently executing tasks\n        service.shutdownNow();\n        // Wait the other half of the timeout for tasks to respond to being cancelled\n        service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);\n      }\n    } catch (InterruptedException ie) {\n      // Preserve interrupt status\n      Thread.currentThread().interrupt();\n      // (Re-)Cancel if current thread also interrupted\n      service.shutdownNow();\n    }\n    return service.isTerminated();\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53067847,"label":true,"oracleId":1420,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"MoreExecutors","javadocTag":"@param terminationTimeout how long to wait for the executor to\n       finish before terminating the JVM","methodJavadoc":"    /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */","methodSourceCode":"public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit){\n    return new Application().getExitingExecutorService(executor, terminationTimeout, timeUnit);\n}","classJavadoc":"/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */","classSourceCode":"/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Queues;\nimport com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */\n@GwtCompatible(emulated = true)\npublic final class MoreExecutors {\n  private MoreExecutors() {}\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ExecutorService getExitingExecutorService(\n      ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ScheduledThreadPoolExecutor into a\n   * ScheduledExecutorService that exits when the application is complete.  It\n   * does so by using daemon threads and adding a shutdown hook to wait for\n   * their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingScheduledExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Add a shutdown hook to wait for thread completion in the given\n   * {@link ExecutorService service}.  This is useful if the given service uses\n   * daemon threads, and we want to keep the JVM from exiting immediately on\n   * shutdown, instead giving these daemon threads a chance to terminate\n   * normally.\n   * @param service ExecutorService which uses daemon threads\n   * @param terminationTimeout how long to wait for the executor to finish\n   *        before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static void addDelayedShutdownHook(\n      ExecutorService service, long terminationTimeout, TimeUnit timeUnit) {\n    new Application()\n        .addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n    return new Application().getExitingExecutorService(executor);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into a ScheduledExecutorService that\n   * exits when the application is complete.  It does so by using daemon threads\n   * and adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor) {\n    return new Application().getExitingScheduledExecutorService(executor);\n  }\n\n  /** Represents the current application to register shutdown hooks. */\n  @GwtIncompatible(\"TODO\")\n  @VisibleForTesting\n  static class Application {\n\n    final ExecutorService getExitingExecutorService(\n        ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ExecutorService service = Executors.unconfigurableExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ScheduledExecutorService service = Executors.unconfigurableScheduledExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final void addDelayedShutdownHook(\n        final ExecutorService service, final long terminationTimeout, final TimeUnit timeUnit) {\n      checkNotNull(service);\n      checkNotNull(timeUnit);\n      addShutdownHook(MoreExecutors.newThread(\"DelayedShutdownHook-for-\" + service, new Runnable() {\n        @Override\n        public void run() {\n          try {\n            // We'd like to log progress and failures that may arise in the\n            // following code, but unfortunately the behavior of logging\n            // is undefined in shutdown hooks.\n            // This is because the logging code installs a shutdown hook of its\n            // own. See Cleaner class inside {@link LogManager}.\n            service.shutdown();\n            service.awaitTermination(terminationTimeout, timeUnit);\n          } catch (InterruptedException ignored) {\n            // We're shutting down anyway, so just ignore.\n          }\n        }\n      }));\n    }\n\n    final ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n      return getExitingExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor) {\n      return getExitingScheduledExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    @VisibleForTesting void addShutdownHook(Thread hook) {\n      Runtime.getRuntime().addShutdownHook(hook);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static void useDaemonThreadFactory(ThreadPoolExecutor executor) {\n    executor.setThreadFactory(new ThreadFactoryBuilder()\n        .setDaemon(true)\n        .setThreadFactory(executor.getThreadFactory())\n        .build());\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}.  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 10.0 (<a href=\"https://github.com/google/guava/wiki/Compatibility\"\n   *        >mostly source-compatible</a> since 3.0)\n   * @deprecated Use {@link #directExecutor()} if you only require an {@link Executor} and\n   *     {@link #newDirectExecutorService()} if you need a {@link ListeningExecutorService}. This\n   *     method will be removed in August 2016.\n   */\n  @Deprecated\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService sameThreadExecutor() {\n    return new DirectExecutorService();\n  }\n\n  // See sameThreadExecutor javadoc for behavioral notes.\n  @GwtIncompatible(\"TODO\")\n  private static final class DirectExecutorService\n      extends AbstractListeningExecutorService {\n    /**\n     * Lock used whenever accessing the state variables\n     * (runningTasks, shutdown) of the executor\n     */\n    private final Object lock = new Object();\n\n    /*\n     * Conceptually, these two variables describe the executor being in\n     * one of three states:\n     *   - Active: shutdown == false\n     *   - Shutdown: runningTasks > 0 and shutdown == true\n     *   - Terminated: runningTasks == 0 and shutdown == true\n     */\n    @GuardedBy(\"lock\") private int runningTasks = 0;\n    @GuardedBy(\"lock\") private boolean shutdown = false;\n\n    @Override\n    public void execute(Runnable command) {\n      startTask();\n      try {\n        command.run();\n      } finally {\n        endTask();\n      }\n    }\n\n    @Override\n    public boolean isShutdown() {\n      synchronized (lock) {\n        return shutdown;\n      }\n    }\n\n    @Override\n    public void shutdown() {\n      synchronized (lock) {\n        shutdown = true;\n        if (runningTasks == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n\n    // See sameThreadExecutor javadoc for unusual behavior of this method.\n    @Override\n    public List<Runnable> shutdownNow() {\n      shutdown();\n      return Collections.emptyList();\n    }\n\n    @Override\n    public boolean isTerminated() {\n      synchronized (lock) {\n        return shutdown && runningTasks == 0;\n      }\n    }\n\n    @Override\n    public boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      long nanos = unit.toNanos(timeout);\n      synchronized (lock) {\n        for (;;) {\n          if (shutdown && runningTasks == 0) {\n            return true;\n          } else if (nanos <= 0) {\n            return false;\n          } else {\n            long now = System.nanoTime();\n            TimeUnit.NANOSECONDS.timedWait(lock, nanos);\n            nanos -= System.nanoTime() - now;  // subtract the actual time we waited\n          }\n        }\n      }\n    }\n\n    /**\n     * Checks if the executor has been shut down and increments the running\n     * task count.\n     *\n     * @throws RejectedExecutionException if the executor has been previously\n     *         shutdown\n     */\n    private void startTask() {\n      synchronized (lock) {\n        if (shutdown) {\n          throw new RejectedExecutionException(\"Executor already shutdown\");\n        }\n        runningTasks++;\n      }\n    }\n\n    /**\n     * Decrements the running task count.\n     */\n    private void endTask() {\n      synchronized (lock) {\n        int numRunning = --runningTasks;\n        if (numRunning == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 18.0 (present as MoreExecutors.sameThreadExecutor() since 10.0)\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService newDirectExecutorService() {\n    return new DirectExecutorService();\n  }\n\n  /**\n   * Returns an {@link Executor} that runs each task in the thread that invokes\n   * {@link Executor#execute execute}, as in {@link CallerRunsPolicy}.\n   *\n   * <p>This instance is equivalent to: <pre>   {@code\n   *   final class DirectExecutor implements Executor {\n   *     public void execute(Runnable r) {\n   *       r.run();\n   *     }\n   *   }}</pre>\n   *\n   * <p>This should be preferred to {@link #newDirectExecutorService()} because the implementing the\n   * {@link ExecutorService} subinterface necessitates significant performance overhead.\n   *\n   * @since 18.0\n   */\n  public static Executor directExecutor() {\n    return DirectExecutor.INSTANCE;\n  }\n\n  /** See {@link #directExecutor} for behavioral notes. */\n  private enum DirectExecutor implements Executor {\n    INSTANCE;\n    @Override public void execute(Runnable command) {\n      command.run();\n    }\n\n    @Override public String toString() {\n      return \"MoreExecutors.directExecutor()\";\n    }\n  }\n\n  /**\n   * Creates an {@link ExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code ListeningExecutorService}\n   * never calls the delegate's {@code submit}, {@code invokeAll}, and {@code\n   * invokeAny} methods, so any special handling of tasks must be implemented in\n   * the delegate's {@code execute} method or by wrapping the returned {@code\n   * ListeningExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningExecutorService}, it is returned untouched, and the rest of this\n   * documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService listeningDecorator(\n      ExecutorService delegate) {\n    return (delegate instanceof ListeningExecutorService)\n        ? (ListeningExecutorService) delegate\n        : (delegate instanceof ScheduledExecutorService)\n        ? new ScheduledListeningDecorator((ScheduledExecutorService) delegate)\n        : new ListeningDecorator(delegate);\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code\n   * ListeningScheduledExecutorService} never calls the delegate's {@code\n   * submit}, {@code invokeAll}, and {@code invokeAny} methods, so any special\n   * handling of tasks must be implemented in the delegate's {@code execute}\n   * method or by wrapping the returned {@code\n   * ListeningScheduledExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningScheduledExecutorService}, it is returned untouched, and the rest\n   * of this documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningScheduledExecutorService listeningDecorator(\n      ScheduledExecutorService delegate) {\n    return (delegate instanceof ListeningScheduledExecutorService)\n        ? (ListeningScheduledExecutorService) delegate\n        : new ScheduledListeningDecorator(delegate);\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static class ListeningDecorator\n      extends AbstractListeningExecutorService {\n    private final ExecutorService delegate;\n\n    ListeningDecorator(ExecutorService delegate) {\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public final boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      return delegate.awaitTermination(timeout, unit);\n    }\n\n    @Override\n    public final boolean isShutdown() {\n      return delegate.isShutdown();\n    }\n\n    @Override\n    public final boolean isTerminated() {\n      return delegate.isTerminated();\n    }\n\n    @Override\n    public final void shutdown() {\n      delegate.shutdown();\n    }\n\n    @Override\n    public final List<Runnable> shutdownNow() {\n      return delegate.shutdownNow();\n    }\n\n    @Override\n    public final void execute(Runnable command) {\n      delegate.execute(command);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static final class ScheduledListeningDecorator\n      extends ListeningDecorator implements ListeningScheduledExecutorService {\n    @SuppressWarnings(\"hiding\")\n    final ScheduledExecutorService delegate;\n\n    ScheduledListeningDecorator(ScheduledExecutorService delegate) {\n      super(delegate);\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> schedule(\n        Runnable command, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<Void> task =\n          TrustedListenableFutureTask.create(command, null);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public <V> ListenableScheduledFuture<V> schedule(\n        Callable<V> callable, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<V>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleAtFixedRate(\n        Runnable command, long initialDelay, long period, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleAtFixedRate(task, initialDelay, period, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleWithFixedDelay(\n        Runnable command, long initialDelay, long delay, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleWithFixedDelay(task, initialDelay, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    private static final class ListenableScheduledTask<V>\n        extends SimpleForwardingListenableFuture<V>\n        implements ListenableScheduledFuture<V> {\n\n      private final ScheduledFuture<?> scheduledDelegate;\n\n      public ListenableScheduledTask(\n          ListenableFuture<V> listenableDelegate,\n          ScheduledFuture<?> scheduledDelegate) {\n        super(listenableDelegate);\n        this.scheduledDelegate = scheduledDelegate;\n      }\n\n      @Override\n      public boolean cancel(boolean mayInterruptIfRunning) {\n        boolean cancelled = super.cancel(mayInterruptIfRunning);\n        if (cancelled) {\n          // Unless it is cancelled, the delegate may continue being scheduled\n          scheduledDelegate.cancel(mayInterruptIfRunning);\n\n          // TODO(user): Cancel \"this\" if \"scheduledDelegate\" is cancelled.\n        }\n        return cancelled;\n      }\n\n      @Override\n      public long getDelay(TimeUnit unit) {\n        return scheduledDelegate.getDelay(unit);\n      }\n\n      @Override\n      public int compareTo(Delayed other) {\n        return scheduledDelegate.compareTo(other);\n      }\n    }\n\n    @GwtIncompatible(\"TODO\")\n    private static final class NeverSuccessfulListenableFutureTask\n        extends AbstractFuture<Void>\n        implements Runnable {\n      private final Runnable delegate;\n\n      public NeverSuccessfulListenableFutureTask(Runnable delegate) {\n        this.delegate = checkNotNull(delegate);\n      }\n\n      @Override public void run() {\n        try {\n          delegate.run();\n        } catch (Throwable t) {\n          setException(t);\n          throw Throwables.propagate(t);\n        }\n      }\n    }\n  }\n\n  /*\n   * This following method is a modified version of one found in\n   * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/AbstractExecutorServiceTest.java?revision=1.30\n   * which contained the following notice:\n   *\n   * Written by Doug Lea with assistance from members of JCP JSR-166\n   * Expert Group and released to the public domain, as explained at\n   * http://creativecommons.org/publicdomain/zero/1.0/\n   * Other contributors include Andrew Wright, Jeffrey Hayes,\n   * Pat Fisher, Mike Judd.\n   */\n\n  /**\n   * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}\n   * implementations.\n   */ static <T> T invokeAnyImpl(ListeningExecutorService executorService,\n      Collection<? extends Callable<T>> tasks, boolean timed, long nanos)\n          throws InterruptedException, ExecutionException, TimeoutException {\n    checkNotNull(executorService);\n    int ntasks = tasks.size();\n    checkArgument(ntasks > 0);\n    List<Future<T>> futures = Lists.newArrayListWithCapacity(ntasks);\n    BlockingQueue<Future<T>> futureQueue = Queues.newLinkedBlockingQueue();\n\n    // For efficiency, especially in executors with limited\n    // parallelism, check to see if previously submitted tasks are\n    // done before submitting more of them. This interleaving\n    // plus the exception mechanics account for messiness of main\n    // loop.\n\n    try {\n      // Record exceptions so that if we fail to obtain any\n      // result, we can throw the last exception we got.\n      ExecutionException ee = null;\n      long lastTime = timed ? System.nanoTime() : 0;\n      Iterator<? extends Callable<T>> it = tasks.iterator();\n\n      futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n      --ntasks;\n      int active = 1;\n\n      for (;;) {\n        Future<T> f = futureQueue.poll();\n        if (f == null) {\n          if (ntasks > 0) {\n            --ntasks;\n            futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n            ++active;\n          } else if (active == 0) {\n            break;\n          } else if (timed) {\n            f = futureQueue.poll(nanos, TimeUnit.NANOSECONDS);\n            if (f == null) {\n              throw new TimeoutException();\n            }\n            long now = System.nanoTime();\n            nanos -= now - lastTime;\n            lastTime = now;\n          } else {\n            f = futureQueue.take();\n          }\n        }\n        if (f != null) {\n          --active;\n          try {\n            return f.get();\n          } catch (ExecutionException eex) {\n            ee = eex;\n          } catch (RuntimeException rex) {\n            ee = new ExecutionException(rex);\n          }\n        }\n      }\n\n      if (ee == null) {\n        ee = new ExecutionException(null);\n      }\n      throw ee;\n    } finally {\n      for (Future<T> f : futures) {\n        f.cancel(true);\n      }\n    }\n  }\n\n  /**\n   * Submits the task and adds a listener that adds the future to {@code queue} when it completes.\n   */\n  @GwtIncompatible(\"TODO\")\n  private static <T> ListenableFuture<T> submitAndAddQueueListener(\n      ListeningExecutorService executorService, Callable<T> task,\n      final BlockingQueue<Future<T>> queue) {\n    final ListenableFuture<T> future = executorService.submit(task);\n    future.addListener(new Runnable() {\n      @Override public void run() {\n        queue.add(future);\n      }\n    }, directExecutor());\n    return future;\n  }\n\n  /**\n   * Returns a default thread factory used to create new threads.\n   *\n   * <p>On AppEngine, returns {@code ThreadManager.currentRequestThreadFactory()}.\n   * Otherwise, returns {@link Executors#defaultThreadFactory()}.\n   *\n   * @since 14.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ThreadFactory platformThreadFactory() {\n    if (!isAppEngine()) {\n      return Executors.defaultThreadFactory();\n    }\n    try {\n      return (ThreadFactory) Class.forName(\"com.google.appengine.api.ThreadManager\")\n          .getMethod(\"currentRequestThreadFactory\")\n          .invoke(null);\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (ClassNotFoundException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (NoSuchMethodException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (InvocationTargetException e) {\n      throw Throwables.propagate(e.getCause());\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static boolean isAppEngine() {\n    if (System.getProperty(\"com.google.appengine.runtime.environment\") == null) {\n      return false;\n    }\n    try {\n      // If the current environment is null, we're not inside AppEngine.\n      return Class.forName(\"com.google.apphosting.api.ApiProxy\")\n          .getMethod(\"getCurrentEnvironment\")\n          .invoke(null) != null;\n    } catch (ClassNotFoundException e) {\n      // If ApiProxy doesn't exist, we're not on AppEngine at all.\n      return false;\n    } catch (InvocationTargetException e) {\n      // If ApiProxy throws an exception, we're not in a proper AppEngine environment.\n      return false;\n    } catch (IllegalAccessException e) {\n      // If the method isn't accessible, we're not on a supported version of AppEngine;\n      return false;\n    } catch (NoSuchMethodException e) {\n      // If the method doesn't exist, we're not on a supported version of AppEngine;\n      return false;\n    }\n  }\n\n  /**\n   * Creates a thread using {@link #platformThreadFactory}, and sets its name to {@code name}\n   * unless changing the name is forbidden by the security manager.\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Thread newThread(String name, Runnable runnable) {\n    checkNotNull(name);\n    checkNotNull(runnable);\n    Thread result = platformThreadFactory().newThread(runnable);\n    try {\n      result.setName(name);\n    } catch (SecurityException e) {\n      // OK if we can't set the name in this environment.\n    }\n    return result;\n  }\n\n  // TODO(lukes): provide overloads for ListeningExecutorService? ListeningScheduledExecutorService?\n  // TODO(lukes): provide overloads that take constant strings? Function<Runnable, String>s to\n  // calculate names?\n\n  /**\n   * Creates an {@link Executor} that renames the {@link Thread threads} that its tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param executor The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier) {\n    checkNotNull(executor);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try\n      return executor;\n    }\n    return new Executor() {\n      @Override public void execute(Runnable command) {\n        executor.execute(Callables.threadRenaming(command, nameSupplier));\n      }\n    };\n  }\n\n  /**\n   * Creates an {@link ExecutorService} that renames the {@link Thread threads} that its tasks run\n   * in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ExecutorService renamingDecorator(final ExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} that renames the {@link Thread threads} that its\n   * tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ScheduledExecutorService renamingDecorator(final ScheduledExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingScheduledExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Shuts down the given executor gradually, first disabling new submissions and later cancelling\n   * existing tasks.\n   *\n   * <p>The method takes the following steps:\n   * <ol>\n   *  <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n   *  <li>waits for half of the specified timeout.\n   *  <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n   *  pending tasks and interrupting running tasks.\n   *  <li>waits for the other half of the specified timeout.\n   * </ol>\n   *\n   * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n   * ExecutorService#shutdownNow()} and returns.\n   *\n   * @param service the {@code ExecutorService} to shut down\n   * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n   * @param unit the time unit of the timeout argument\n   * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n   *     the call timed out or was interrupted\n   * @since 17.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static boolean shutdownAndAwaitTermination(\n      ExecutorService service, long timeout, TimeUnit unit) {\n    checkNotNull(unit);\n    // Disable new tasks from being submitted\n    service.shutdown();\n    try {\n      long halfTimeoutNanos = TimeUnit.NANOSECONDS.convert(timeout, unit) / 2;\n      // Wait for half the duration of the timeout for existing tasks to terminate\n      if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {\n        // Cancel currently executing tasks\n        service.shutdownNow();\n        // Wait the other half of the timeout for tasks to respond to being cancelled\n        service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);\n      }\n    } catch (InterruptedException ie) {\n      // Preserve interrupt status\n      Thread.currentThread().interrupt();\n      // (Re-)Cancel if current thread also interrupted\n      service.shutdownNow();\n    }\n    return service.isTerminated();\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53068306,"label":true,"oracleId":1421,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"MoreExecutors","javadocTag":"@param timeUnit unit of time for the time parameter","methodJavadoc":"    /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */","methodSourceCode":"public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit){\n    return new Application().getExitingExecutorService(executor, terminationTimeout, timeUnit);\n}","classJavadoc":"/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */","classSourceCode":"/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Queues;\nimport com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */\n@GwtCompatible(emulated = true)\npublic final class MoreExecutors {\n  private MoreExecutors() {}\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ExecutorService getExitingExecutorService(\n      ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ScheduledThreadPoolExecutor into a\n   * ScheduledExecutorService that exits when the application is complete.  It\n   * does so by using daemon threads and adding a shutdown hook to wait for\n   * their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingScheduledExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Add a shutdown hook to wait for thread completion in the given\n   * {@link ExecutorService service}.  This is useful if the given service uses\n   * daemon threads, and we want to keep the JVM from exiting immediately on\n   * shutdown, instead giving these daemon threads a chance to terminate\n   * normally.\n   * @param service ExecutorService which uses daemon threads\n   * @param terminationTimeout how long to wait for the executor to finish\n   *        before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static void addDelayedShutdownHook(\n      ExecutorService service, long terminationTimeout, TimeUnit timeUnit) {\n    new Application()\n        .addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n    return new Application().getExitingExecutorService(executor);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into a ScheduledExecutorService that\n   * exits when the application is complete.  It does so by using daemon threads\n   * and adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor) {\n    return new Application().getExitingScheduledExecutorService(executor);\n  }\n\n  /** Represents the current application to register shutdown hooks. */\n  @GwtIncompatible(\"TODO\")\n  @VisibleForTesting\n  static class Application {\n\n    final ExecutorService getExitingExecutorService(\n        ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ExecutorService service = Executors.unconfigurableExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ScheduledExecutorService service = Executors.unconfigurableScheduledExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final void addDelayedShutdownHook(\n        final ExecutorService service, final long terminationTimeout, final TimeUnit timeUnit) {\n      checkNotNull(service);\n      checkNotNull(timeUnit);\n      addShutdownHook(MoreExecutors.newThread(\"DelayedShutdownHook-for-\" + service, new Runnable() {\n        @Override\n        public void run() {\n          try {\n            // We'd like to log progress and failures that may arise in the\n            // following code, but unfortunately the behavior of logging\n            // is undefined in shutdown hooks.\n            // This is because the logging code installs a shutdown hook of its\n            // own. See Cleaner class inside {@link LogManager}.\n            service.shutdown();\n            service.awaitTermination(terminationTimeout, timeUnit);\n          } catch (InterruptedException ignored) {\n            // We're shutting down anyway, so just ignore.\n          }\n        }\n      }));\n    }\n\n    final ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n      return getExitingExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor) {\n      return getExitingScheduledExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    @VisibleForTesting void addShutdownHook(Thread hook) {\n      Runtime.getRuntime().addShutdownHook(hook);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static void useDaemonThreadFactory(ThreadPoolExecutor executor) {\n    executor.setThreadFactory(new ThreadFactoryBuilder()\n        .setDaemon(true)\n        .setThreadFactory(executor.getThreadFactory())\n        .build());\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}.  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 10.0 (<a href=\"https://github.com/google/guava/wiki/Compatibility\"\n   *        >mostly source-compatible</a> since 3.0)\n   * @deprecated Use {@link #directExecutor()} if you only require an {@link Executor} and\n   *     {@link #newDirectExecutorService()} if you need a {@link ListeningExecutorService}. This\n   *     method will be removed in August 2016.\n   */\n  @Deprecated\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService sameThreadExecutor() {\n    return new DirectExecutorService();\n  }\n\n  // See sameThreadExecutor javadoc for behavioral notes.\n  @GwtIncompatible(\"TODO\")\n  private static final class DirectExecutorService\n      extends AbstractListeningExecutorService {\n    /**\n     * Lock used whenever accessing the state variables\n     * (runningTasks, shutdown) of the executor\n     */\n    private final Object lock = new Object();\n\n    /*\n     * Conceptually, these two variables describe the executor being in\n     * one of three states:\n     *   - Active: shutdown == false\n     *   - Shutdown: runningTasks > 0 and shutdown == true\n     *   - Terminated: runningTasks == 0 and shutdown == true\n     */\n    @GuardedBy(\"lock\") private int runningTasks = 0;\n    @GuardedBy(\"lock\") private boolean shutdown = false;\n\n    @Override\n    public void execute(Runnable command) {\n      startTask();\n      try {\n        command.run();\n      } finally {\n        endTask();\n      }\n    }\n\n    @Override\n    public boolean isShutdown() {\n      synchronized (lock) {\n        return shutdown;\n      }\n    }\n\n    @Override\n    public void shutdown() {\n      synchronized (lock) {\n        shutdown = true;\n        if (runningTasks == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n\n    // See sameThreadExecutor javadoc for unusual behavior of this method.\n    @Override\n    public List<Runnable> shutdownNow() {\n      shutdown();\n      return Collections.emptyList();\n    }\n\n    @Override\n    public boolean isTerminated() {\n      synchronized (lock) {\n        return shutdown && runningTasks == 0;\n      }\n    }\n\n    @Override\n    public boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      long nanos = unit.toNanos(timeout);\n      synchronized (lock) {\n        for (;;) {\n          if (shutdown && runningTasks == 0) {\n            return true;\n          } else if (nanos <= 0) {\n            return false;\n          } else {\n            long now = System.nanoTime();\n            TimeUnit.NANOSECONDS.timedWait(lock, nanos);\n            nanos -= System.nanoTime() - now;  // subtract the actual time we waited\n          }\n        }\n      }\n    }\n\n    /**\n     * Checks if the executor has been shut down and increments the running\n     * task count.\n     *\n     * @throws RejectedExecutionException if the executor has been previously\n     *         shutdown\n     */\n    private void startTask() {\n      synchronized (lock) {\n        if (shutdown) {\n          throw new RejectedExecutionException(\"Executor already shutdown\");\n        }\n        runningTasks++;\n      }\n    }\n\n    /**\n     * Decrements the running task count.\n     */\n    private void endTask() {\n      synchronized (lock) {\n        int numRunning = --runningTasks;\n        if (numRunning == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 18.0 (present as MoreExecutors.sameThreadExecutor() since 10.0)\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService newDirectExecutorService() {\n    return new DirectExecutorService();\n  }\n\n  /**\n   * Returns an {@link Executor} that runs each task in the thread that invokes\n   * {@link Executor#execute execute}, as in {@link CallerRunsPolicy}.\n   *\n   * <p>This instance is equivalent to: <pre>   {@code\n   *   final class DirectExecutor implements Executor {\n   *     public void execute(Runnable r) {\n   *       r.run();\n   *     }\n   *   }}</pre>\n   *\n   * <p>This should be preferred to {@link #newDirectExecutorService()} because the implementing the\n   * {@link ExecutorService} subinterface necessitates significant performance overhead.\n   *\n   * @since 18.0\n   */\n  public static Executor directExecutor() {\n    return DirectExecutor.INSTANCE;\n  }\n\n  /** See {@link #directExecutor} for behavioral notes. */\n  private enum DirectExecutor implements Executor {\n    INSTANCE;\n    @Override public void execute(Runnable command) {\n      command.run();\n    }\n\n    @Override public String toString() {\n      return \"MoreExecutors.directExecutor()\";\n    }\n  }\n\n  /**\n   * Creates an {@link ExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code ListeningExecutorService}\n   * never calls the delegate's {@code submit}, {@code invokeAll}, and {@code\n   * invokeAny} methods, so any special handling of tasks must be implemented in\n   * the delegate's {@code execute} method or by wrapping the returned {@code\n   * ListeningExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningExecutorService}, it is returned untouched, and the rest of this\n   * documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService listeningDecorator(\n      ExecutorService delegate) {\n    return (delegate instanceof ListeningExecutorService)\n        ? (ListeningExecutorService) delegate\n        : (delegate instanceof ScheduledExecutorService)\n        ? new ScheduledListeningDecorator((ScheduledExecutorService) delegate)\n        : new ListeningDecorator(delegate);\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code\n   * ListeningScheduledExecutorService} never calls the delegate's {@code\n   * submit}, {@code invokeAll}, and {@code invokeAny} methods, so any special\n   * handling of tasks must be implemented in the delegate's {@code execute}\n   * method or by wrapping the returned {@code\n   * ListeningScheduledExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningScheduledExecutorService}, it is returned untouched, and the rest\n   * of this documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningScheduledExecutorService listeningDecorator(\n      ScheduledExecutorService delegate) {\n    return (delegate instanceof ListeningScheduledExecutorService)\n        ? (ListeningScheduledExecutorService) delegate\n        : new ScheduledListeningDecorator(delegate);\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static class ListeningDecorator\n      extends AbstractListeningExecutorService {\n    private final ExecutorService delegate;\n\n    ListeningDecorator(ExecutorService delegate) {\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public final boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      return delegate.awaitTermination(timeout, unit);\n    }\n\n    @Override\n    public final boolean isShutdown() {\n      return delegate.isShutdown();\n    }\n\n    @Override\n    public final boolean isTerminated() {\n      return delegate.isTerminated();\n    }\n\n    @Override\n    public final void shutdown() {\n      delegate.shutdown();\n    }\n\n    @Override\n    public final List<Runnable> shutdownNow() {\n      return delegate.shutdownNow();\n    }\n\n    @Override\n    public final void execute(Runnable command) {\n      delegate.execute(command);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static final class ScheduledListeningDecorator\n      extends ListeningDecorator implements ListeningScheduledExecutorService {\n    @SuppressWarnings(\"hiding\")\n    final ScheduledExecutorService delegate;\n\n    ScheduledListeningDecorator(ScheduledExecutorService delegate) {\n      super(delegate);\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> schedule(\n        Runnable command, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<Void> task =\n          TrustedListenableFutureTask.create(command, null);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public <V> ListenableScheduledFuture<V> schedule(\n        Callable<V> callable, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<V>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleAtFixedRate(\n        Runnable command, long initialDelay, long period, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleAtFixedRate(task, initialDelay, period, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleWithFixedDelay(\n        Runnable command, long initialDelay, long delay, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleWithFixedDelay(task, initialDelay, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    private static final class ListenableScheduledTask<V>\n        extends SimpleForwardingListenableFuture<V>\n        implements ListenableScheduledFuture<V> {\n\n      private final ScheduledFuture<?> scheduledDelegate;\n\n      public ListenableScheduledTask(\n          ListenableFuture<V> listenableDelegate,\n          ScheduledFuture<?> scheduledDelegate) {\n        super(listenableDelegate);\n        this.scheduledDelegate = scheduledDelegate;\n      }\n\n      @Override\n      public boolean cancel(boolean mayInterruptIfRunning) {\n        boolean cancelled = super.cancel(mayInterruptIfRunning);\n        if (cancelled) {\n          // Unless it is cancelled, the delegate may continue being scheduled\n          scheduledDelegate.cancel(mayInterruptIfRunning);\n\n          // TODO(user): Cancel \"this\" if \"scheduledDelegate\" is cancelled.\n        }\n        return cancelled;\n      }\n\n      @Override\n      public long getDelay(TimeUnit unit) {\n        return scheduledDelegate.getDelay(unit);\n      }\n\n      @Override\n      public int compareTo(Delayed other) {\n        return scheduledDelegate.compareTo(other);\n      }\n    }\n\n    @GwtIncompatible(\"TODO\")\n    private static final class NeverSuccessfulListenableFutureTask\n        extends AbstractFuture<Void>\n        implements Runnable {\n      private final Runnable delegate;\n\n      public NeverSuccessfulListenableFutureTask(Runnable delegate) {\n        this.delegate = checkNotNull(delegate);\n      }\n\n      @Override public void run() {\n        try {\n          delegate.run();\n        } catch (Throwable t) {\n          setException(t);\n          throw Throwables.propagate(t);\n        }\n      }\n    }\n  }\n\n  /*\n   * This following method is a modified version of one found in\n   * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/AbstractExecutorServiceTest.java?revision=1.30\n   * which contained the following notice:\n   *\n   * Written by Doug Lea with assistance from members of JCP JSR-166\n   * Expert Group and released to the public domain, as explained at\n   * http://creativecommons.org/publicdomain/zero/1.0/\n   * Other contributors include Andrew Wright, Jeffrey Hayes,\n   * Pat Fisher, Mike Judd.\n   */\n\n  /**\n   * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}\n   * implementations.\n   */ static <T> T invokeAnyImpl(ListeningExecutorService executorService,\n      Collection<? extends Callable<T>> tasks, boolean timed, long nanos)\n          throws InterruptedException, ExecutionException, TimeoutException {\n    checkNotNull(executorService);\n    int ntasks = tasks.size();\n    checkArgument(ntasks > 0);\n    List<Future<T>> futures = Lists.newArrayListWithCapacity(ntasks);\n    BlockingQueue<Future<T>> futureQueue = Queues.newLinkedBlockingQueue();\n\n    // For efficiency, especially in executors with limited\n    // parallelism, check to see if previously submitted tasks are\n    // done before submitting more of them. This interleaving\n    // plus the exception mechanics account for messiness of main\n    // loop.\n\n    try {\n      // Record exceptions so that if we fail to obtain any\n      // result, we can throw the last exception we got.\n      ExecutionException ee = null;\n      long lastTime = timed ? System.nanoTime() : 0;\n      Iterator<? extends Callable<T>> it = tasks.iterator();\n\n      futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n      --ntasks;\n      int active = 1;\n\n      for (;;) {\n        Future<T> f = futureQueue.poll();\n        if (f == null) {\n          if (ntasks > 0) {\n            --ntasks;\n            futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n            ++active;\n          } else if (active == 0) {\n            break;\n          } else if (timed) {\n            f = futureQueue.poll(nanos, TimeUnit.NANOSECONDS);\n            if (f == null) {\n              throw new TimeoutException();\n            }\n            long now = System.nanoTime();\n            nanos -= now - lastTime;\n            lastTime = now;\n          } else {\n            f = futureQueue.take();\n          }\n        }\n        if (f != null) {\n          --active;\n          try {\n            return f.get();\n          } catch (ExecutionException eex) {\n            ee = eex;\n          } catch (RuntimeException rex) {\n            ee = new ExecutionException(rex);\n          }\n        }\n      }\n\n      if (ee == null) {\n        ee = new ExecutionException(null);\n      }\n      throw ee;\n    } finally {\n      for (Future<T> f : futures) {\n        f.cancel(true);\n      }\n    }\n  }\n\n  /**\n   * Submits the task and adds a listener that adds the future to {@code queue} when it completes.\n   */\n  @GwtIncompatible(\"TODO\")\n  private static <T> ListenableFuture<T> submitAndAddQueueListener(\n      ListeningExecutorService executorService, Callable<T> task,\n      final BlockingQueue<Future<T>> queue) {\n    final ListenableFuture<T> future = executorService.submit(task);\n    future.addListener(new Runnable() {\n      @Override public void run() {\n        queue.add(future);\n      }\n    }, directExecutor());\n    return future;\n  }\n\n  /**\n   * Returns a default thread factory used to create new threads.\n   *\n   * <p>On AppEngine, returns {@code ThreadManager.currentRequestThreadFactory()}.\n   * Otherwise, returns {@link Executors#defaultThreadFactory()}.\n   *\n   * @since 14.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ThreadFactory platformThreadFactory() {\n    if (!isAppEngine()) {\n      return Executors.defaultThreadFactory();\n    }\n    try {\n      return (ThreadFactory) Class.forName(\"com.google.appengine.api.ThreadManager\")\n          .getMethod(\"currentRequestThreadFactory\")\n          .invoke(null);\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (ClassNotFoundException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (NoSuchMethodException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (InvocationTargetException e) {\n      throw Throwables.propagate(e.getCause());\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static boolean isAppEngine() {\n    if (System.getProperty(\"com.google.appengine.runtime.environment\") == null) {\n      return false;\n    }\n    try {\n      // If the current environment is null, we're not inside AppEngine.\n      return Class.forName(\"com.google.apphosting.api.ApiProxy\")\n          .getMethod(\"getCurrentEnvironment\")\n          .invoke(null) != null;\n    } catch (ClassNotFoundException e) {\n      // If ApiProxy doesn't exist, we're not on AppEngine at all.\n      return false;\n    } catch (InvocationTargetException e) {\n      // If ApiProxy throws an exception, we're not in a proper AppEngine environment.\n      return false;\n    } catch (IllegalAccessException e) {\n      // If the method isn't accessible, we're not on a supported version of AppEngine;\n      return false;\n    } catch (NoSuchMethodException e) {\n      // If the method doesn't exist, we're not on a supported version of AppEngine;\n      return false;\n    }\n  }\n\n  /**\n   * Creates a thread using {@link #platformThreadFactory}, and sets its name to {@code name}\n   * unless changing the name is forbidden by the security manager.\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Thread newThread(String name, Runnable runnable) {\n    checkNotNull(name);\n    checkNotNull(runnable);\n    Thread result = platformThreadFactory().newThread(runnable);\n    try {\n      result.setName(name);\n    } catch (SecurityException e) {\n      // OK if we can't set the name in this environment.\n    }\n    return result;\n  }\n\n  // TODO(lukes): provide overloads for ListeningExecutorService? ListeningScheduledExecutorService?\n  // TODO(lukes): provide overloads that take constant strings? Function<Runnable, String>s to\n  // calculate names?\n\n  /**\n   * Creates an {@link Executor} that renames the {@link Thread threads} that its tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param executor The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier) {\n    checkNotNull(executor);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try\n      return executor;\n    }\n    return new Executor() {\n      @Override public void execute(Runnable command) {\n        executor.execute(Callables.threadRenaming(command, nameSupplier));\n      }\n    };\n  }\n\n  /**\n   * Creates an {@link ExecutorService} that renames the {@link Thread threads} that its tasks run\n   * in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ExecutorService renamingDecorator(final ExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} that renames the {@link Thread threads} that its\n   * tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ScheduledExecutorService renamingDecorator(final ScheduledExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingScheduledExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Shuts down the given executor gradually, first disabling new submissions and later cancelling\n   * existing tasks.\n   *\n   * <p>The method takes the following steps:\n   * <ol>\n   *  <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n   *  <li>waits for half of the specified timeout.\n   *  <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n   *  pending tasks and interrupting running tasks.\n   *  <li>waits for the other half of the specified timeout.\n   * </ol>\n   *\n   * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n   * ExecutorService#shutdownNow()} and returns.\n   *\n   * @param service the {@code ExecutorService} to shut down\n   * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n   * @param unit the time unit of the timeout argument\n   * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n   *     the call timed out or was interrupted\n   * @since 17.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static boolean shutdownAndAwaitTermination(\n      ExecutorService service, long timeout, TimeUnit unit) {\n    checkNotNull(unit);\n    // Disable new tasks from being submitted\n    service.shutdown();\n    try {\n      long halfTimeoutNanos = TimeUnit.NANOSECONDS.convert(timeout, unit) / 2;\n      // Wait for half the duration of the timeout for existing tasks to terminate\n      if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {\n        // Cancel currently executing tasks\n        service.shutdownNow();\n        // Wait the other half of the timeout for tasks to respond to being cancelled\n        service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);\n      }\n    } catch (InterruptedException ie) {\n      // Preserve interrupt status\n      Thread.currentThread().interrupt();\n      // (Re-)Cancel if current thread also interrupted\n      service.shutdownNow();\n    }\n    return service.isTerminated();\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53068766,"label":true,"oracleId":1422,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"MoreExecutors","javadocTag":"@return an unmodifiable version of the input which will not hang the JVM","methodJavadoc":"    /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */","methodSourceCode":"public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit){\n    return new Application().getExitingExecutorService(executor, terminationTimeout, timeUnit);\n}","classJavadoc":"/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */","classSourceCode":"/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Queues;\nimport com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */\n@GwtCompatible(emulated = true)\npublic final class MoreExecutors {\n  private MoreExecutors() {}\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ExecutorService getExitingExecutorService(\n      ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ScheduledThreadPoolExecutor into a\n   * ScheduledExecutorService that exits when the application is complete.  It\n   * does so by using daemon threads and adding a shutdown hook to wait for\n   * their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingScheduledExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Add a shutdown hook to wait for thread completion in the given\n   * {@link ExecutorService service}.  This is useful if the given service uses\n   * daemon threads, and we want to keep the JVM from exiting immediately on\n   * shutdown, instead giving these daemon threads a chance to terminate\n   * normally.\n   * @param service ExecutorService which uses daemon threads\n   * @param terminationTimeout how long to wait for the executor to finish\n   *        before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static void addDelayedShutdownHook(\n      ExecutorService service, long terminationTimeout, TimeUnit timeUnit) {\n    new Application()\n        .addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n    return new Application().getExitingExecutorService(executor);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into a ScheduledExecutorService that\n   * exits when the application is complete.  It does so by using daemon threads\n   * and adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor) {\n    return new Application().getExitingScheduledExecutorService(executor);\n  }\n\n  /** Represents the current application to register shutdown hooks. */\n  @GwtIncompatible(\"TODO\")\n  @VisibleForTesting\n  static class Application {\n\n    final ExecutorService getExitingExecutorService(\n        ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ExecutorService service = Executors.unconfigurableExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ScheduledExecutorService service = Executors.unconfigurableScheduledExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final void addDelayedShutdownHook(\n        final ExecutorService service, final long terminationTimeout, final TimeUnit timeUnit) {\n      checkNotNull(service);\n      checkNotNull(timeUnit);\n      addShutdownHook(MoreExecutors.newThread(\"DelayedShutdownHook-for-\" + service, new Runnable() {\n        @Override\n        public void run() {\n          try {\n            // We'd like to log progress and failures that may arise in the\n            // following code, but unfortunately the behavior of logging\n            // is undefined in shutdown hooks.\n            // This is because the logging code installs a shutdown hook of its\n            // own. See Cleaner class inside {@link LogManager}.\n            service.shutdown();\n            service.awaitTermination(terminationTimeout, timeUnit);\n          } catch (InterruptedException ignored) {\n            // We're shutting down anyway, so just ignore.\n          }\n        }\n      }));\n    }\n\n    final ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n      return getExitingExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor) {\n      return getExitingScheduledExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    @VisibleForTesting void addShutdownHook(Thread hook) {\n      Runtime.getRuntime().addShutdownHook(hook);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static void useDaemonThreadFactory(ThreadPoolExecutor executor) {\n    executor.setThreadFactory(new ThreadFactoryBuilder()\n        .setDaemon(true)\n        .setThreadFactory(executor.getThreadFactory())\n        .build());\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}.  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 10.0 (<a href=\"https://github.com/google/guava/wiki/Compatibility\"\n   *        >mostly source-compatible</a> since 3.0)\n   * @deprecated Use {@link #directExecutor()} if you only require an {@link Executor} and\n   *     {@link #newDirectExecutorService()} if you need a {@link ListeningExecutorService}. This\n   *     method will be removed in August 2016.\n   */\n  @Deprecated\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService sameThreadExecutor() {\n    return new DirectExecutorService();\n  }\n\n  // See sameThreadExecutor javadoc for behavioral notes.\n  @GwtIncompatible(\"TODO\")\n  private static final class DirectExecutorService\n      extends AbstractListeningExecutorService {\n    /**\n     * Lock used whenever accessing the state variables\n     * (runningTasks, shutdown) of the executor\n     */\n    private final Object lock = new Object();\n\n    /*\n     * Conceptually, these two variables describe the executor being in\n     * one of three states:\n     *   - Active: shutdown == false\n     *   - Shutdown: runningTasks > 0 and shutdown == true\n     *   - Terminated: runningTasks == 0 and shutdown == true\n     */\n    @GuardedBy(\"lock\") private int runningTasks = 0;\n    @GuardedBy(\"lock\") private boolean shutdown = false;\n\n    @Override\n    public void execute(Runnable command) {\n      startTask();\n      try {\n        command.run();\n      } finally {\n        endTask();\n      }\n    }\n\n    @Override\n    public boolean isShutdown() {\n      synchronized (lock) {\n        return shutdown;\n      }\n    }\n\n    @Override\n    public void shutdown() {\n      synchronized (lock) {\n        shutdown = true;\n        if (runningTasks == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n\n    // See sameThreadExecutor javadoc for unusual behavior of this method.\n    @Override\n    public List<Runnable> shutdownNow() {\n      shutdown();\n      return Collections.emptyList();\n    }\n\n    @Override\n    public boolean isTerminated() {\n      synchronized (lock) {\n        return shutdown && runningTasks == 0;\n      }\n    }\n\n    @Override\n    public boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      long nanos = unit.toNanos(timeout);\n      synchronized (lock) {\n        for (;;) {\n          if (shutdown && runningTasks == 0) {\n            return true;\n          } else if (nanos <= 0) {\n            return false;\n          } else {\n            long now = System.nanoTime();\n            TimeUnit.NANOSECONDS.timedWait(lock, nanos);\n            nanos -= System.nanoTime() - now;  // subtract the actual time we waited\n          }\n        }\n      }\n    }\n\n    /**\n     * Checks if the executor has been shut down and increments the running\n     * task count.\n     *\n     * @throws RejectedExecutionException if the executor has been previously\n     *         shutdown\n     */\n    private void startTask() {\n      synchronized (lock) {\n        if (shutdown) {\n          throw new RejectedExecutionException(\"Executor already shutdown\");\n        }\n        runningTasks++;\n      }\n    }\n\n    /**\n     * Decrements the running task count.\n     */\n    private void endTask() {\n      synchronized (lock) {\n        int numRunning = --runningTasks;\n        if (numRunning == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 18.0 (present as MoreExecutors.sameThreadExecutor() since 10.0)\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService newDirectExecutorService() {\n    return new DirectExecutorService();\n  }\n\n  /**\n   * Returns an {@link Executor} that runs each task in the thread that invokes\n   * {@link Executor#execute execute}, as in {@link CallerRunsPolicy}.\n   *\n   * <p>This instance is equivalent to: <pre>   {@code\n   *   final class DirectExecutor implements Executor {\n   *     public void execute(Runnable r) {\n   *       r.run();\n   *     }\n   *   }}</pre>\n   *\n   * <p>This should be preferred to {@link #newDirectExecutorService()} because the implementing the\n   * {@link ExecutorService} subinterface necessitates significant performance overhead.\n   *\n   * @since 18.0\n   */\n  public static Executor directExecutor() {\n    return DirectExecutor.INSTANCE;\n  }\n\n  /** See {@link #directExecutor} for behavioral notes. */\n  private enum DirectExecutor implements Executor {\n    INSTANCE;\n    @Override public void execute(Runnable command) {\n      command.run();\n    }\n\n    @Override public String toString() {\n      return \"MoreExecutors.directExecutor()\";\n    }\n  }\n\n  /**\n   * Creates an {@link ExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code ListeningExecutorService}\n   * never calls the delegate's {@code submit}, {@code invokeAll}, and {@code\n   * invokeAny} methods, so any special handling of tasks must be implemented in\n   * the delegate's {@code execute} method or by wrapping the returned {@code\n   * ListeningExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningExecutorService}, it is returned untouched, and the rest of this\n   * documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService listeningDecorator(\n      ExecutorService delegate) {\n    return (delegate instanceof ListeningExecutorService)\n        ? (ListeningExecutorService) delegate\n        : (delegate instanceof ScheduledExecutorService)\n        ? new ScheduledListeningDecorator((ScheduledExecutorService) delegate)\n        : new ListeningDecorator(delegate);\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code\n   * ListeningScheduledExecutorService} never calls the delegate's {@code\n   * submit}, {@code invokeAll}, and {@code invokeAny} methods, so any special\n   * handling of tasks must be implemented in the delegate's {@code execute}\n   * method or by wrapping the returned {@code\n   * ListeningScheduledExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningScheduledExecutorService}, it is returned untouched, and the rest\n   * of this documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningScheduledExecutorService listeningDecorator(\n      ScheduledExecutorService delegate) {\n    return (delegate instanceof ListeningScheduledExecutorService)\n        ? (ListeningScheduledExecutorService) delegate\n        : new ScheduledListeningDecorator(delegate);\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static class ListeningDecorator\n      extends AbstractListeningExecutorService {\n    private final ExecutorService delegate;\n\n    ListeningDecorator(ExecutorService delegate) {\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public final boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      return delegate.awaitTermination(timeout, unit);\n    }\n\n    @Override\n    public final boolean isShutdown() {\n      return delegate.isShutdown();\n    }\n\n    @Override\n    public final boolean isTerminated() {\n      return delegate.isTerminated();\n    }\n\n    @Override\n    public final void shutdown() {\n      delegate.shutdown();\n    }\n\n    @Override\n    public final List<Runnable> shutdownNow() {\n      return delegate.shutdownNow();\n    }\n\n    @Override\n    public final void execute(Runnable command) {\n      delegate.execute(command);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static final class ScheduledListeningDecorator\n      extends ListeningDecorator implements ListeningScheduledExecutorService {\n    @SuppressWarnings(\"hiding\")\n    final ScheduledExecutorService delegate;\n\n    ScheduledListeningDecorator(ScheduledExecutorService delegate) {\n      super(delegate);\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> schedule(\n        Runnable command, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<Void> task =\n          TrustedListenableFutureTask.create(command, null);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public <V> ListenableScheduledFuture<V> schedule(\n        Callable<V> callable, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<V>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleAtFixedRate(\n        Runnable command, long initialDelay, long period, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleAtFixedRate(task, initialDelay, period, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleWithFixedDelay(\n        Runnable command, long initialDelay, long delay, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleWithFixedDelay(task, initialDelay, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    private static final class ListenableScheduledTask<V>\n        extends SimpleForwardingListenableFuture<V>\n        implements ListenableScheduledFuture<V> {\n\n      private final ScheduledFuture<?> scheduledDelegate;\n\n      public ListenableScheduledTask(\n          ListenableFuture<V> listenableDelegate,\n          ScheduledFuture<?> scheduledDelegate) {\n        super(listenableDelegate);\n        this.scheduledDelegate = scheduledDelegate;\n      }\n\n      @Override\n      public boolean cancel(boolean mayInterruptIfRunning) {\n        boolean cancelled = super.cancel(mayInterruptIfRunning);\n        if (cancelled) {\n          // Unless it is cancelled, the delegate may continue being scheduled\n          scheduledDelegate.cancel(mayInterruptIfRunning);\n\n          // TODO(user): Cancel \"this\" if \"scheduledDelegate\" is cancelled.\n        }\n        return cancelled;\n      }\n\n      @Override\n      public long getDelay(TimeUnit unit) {\n        return scheduledDelegate.getDelay(unit);\n      }\n\n      @Override\n      public int compareTo(Delayed other) {\n        return scheduledDelegate.compareTo(other);\n      }\n    }\n\n    @GwtIncompatible(\"TODO\")\n    private static final class NeverSuccessfulListenableFutureTask\n        extends AbstractFuture<Void>\n        implements Runnable {\n      private final Runnable delegate;\n\n      public NeverSuccessfulListenableFutureTask(Runnable delegate) {\n        this.delegate = checkNotNull(delegate);\n      }\n\n      @Override public void run() {\n        try {\n          delegate.run();\n        } catch (Throwable t) {\n          setException(t);\n          throw Throwables.propagate(t);\n        }\n      }\n    }\n  }\n\n  /*\n   * This following method is a modified version of one found in\n   * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/AbstractExecutorServiceTest.java?revision=1.30\n   * which contained the following notice:\n   *\n   * Written by Doug Lea with assistance from members of JCP JSR-166\n   * Expert Group and released to the public domain, as explained at\n   * http://creativecommons.org/publicdomain/zero/1.0/\n   * Other contributors include Andrew Wright, Jeffrey Hayes,\n   * Pat Fisher, Mike Judd.\n   */\n\n  /**\n   * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}\n   * implementations.\n   */ static <T> T invokeAnyImpl(ListeningExecutorService executorService,\n      Collection<? extends Callable<T>> tasks, boolean timed, long nanos)\n          throws InterruptedException, ExecutionException, TimeoutException {\n    checkNotNull(executorService);\n    int ntasks = tasks.size();\n    checkArgument(ntasks > 0);\n    List<Future<T>> futures = Lists.newArrayListWithCapacity(ntasks);\n    BlockingQueue<Future<T>> futureQueue = Queues.newLinkedBlockingQueue();\n\n    // For efficiency, especially in executors with limited\n    // parallelism, check to see if previously submitted tasks are\n    // done before submitting more of them. This interleaving\n    // plus the exception mechanics account for messiness of main\n    // loop.\n\n    try {\n      // Record exceptions so that if we fail to obtain any\n      // result, we can throw the last exception we got.\n      ExecutionException ee = null;\n      long lastTime = timed ? System.nanoTime() : 0;\n      Iterator<? extends Callable<T>> it = tasks.iterator();\n\n      futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n      --ntasks;\n      int active = 1;\n\n      for (;;) {\n        Future<T> f = futureQueue.poll();\n        if (f == null) {\n          if (ntasks > 0) {\n            --ntasks;\n            futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n            ++active;\n          } else if (active == 0) {\n            break;\n          } else if (timed) {\n            f = futureQueue.poll(nanos, TimeUnit.NANOSECONDS);\n            if (f == null) {\n              throw new TimeoutException();\n            }\n            long now = System.nanoTime();\n            nanos -= now - lastTime;\n            lastTime = now;\n          } else {\n            f = futureQueue.take();\n          }\n        }\n        if (f != null) {\n          --active;\n          try {\n            return f.get();\n          } catch (ExecutionException eex) {\n            ee = eex;\n          } catch (RuntimeException rex) {\n            ee = new ExecutionException(rex);\n          }\n        }\n      }\n\n      if (ee == null) {\n        ee = new ExecutionException(null);\n      }\n      throw ee;\n    } finally {\n      for (Future<T> f : futures) {\n        f.cancel(true);\n      }\n    }\n  }\n\n  /**\n   * Submits the task and adds a listener that adds the future to {@code queue} when it completes.\n   */\n  @GwtIncompatible(\"TODO\")\n  private static <T> ListenableFuture<T> submitAndAddQueueListener(\n      ListeningExecutorService executorService, Callable<T> task,\n      final BlockingQueue<Future<T>> queue) {\n    final ListenableFuture<T> future = executorService.submit(task);\n    future.addListener(new Runnable() {\n      @Override public void run() {\n        queue.add(future);\n      }\n    }, directExecutor());\n    return future;\n  }\n\n  /**\n   * Returns a default thread factory used to create new threads.\n   *\n   * <p>On AppEngine, returns {@code ThreadManager.currentRequestThreadFactory()}.\n   * Otherwise, returns {@link Executors#defaultThreadFactory()}.\n   *\n   * @since 14.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ThreadFactory platformThreadFactory() {\n    if (!isAppEngine()) {\n      return Executors.defaultThreadFactory();\n    }\n    try {\n      return (ThreadFactory) Class.forName(\"com.google.appengine.api.ThreadManager\")\n          .getMethod(\"currentRequestThreadFactory\")\n          .invoke(null);\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (ClassNotFoundException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (NoSuchMethodException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (InvocationTargetException e) {\n      throw Throwables.propagate(e.getCause());\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static boolean isAppEngine() {\n    if (System.getProperty(\"com.google.appengine.runtime.environment\") == null) {\n      return false;\n    }\n    try {\n      // If the current environment is null, we're not inside AppEngine.\n      return Class.forName(\"com.google.apphosting.api.ApiProxy\")\n          .getMethod(\"getCurrentEnvironment\")\n          .invoke(null) != null;\n    } catch (ClassNotFoundException e) {\n      // If ApiProxy doesn't exist, we're not on AppEngine at all.\n      return false;\n    } catch (InvocationTargetException e) {\n      // If ApiProxy throws an exception, we're not in a proper AppEngine environment.\n      return false;\n    } catch (IllegalAccessException e) {\n      // If the method isn't accessible, we're not on a supported version of AppEngine;\n      return false;\n    } catch (NoSuchMethodException e) {\n      // If the method doesn't exist, we're not on a supported version of AppEngine;\n      return false;\n    }\n  }\n\n  /**\n   * Creates a thread using {@link #platformThreadFactory}, and sets its name to {@code name}\n   * unless changing the name is forbidden by the security manager.\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Thread newThread(String name, Runnable runnable) {\n    checkNotNull(name);\n    checkNotNull(runnable);\n    Thread result = platformThreadFactory().newThread(runnable);\n    try {\n      result.setName(name);\n    } catch (SecurityException e) {\n      // OK if we can't set the name in this environment.\n    }\n    return result;\n  }\n\n  // TODO(lukes): provide overloads for ListeningExecutorService? ListeningScheduledExecutorService?\n  // TODO(lukes): provide overloads that take constant strings? Function<Runnable, String>s to\n  // calculate names?\n\n  /**\n   * Creates an {@link Executor} that renames the {@link Thread threads} that its tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param executor The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier) {\n    checkNotNull(executor);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try\n      return executor;\n    }\n    return new Executor() {\n      @Override public void execute(Runnable command) {\n        executor.execute(Callables.threadRenaming(command, nameSupplier));\n      }\n    };\n  }\n\n  /**\n   * Creates an {@link ExecutorService} that renames the {@link Thread threads} that its tasks run\n   * in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ExecutorService renamingDecorator(final ExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} that renames the {@link Thread threads} that its\n   * tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ScheduledExecutorService renamingDecorator(final ScheduledExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingScheduledExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Shuts down the given executor gradually, first disabling new submissions and later cancelling\n   * existing tasks.\n   *\n   * <p>The method takes the following steps:\n   * <ol>\n   *  <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n   *  <li>waits for half of the specified timeout.\n   *  <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n   *  pending tasks and interrupting running tasks.\n   *  <li>waits for the other half of the specified timeout.\n   * </ol>\n   *\n   * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n   * ExecutorService#shutdownNow()} and returns.\n   *\n   * @param service the {@code ExecutorService} to shut down\n   * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n   * @param unit the time unit of the timeout argument\n   * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n   *     the call timed out or was interrupted\n   * @since 17.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static boolean shutdownAndAwaitTermination(\n      ExecutorService service, long timeout, TimeUnit unit) {\n    checkNotNull(unit);\n    // Disable new tasks from being submitted\n    service.shutdown();\n    try {\n      long halfTimeoutNanos = TimeUnit.NANOSECONDS.convert(timeout, unit) / 2;\n      // Wait for half the duration of the timeout for existing tasks to terminate\n      if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {\n        // Cancel currently executing tasks\n        service.shutdownNow();\n        // Wait the other half of the timeout for tasks to respond to being cancelled\n        service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);\n      }\n    } catch (InterruptedException ie) {\n      // Preserve interrupt status\n      Thread.currentThread().interrupt();\n      // (Re-)Cancel if current thread also interrupted\n      service.shutdownNow();\n    }\n    return service.isTerminated();\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53069225,"label":true,"oracleId":1423,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"MoreExecutors","javadocTag":"@param executor the executor to modify to make sure it exits when the\n       application is finished","methodJavadoc":"    /**\n   * Converts the given ScheduledThreadPoolExecutor into a\n   * ScheduledExecutorService that exits when the application is complete.  It\n   * does so by using daemon threads and adding a shutdown hook to wait for\n   * their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */","methodSourceCode":"public static ScheduledExecutorService getExitingScheduledExecutorService(ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit){\n    return new Application().getExitingScheduledExecutorService(executor, terminationTimeout, timeUnit);\n}","classJavadoc":"/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */","classSourceCode":"/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Queues;\nimport com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */\n@GwtCompatible(emulated = true)\npublic final class MoreExecutors {\n  private MoreExecutors() {}\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ExecutorService getExitingExecutorService(\n      ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ScheduledThreadPoolExecutor into a\n   * ScheduledExecutorService that exits when the application is complete.  It\n   * does so by using daemon threads and adding a shutdown hook to wait for\n   * their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingScheduledExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Add a shutdown hook to wait for thread completion in the given\n   * {@link ExecutorService service}.  This is useful if the given service uses\n   * daemon threads, and we want to keep the JVM from exiting immediately on\n   * shutdown, instead giving these daemon threads a chance to terminate\n   * normally.\n   * @param service ExecutorService which uses daemon threads\n   * @param terminationTimeout how long to wait for the executor to finish\n   *        before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static void addDelayedShutdownHook(\n      ExecutorService service, long terminationTimeout, TimeUnit timeUnit) {\n    new Application()\n        .addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n    return new Application().getExitingExecutorService(executor);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into a ScheduledExecutorService that\n   * exits when the application is complete.  It does so by using daemon threads\n   * and adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor) {\n    return new Application().getExitingScheduledExecutorService(executor);\n  }\n\n  /** Represents the current application to register shutdown hooks. */\n  @GwtIncompatible(\"TODO\")\n  @VisibleForTesting\n  static class Application {\n\n    final ExecutorService getExitingExecutorService(\n        ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ExecutorService service = Executors.unconfigurableExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ScheduledExecutorService service = Executors.unconfigurableScheduledExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final void addDelayedShutdownHook(\n        final ExecutorService service, final long terminationTimeout, final TimeUnit timeUnit) {\n      checkNotNull(service);\n      checkNotNull(timeUnit);\n      addShutdownHook(MoreExecutors.newThread(\"DelayedShutdownHook-for-\" + service, new Runnable() {\n        @Override\n        public void run() {\n          try {\n            // We'd like to log progress and failures that may arise in the\n            // following code, but unfortunately the behavior of logging\n            // is undefined in shutdown hooks.\n            // This is because the logging code installs a shutdown hook of its\n            // own. See Cleaner class inside {@link LogManager}.\n            service.shutdown();\n            service.awaitTermination(terminationTimeout, timeUnit);\n          } catch (InterruptedException ignored) {\n            // We're shutting down anyway, so just ignore.\n          }\n        }\n      }));\n    }\n\n    final ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n      return getExitingExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor) {\n      return getExitingScheduledExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    @VisibleForTesting void addShutdownHook(Thread hook) {\n      Runtime.getRuntime().addShutdownHook(hook);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static void useDaemonThreadFactory(ThreadPoolExecutor executor) {\n    executor.setThreadFactory(new ThreadFactoryBuilder()\n        .setDaemon(true)\n        .setThreadFactory(executor.getThreadFactory())\n        .build());\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}.  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 10.0 (<a href=\"https://github.com/google/guava/wiki/Compatibility\"\n   *        >mostly source-compatible</a> since 3.0)\n   * @deprecated Use {@link #directExecutor()} if you only require an {@link Executor} and\n   *     {@link #newDirectExecutorService()} if you need a {@link ListeningExecutorService}. This\n   *     method will be removed in August 2016.\n   */\n  @Deprecated\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService sameThreadExecutor() {\n    return new DirectExecutorService();\n  }\n\n  // See sameThreadExecutor javadoc for behavioral notes.\n  @GwtIncompatible(\"TODO\")\n  private static final class DirectExecutorService\n      extends AbstractListeningExecutorService {\n    /**\n     * Lock used whenever accessing the state variables\n     * (runningTasks, shutdown) of the executor\n     */\n    private final Object lock = new Object();\n\n    /*\n     * Conceptually, these two variables describe the executor being in\n     * one of three states:\n     *   - Active: shutdown == false\n     *   - Shutdown: runningTasks > 0 and shutdown == true\n     *   - Terminated: runningTasks == 0 and shutdown == true\n     */\n    @GuardedBy(\"lock\") private int runningTasks = 0;\n    @GuardedBy(\"lock\") private boolean shutdown = false;\n\n    @Override\n    public void execute(Runnable command) {\n      startTask();\n      try {\n        command.run();\n      } finally {\n        endTask();\n      }\n    }\n\n    @Override\n    public boolean isShutdown() {\n      synchronized (lock) {\n        return shutdown;\n      }\n    }\n\n    @Override\n    public void shutdown() {\n      synchronized (lock) {\n        shutdown = true;\n        if (runningTasks == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n\n    // See sameThreadExecutor javadoc for unusual behavior of this method.\n    @Override\n    public List<Runnable> shutdownNow() {\n      shutdown();\n      return Collections.emptyList();\n    }\n\n    @Override\n    public boolean isTerminated() {\n      synchronized (lock) {\n        return shutdown && runningTasks == 0;\n      }\n    }\n\n    @Override\n    public boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      long nanos = unit.toNanos(timeout);\n      synchronized (lock) {\n        for (;;) {\n          if (shutdown && runningTasks == 0) {\n            return true;\n          } else if (nanos <= 0) {\n            return false;\n          } else {\n            long now = System.nanoTime();\n            TimeUnit.NANOSECONDS.timedWait(lock, nanos);\n            nanos -= System.nanoTime() - now;  // subtract the actual time we waited\n          }\n        }\n      }\n    }\n\n    /**\n     * Checks if the executor has been shut down and increments the running\n     * task count.\n     *\n     * @throws RejectedExecutionException if the executor has been previously\n     *         shutdown\n     */\n    private void startTask() {\n      synchronized (lock) {\n        if (shutdown) {\n          throw new RejectedExecutionException(\"Executor already shutdown\");\n        }\n        runningTasks++;\n      }\n    }\n\n    /**\n     * Decrements the running task count.\n     */\n    private void endTask() {\n      synchronized (lock) {\n        int numRunning = --runningTasks;\n        if (numRunning == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 18.0 (present as MoreExecutors.sameThreadExecutor() since 10.0)\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService newDirectExecutorService() {\n    return new DirectExecutorService();\n  }\n\n  /**\n   * Returns an {@link Executor} that runs each task in the thread that invokes\n   * {@link Executor#execute execute}, as in {@link CallerRunsPolicy}.\n   *\n   * <p>This instance is equivalent to: <pre>   {@code\n   *   final class DirectExecutor implements Executor {\n   *     public void execute(Runnable r) {\n   *       r.run();\n   *     }\n   *   }}</pre>\n   *\n   * <p>This should be preferred to {@link #newDirectExecutorService()} because the implementing the\n   * {@link ExecutorService} subinterface necessitates significant performance overhead.\n   *\n   * @since 18.0\n   */\n  public static Executor directExecutor() {\n    return DirectExecutor.INSTANCE;\n  }\n\n  /** See {@link #directExecutor} for behavioral notes. */\n  private enum DirectExecutor implements Executor {\n    INSTANCE;\n    @Override public void execute(Runnable command) {\n      command.run();\n    }\n\n    @Override public String toString() {\n      return \"MoreExecutors.directExecutor()\";\n    }\n  }\n\n  /**\n   * Creates an {@link ExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code ListeningExecutorService}\n   * never calls the delegate's {@code submit}, {@code invokeAll}, and {@code\n   * invokeAny} methods, so any special handling of tasks must be implemented in\n   * the delegate's {@code execute} method or by wrapping the returned {@code\n   * ListeningExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningExecutorService}, it is returned untouched, and the rest of this\n   * documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService listeningDecorator(\n      ExecutorService delegate) {\n    return (delegate instanceof ListeningExecutorService)\n        ? (ListeningExecutorService) delegate\n        : (delegate instanceof ScheduledExecutorService)\n        ? new ScheduledListeningDecorator((ScheduledExecutorService) delegate)\n        : new ListeningDecorator(delegate);\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code\n   * ListeningScheduledExecutorService} never calls the delegate's {@code\n   * submit}, {@code invokeAll}, and {@code invokeAny} methods, so any special\n   * handling of tasks must be implemented in the delegate's {@code execute}\n   * method or by wrapping the returned {@code\n   * ListeningScheduledExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningScheduledExecutorService}, it is returned untouched, and the rest\n   * of this documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningScheduledExecutorService listeningDecorator(\n      ScheduledExecutorService delegate) {\n    return (delegate instanceof ListeningScheduledExecutorService)\n        ? (ListeningScheduledExecutorService) delegate\n        : new ScheduledListeningDecorator(delegate);\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static class ListeningDecorator\n      extends AbstractListeningExecutorService {\n    private final ExecutorService delegate;\n\n    ListeningDecorator(ExecutorService delegate) {\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public final boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      return delegate.awaitTermination(timeout, unit);\n    }\n\n    @Override\n    public final boolean isShutdown() {\n      return delegate.isShutdown();\n    }\n\n    @Override\n    public final boolean isTerminated() {\n      return delegate.isTerminated();\n    }\n\n    @Override\n    public final void shutdown() {\n      delegate.shutdown();\n    }\n\n    @Override\n    public final List<Runnable> shutdownNow() {\n      return delegate.shutdownNow();\n    }\n\n    @Override\n    public final void execute(Runnable command) {\n      delegate.execute(command);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static final class ScheduledListeningDecorator\n      extends ListeningDecorator implements ListeningScheduledExecutorService {\n    @SuppressWarnings(\"hiding\")\n    final ScheduledExecutorService delegate;\n\n    ScheduledListeningDecorator(ScheduledExecutorService delegate) {\n      super(delegate);\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> schedule(\n        Runnable command, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<Void> task =\n          TrustedListenableFutureTask.create(command, null);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public <V> ListenableScheduledFuture<V> schedule(\n        Callable<V> callable, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<V>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleAtFixedRate(\n        Runnable command, long initialDelay, long period, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleAtFixedRate(task, initialDelay, period, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleWithFixedDelay(\n        Runnable command, long initialDelay, long delay, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleWithFixedDelay(task, initialDelay, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    private static final class ListenableScheduledTask<V>\n        extends SimpleForwardingListenableFuture<V>\n        implements ListenableScheduledFuture<V> {\n\n      private final ScheduledFuture<?> scheduledDelegate;\n\n      public ListenableScheduledTask(\n          ListenableFuture<V> listenableDelegate,\n          ScheduledFuture<?> scheduledDelegate) {\n        super(listenableDelegate);\n        this.scheduledDelegate = scheduledDelegate;\n      }\n\n      @Override\n      public boolean cancel(boolean mayInterruptIfRunning) {\n        boolean cancelled = super.cancel(mayInterruptIfRunning);\n        if (cancelled) {\n          // Unless it is cancelled, the delegate may continue being scheduled\n          scheduledDelegate.cancel(mayInterruptIfRunning);\n\n          // TODO(user): Cancel \"this\" if \"scheduledDelegate\" is cancelled.\n        }\n        return cancelled;\n      }\n\n      @Override\n      public long getDelay(TimeUnit unit) {\n        return scheduledDelegate.getDelay(unit);\n      }\n\n      @Override\n      public int compareTo(Delayed other) {\n        return scheduledDelegate.compareTo(other);\n      }\n    }\n\n    @GwtIncompatible(\"TODO\")\n    private static final class NeverSuccessfulListenableFutureTask\n        extends AbstractFuture<Void>\n        implements Runnable {\n      private final Runnable delegate;\n\n      public NeverSuccessfulListenableFutureTask(Runnable delegate) {\n        this.delegate = checkNotNull(delegate);\n      }\n\n      @Override public void run() {\n        try {\n          delegate.run();\n        } catch (Throwable t) {\n          setException(t);\n          throw Throwables.propagate(t);\n        }\n      }\n    }\n  }\n\n  /*\n   * This following method is a modified version of one found in\n   * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/AbstractExecutorServiceTest.java?revision=1.30\n   * which contained the following notice:\n   *\n   * Written by Doug Lea with assistance from members of JCP JSR-166\n   * Expert Group and released to the public domain, as explained at\n   * http://creativecommons.org/publicdomain/zero/1.0/\n   * Other contributors include Andrew Wright, Jeffrey Hayes,\n   * Pat Fisher, Mike Judd.\n   */\n\n  /**\n   * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}\n   * implementations.\n   */ static <T> T invokeAnyImpl(ListeningExecutorService executorService,\n      Collection<? extends Callable<T>> tasks, boolean timed, long nanos)\n          throws InterruptedException, ExecutionException, TimeoutException {\n    checkNotNull(executorService);\n    int ntasks = tasks.size();\n    checkArgument(ntasks > 0);\n    List<Future<T>> futures = Lists.newArrayListWithCapacity(ntasks);\n    BlockingQueue<Future<T>> futureQueue = Queues.newLinkedBlockingQueue();\n\n    // For efficiency, especially in executors with limited\n    // parallelism, check to see if previously submitted tasks are\n    // done before submitting more of them. This interleaving\n    // plus the exception mechanics account for messiness of main\n    // loop.\n\n    try {\n      // Record exceptions so that if we fail to obtain any\n      // result, we can throw the last exception we got.\n      ExecutionException ee = null;\n      long lastTime = timed ? System.nanoTime() : 0;\n      Iterator<? extends Callable<T>> it = tasks.iterator();\n\n      futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n      --ntasks;\n      int active = 1;\n\n      for (;;) {\n        Future<T> f = futureQueue.poll();\n        if (f == null) {\n          if (ntasks > 0) {\n            --ntasks;\n            futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n            ++active;\n          } else if (active == 0) {\n            break;\n          } else if (timed) {\n            f = futureQueue.poll(nanos, TimeUnit.NANOSECONDS);\n            if (f == null) {\n              throw new TimeoutException();\n            }\n            long now = System.nanoTime();\n            nanos -= now - lastTime;\n            lastTime = now;\n          } else {\n            f = futureQueue.take();\n          }\n        }\n        if (f != null) {\n          --active;\n          try {\n            return f.get();\n          } catch (ExecutionException eex) {\n            ee = eex;\n          } catch (RuntimeException rex) {\n            ee = new ExecutionException(rex);\n          }\n        }\n      }\n\n      if (ee == null) {\n        ee = new ExecutionException(null);\n      }\n      throw ee;\n    } finally {\n      for (Future<T> f : futures) {\n        f.cancel(true);\n      }\n    }\n  }\n\n  /**\n   * Submits the task and adds a listener that adds the future to {@code queue} when it completes.\n   */\n  @GwtIncompatible(\"TODO\")\n  private static <T> ListenableFuture<T> submitAndAddQueueListener(\n      ListeningExecutorService executorService, Callable<T> task,\n      final BlockingQueue<Future<T>> queue) {\n    final ListenableFuture<T> future = executorService.submit(task);\n    future.addListener(new Runnable() {\n      @Override public void run() {\n        queue.add(future);\n      }\n    }, directExecutor());\n    return future;\n  }\n\n  /**\n   * Returns a default thread factory used to create new threads.\n   *\n   * <p>On AppEngine, returns {@code ThreadManager.currentRequestThreadFactory()}.\n   * Otherwise, returns {@link Executors#defaultThreadFactory()}.\n   *\n   * @since 14.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ThreadFactory platformThreadFactory() {\n    if (!isAppEngine()) {\n      return Executors.defaultThreadFactory();\n    }\n    try {\n      return (ThreadFactory) Class.forName(\"com.google.appengine.api.ThreadManager\")\n          .getMethod(\"currentRequestThreadFactory\")\n          .invoke(null);\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (ClassNotFoundException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (NoSuchMethodException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (InvocationTargetException e) {\n      throw Throwables.propagate(e.getCause());\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static boolean isAppEngine() {\n    if (System.getProperty(\"com.google.appengine.runtime.environment\") == null) {\n      return false;\n    }\n    try {\n      // If the current environment is null, we're not inside AppEngine.\n      return Class.forName(\"com.google.apphosting.api.ApiProxy\")\n          .getMethod(\"getCurrentEnvironment\")\n          .invoke(null) != null;\n    } catch (ClassNotFoundException e) {\n      // If ApiProxy doesn't exist, we're not on AppEngine at all.\n      return false;\n    } catch (InvocationTargetException e) {\n      // If ApiProxy throws an exception, we're not in a proper AppEngine environment.\n      return false;\n    } catch (IllegalAccessException e) {\n      // If the method isn't accessible, we're not on a supported version of AppEngine;\n      return false;\n    } catch (NoSuchMethodException e) {\n      // If the method doesn't exist, we're not on a supported version of AppEngine;\n      return false;\n    }\n  }\n\n  /**\n   * Creates a thread using {@link #platformThreadFactory}, and sets its name to {@code name}\n   * unless changing the name is forbidden by the security manager.\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Thread newThread(String name, Runnable runnable) {\n    checkNotNull(name);\n    checkNotNull(runnable);\n    Thread result = platformThreadFactory().newThread(runnable);\n    try {\n      result.setName(name);\n    } catch (SecurityException e) {\n      // OK if we can't set the name in this environment.\n    }\n    return result;\n  }\n\n  // TODO(lukes): provide overloads for ListeningExecutorService? ListeningScheduledExecutorService?\n  // TODO(lukes): provide overloads that take constant strings? Function<Runnable, String>s to\n  // calculate names?\n\n  /**\n   * Creates an {@link Executor} that renames the {@link Thread threads} that its tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param executor The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier) {\n    checkNotNull(executor);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try\n      return executor;\n    }\n    return new Executor() {\n      @Override public void execute(Runnable command) {\n        executor.execute(Callables.threadRenaming(command, nameSupplier));\n      }\n    };\n  }\n\n  /**\n   * Creates an {@link ExecutorService} that renames the {@link Thread threads} that its tasks run\n   * in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ExecutorService renamingDecorator(final ExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} that renames the {@link Thread threads} that its\n   * tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ScheduledExecutorService renamingDecorator(final ScheduledExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingScheduledExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Shuts down the given executor gradually, first disabling new submissions and later cancelling\n   * existing tasks.\n   *\n   * <p>The method takes the following steps:\n   * <ol>\n   *  <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n   *  <li>waits for half of the specified timeout.\n   *  <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n   *  pending tasks and interrupting running tasks.\n   *  <li>waits for the other half of the specified timeout.\n   * </ol>\n   *\n   * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n   * ExecutorService#shutdownNow()} and returns.\n   *\n   * @param service the {@code ExecutorService} to shut down\n   * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n   * @param unit the time unit of the timeout argument\n   * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n   *     the call timed out or was interrupted\n   * @since 17.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static boolean shutdownAndAwaitTermination(\n      ExecutorService service, long timeout, TimeUnit unit) {\n    checkNotNull(unit);\n    // Disable new tasks from being submitted\n    service.shutdown();\n    try {\n      long halfTimeoutNanos = TimeUnit.NANOSECONDS.convert(timeout, unit) / 2;\n      // Wait for half the duration of the timeout for existing tasks to terminate\n      if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {\n        // Cancel currently executing tasks\n        service.shutdownNow();\n        // Wait the other half of the timeout for tasks to respond to being cancelled\n        service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);\n      }\n    } catch (InterruptedException ie) {\n      // Preserve interrupt status\n      Thread.currentThread().interrupt();\n      // (Re-)Cancel if current thread also interrupted\n      service.shutdownNow();\n    }\n    return service.isTerminated();\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53069684,"label":true,"oracleId":1424,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"MoreExecutors","javadocTag":"@param terminationTimeout how long to wait for the executor to\n       finish before terminating the JVM","methodJavadoc":"    /**\n   * Converts the given ScheduledThreadPoolExecutor into a\n   * ScheduledExecutorService that exits when the application is complete.  It\n   * does so by using daemon threads and adding a shutdown hook to wait for\n   * their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */","methodSourceCode":"public static ScheduledExecutorService getExitingScheduledExecutorService(ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit){\n    return new Application().getExitingScheduledExecutorService(executor, terminationTimeout, timeUnit);\n}","classJavadoc":"/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */","classSourceCode":"/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Queues;\nimport com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */\n@GwtCompatible(emulated = true)\npublic final class MoreExecutors {\n  private MoreExecutors() {}\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ExecutorService getExitingExecutorService(\n      ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ScheduledThreadPoolExecutor into a\n   * ScheduledExecutorService that exits when the application is complete.  It\n   * does so by using daemon threads and adding a shutdown hook to wait for\n   * their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingScheduledExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Add a shutdown hook to wait for thread completion in the given\n   * {@link ExecutorService service}.  This is useful if the given service uses\n   * daemon threads, and we want to keep the JVM from exiting immediately on\n   * shutdown, instead giving these daemon threads a chance to terminate\n   * normally.\n   * @param service ExecutorService which uses daemon threads\n   * @param terminationTimeout how long to wait for the executor to finish\n   *        before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static void addDelayedShutdownHook(\n      ExecutorService service, long terminationTimeout, TimeUnit timeUnit) {\n    new Application()\n        .addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n    return new Application().getExitingExecutorService(executor);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into a ScheduledExecutorService that\n   * exits when the application is complete.  It does so by using daemon threads\n   * and adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor) {\n    return new Application().getExitingScheduledExecutorService(executor);\n  }\n\n  /** Represents the current application to register shutdown hooks. */\n  @GwtIncompatible(\"TODO\")\n  @VisibleForTesting\n  static class Application {\n\n    final ExecutorService getExitingExecutorService(\n        ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ExecutorService service = Executors.unconfigurableExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ScheduledExecutorService service = Executors.unconfigurableScheduledExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final void addDelayedShutdownHook(\n        final ExecutorService service, final long terminationTimeout, final TimeUnit timeUnit) {\n      checkNotNull(service);\n      checkNotNull(timeUnit);\n      addShutdownHook(MoreExecutors.newThread(\"DelayedShutdownHook-for-\" + service, new Runnable() {\n        @Override\n        public void run() {\n          try {\n            // We'd like to log progress and failures that may arise in the\n            // following code, but unfortunately the behavior of logging\n            // is undefined in shutdown hooks.\n            // This is because the logging code installs a shutdown hook of its\n            // own. See Cleaner class inside {@link LogManager}.\n            service.shutdown();\n            service.awaitTermination(terminationTimeout, timeUnit);\n          } catch (InterruptedException ignored) {\n            // We're shutting down anyway, so just ignore.\n          }\n        }\n      }));\n    }\n\n    final ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n      return getExitingExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor) {\n      return getExitingScheduledExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    @VisibleForTesting void addShutdownHook(Thread hook) {\n      Runtime.getRuntime().addShutdownHook(hook);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static void useDaemonThreadFactory(ThreadPoolExecutor executor) {\n    executor.setThreadFactory(new ThreadFactoryBuilder()\n        .setDaemon(true)\n        .setThreadFactory(executor.getThreadFactory())\n        .build());\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}.  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 10.0 (<a href=\"https://github.com/google/guava/wiki/Compatibility\"\n   *        >mostly source-compatible</a> since 3.0)\n   * @deprecated Use {@link #directExecutor()} if you only require an {@link Executor} and\n   *     {@link #newDirectExecutorService()} if you need a {@link ListeningExecutorService}. This\n   *     method will be removed in August 2016.\n   */\n  @Deprecated\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService sameThreadExecutor() {\n    return new DirectExecutorService();\n  }\n\n  // See sameThreadExecutor javadoc for behavioral notes.\n  @GwtIncompatible(\"TODO\")\n  private static final class DirectExecutorService\n      extends AbstractListeningExecutorService {\n    /**\n     * Lock used whenever accessing the state variables\n     * (runningTasks, shutdown) of the executor\n     */\n    private final Object lock = new Object();\n\n    /*\n     * Conceptually, these two variables describe the executor being in\n     * one of three states:\n     *   - Active: shutdown == false\n     *   - Shutdown: runningTasks > 0 and shutdown == true\n     *   - Terminated: runningTasks == 0 and shutdown == true\n     */\n    @GuardedBy(\"lock\") private int runningTasks = 0;\n    @GuardedBy(\"lock\") private boolean shutdown = false;\n\n    @Override\n    public void execute(Runnable command) {\n      startTask();\n      try {\n        command.run();\n      } finally {\n        endTask();\n      }\n    }\n\n    @Override\n    public boolean isShutdown() {\n      synchronized (lock) {\n        return shutdown;\n      }\n    }\n\n    @Override\n    public void shutdown() {\n      synchronized (lock) {\n        shutdown = true;\n        if (runningTasks == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n\n    // See sameThreadExecutor javadoc for unusual behavior of this method.\n    @Override\n    public List<Runnable> shutdownNow() {\n      shutdown();\n      return Collections.emptyList();\n    }\n\n    @Override\n    public boolean isTerminated() {\n      synchronized (lock) {\n        return shutdown && runningTasks == 0;\n      }\n    }\n\n    @Override\n    public boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      long nanos = unit.toNanos(timeout);\n      synchronized (lock) {\n        for (;;) {\n          if (shutdown && runningTasks == 0) {\n            return true;\n          } else if (nanos <= 0) {\n            return false;\n          } else {\n            long now = System.nanoTime();\n            TimeUnit.NANOSECONDS.timedWait(lock, nanos);\n            nanos -= System.nanoTime() - now;  // subtract the actual time we waited\n          }\n        }\n      }\n    }\n\n    /**\n     * Checks if the executor has been shut down and increments the running\n     * task count.\n     *\n     * @throws RejectedExecutionException if the executor has been previously\n     *         shutdown\n     */\n    private void startTask() {\n      synchronized (lock) {\n        if (shutdown) {\n          throw new RejectedExecutionException(\"Executor already shutdown\");\n        }\n        runningTasks++;\n      }\n    }\n\n    /**\n     * Decrements the running task count.\n     */\n    private void endTask() {\n      synchronized (lock) {\n        int numRunning = --runningTasks;\n        if (numRunning == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 18.0 (present as MoreExecutors.sameThreadExecutor() since 10.0)\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService newDirectExecutorService() {\n    return new DirectExecutorService();\n  }\n\n  /**\n   * Returns an {@link Executor} that runs each task in the thread that invokes\n   * {@link Executor#execute execute}, as in {@link CallerRunsPolicy}.\n   *\n   * <p>This instance is equivalent to: <pre>   {@code\n   *   final class DirectExecutor implements Executor {\n   *     public void execute(Runnable r) {\n   *       r.run();\n   *     }\n   *   }}</pre>\n   *\n   * <p>This should be preferred to {@link #newDirectExecutorService()} because the implementing the\n   * {@link ExecutorService} subinterface necessitates significant performance overhead.\n   *\n   * @since 18.0\n   */\n  public static Executor directExecutor() {\n    return DirectExecutor.INSTANCE;\n  }\n\n  /** See {@link #directExecutor} for behavioral notes. */\n  private enum DirectExecutor implements Executor {\n    INSTANCE;\n    @Override public void execute(Runnable command) {\n      command.run();\n    }\n\n    @Override public String toString() {\n      return \"MoreExecutors.directExecutor()\";\n    }\n  }\n\n  /**\n   * Creates an {@link ExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code ListeningExecutorService}\n   * never calls the delegate's {@code submit}, {@code invokeAll}, and {@code\n   * invokeAny} methods, so any special handling of tasks must be implemented in\n   * the delegate's {@code execute} method or by wrapping the returned {@code\n   * ListeningExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningExecutorService}, it is returned untouched, and the rest of this\n   * documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService listeningDecorator(\n      ExecutorService delegate) {\n    return (delegate instanceof ListeningExecutorService)\n        ? (ListeningExecutorService) delegate\n        : (delegate instanceof ScheduledExecutorService)\n        ? new ScheduledListeningDecorator((ScheduledExecutorService) delegate)\n        : new ListeningDecorator(delegate);\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code\n   * ListeningScheduledExecutorService} never calls the delegate's {@code\n   * submit}, {@code invokeAll}, and {@code invokeAny} methods, so any special\n   * handling of tasks must be implemented in the delegate's {@code execute}\n   * method or by wrapping the returned {@code\n   * ListeningScheduledExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningScheduledExecutorService}, it is returned untouched, and the rest\n   * of this documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningScheduledExecutorService listeningDecorator(\n      ScheduledExecutorService delegate) {\n    return (delegate instanceof ListeningScheduledExecutorService)\n        ? (ListeningScheduledExecutorService) delegate\n        : new ScheduledListeningDecorator(delegate);\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static class ListeningDecorator\n      extends AbstractListeningExecutorService {\n    private final ExecutorService delegate;\n\n    ListeningDecorator(ExecutorService delegate) {\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public final boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      return delegate.awaitTermination(timeout, unit);\n    }\n\n    @Override\n    public final boolean isShutdown() {\n      return delegate.isShutdown();\n    }\n\n    @Override\n    public final boolean isTerminated() {\n      return delegate.isTerminated();\n    }\n\n    @Override\n    public final void shutdown() {\n      delegate.shutdown();\n    }\n\n    @Override\n    public final List<Runnable> shutdownNow() {\n      return delegate.shutdownNow();\n    }\n\n    @Override\n    public final void execute(Runnable command) {\n      delegate.execute(command);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static final class ScheduledListeningDecorator\n      extends ListeningDecorator implements ListeningScheduledExecutorService {\n    @SuppressWarnings(\"hiding\")\n    final ScheduledExecutorService delegate;\n\n    ScheduledListeningDecorator(ScheduledExecutorService delegate) {\n      super(delegate);\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> schedule(\n        Runnable command, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<Void> task =\n          TrustedListenableFutureTask.create(command, null);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public <V> ListenableScheduledFuture<V> schedule(\n        Callable<V> callable, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<V>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleAtFixedRate(\n        Runnable command, long initialDelay, long period, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleAtFixedRate(task, initialDelay, period, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleWithFixedDelay(\n        Runnable command, long initialDelay, long delay, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleWithFixedDelay(task, initialDelay, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    private static final class ListenableScheduledTask<V>\n        extends SimpleForwardingListenableFuture<V>\n        implements ListenableScheduledFuture<V> {\n\n      private final ScheduledFuture<?> scheduledDelegate;\n\n      public ListenableScheduledTask(\n          ListenableFuture<V> listenableDelegate,\n          ScheduledFuture<?> scheduledDelegate) {\n        super(listenableDelegate);\n        this.scheduledDelegate = scheduledDelegate;\n      }\n\n      @Override\n      public boolean cancel(boolean mayInterruptIfRunning) {\n        boolean cancelled = super.cancel(mayInterruptIfRunning);\n        if (cancelled) {\n          // Unless it is cancelled, the delegate may continue being scheduled\n          scheduledDelegate.cancel(mayInterruptIfRunning);\n\n          // TODO(user): Cancel \"this\" if \"scheduledDelegate\" is cancelled.\n        }\n        return cancelled;\n      }\n\n      @Override\n      public long getDelay(TimeUnit unit) {\n        return scheduledDelegate.getDelay(unit);\n      }\n\n      @Override\n      public int compareTo(Delayed other) {\n        return scheduledDelegate.compareTo(other);\n      }\n    }\n\n    @GwtIncompatible(\"TODO\")\n    private static final class NeverSuccessfulListenableFutureTask\n        extends AbstractFuture<Void>\n        implements Runnable {\n      private final Runnable delegate;\n\n      public NeverSuccessfulListenableFutureTask(Runnable delegate) {\n        this.delegate = checkNotNull(delegate);\n      }\n\n      @Override public void run() {\n        try {\n          delegate.run();\n        } catch (Throwable t) {\n          setException(t);\n          throw Throwables.propagate(t);\n        }\n      }\n    }\n  }\n\n  /*\n   * This following method is a modified version of one found in\n   * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/AbstractExecutorServiceTest.java?revision=1.30\n   * which contained the following notice:\n   *\n   * Written by Doug Lea with assistance from members of JCP JSR-166\n   * Expert Group and released to the public domain, as explained at\n   * http://creativecommons.org/publicdomain/zero/1.0/\n   * Other contributors include Andrew Wright, Jeffrey Hayes,\n   * Pat Fisher, Mike Judd.\n   */\n\n  /**\n   * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}\n   * implementations.\n   */ static <T> T invokeAnyImpl(ListeningExecutorService executorService,\n      Collection<? extends Callable<T>> tasks, boolean timed, long nanos)\n          throws InterruptedException, ExecutionException, TimeoutException {\n    checkNotNull(executorService);\n    int ntasks = tasks.size();\n    checkArgument(ntasks > 0);\n    List<Future<T>> futures = Lists.newArrayListWithCapacity(ntasks);\n    BlockingQueue<Future<T>> futureQueue = Queues.newLinkedBlockingQueue();\n\n    // For efficiency, especially in executors with limited\n    // parallelism, check to see if previously submitted tasks are\n    // done before submitting more of them. This interleaving\n    // plus the exception mechanics account for messiness of main\n    // loop.\n\n    try {\n      // Record exceptions so that if we fail to obtain any\n      // result, we can throw the last exception we got.\n      ExecutionException ee = null;\n      long lastTime = timed ? System.nanoTime() : 0;\n      Iterator<? extends Callable<T>> it = tasks.iterator();\n\n      futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n      --ntasks;\n      int active = 1;\n\n      for (;;) {\n        Future<T> f = futureQueue.poll();\n        if (f == null) {\n          if (ntasks > 0) {\n            --ntasks;\n            futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n            ++active;\n          } else if (active == 0) {\n            break;\n          } else if (timed) {\n            f = futureQueue.poll(nanos, TimeUnit.NANOSECONDS);\n            if (f == null) {\n              throw new TimeoutException();\n            }\n            long now = System.nanoTime();\n            nanos -= now - lastTime;\n            lastTime = now;\n          } else {\n            f = futureQueue.take();\n          }\n        }\n        if (f != null) {\n          --active;\n          try {\n            return f.get();\n          } catch (ExecutionException eex) {\n            ee = eex;\n          } catch (RuntimeException rex) {\n            ee = new ExecutionException(rex);\n          }\n        }\n      }\n\n      if (ee == null) {\n        ee = new ExecutionException(null);\n      }\n      throw ee;\n    } finally {\n      for (Future<T> f : futures) {\n        f.cancel(true);\n      }\n    }\n  }\n\n  /**\n   * Submits the task and adds a listener that adds the future to {@code queue} when it completes.\n   */\n  @GwtIncompatible(\"TODO\")\n  private static <T> ListenableFuture<T> submitAndAddQueueListener(\n      ListeningExecutorService executorService, Callable<T> task,\n      final BlockingQueue<Future<T>> queue) {\n    final ListenableFuture<T> future = executorService.submit(task);\n    future.addListener(new Runnable() {\n      @Override public void run() {\n        queue.add(future);\n      }\n    }, directExecutor());\n    return future;\n  }\n\n  /**\n   * Returns a default thread factory used to create new threads.\n   *\n   * <p>On AppEngine, returns {@code ThreadManager.currentRequestThreadFactory()}.\n   * Otherwise, returns {@link Executors#defaultThreadFactory()}.\n   *\n   * @since 14.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ThreadFactory platformThreadFactory() {\n    if (!isAppEngine()) {\n      return Executors.defaultThreadFactory();\n    }\n    try {\n      return (ThreadFactory) Class.forName(\"com.google.appengine.api.ThreadManager\")\n          .getMethod(\"currentRequestThreadFactory\")\n          .invoke(null);\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (ClassNotFoundException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (NoSuchMethodException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (InvocationTargetException e) {\n      throw Throwables.propagate(e.getCause());\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static boolean isAppEngine() {\n    if (System.getProperty(\"com.google.appengine.runtime.environment\") == null) {\n      return false;\n    }\n    try {\n      // If the current environment is null, we're not inside AppEngine.\n      return Class.forName(\"com.google.apphosting.api.ApiProxy\")\n          .getMethod(\"getCurrentEnvironment\")\n          .invoke(null) != null;\n    } catch (ClassNotFoundException e) {\n      // If ApiProxy doesn't exist, we're not on AppEngine at all.\n      return false;\n    } catch (InvocationTargetException e) {\n      // If ApiProxy throws an exception, we're not in a proper AppEngine environment.\n      return false;\n    } catch (IllegalAccessException e) {\n      // If the method isn't accessible, we're not on a supported version of AppEngine;\n      return false;\n    } catch (NoSuchMethodException e) {\n      // If the method doesn't exist, we're not on a supported version of AppEngine;\n      return false;\n    }\n  }\n\n  /**\n   * Creates a thread using {@link #platformThreadFactory}, and sets its name to {@code name}\n   * unless changing the name is forbidden by the security manager.\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Thread newThread(String name, Runnable runnable) {\n    checkNotNull(name);\n    checkNotNull(runnable);\n    Thread result = platformThreadFactory().newThread(runnable);\n    try {\n      result.setName(name);\n    } catch (SecurityException e) {\n      // OK if we can't set the name in this environment.\n    }\n    return result;\n  }\n\n  // TODO(lukes): provide overloads for ListeningExecutorService? ListeningScheduledExecutorService?\n  // TODO(lukes): provide overloads that take constant strings? Function<Runnable, String>s to\n  // calculate names?\n\n  /**\n   * Creates an {@link Executor} that renames the {@link Thread threads} that its tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param executor The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier) {\n    checkNotNull(executor);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try\n      return executor;\n    }\n    return new Executor() {\n      @Override public void execute(Runnable command) {\n        executor.execute(Callables.threadRenaming(command, nameSupplier));\n      }\n    };\n  }\n\n  /**\n   * Creates an {@link ExecutorService} that renames the {@link Thread threads} that its tasks run\n   * in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ExecutorService renamingDecorator(final ExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} that renames the {@link Thread threads} that its\n   * tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ScheduledExecutorService renamingDecorator(final ScheduledExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingScheduledExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Shuts down the given executor gradually, first disabling new submissions and later cancelling\n   * existing tasks.\n   *\n   * <p>The method takes the following steps:\n   * <ol>\n   *  <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n   *  <li>waits for half of the specified timeout.\n   *  <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n   *  pending tasks and interrupting running tasks.\n   *  <li>waits for the other half of the specified timeout.\n   * </ol>\n   *\n   * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n   * ExecutorService#shutdownNow()} and returns.\n   *\n   * @param service the {@code ExecutorService} to shut down\n   * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n   * @param unit the time unit of the timeout argument\n   * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n   *     the call timed out or was interrupted\n   * @since 17.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static boolean shutdownAndAwaitTermination(\n      ExecutorService service, long timeout, TimeUnit unit) {\n    checkNotNull(unit);\n    // Disable new tasks from being submitted\n    service.shutdown();\n    try {\n      long halfTimeoutNanos = TimeUnit.NANOSECONDS.convert(timeout, unit) / 2;\n      // Wait for half the duration of the timeout for existing tasks to terminate\n      if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {\n        // Cancel currently executing tasks\n        service.shutdownNow();\n        // Wait the other half of the timeout for tasks to respond to being cancelled\n        service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);\n      }\n    } catch (InterruptedException ie) {\n      // Preserve interrupt status\n      Thread.currentThread().interrupt();\n      // (Re-)Cancel if current thread also interrupted\n      service.shutdownNow();\n    }\n    return service.isTerminated();\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53070143,"label":true,"oracleId":1425,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"MoreExecutors","javadocTag":"@param timeUnit unit of time for the time parameter","methodJavadoc":"    /**\n   * Converts the given ScheduledThreadPoolExecutor into a\n   * ScheduledExecutorService that exits when the application is complete.  It\n   * does so by using daemon threads and adding a shutdown hook to wait for\n   * their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */","methodSourceCode":"public static ScheduledExecutorService getExitingScheduledExecutorService(ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit){\n    return new Application().getExitingScheduledExecutorService(executor, terminationTimeout, timeUnit);\n}","classJavadoc":"/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */","classSourceCode":"/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Queues;\nimport com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */\n@GwtCompatible(emulated = true)\npublic final class MoreExecutors {\n  private MoreExecutors() {}\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ExecutorService getExitingExecutorService(\n      ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ScheduledThreadPoolExecutor into a\n   * ScheduledExecutorService that exits when the application is complete.  It\n   * does so by using daemon threads and adding a shutdown hook to wait for\n   * their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingScheduledExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Add a shutdown hook to wait for thread completion in the given\n   * {@link ExecutorService service}.  This is useful if the given service uses\n   * daemon threads, and we want to keep the JVM from exiting immediately on\n   * shutdown, instead giving these daemon threads a chance to terminate\n   * normally.\n   * @param service ExecutorService which uses daemon threads\n   * @param terminationTimeout how long to wait for the executor to finish\n   *        before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static void addDelayedShutdownHook(\n      ExecutorService service, long terminationTimeout, TimeUnit timeUnit) {\n    new Application()\n        .addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n    return new Application().getExitingExecutorService(executor);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into a ScheduledExecutorService that\n   * exits when the application is complete.  It does so by using daemon threads\n   * and adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor) {\n    return new Application().getExitingScheduledExecutorService(executor);\n  }\n\n  /** Represents the current application to register shutdown hooks. */\n  @GwtIncompatible(\"TODO\")\n  @VisibleForTesting\n  static class Application {\n\n    final ExecutorService getExitingExecutorService(\n        ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ExecutorService service = Executors.unconfigurableExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ScheduledExecutorService service = Executors.unconfigurableScheduledExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final void addDelayedShutdownHook(\n        final ExecutorService service, final long terminationTimeout, final TimeUnit timeUnit) {\n      checkNotNull(service);\n      checkNotNull(timeUnit);\n      addShutdownHook(MoreExecutors.newThread(\"DelayedShutdownHook-for-\" + service, new Runnable() {\n        @Override\n        public void run() {\n          try {\n            // We'd like to log progress and failures that may arise in the\n            // following code, but unfortunately the behavior of logging\n            // is undefined in shutdown hooks.\n            // This is because the logging code installs a shutdown hook of its\n            // own. See Cleaner class inside {@link LogManager}.\n            service.shutdown();\n            service.awaitTermination(terminationTimeout, timeUnit);\n          } catch (InterruptedException ignored) {\n            // We're shutting down anyway, so just ignore.\n          }\n        }\n      }));\n    }\n\n    final ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n      return getExitingExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor) {\n      return getExitingScheduledExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    @VisibleForTesting void addShutdownHook(Thread hook) {\n      Runtime.getRuntime().addShutdownHook(hook);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static void useDaemonThreadFactory(ThreadPoolExecutor executor) {\n    executor.setThreadFactory(new ThreadFactoryBuilder()\n        .setDaemon(true)\n        .setThreadFactory(executor.getThreadFactory())\n        .build());\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}.  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 10.0 (<a href=\"https://github.com/google/guava/wiki/Compatibility\"\n   *        >mostly source-compatible</a> since 3.0)\n   * @deprecated Use {@link #directExecutor()} if you only require an {@link Executor} and\n   *     {@link #newDirectExecutorService()} if you need a {@link ListeningExecutorService}. This\n   *     method will be removed in August 2016.\n   */\n  @Deprecated\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService sameThreadExecutor() {\n    return new DirectExecutorService();\n  }\n\n  // See sameThreadExecutor javadoc for behavioral notes.\n  @GwtIncompatible(\"TODO\")\n  private static final class DirectExecutorService\n      extends AbstractListeningExecutorService {\n    /**\n     * Lock used whenever accessing the state variables\n     * (runningTasks, shutdown) of the executor\n     */\n    private final Object lock = new Object();\n\n    /*\n     * Conceptually, these two variables describe the executor being in\n     * one of three states:\n     *   - Active: shutdown == false\n     *   - Shutdown: runningTasks > 0 and shutdown == true\n     *   - Terminated: runningTasks == 0 and shutdown == true\n     */\n    @GuardedBy(\"lock\") private int runningTasks = 0;\n    @GuardedBy(\"lock\") private boolean shutdown = false;\n\n    @Override\n    public void execute(Runnable command) {\n      startTask();\n      try {\n        command.run();\n      } finally {\n        endTask();\n      }\n    }\n\n    @Override\n    public boolean isShutdown() {\n      synchronized (lock) {\n        return shutdown;\n      }\n    }\n\n    @Override\n    public void shutdown() {\n      synchronized (lock) {\n        shutdown = true;\n        if (runningTasks == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n\n    // See sameThreadExecutor javadoc for unusual behavior of this method.\n    @Override\n    public List<Runnable> shutdownNow() {\n      shutdown();\n      return Collections.emptyList();\n    }\n\n    @Override\n    public boolean isTerminated() {\n      synchronized (lock) {\n        return shutdown && runningTasks == 0;\n      }\n    }\n\n    @Override\n    public boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      long nanos = unit.toNanos(timeout);\n      synchronized (lock) {\n        for (;;) {\n          if (shutdown && runningTasks == 0) {\n            return true;\n          } else if (nanos <= 0) {\n            return false;\n          } else {\n            long now = System.nanoTime();\n            TimeUnit.NANOSECONDS.timedWait(lock, nanos);\n            nanos -= System.nanoTime() - now;  // subtract the actual time we waited\n          }\n        }\n      }\n    }\n\n    /**\n     * Checks if the executor has been shut down and increments the running\n     * task count.\n     *\n     * @throws RejectedExecutionException if the executor has been previously\n     *         shutdown\n     */\n    private void startTask() {\n      synchronized (lock) {\n        if (shutdown) {\n          throw new RejectedExecutionException(\"Executor already shutdown\");\n        }\n        runningTasks++;\n      }\n    }\n\n    /**\n     * Decrements the running task count.\n     */\n    private void endTask() {\n      synchronized (lock) {\n        int numRunning = --runningTasks;\n        if (numRunning == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 18.0 (present as MoreExecutors.sameThreadExecutor() since 10.0)\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService newDirectExecutorService() {\n    return new DirectExecutorService();\n  }\n\n  /**\n   * Returns an {@link Executor} that runs each task in the thread that invokes\n   * {@link Executor#execute execute}, as in {@link CallerRunsPolicy}.\n   *\n   * <p>This instance is equivalent to: <pre>   {@code\n   *   final class DirectExecutor implements Executor {\n   *     public void execute(Runnable r) {\n   *       r.run();\n   *     }\n   *   }}</pre>\n   *\n   * <p>This should be preferred to {@link #newDirectExecutorService()} because the implementing the\n   * {@link ExecutorService} subinterface necessitates significant performance overhead.\n   *\n   * @since 18.0\n   */\n  public static Executor directExecutor() {\n    return DirectExecutor.INSTANCE;\n  }\n\n  /** See {@link #directExecutor} for behavioral notes. */\n  private enum DirectExecutor implements Executor {\n    INSTANCE;\n    @Override public void execute(Runnable command) {\n      command.run();\n    }\n\n    @Override public String toString() {\n      return \"MoreExecutors.directExecutor()\";\n    }\n  }\n\n  /**\n   * Creates an {@link ExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code ListeningExecutorService}\n   * never calls the delegate's {@code submit}, {@code invokeAll}, and {@code\n   * invokeAny} methods, so any special handling of tasks must be implemented in\n   * the delegate's {@code execute} method or by wrapping the returned {@code\n   * ListeningExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningExecutorService}, it is returned untouched, and the rest of this\n   * documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService listeningDecorator(\n      ExecutorService delegate) {\n    return (delegate instanceof ListeningExecutorService)\n        ? (ListeningExecutorService) delegate\n        : (delegate instanceof ScheduledExecutorService)\n        ? new ScheduledListeningDecorator((ScheduledExecutorService) delegate)\n        : new ListeningDecorator(delegate);\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code\n   * ListeningScheduledExecutorService} never calls the delegate's {@code\n   * submit}, {@code invokeAll}, and {@code invokeAny} methods, so any special\n   * handling of tasks must be implemented in the delegate's {@code execute}\n   * method or by wrapping the returned {@code\n   * ListeningScheduledExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningScheduledExecutorService}, it is returned untouched, and the rest\n   * of this documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningScheduledExecutorService listeningDecorator(\n      ScheduledExecutorService delegate) {\n    return (delegate instanceof ListeningScheduledExecutorService)\n        ? (ListeningScheduledExecutorService) delegate\n        : new ScheduledListeningDecorator(delegate);\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static class ListeningDecorator\n      extends AbstractListeningExecutorService {\n    private final ExecutorService delegate;\n\n    ListeningDecorator(ExecutorService delegate) {\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public final boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      return delegate.awaitTermination(timeout, unit);\n    }\n\n    @Override\n    public final boolean isShutdown() {\n      return delegate.isShutdown();\n    }\n\n    @Override\n    public final boolean isTerminated() {\n      return delegate.isTerminated();\n    }\n\n    @Override\n    public final void shutdown() {\n      delegate.shutdown();\n    }\n\n    @Override\n    public final List<Runnable> shutdownNow() {\n      return delegate.shutdownNow();\n    }\n\n    @Override\n    public final void execute(Runnable command) {\n      delegate.execute(command);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static final class ScheduledListeningDecorator\n      extends ListeningDecorator implements ListeningScheduledExecutorService {\n    @SuppressWarnings(\"hiding\")\n    final ScheduledExecutorService delegate;\n\n    ScheduledListeningDecorator(ScheduledExecutorService delegate) {\n      super(delegate);\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> schedule(\n        Runnable command, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<Void> task =\n          TrustedListenableFutureTask.create(command, null);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public <V> ListenableScheduledFuture<V> schedule(\n        Callable<V> callable, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<V>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleAtFixedRate(\n        Runnable command, long initialDelay, long period, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleAtFixedRate(task, initialDelay, period, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleWithFixedDelay(\n        Runnable command, long initialDelay, long delay, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleWithFixedDelay(task, initialDelay, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    private static final class ListenableScheduledTask<V>\n        extends SimpleForwardingListenableFuture<V>\n        implements ListenableScheduledFuture<V> {\n\n      private final ScheduledFuture<?> scheduledDelegate;\n\n      public ListenableScheduledTask(\n          ListenableFuture<V> listenableDelegate,\n          ScheduledFuture<?> scheduledDelegate) {\n        super(listenableDelegate);\n        this.scheduledDelegate = scheduledDelegate;\n      }\n\n      @Override\n      public boolean cancel(boolean mayInterruptIfRunning) {\n        boolean cancelled = super.cancel(mayInterruptIfRunning);\n        if (cancelled) {\n          // Unless it is cancelled, the delegate may continue being scheduled\n          scheduledDelegate.cancel(mayInterruptIfRunning);\n\n          // TODO(user): Cancel \"this\" if \"scheduledDelegate\" is cancelled.\n        }\n        return cancelled;\n      }\n\n      @Override\n      public long getDelay(TimeUnit unit) {\n        return scheduledDelegate.getDelay(unit);\n      }\n\n      @Override\n      public int compareTo(Delayed other) {\n        return scheduledDelegate.compareTo(other);\n      }\n    }\n\n    @GwtIncompatible(\"TODO\")\n    private static final class NeverSuccessfulListenableFutureTask\n        extends AbstractFuture<Void>\n        implements Runnable {\n      private final Runnable delegate;\n\n      public NeverSuccessfulListenableFutureTask(Runnable delegate) {\n        this.delegate = checkNotNull(delegate);\n      }\n\n      @Override public void run() {\n        try {\n          delegate.run();\n        } catch (Throwable t) {\n          setException(t);\n          throw Throwables.propagate(t);\n        }\n      }\n    }\n  }\n\n  /*\n   * This following method is a modified version of one found in\n   * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/AbstractExecutorServiceTest.java?revision=1.30\n   * which contained the following notice:\n   *\n   * Written by Doug Lea with assistance from members of JCP JSR-166\n   * Expert Group and released to the public domain, as explained at\n   * http://creativecommons.org/publicdomain/zero/1.0/\n   * Other contributors include Andrew Wright, Jeffrey Hayes,\n   * Pat Fisher, Mike Judd.\n   */\n\n  /**\n   * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}\n   * implementations.\n   */ static <T> T invokeAnyImpl(ListeningExecutorService executorService,\n      Collection<? extends Callable<T>> tasks, boolean timed, long nanos)\n          throws InterruptedException, ExecutionException, TimeoutException {\n    checkNotNull(executorService);\n    int ntasks = tasks.size();\n    checkArgument(ntasks > 0);\n    List<Future<T>> futures = Lists.newArrayListWithCapacity(ntasks);\n    BlockingQueue<Future<T>> futureQueue = Queues.newLinkedBlockingQueue();\n\n    // For efficiency, especially in executors with limited\n    // parallelism, check to see if previously submitted tasks are\n    // done before submitting more of them. This interleaving\n    // plus the exception mechanics account for messiness of main\n    // loop.\n\n    try {\n      // Record exceptions so that if we fail to obtain any\n      // result, we can throw the last exception we got.\n      ExecutionException ee = null;\n      long lastTime = timed ? System.nanoTime() : 0;\n      Iterator<? extends Callable<T>> it = tasks.iterator();\n\n      futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n      --ntasks;\n      int active = 1;\n\n      for (;;) {\n        Future<T> f = futureQueue.poll();\n        if (f == null) {\n          if (ntasks > 0) {\n            --ntasks;\n            futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n            ++active;\n          } else if (active == 0) {\n            break;\n          } else if (timed) {\n            f = futureQueue.poll(nanos, TimeUnit.NANOSECONDS);\n            if (f == null) {\n              throw new TimeoutException();\n            }\n            long now = System.nanoTime();\n            nanos -= now - lastTime;\n            lastTime = now;\n          } else {\n            f = futureQueue.take();\n          }\n        }\n        if (f != null) {\n          --active;\n          try {\n            return f.get();\n          } catch (ExecutionException eex) {\n            ee = eex;\n          } catch (RuntimeException rex) {\n            ee = new ExecutionException(rex);\n          }\n        }\n      }\n\n      if (ee == null) {\n        ee = new ExecutionException(null);\n      }\n      throw ee;\n    } finally {\n      for (Future<T> f : futures) {\n        f.cancel(true);\n      }\n    }\n  }\n\n  /**\n   * Submits the task and adds a listener that adds the future to {@code queue} when it completes.\n   */\n  @GwtIncompatible(\"TODO\")\n  private static <T> ListenableFuture<T> submitAndAddQueueListener(\n      ListeningExecutorService executorService, Callable<T> task,\n      final BlockingQueue<Future<T>> queue) {\n    final ListenableFuture<T> future = executorService.submit(task);\n    future.addListener(new Runnable() {\n      @Override public void run() {\n        queue.add(future);\n      }\n    }, directExecutor());\n    return future;\n  }\n\n  /**\n   * Returns a default thread factory used to create new threads.\n   *\n   * <p>On AppEngine, returns {@code ThreadManager.currentRequestThreadFactory()}.\n   * Otherwise, returns {@link Executors#defaultThreadFactory()}.\n   *\n   * @since 14.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ThreadFactory platformThreadFactory() {\n    if (!isAppEngine()) {\n      return Executors.defaultThreadFactory();\n    }\n    try {\n      return (ThreadFactory) Class.forName(\"com.google.appengine.api.ThreadManager\")\n          .getMethod(\"currentRequestThreadFactory\")\n          .invoke(null);\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (ClassNotFoundException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (NoSuchMethodException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (InvocationTargetException e) {\n      throw Throwables.propagate(e.getCause());\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static boolean isAppEngine() {\n    if (System.getProperty(\"com.google.appengine.runtime.environment\") == null) {\n      return false;\n    }\n    try {\n      // If the current environment is null, we're not inside AppEngine.\n      return Class.forName(\"com.google.apphosting.api.ApiProxy\")\n          .getMethod(\"getCurrentEnvironment\")\n          .invoke(null) != null;\n    } catch (ClassNotFoundException e) {\n      // If ApiProxy doesn't exist, we're not on AppEngine at all.\n      return false;\n    } catch (InvocationTargetException e) {\n      // If ApiProxy throws an exception, we're not in a proper AppEngine environment.\n      return false;\n    } catch (IllegalAccessException e) {\n      // If the method isn't accessible, we're not on a supported version of AppEngine;\n      return false;\n    } catch (NoSuchMethodException e) {\n      // If the method doesn't exist, we're not on a supported version of AppEngine;\n      return false;\n    }\n  }\n\n  /**\n   * Creates a thread using {@link #platformThreadFactory}, and sets its name to {@code name}\n   * unless changing the name is forbidden by the security manager.\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Thread newThread(String name, Runnable runnable) {\n    checkNotNull(name);\n    checkNotNull(runnable);\n    Thread result = platformThreadFactory().newThread(runnable);\n    try {\n      result.setName(name);\n    } catch (SecurityException e) {\n      // OK if we can't set the name in this environment.\n    }\n    return result;\n  }\n\n  // TODO(lukes): provide overloads for ListeningExecutorService? ListeningScheduledExecutorService?\n  // TODO(lukes): provide overloads that take constant strings? Function<Runnable, String>s to\n  // calculate names?\n\n  /**\n   * Creates an {@link Executor} that renames the {@link Thread threads} that its tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param executor The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier) {\n    checkNotNull(executor);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try\n      return executor;\n    }\n    return new Executor() {\n      @Override public void execute(Runnable command) {\n        executor.execute(Callables.threadRenaming(command, nameSupplier));\n      }\n    };\n  }\n\n  /**\n   * Creates an {@link ExecutorService} that renames the {@link Thread threads} that its tasks run\n   * in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ExecutorService renamingDecorator(final ExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} that renames the {@link Thread threads} that its\n   * tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ScheduledExecutorService renamingDecorator(final ScheduledExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingScheduledExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Shuts down the given executor gradually, first disabling new submissions and later cancelling\n   * existing tasks.\n   *\n   * <p>The method takes the following steps:\n   * <ol>\n   *  <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n   *  <li>waits for half of the specified timeout.\n   *  <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n   *  pending tasks and interrupting running tasks.\n   *  <li>waits for the other half of the specified timeout.\n   * </ol>\n   *\n   * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n   * ExecutorService#shutdownNow()} and returns.\n   *\n   * @param service the {@code ExecutorService} to shut down\n   * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n   * @param unit the time unit of the timeout argument\n   * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n   *     the call timed out or was interrupted\n   * @since 17.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static boolean shutdownAndAwaitTermination(\n      ExecutorService service, long timeout, TimeUnit unit) {\n    checkNotNull(unit);\n    // Disable new tasks from being submitted\n    service.shutdown();\n    try {\n      long halfTimeoutNanos = TimeUnit.NANOSECONDS.convert(timeout, unit) / 2;\n      // Wait for half the duration of the timeout for existing tasks to terminate\n      if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {\n        // Cancel currently executing tasks\n        service.shutdownNow();\n        // Wait the other half of the timeout for tasks to respond to being cancelled\n        service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);\n      }\n    } catch (InterruptedException ie) {\n      // Preserve interrupt status\n      Thread.currentThread().interrupt();\n      // (Re-)Cancel if current thread also interrupted\n      service.shutdownNow();\n    }\n    return service.isTerminated();\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53070603,"label":true,"oracleId":1426,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"MoreExecutors","javadocTag":"@return an unmodifiable version of the input which will not hang the JVM","methodJavadoc":"    /**\n   * Converts the given ScheduledThreadPoolExecutor into a\n   * ScheduledExecutorService that exits when the application is complete.  It\n   * does so by using daemon threads and adding a shutdown hook to wait for\n   * their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */","methodSourceCode":"public static ScheduledExecutorService getExitingScheduledExecutorService(ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit){\n    return new Application().getExitingScheduledExecutorService(executor, terminationTimeout, timeUnit);\n}","classJavadoc":"/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */","classSourceCode":"/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Queues;\nimport com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */\n@GwtCompatible(emulated = true)\npublic final class MoreExecutors {\n  private MoreExecutors() {}\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ExecutorService getExitingExecutorService(\n      ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ScheduledThreadPoolExecutor into a\n   * ScheduledExecutorService that exits when the application is complete.  It\n   * does so by using daemon threads and adding a shutdown hook to wait for\n   * their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingScheduledExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Add a shutdown hook to wait for thread completion in the given\n   * {@link ExecutorService service}.  This is useful if the given service uses\n   * daemon threads, and we want to keep the JVM from exiting immediately on\n   * shutdown, instead giving these daemon threads a chance to terminate\n   * normally.\n   * @param service ExecutorService which uses daemon threads\n   * @param terminationTimeout how long to wait for the executor to finish\n   *        before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static void addDelayedShutdownHook(\n      ExecutorService service, long terminationTimeout, TimeUnit timeUnit) {\n    new Application()\n        .addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n    return new Application().getExitingExecutorService(executor);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into a ScheduledExecutorService that\n   * exits when the application is complete.  It does so by using daemon threads\n   * and adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor) {\n    return new Application().getExitingScheduledExecutorService(executor);\n  }\n\n  /** Represents the current application to register shutdown hooks. */\n  @GwtIncompatible(\"TODO\")\n  @VisibleForTesting\n  static class Application {\n\n    final ExecutorService getExitingExecutorService(\n        ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ExecutorService service = Executors.unconfigurableExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ScheduledExecutorService service = Executors.unconfigurableScheduledExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final void addDelayedShutdownHook(\n        final ExecutorService service, final long terminationTimeout, final TimeUnit timeUnit) {\n      checkNotNull(service);\n      checkNotNull(timeUnit);\n      addShutdownHook(MoreExecutors.newThread(\"DelayedShutdownHook-for-\" + service, new Runnable() {\n        @Override\n        public void run() {\n          try {\n            // We'd like to log progress and failures that may arise in the\n            // following code, but unfortunately the behavior of logging\n            // is undefined in shutdown hooks.\n            // This is because the logging code installs a shutdown hook of its\n            // own. See Cleaner class inside {@link LogManager}.\n            service.shutdown();\n            service.awaitTermination(terminationTimeout, timeUnit);\n          } catch (InterruptedException ignored) {\n            // We're shutting down anyway, so just ignore.\n          }\n        }\n      }));\n    }\n\n    final ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n      return getExitingExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor) {\n      return getExitingScheduledExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    @VisibleForTesting void addShutdownHook(Thread hook) {\n      Runtime.getRuntime().addShutdownHook(hook);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static void useDaemonThreadFactory(ThreadPoolExecutor executor) {\n    executor.setThreadFactory(new ThreadFactoryBuilder()\n        .setDaemon(true)\n        .setThreadFactory(executor.getThreadFactory())\n        .build());\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}.  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 10.0 (<a href=\"https://github.com/google/guava/wiki/Compatibility\"\n   *        >mostly source-compatible</a> since 3.0)\n   * @deprecated Use {@link #directExecutor()} if you only require an {@link Executor} and\n   *     {@link #newDirectExecutorService()} if you need a {@link ListeningExecutorService}. This\n   *     method will be removed in August 2016.\n   */\n  @Deprecated\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService sameThreadExecutor() {\n    return new DirectExecutorService();\n  }\n\n  // See sameThreadExecutor javadoc for behavioral notes.\n  @GwtIncompatible(\"TODO\")\n  private static final class DirectExecutorService\n      extends AbstractListeningExecutorService {\n    /**\n     * Lock used whenever accessing the state variables\n     * (runningTasks, shutdown) of the executor\n     */\n    private final Object lock = new Object();\n\n    /*\n     * Conceptually, these two variables describe the executor being in\n     * one of three states:\n     *   - Active: shutdown == false\n     *   - Shutdown: runningTasks > 0 and shutdown == true\n     *   - Terminated: runningTasks == 0 and shutdown == true\n     */\n    @GuardedBy(\"lock\") private int runningTasks = 0;\n    @GuardedBy(\"lock\") private boolean shutdown = false;\n\n    @Override\n    public void execute(Runnable command) {\n      startTask();\n      try {\n        command.run();\n      } finally {\n        endTask();\n      }\n    }\n\n    @Override\n    public boolean isShutdown() {\n      synchronized (lock) {\n        return shutdown;\n      }\n    }\n\n    @Override\n    public void shutdown() {\n      synchronized (lock) {\n        shutdown = true;\n        if (runningTasks == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n\n    // See sameThreadExecutor javadoc for unusual behavior of this method.\n    @Override\n    public List<Runnable> shutdownNow() {\n      shutdown();\n      return Collections.emptyList();\n    }\n\n    @Override\n    public boolean isTerminated() {\n      synchronized (lock) {\n        return shutdown && runningTasks == 0;\n      }\n    }\n\n    @Override\n    public boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      long nanos = unit.toNanos(timeout);\n      synchronized (lock) {\n        for (;;) {\n          if (shutdown && runningTasks == 0) {\n            return true;\n          } else if (nanos <= 0) {\n            return false;\n          } else {\n            long now = System.nanoTime();\n            TimeUnit.NANOSECONDS.timedWait(lock, nanos);\n            nanos -= System.nanoTime() - now;  // subtract the actual time we waited\n          }\n        }\n      }\n    }\n\n    /**\n     * Checks if the executor has been shut down and increments the running\n     * task count.\n     *\n     * @throws RejectedExecutionException if the executor has been previously\n     *         shutdown\n     */\n    private void startTask() {\n      synchronized (lock) {\n        if (shutdown) {\n          throw new RejectedExecutionException(\"Executor already shutdown\");\n        }\n        runningTasks++;\n      }\n    }\n\n    /**\n     * Decrements the running task count.\n     */\n    private void endTask() {\n      synchronized (lock) {\n        int numRunning = --runningTasks;\n        if (numRunning == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 18.0 (present as MoreExecutors.sameThreadExecutor() since 10.0)\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService newDirectExecutorService() {\n    return new DirectExecutorService();\n  }\n\n  /**\n   * Returns an {@link Executor} that runs each task in the thread that invokes\n   * {@link Executor#execute execute}, as in {@link CallerRunsPolicy}.\n   *\n   * <p>This instance is equivalent to: <pre>   {@code\n   *   final class DirectExecutor implements Executor {\n   *     public void execute(Runnable r) {\n   *       r.run();\n   *     }\n   *   }}</pre>\n   *\n   * <p>This should be preferred to {@link #newDirectExecutorService()} because the implementing the\n   * {@link ExecutorService} subinterface necessitates significant performance overhead.\n   *\n   * @since 18.0\n   */\n  public static Executor directExecutor() {\n    return DirectExecutor.INSTANCE;\n  }\n\n  /** See {@link #directExecutor} for behavioral notes. */\n  private enum DirectExecutor implements Executor {\n    INSTANCE;\n    @Override public void execute(Runnable command) {\n      command.run();\n    }\n\n    @Override public String toString() {\n      return \"MoreExecutors.directExecutor()\";\n    }\n  }\n\n  /**\n   * Creates an {@link ExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code ListeningExecutorService}\n   * never calls the delegate's {@code submit}, {@code invokeAll}, and {@code\n   * invokeAny} methods, so any special handling of tasks must be implemented in\n   * the delegate's {@code execute} method or by wrapping the returned {@code\n   * ListeningExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningExecutorService}, it is returned untouched, and the rest of this\n   * documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService listeningDecorator(\n      ExecutorService delegate) {\n    return (delegate instanceof ListeningExecutorService)\n        ? (ListeningExecutorService) delegate\n        : (delegate instanceof ScheduledExecutorService)\n        ? new ScheduledListeningDecorator((ScheduledExecutorService) delegate)\n        : new ListeningDecorator(delegate);\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code\n   * ListeningScheduledExecutorService} never calls the delegate's {@code\n   * submit}, {@code invokeAll}, and {@code invokeAny} methods, so any special\n   * handling of tasks must be implemented in the delegate's {@code execute}\n   * method or by wrapping the returned {@code\n   * ListeningScheduledExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningScheduledExecutorService}, it is returned untouched, and the rest\n   * of this documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningScheduledExecutorService listeningDecorator(\n      ScheduledExecutorService delegate) {\n    return (delegate instanceof ListeningScheduledExecutorService)\n        ? (ListeningScheduledExecutorService) delegate\n        : new ScheduledListeningDecorator(delegate);\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static class ListeningDecorator\n      extends AbstractListeningExecutorService {\n    private final ExecutorService delegate;\n\n    ListeningDecorator(ExecutorService delegate) {\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public final boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      return delegate.awaitTermination(timeout, unit);\n    }\n\n    @Override\n    public final boolean isShutdown() {\n      return delegate.isShutdown();\n    }\n\n    @Override\n    public final boolean isTerminated() {\n      return delegate.isTerminated();\n    }\n\n    @Override\n    public final void shutdown() {\n      delegate.shutdown();\n    }\n\n    @Override\n    public final List<Runnable> shutdownNow() {\n      return delegate.shutdownNow();\n    }\n\n    @Override\n    public final void execute(Runnable command) {\n      delegate.execute(command);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static final class ScheduledListeningDecorator\n      extends ListeningDecorator implements ListeningScheduledExecutorService {\n    @SuppressWarnings(\"hiding\")\n    final ScheduledExecutorService delegate;\n\n    ScheduledListeningDecorator(ScheduledExecutorService delegate) {\n      super(delegate);\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> schedule(\n        Runnable command, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<Void> task =\n          TrustedListenableFutureTask.create(command, null);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public <V> ListenableScheduledFuture<V> schedule(\n        Callable<V> callable, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<V>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleAtFixedRate(\n        Runnable command, long initialDelay, long period, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleAtFixedRate(task, initialDelay, period, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleWithFixedDelay(\n        Runnable command, long initialDelay, long delay, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleWithFixedDelay(task, initialDelay, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    private static final class ListenableScheduledTask<V>\n        extends SimpleForwardingListenableFuture<V>\n        implements ListenableScheduledFuture<V> {\n\n      private final ScheduledFuture<?> scheduledDelegate;\n\n      public ListenableScheduledTask(\n          ListenableFuture<V> listenableDelegate,\n          ScheduledFuture<?> scheduledDelegate) {\n        super(listenableDelegate);\n        this.scheduledDelegate = scheduledDelegate;\n      }\n\n      @Override\n      public boolean cancel(boolean mayInterruptIfRunning) {\n        boolean cancelled = super.cancel(mayInterruptIfRunning);\n        if (cancelled) {\n          // Unless it is cancelled, the delegate may continue being scheduled\n          scheduledDelegate.cancel(mayInterruptIfRunning);\n\n          // TODO(user): Cancel \"this\" if \"scheduledDelegate\" is cancelled.\n        }\n        return cancelled;\n      }\n\n      @Override\n      public long getDelay(TimeUnit unit) {\n        return scheduledDelegate.getDelay(unit);\n      }\n\n      @Override\n      public int compareTo(Delayed other) {\n        return scheduledDelegate.compareTo(other);\n      }\n    }\n\n    @GwtIncompatible(\"TODO\")\n    private static final class NeverSuccessfulListenableFutureTask\n        extends AbstractFuture<Void>\n        implements Runnable {\n      private final Runnable delegate;\n\n      public NeverSuccessfulListenableFutureTask(Runnable delegate) {\n        this.delegate = checkNotNull(delegate);\n      }\n\n      @Override public void run() {\n        try {\n          delegate.run();\n        } catch (Throwable t) {\n          setException(t);\n          throw Throwables.propagate(t);\n        }\n      }\n    }\n  }\n\n  /*\n   * This following method is a modified version of one found in\n   * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/AbstractExecutorServiceTest.java?revision=1.30\n   * which contained the following notice:\n   *\n   * Written by Doug Lea with assistance from members of JCP JSR-166\n   * Expert Group and released to the public domain, as explained at\n   * http://creativecommons.org/publicdomain/zero/1.0/\n   * Other contributors include Andrew Wright, Jeffrey Hayes,\n   * Pat Fisher, Mike Judd.\n   */\n\n  /**\n   * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}\n   * implementations.\n   */ static <T> T invokeAnyImpl(ListeningExecutorService executorService,\n      Collection<? extends Callable<T>> tasks, boolean timed, long nanos)\n          throws InterruptedException, ExecutionException, TimeoutException {\n    checkNotNull(executorService);\n    int ntasks = tasks.size();\n    checkArgument(ntasks > 0);\n    List<Future<T>> futures = Lists.newArrayListWithCapacity(ntasks);\n    BlockingQueue<Future<T>> futureQueue = Queues.newLinkedBlockingQueue();\n\n    // For efficiency, especially in executors with limited\n    // parallelism, check to see if previously submitted tasks are\n    // done before submitting more of them. This interleaving\n    // plus the exception mechanics account for messiness of main\n    // loop.\n\n    try {\n      // Record exceptions so that if we fail to obtain any\n      // result, we can throw the last exception we got.\n      ExecutionException ee = null;\n      long lastTime = timed ? System.nanoTime() : 0;\n      Iterator<? extends Callable<T>> it = tasks.iterator();\n\n      futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n      --ntasks;\n      int active = 1;\n\n      for (;;) {\n        Future<T> f = futureQueue.poll();\n        if (f == null) {\n          if (ntasks > 0) {\n            --ntasks;\n            futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n            ++active;\n          } else if (active == 0) {\n            break;\n          } else if (timed) {\n            f = futureQueue.poll(nanos, TimeUnit.NANOSECONDS);\n            if (f == null) {\n              throw new TimeoutException();\n            }\n            long now = System.nanoTime();\n            nanos -= now - lastTime;\n            lastTime = now;\n          } else {\n            f = futureQueue.take();\n          }\n        }\n        if (f != null) {\n          --active;\n          try {\n            return f.get();\n          } catch (ExecutionException eex) {\n            ee = eex;\n          } catch (RuntimeException rex) {\n            ee = new ExecutionException(rex);\n          }\n        }\n      }\n\n      if (ee == null) {\n        ee = new ExecutionException(null);\n      }\n      throw ee;\n    } finally {\n      for (Future<T> f : futures) {\n        f.cancel(true);\n      }\n    }\n  }\n\n  /**\n   * Submits the task and adds a listener that adds the future to {@code queue} when it completes.\n   */\n  @GwtIncompatible(\"TODO\")\n  private static <T> ListenableFuture<T> submitAndAddQueueListener(\n      ListeningExecutorService executorService, Callable<T> task,\n      final BlockingQueue<Future<T>> queue) {\n    final ListenableFuture<T> future = executorService.submit(task);\n    future.addListener(new Runnable() {\n      @Override public void run() {\n        queue.add(future);\n      }\n    }, directExecutor());\n    return future;\n  }\n\n  /**\n   * Returns a default thread factory used to create new threads.\n   *\n   * <p>On AppEngine, returns {@code ThreadManager.currentRequestThreadFactory()}.\n   * Otherwise, returns {@link Executors#defaultThreadFactory()}.\n   *\n   * @since 14.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ThreadFactory platformThreadFactory() {\n    if (!isAppEngine()) {\n      return Executors.defaultThreadFactory();\n    }\n    try {\n      return (ThreadFactory) Class.forName(\"com.google.appengine.api.ThreadManager\")\n          .getMethod(\"currentRequestThreadFactory\")\n          .invoke(null);\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (ClassNotFoundException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (NoSuchMethodException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (InvocationTargetException e) {\n      throw Throwables.propagate(e.getCause());\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static boolean isAppEngine() {\n    if (System.getProperty(\"com.google.appengine.runtime.environment\") == null) {\n      return false;\n    }\n    try {\n      // If the current environment is null, we're not inside AppEngine.\n      return Class.forName(\"com.google.apphosting.api.ApiProxy\")\n          .getMethod(\"getCurrentEnvironment\")\n          .invoke(null) != null;\n    } catch (ClassNotFoundException e) {\n      // If ApiProxy doesn't exist, we're not on AppEngine at all.\n      return false;\n    } catch (InvocationTargetException e) {\n      // If ApiProxy throws an exception, we're not in a proper AppEngine environment.\n      return false;\n    } catch (IllegalAccessException e) {\n      // If the method isn't accessible, we're not on a supported version of AppEngine;\n      return false;\n    } catch (NoSuchMethodException e) {\n      // If the method doesn't exist, we're not on a supported version of AppEngine;\n      return false;\n    }\n  }\n\n  /**\n   * Creates a thread using {@link #platformThreadFactory}, and sets its name to {@code name}\n   * unless changing the name is forbidden by the security manager.\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Thread newThread(String name, Runnable runnable) {\n    checkNotNull(name);\n    checkNotNull(runnable);\n    Thread result = platformThreadFactory().newThread(runnable);\n    try {\n      result.setName(name);\n    } catch (SecurityException e) {\n      // OK if we can't set the name in this environment.\n    }\n    return result;\n  }\n\n  // TODO(lukes): provide overloads for ListeningExecutorService? ListeningScheduledExecutorService?\n  // TODO(lukes): provide overloads that take constant strings? Function<Runnable, String>s to\n  // calculate names?\n\n  /**\n   * Creates an {@link Executor} that renames the {@link Thread threads} that its tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param executor The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier) {\n    checkNotNull(executor);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try\n      return executor;\n    }\n    return new Executor() {\n      @Override public void execute(Runnable command) {\n        executor.execute(Callables.threadRenaming(command, nameSupplier));\n      }\n    };\n  }\n\n  /**\n   * Creates an {@link ExecutorService} that renames the {@link Thread threads} that its tasks run\n   * in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ExecutorService renamingDecorator(final ExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} that renames the {@link Thread threads} that its\n   * tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ScheduledExecutorService renamingDecorator(final ScheduledExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingScheduledExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Shuts down the given executor gradually, first disabling new submissions and later cancelling\n   * existing tasks.\n   *\n   * <p>The method takes the following steps:\n   * <ol>\n   *  <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n   *  <li>waits for half of the specified timeout.\n   *  <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n   *  pending tasks and interrupting running tasks.\n   *  <li>waits for the other half of the specified timeout.\n   * </ol>\n   *\n   * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n   * ExecutorService#shutdownNow()} and returns.\n   *\n   * @param service the {@code ExecutorService} to shut down\n   * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n   * @param unit the time unit of the timeout argument\n   * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n   *     the call timed out or was interrupted\n   * @since 17.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static boolean shutdownAndAwaitTermination(\n      ExecutorService service, long timeout, TimeUnit unit) {\n    checkNotNull(unit);\n    // Disable new tasks from being submitted\n    service.shutdown();\n    try {\n      long halfTimeoutNanos = TimeUnit.NANOSECONDS.convert(timeout, unit) / 2;\n      // Wait for half the duration of the timeout for existing tasks to terminate\n      if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {\n        // Cancel currently executing tasks\n        service.shutdownNow();\n        // Wait the other half of the timeout for tasks to respond to being cancelled\n        service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);\n      }\n    } catch (InterruptedException ie) {\n      // Preserve interrupt status\n      Thread.currentThread().interrupt();\n      // (Re-)Cancel if current thread also interrupted\n      service.shutdownNow();\n    }\n    return service.isTerminated();\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53071062,"label":true,"oracleId":1427,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"MoreExecutors","javadocTag":"@param service ExecutorService which uses daemon threads","methodJavadoc":"    /**\n   * Add a shutdown hook to wait for thread completion in the given\n   * {@link ExecutorService service}.  This is useful if the given service uses\n   * daemon threads, and we want to keep the JVM from exiting immediately on\n   * shutdown, instead giving these daemon threads a chance to terminate\n   * normally.\n   * @param service ExecutorService which uses daemon threads\n   * @param terminationTimeout how long to wait for the executor to finish\n   *        before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   */","methodSourceCode":"public static void addDelayedShutdownHook(ExecutorService service, long terminationTimeout, TimeUnit timeUnit){\n    new Application().addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n}","classJavadoc":"/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */","classSourceCode":"/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Queues;\nimport com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */\n@GwtCompatible(emulated = true)\npublic final class MoreExecutors {\n  private MoreExecutors() {}\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ExecutorService getExitingExecutorService(\n      ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ScheduledThreadPoolExecutor into a\n   * ScheduledExecutorService that exits when the application is complete.  It\n   * does so by using daemon threads and adding a shutdown hook to wait for\n   * their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingScheduledExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Add a shutdown hook to wait for thread completion in the given\n   * {@link ExecutorService service}.  This is useful if the given service uses\n   * daemon threads, and we want to keep the JVM from exiting immediately on\n   * shutdown, instead giving these daemon threads a chance to terminate\n   * normally.\n   * @param service ExecutorService which uses daemon threads\n   * @param terminationTimeout how long to wait for the executor to finish\n   *        before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static void addDelayedShutdownHook(\n      ExecutorService service, long terminationTimeout, TimeUnit timeUnit) {\n    new Application()\n        .addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n    return new Application().getExitingExecutorService(executor);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into a ScheduledExecutorService that\n   * exits when the application is complete.  It does so by using daemon threads\n   * and adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor) {\n    return new Application().getExitingScheduledExecutorService(executor);\n  }\n\n  /** Represents the current application to register shutdown hooks. */\n  @GwtIncompatible(\"TODO\")\n  @VisibleForTesting\n  static class Application {\n\n    final ExecutorService getExitingExecutorService(\n        ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ExecutorService service = Executors.unconfigurableExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ScheduledExecutorService service = Executors.unconfigurableScheduledExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final void addDelayedShutdownHook(\n        final ExecutorService service, final long terminationTimeout, final TimeUnit timeUnit) {\n      checkNotNull(service);\n      checkNotNull(timeUnit);\n      addShutdownHook(MoreExecutors.newThread(\"DelayedShutdownHook-for-\" + service, new Runnable() {\n        @Override\n        public void run() {\n          try {\n            // We'd like to log progress and failures that may arise in the\n            // following code, but unfortunately the behavior of logging\n            // is undefined in shutdown hooks.\n            // This is because the logging code installs a shutdown hook of its\n            // own. See Cleaner class inside {@link LogManager}.\n            service.shutdown();\n            service.awaitTermination(terminationTimeout, timeUnit);\n          } catch (InterruptedException ignored) {\n            // We're shutting down anyway, so just ignore.\n          }\n        }\n      }));\n    }\n\n    final ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n      return getExitingExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor) {\n      return getExitingScheduledExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    @VisibleForTesting void addShutdownHook(Thread hook) {\n      Runtime.getRuntime().addShutdownHook(hook);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static void useDaemonThreadFactory(ThreadPoolExecutor executor) {\n    executor.setThreadFactory(new ThreadFactoryBuilder()\n        .setDaemon(true)\n        .setThreadFactory(executor.getThreadFactory())\n        .build());\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}.  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 10.0 (<a href=\"https://github.com/google/guava/wiki/Compatibility\"\n   *        >mostly source-compatible</a> since 3.0)\n   * @deprecated Use {@link #directExecutor()} if you only require an {@link Executor} and\n   *     {@link #newDirectExecutorService()} if you need a {@link ListeningExecutorService}. This\n   *     method will be removed in August 2016.\n   */\n  @Deprecated\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService sameThreadExecutor() {\n    return new DirectExecutorService();\n  }\n\n  // See sameThreadExecutor javadoc for behavioral notes.\n  @GwtIncompatible(\"TODO\")\n  private static final class DirectExecutorService\n      extends AbstractListeningExecutorService {\n    /**\n     * Lock used whenever accessing the state variables\n     * (runningTasks, shutdown) of the executor\n     */\n    private final Object lock = new Object();\n\n    /*\n     * Conceptually, these two variables describe the executor being in\n     * one of three states:\n     *   - Active: shutdown == false\n     *   - Shutdown: runningTasks > 0 and shutdown == true\n     *   - Terminated: runningTasks == 0 and shutdown == true\n     */\n    @GuardedBy(\"lock\") private int runningTasks = 0;\n    @GuardedBy(\"lock\") private boolean shutdown = false;\n\n    @Override\n    public void execute(Runnable command) {\n      startTask();\n      try {\n        command.run();\n      } finally {\n        endTask();\n      }\n    }\n\n    @Override\n    public boolean isShutdown() {\n      synchronized (lock) {\n        return shutdown;\n      }\n    }\n\n    @Override\n    public void shutdown() {\n      synchronized (lock) {\n        shutdown = true;\n        if (runningTasks == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n\n    // See sameThreadExecutor javadoc for unusual behavior of this method.\n    @Override\n    public List<Runnable> shutdownNow() {\n      shutdown();\n      return Collections.emptyList();\n    }\n\n    @Override\n    public boolean isTerminated() {\n      synchronized (lock) {\n        return shutdown && runningTasks == 0;\n      }\n    }\n\n    @Override\n    public boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      long nanos = unit.toNanos(timeout);\n      synchronized (lock) {\n        for (;;) {\n          if (shutdown && runningTasks == 0) {\n            return true;\n          } else if (nanos <= 0) {\n            return false;\n          } else {\n            long now = System.nanoTime();\n            TimeUnit.NANOSECONDS.timedWait(lock, nanos);\n            nanos -= System.nanoTime() - now;  // subtract the actual time we waited\n          }\n        }\n      }\n    }\n\n    /**\n     * Checks if the executor has been shut down and increments the running\n     * task count.\n     *\n     * @throws RejectedExecutionException if the executor has been previously\n     *         shutdown\n     */\n    private void startTask() {\n      synchronized (lock) {\n        if (shutdown) {\n          throw new RejectedExecutionException(\"Executor already shutdown\");\n        }\n        runningTasks++;\n      }\n    }\n\n    /**\n     * Decrements the running task count.\n     */\n    private void endTask() {\n      synchronized (lock) {\n        int numRunning = --runningTasks;\n        if (numRunning == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 18.0 (present as MoreExecutors.sameThreadExecutor() since 10.0)\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService newDirectExecutorService() {\n    return new DirectExecutorService();\n  }\n\n  /**\n   * Returns an {@link Executor} that runs each task in the thread that invokes\n   * {@link Executor#execute execute}, as in {@link CallerRunsPolicy}.\n   *\n   * <p>This instance is equivalent to: <pre>   {@code\n   *   final class DirectExecutor implements Executor {\n   *     public void execute(Runnable r) {\n   *       r.run();\n   *     }\n   *   }}</pre>\n   *\n   * <p>This should be preferred to {@link #newDirectExecutorService()} because the implementing the\n   * {@link ExecutorService} subinterface necessitates significant performance overhead.\n   *\n   * @since 18.0\n   */\n  public static Executor directExecutor() {\n    return DirectExecutor.INSTANCE;\n  }\n\n  /** See {@link #directExecutor} for behavioral notes. */\n  private enum DirectExecutor implements Executor {\n    INSTANCE;\n    @Override public void execute(Runnable command) {\n      command.run();\n    }\n\n    @Override public String toString() {\n      return \"MoreExecutors.directExecutor()\";\n    }\n  }\n\n  /**\n   * Creates an {@link ExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code ListeningExecutorService}\n   * never calls the delegate's {@code submit}, {@code invokeAll}, and {@code\n   * invokeAny} methods, so any special handling of tasks must be implemented in\n   * the delegate's {@code execute} method or by wrapping the returned {@code\n   * ListeningExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningExecutorService}, it is returned untouched, and the rest of this\n   * documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService listeningDecorator(\n      ExecutorService delegate) {\n    return (delegate instanceof ListeningExecutorService)\n        ? (ListeningExecutorService) delegate\n        : (delegate instanceof ScheduledExecutorService)\n        ? new ScheduledListeningDecorator((ScheduledExecutorService) delegate)\n        : new ListeningDecorator(delegate);\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code\n   * ListeningScheduledExecutorService} never calls the delegate's {@code\n   * submit}, {@code invokeAll}, and {@code invokeAny} methods, so any special\n   * handling of tasks must be implemented in the delegate's {@code execute}\n   * method or by wrapping the returned {@code\n   * ListeningScheduledExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningScheduledExecutorService}, it is returned untouched, and the rest\n   * of this documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningScheduledExecutorService listeningDecorator(\n      ScheduledExecutorService delegate) {\n    return (delegate instanceof ListeningScheduledExecutorService)\n        ? (ListeningScheduledExecutorService) delegate\n        : new ScheduledListeningDecorator(delegate);\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static class ListeningDecorator\n      extends AbstractListeningExecutorService {\n    private final ExecutorService delegate;\n\n    ListeningDecorator(ExecutorService delegate) {\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public final boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      return delegate.awaitTermination(timeout, unit);\n    }\n\n    @Override\n    public final boolean isShutdown() {\n      return delegate.isShutdown();\n    }\n\n    @Override\n    public final boolean isTerminated() {\n      return delegate.isTerminated();\n    }\n\n    @Override\n    public final void shutdown() {\n      delegate.shutdown();\n    }\n\n    @Override\n    public final List<Runnable> shutdownNow() {\n      return delegate.shutdownNow();\n    }\n\n    @Override\n    public final void execute(Runnable command) {\n      delegate.execute(command);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static final class ScheduledListeningDecorator\n      extends ListeningDecorator implements ListeningScheduledExecutorService {\n    @SuppressWarnings(\"hiding\")\n    final ScheduledExecutorService delegate;\n\n    ScheduledListeningDecorator(ScheduledExecutorService delegate) {\n      super(delegate);\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> schedule(\n        Runnable command, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<Void> task =\n          TrustedListenableFutureTask.create(command, null);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public <V> ListenableScheduledFuture<V> schedule(\n        Callable<V> callable, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<V>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleAtFixedRate(\n        Runnable command, long initialDelay, long period, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleAtFixedRate(task, initialDelay, period, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleWithFixedDelay(\n        Runnable command, long initialDelay, long delay, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleWithFixedDelay(task, initialDelay, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    private static final class ListenableScheduledTask<V>\n        extends SimpleForwardingListenableFuture<V>\n        implements ListenableScheduledFuture<V> {\n\n      private final ScheduledFuture<?> scheduledDelegate;\n\n      public ListenableScheduledTask(\n          ListenableFuture<V> listenableDelegate,\n          ScheduledFuture<?> scheduledDelegate) {\n        super(listenableDelegate);\n        this.scheduledDelegate = scheduledDelegate;\n      }\n\n      @Override\n      public boolean cancel(boolean mayInterruptIfRunning) {\n        boolean cancelled = super.cancel(mayInterruptIfRunning);\n        if (cancelled) {\n          // Unless it is cancelled, the delegate may continue being scheduled\n          scheduledDelegate.cancel(mayInterruptIfRunning);\n\n          // TODO(user): Cancel \"this\" if \"scheduledDelegate\" is cancelled.\n        }\n        return cancelled;\n      }\n\n      @Override\n      public long getDelay(TimeUnit unit) {\n        return scheduledDelegate.getDelay(unit);\n      }\n\n      @Override\n      public int compareTo(Delayed other) {\n        return scheduledDelegate.compareTo(other);\n      }\n    }\n\n    @GwtIncompatible(\"TODO\")\n    private static final class NeverSuccessfulListenableFutureTask\n        extends AbstractFuture<Void>\n        implements Runnable {\n      private final Runnable delegate;\n\n      public NeverSuccessfulListenableFutureTask(Runnable delegate) {\n        this.delegate = checkNotNull(delegate);\n      }\n\n      @Override public void run() {\n        try {\n          delegate.run();\n        } catch (Throwable t) {\n          setException(t);\n          throw Throwables.propagate(t);\n        }\n      }\n    }\n  }\n\n  /*\n   * This following method is a modified version of one found in\n   * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/AbstractExecutorServiceTest.java?revision=1.30\n   * which contained the following notice:\n   *\n   * Written by Doug Lea with assistance from members of JCP JSR-166\n   * Expert Group and released to the public domain, as explained at\n   * http://creativecommons.org/publicdomain/zero/1.0/\n   * Other contributors include Andrew Wright, Jeffrey Hayes,\n   * Pat Fisher, Mike Judd.\n   */\n\n  /**\n   * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}\n   * implementations.\n   */ static <T> T invokeAnyImpl(ListeningExecutorService executorService,\n      Collection<? extends Callable<T>> tasks, boolean timed, long nanos)\n          throws InterruptedException, ExecutionException, TimeoutException {\n    checkNotNull(executorService);\n    int ntasks = tasks.size();\n    checkArgument(ntasks > 0);\n    List<Future<T>> futures = Lists.newArrayListWithCapacity(ntasks);\n    BlockingQueue<Future<T>> futureQueue = Queues.newLinkedBlockingQueue();\n\n    // For efficiency, especially in executors with limited\n    // parallelism, check to see if previously submitted tasks are\n    // done before submitting more of them. This interleaving\n    // plus the exception mechanics account for messiness of main\n    // loop.\n\n    try {\n      // Record exceptions so that if we fail to obtain any\n      // result, we can throw the last exception we got.\n      ExecutionException ee = null;\n      long lastTime = timed ? System.nanoTime() : 0;\n      Iterator<? extends Callable<T>> it = tasks.iterator();\n\n      futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n      --ntasks;\n      int active = 1;\n\n      for (;;) {\n        Future<T> f = futureQueue.poll();\n        if (f == null) {\n          if (ntasks > 0) {\n            --ntasks;\n            futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n            ++active;\n          } else if (active == 0) {\n            break;\n          } else if (timed) {\n            f = futureQueue.poll(nanos, TimeUnit.NANOSECONDS);\n            if (f == null) {\n              throw new TimeoutException();\n            }\n            long now = System.nanoTime();\n            nanos -= now - lastTime;\n            lastTime = now;\n          } else {\n            f = futureQueue.take();\n          }\n        }\n        if (f != null) {\n          --active;\n          try {\n            return f.get();\n          } catch (ExecutionException eex) {\n            ee = eex;\n          } catch (RuntimeException rex) {\n            ee = new ExecutionException(rex);\n          }\n        }\n      }\n\n      if (ee == null) {\n        ee = new ExecutionException(null);\n      }\n      throw ee;\n    } finally {\n      for (Future<T> f : futures) {\n        f.cancel(true);\n      }\n    }\n  }\n\n  /**\n   * Submits the task and adds a listener that adds the future to {@code queue} when it completes.\n   */\n  @GwtIncompatible(\"TODO\")\n  private static <T> ListenableFuture<T> submitAndAddQueueListener(\n      ListeningExecutorService executorService, Callable<T> task,\n      final BlockingQueue<Future<T>> queue) {\n    final ListenableFuture<T> future = executorService.submit(task);\n    future.addListener(new Runnable() {\n      @Override public void run() {\n        queue.add(future);\n      }\n    }, directExecutor());\n    return future;\n  }\n\n  /**\n   * Returns a default thread factory used to create new threads.\n   *\n   * <p>On AppEngine, returns {@code ThreadManager.currentRequestThreadFactory()}.\n   * Otherwise, returns {@link Executors#defaultThreadFactory()}.\n   *\n   * @since 14.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ThreadFactory platformThreadFactory() {\n    if (!isAppEngine()) {\n      return Executors.defaultThreadFactory();\n    }\n    try {\n      return (ThreadFactory) Class.forName(\"com.google.appengine.api.ThreadManager\")\n          .getMethod(\"currentRequestThreadFactory\")\n          .invoke(null);\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (ClassNotFoundException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (NoSuchMethodException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (InvocationTargetException e) {\n      throw Throwables.propagate(e.getCause());\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static boolean isAppEngine() {\n    if (System.getProperty(\"com.google.appengine.runtime.environment\") == null) {\n      return false;\n    }\n    try {\n      // If the current environment is null, we're not inside AppEngine.\n      return Class.forName(\"com.google.apphosting.api.ApiProxy\")\n          .getMethod(\"getCurrentEnvironment\")\n          .invoke(null) != null;\n    } catch (ClassNotFoundException e) {\n      // If ApiProxy doesn't exist, we're not on AppEngine at all.\n      return false;\n    } catch (InvocationTargetException e) {\n      // If ApiProxy throws an exception, we're not in a proper AppEngine environment.\n      return false;\n    } catch (IllegalAccessException e) {\n      // If the method isn't accessible, we're not on a supported version of AppEngine;\n      return false;\n    } catch (NoSuchMethodException e) {\n      // If the method doesn't exist, we're not on a supported version of AppEngine;\n      return false;\n    }\n  }\n\n  /**\n   * Creates a thread using {@link #platformThreadFactory}, and sets its name to {@code name}\n   * unless changing the name is forbidden by the security manager.\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Thread newThread(String name, Runnable runnable) {\n    checkNotNull(name);\n    checkNotNull(runnable);\n    Thread result = platformThreadFactory().newThread(runnable);\n    try {\n      result.setName(name);\n    } catch (SecurityException e) {\n      // OK if we can't set the name in this environment.\n    }\n    return result;\n  }\n\n  // TODO(lukes): provide overloads for ListeningExecutorService? ListeningScheduledExecutorService?\n  // TODO(lukes): provide overloads that take constant strings? Function<Runnable, String>s to\n  // calculate names?\n\n  /**\n   * Creates an {@link Executor} that renames the {@link Thread threads} that its tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param executor The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier) {\n    checkNotNull(executor);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try\n      return executor;\n    }\n    return new Executor() {\n      @Override public void execute(Runnable command) {\n        executor.execute(Callables.threadRenaming(command, nameSupplier));\n      }\n    };\n  }\n\n  /**\n   * Creates an {@link ExecutorService} that renames the {@link Thread threads} that its tasks run\n   * in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ExecutorService renamingDecorator(final ExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} that renames the {@link Thread threads} that its\n   * tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ScheduledExecutorService renamingDecorator(final ScheduledExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingScheduledExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Shuts down the given executor gradually, first disabling new submissions and later cancelling\n   * existing tasks.\n   *\n   * <p>The method takes the following steps:\n   * <ol>\n   *  <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n   *  <li>waits for half of the specified timeout.\n   *  <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n   *  pending tasks and interrupting running tasks.\n   *  <li>waits for the other half of the specified timeout.\n   * </ol>\n   *\n   * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n   * ExecutorService#shutdownNow()} and returns.\n   *\n   * @param service the {@code ExecutorService} to shut down\n   * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n   * @param unit the time unit of the timeout argument\n   * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n   *     the call timed out or was interrupted\n   * @since 17.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static boolean shutdownAndAwaitTermination(\n      ExecutorService service, long timeout, TimeUnit unit) {\n    checkNotNull(unit);\n    // Disable new tasks from being submitted\n    service.shutdown();\n    try {\n      long halfTimeoutNanos = TimeUnit.NANOSECONDS.convert(timeout, unit) / 2;\n      // Wait for half the duration of the timeout for existing tasks to terminate\n      if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {\n        // Cancel currently executing tasks\n        service.shutdownNow();\n        // Wait the other half of the timeout for tasks to respond to being cancelled\n        service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);\n      }\n    } catch (InterruptedException ie) {\n      // Preserve interrupt status\n      Thread.currentThread().interrupt();\n      // (Re-)Cancel if current thread also interrupted\n      service.shutdownNow();\n    }\n    return service.isTerminated();\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53071521,"label":true,"oracleId":1428,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"MoreExecutors","javadocTag":"@param terminationTimeout how long to wait for the executor to finish\n       before terminating the JVM","methodJavadoc":"    /**\n   * Add a shutdown hook to wait for thread completion in the given\n   * {@link ExecutorService service}.  This is useful if the given service uses\n   * daemon threads, and we want to keep the JVM from exiting immediately on\n   * shutdown, instead giving these daemon threads a chance to terminate\n   * normally.\n   * @param service ExecutorService which uses daemon threads\n   * @param terminationTimeout how long to wait for the executor to finish\n   *        before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   */","methodSourceCode":"public static void addDelayedShutdownHook(ExecutorService service, long terminationTimeout, TimeUnit timeUnit){\n    new Application().addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n}","classJavadoc":"/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */","classSourceCode":"/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Queues;\nimport com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */\n@GwtCompatible(emulated = true)\npublic final class MoreExecutors {\n  private MoreExecutors() {}\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ExecutorService getExitingExecutorService(\n      ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ScheduledThreadPoolExecutor into a\n   * ScheduledExecutorService that exits when the application is complete.  It\n   * does so by using daemon threads and adding a shutdown hook to wait for\n   * their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingScheduledExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Add a shutdown hook to wait for thread completion in the given\n   * {@link ExecutorService service}.  This is useful if the given service uses\n   * daemon threads, and we want to keep the JVM from exiting immediately on\n   * shutdown, instead giving these daemon threads a chance to terminate\n   * normally.\n   * @param service ExecutorService which uses daemon threads\n   * @param terminationTimeout how long to wait for the executor to finish\n   *        before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static void addDelayedShutdownHook(\n      ExecutorService service, long terminationTimeout, TimeUnit timeUnit) {\n    new Application()\n        .addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n    return new Application().getExitingExecutorService(executor);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into a ScheduledExecutorService that\n   * exits when the application is complete.  It does so by using daemon threads\n   * and adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor) {\n    return new Application().getExitingScheduledExecutorService(executor);\n  }\n\n  /** Represents the current application to register shutdown hooks. */\n  @GwtIncompatible(\"TODO\")\n  @VisibleForTesting\n  static class Application {\n\n    final ExecutorService getExitingExecutorService(\n        ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ExecutorService service = Executors.unconfigurableExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ScheduledExecutorService service = Executors.unconfigurableScheduledExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final void addDelayedShutdownHook(\n        final ExecutorService service, final long terminationTimeout, final TimeUnit timeUnit) {\n      checkNotNull(service);\n      checkNotNull(timeUnit);\n      addShutdownHook(MoreExecutors.newThread(\"DelayedShutdownHook-for-\" + service, new Runnable() {\n        @Override\n        public void run() {\n          try {\n            // We'd like to log progress and failures that may arise in the\n            // following code, but unfortunately the behavior of logging\n            // is undefined in shutdown hooks.\n            // This is because the logging code installs a shutdown hook of its\n            // own. See Cleaner class inside {@link LogManager}.\n            service.shutdown();\n            service.awaitTermination(terminationTimeout, timeUnit);\n          } catch (InterruptedException ignored) {\n            // We're shutting down anyway, so just ignore.\n          }\n        }\n      }));\n    }\n\n    final ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n      return getExitingExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor) {\n      return getExitingScheduledExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    @VisibleForTesting void addShutdownHook(Thread hook) {\n      Runtime.getRuntime().addShutdownHook(hook);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static void useDaemonThreadFactory(ThreadPoolExecutor executor) {\n    executor.setThreadFactory(new ThreadFactoryBuilder()\n        .setDaemon(true)\n        .setThreadFactory(executor.getThreadFactory())\n        .build());\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}.  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 10.0 (<a href=\"https://github.com/google/guava/wiki/Compatibility\"\n   *        >mostly source-compatible</a> since 3.0)\n   * @deprecated Use {@link #directExecutor()} if you only require an {@link Executor} and\n   *     {@link #newDirectExecutorService()} if you need a {@link ListeningExecutorService}. This\n   *     method will be removed in August 2016.\n   */\n  @Deprecated\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService sameThreadExecutor() {\n    return new DirectExecutorService();\n  }\n\n  // See sameThreadExecutor javadoc for behavioral notes.\n  @GwtIncompatible(\"TODO\")\n  private static final class DirectExecutorService\n      extends AbstractListeningExecutorService {\n    /**\n     * Lock used whenever accessing the state variables\n     * (runningTasks, shutdown) of the executor\n     */\n    private final Object lock = new Object();\n\n    /*\n     * Conceptually, these two variables describe the executor being in\n     * one of three states:\n     *   - Active: shutdown == false\n     *   - Shutdown: runningTasks > 0 and shutdown == true\n     *   - Terminated: runningTasks == 0 and shutdown == true\n     */\n    @GuardedBy(\"lock\") private int runningTasks = 0;\n    @GuardedBy(\"lock\") private boolean shutdown = false;\n\n    @Override\n    public void execute(Runnable command) {\n      startTask();\n      try {\n        command.run();\n      } finally {\n        endTask();\n      }\n    }\n\n    @Override\n    public boolean isShutdown() {\n      synchronized (lock) {\n        return shutdown;\n      }\n    }\n\n    @Override\n    public void shutdown() {\n      synchronized (lock) {\n        shutdown = true;\n        if (runningTasks == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n\n    // See sameThreadExecutor javadoc for unusual behavior of this method.\n    @Override\n    public List<Runnable> shutdownNow() {\n      shutdown();\n      return Collections.emptyList();\n    }\n\n    @Override\n    public boolean isTerminated() {\n      synchronized (lock) {\n        return shutdown && runningTasks == 0;\n      }\n    }\n\n    @Override\n    public boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      long nanos = unit.toNanos(timeout);\n      synchronized (lock) {\n        for (;;) {\n          if (shutdown && runningTasks == 0) {\n            return true;\n          } else if (nanos <= 0) {\n            return false;\n          } else {\n            long now = System.nanoTime();\n            TimeUnit.NANOSECONDS.timedWait(lock, nanos);\n            nanos -= System.nanoTime() - now;  // subtract the actual time we waited\n          }\n        }\n      }\n    }\n\n    /**\n     * Checks if the executor has been shut down and increments the running\n     * task count.\n     *\n     * @throws RejectedExecutionException if the executor has been previously\n     *         shutdown\n     */\n    private void startTask() {\n      synchronized (lock) {\n        if (shutdown) {\n          throw new RejectedExecutionException(\"Executor already shutdown\");\n        }\n        runningTasks++;\n      }\n    }\n\n    /**\n     * Decrements the running task count.\n     */\n    private void endTask() {\n      synchronized (lock) {\n        int numRunning = --runningTasks;\n        if (numRunning == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 18.0 (present as MoreExecutors.sameThreadExecutor() since 10.0)\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService newDirectExecutorService() {\n    return new DirectExecutorService();\n  }\n\n  /**\n   * Returns an {@link Executor} that runs each task in the thread that invokes\n   * {@link Executor#execute execute}, as in {@link CallerRunsPolicy}.\n   *\n   * <p>This instance is equivalent to: <pre>   {@code\n   *   final class DirectExecutor implements Executor {\n   *     public void execute(Runnable r) {\n   *       r.run();\n   *     }\n   *   }}</pre>\n   *\n   * <p>This should be preferred to {@link #newDirectExecutorService()} because the implementing the\n   * {@link ExecutorService} subinterface necessitates significant performance overhead.\n   *\n   * @since 18.0\n   */\n  public static Executor directExecutor() {\n    return DirectExecutor.INSTANCE;\n  }\n\n  /** See {@link #directExecutor} for behavioral notes. */\n  private enum DirectExecutor implements Executor {\n    INSTANCE;\n    @Override public void execute(Runnable command) {\n      command.run();\n    }\n\n    @Override public String toString() {\n      return \"MoreExecutors.directExecutor()\";\n    }\n  }\n\n  /**\n   * Creates an {@link ExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code ListeningExecutorService}\n   * never calls the delegate's {@code submit}, {@code invokeAll}, and {@code\n   * invokeAny} methods, so any special handling of tasks must be implemented in\n   * the delegate's {@code execute} method or by wrapping the returned {@code\n   * ListeningExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningExecutorService}, it is returned untouched, and the rest of this\n   * documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService listeningDecorator(\n      ExecutorService delegate) {\n    return (delegate instanceof ListeningExecutorService)\n        ? (ListeningExecutorService) delegate\n        : (delegate instanceof ScheduledExecutorService)\n        ? new ScheduledListeningDecorator((ScheduledExecutorService) delegate)\n        : new ListeningDecorator(delegate);\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code\n   * ListeningScheduledExecutorService} never calls the delegate's {@code\n   * submit}, {@code invokeAll}, and {@code invokeAny} methods, so any special\n   * handling of tasks must be implemented in the delegate's {@code execute}\n   * method or by wrapping the returned {@code\n   * ListeningScheduledExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningScheduledExecutorService}, it is returned untouched, and the rest\n   * of this documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningScheduledExecutorService listeningDecorator(\n      ScheduledExecutorService delegate) {\n    return (delegate instanceof ListeningScheduledExecutorService)\n        ? (ListeningScheduledExecutorService) delegate\n        : new ScheduledListeningDecorator(delegate);\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static class ListeningDecorator\n      extends AbstractListeningExecutorService {\n    private final ExecutorService delegate;\n\n    ListeningDecorator(ExecutorService delegate) {\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public final boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      return delegate.awaitTermination(timeout, unit);\n    }\n\n    @Override\n    public final boolean isShutdown() {\n      return delegate.isShutdown();\n    }\n\n    @Override\n    public final boolean isTerminated() {\n      return delegate.isTerminated();\n    }\n\n    @Override\n    public final void shutdown() {\n      delegate.shutdown();\n    }\n\n    @Override\n    public final List<Runnable> shutdownNow() {\n      return delegate.shutdownNow();\n    }\n\n    @Override\n    public final void execute(Runnable command) {\n      delegate.execute(command);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static final class ScheduledListeningDecorator\n      extends ListeningDecorator implements ListeningScheduledExecutorService {\n    @SuppressWarnings(\"hiding\")\n    final ScheduledExecutorService delegate;\n\n    ScheduledListeningDecorator(ScheduledExecutorService delegate) {\n      super(delegate);\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> schedule(\n        Runnable command, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<Void> task =\n          TrustedListenableFutureTask.create(command, null);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public <V> ListenableScheduledFuture<V> schedule(\n        Callable<V> callable, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<V>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleAtFixedRate(\n        Runnable command, long initialDelay, long period, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleAtFixedRate(task, initialDelay, period, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleWithFixedDelay(\n        Runnable command, long initialDelay, long delay, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleWithFixedDelay(task, initialDelay, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    private static final class ListenableScheduledTask<V>\n        extends SimpleForwardingListenableFuture<V>\n        implements ListenableScheduledFuture<V> {\n\n      private final ScheduledFuture<?> scheduledDelegate;\n\n      public ListenableScheduledTask(\n          ListenableFuture<V> listenableDelegate,\n          ScheduledFuture<?> scheduledDelegate) {\n        super(listenableDelegate);\n        this.scheduledDelegate = scheduledDelegate;\n      }\n\n      @Override\n      public boolean cancel(boolean mayInterruptIfRunning) {\n        boolean cancelled = super.cancel(mayInterruptIfRunning);\n        if (cancelled) {\n          // Unless it is cancelled, the delegate may continue being scheduled\n          scheduledDelegate.cancel(mayInterruptIfRunning);\n\n          // TODO(user): Cancel \"this\" if \"scheduledDelegate\" is cancelled.\n        }\n        return cancelled;\n      }\n\n      @Override\n      public long getDelay(TimeUnit unit) {\n        return scheduledDelegate.getDelay(unit);\n      }\n\n      @Override\n      public int compareTo(Delayed other) {\n        return scheduledDelegate.compareTo(other);\n      }\n    }\n\n    @GwtIncompatible(\"TODO\")\n    private static final class NeverSuccessfulListenableFutureTask\n        extends AbstractFuture<Void>\n        implements Runnable {\n      private final Runnable delegate;\n\n      public NeverSuccessfulListenableFutureTask(Runnable delegate) {\n        this.delegate = checkNotNull(delegate);\n      }\n\n      @Override public void run() {\n        try {\n          delegate.run();\n        } catch (Throwable t) {\n          setException(t);\n          throw Throwables.propagate(t);\n        }\n      }\n    }\n  }\n\n  /*\n   * This following method is a modified version of one found in\n   * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/AbstractExecutorServiceTest.java?revision=1.30\n   * which contained the following notice:\n   *\n   * Written by Doug Lea with assistance from members of JCP JSR-166\n   * Expert Group and released to the public domain, as explained at\n   * http://creativecommons.org/publicdomain/zero/1.0/\n   * Other contributors include Andrew Wright, Jeffrey Hayes,\n   * Pat Fisher, Mike Judd.\n   */\n\n  /**\n   * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}\n   * implementations.\n   */ static <T> T invokeAnyImpl(ListeningExecutorService executorService,\n      Collection<? extends Callable<T>> tasks, boolean timed, long nanos)\n          throws InterruptedException, ExecutionException, TimeoutException {\n    checkNotNull(executorService);\n    int ntasks = tasks.size();\n    checkArgument(ntasks > 0);\n    List<Future<T>> futures = Lists.newArrayListWithCapacity(ntasks);\n    BlockingQueue<Future<T>> futureQueue = Queues.newLinkedBlockingQueue();\n\n    // For efficiency, especially in executors with limited\n    // parallelism, check to see if previously submitted tasks are\n    // done before submitting more of them. This interleaving\n    // plus the exception mechanics account for messiness of main\n    // loop.\n\n    try {\n      // Record exceptions so that if we fail to obtain any\n      // result, we can throw the last exception we got.\n      ExecutionException ee = null;\n      long lastTime = timed ? System.nanoTime() : 0;\n      Iterator<? extends Callable<T>> it = tasks.iterator();\n\n      futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n      --ntasks;\n      int active = 1;\n\n      for (;;) {\n        Future<T> f = futureQueue.poll();\n        if (f == null) {\n          if (ntasks > 0) {\n            --ntasks;\n            futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n            ++active;\n          } else if (active == 0) {\n            break;\n          } else if (timed) {\n            f = futureQueue.poll(nanos, TimeUnit.NANOSECONDS);\n            if (f == null) {\n              throw new TimeoutException();\n            }\n            long now = System.nanoTime();\n            nanos -= now - lastTime;\n            lastTime = now;\n          } else {\n            f = futureQueue.take();\n          }\n        }\n        if (f != null) {\n          --active;\n          try {\n            return f.get();\n          } catch (ExecutionException eex) {\n            ee = eex;\n          } catch (RuntimeException rex) {\n            ee = new ExecutionException(rex);\n          }\n        }\n      }\n\n      if (ee == null) {\n        ee = new ExecutionException(null);\n      }\n      throw ee;\n    } finally {\n      for (Future<T> f : futures) {\n        f.cancel(true);\n      }\n    }\n  }\n\n  /**\n   * Submits the task and adds a listener that adds the future to {@code queue} when it completes.\n   */\n  @GwtIncompatible(\"TODO\")\n  private static <T> ListenableFuture<T> submitAndAddQueueListener(\n      ListeningExecutorService executorService, Callable<T> task,\n      final BlockingQueue<Future<T>> queue) {\n    final ListenableFuture<T> future = executorService.submit(task);\n    future.addListener(new Runnable() {\n      @Override public void run() {\n        queue.add(future);\n      }\n    }, directExecutor());\n    return future;\n  }\n\n  /**\n   * Returns a default thread factory used to create new threads.\n   *\n   * <p>On AppEngine, returns {@code ThreadManager.currentRequestThreadFactory()}.\n   * Otherwise, returns {@link Executors#defaultThreadFactory()}.\n   *\n   * @since 14.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ThreadFactory platformThreadFactory() {\n    if (!isAppEngine()) {\n      return Executors.defaultThreadFactory();\n    }\n    try {\n      return (ThreadFactory) Class.forName(\"com.google.appengine.api.ThreadManager\")\n          .getMethod(\"currentRequestThreadFactory\")\n          .invoke(null);\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (ClassNotFoundException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (NoSuchMethodException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (InvocationTargetException e) {\n      throw Throwables.propagate(e.getCause());\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static boolean isAppEngine() {\n    if (System.getProperty(\"com.google.appengine.runtime.environment\") == null) {\n      return false;\n    }\n    try {\n      // If the current environment is null, we're not inside AppEngine.\n      return Class.forName(\"com.google.apphosting.api.ApiProxy\")\n          .getMethod(\"getCurrentEnvironment\")\n          .invoke(null) != null;\n    } catch (ClassNotFoundException e) {\n      // If ApiProxy doesn't exist, we're not on AppEngine at all.\n      return false;\n    } catch (InvocationTargetException e) {\n      // If ApiProxy throws an exception, we're not in a proper AppEngine environment.\n      return false;\n    } catch (IllegalAccessException e) {\n      // If the method isn't accessible, we're not on a supported version of AppEngine;\n      return false;\n    } catch (NoSuchMethodException e) {\n      // If the method doesn't exist, we're not on a supported version of AppEngine;\n      return false;\n    }\n  }\n\n  /**\n   * Creates a thread using {@link #platformThreadFactory}, and sets its name to {@code name}\n   * unless changing the name is forbidden by the security manager.\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Thread newThread(String name, Runnable runnable) {\n    checkNotNull(name);\n    checkNotNull(runnable);\n    Thread result = platformThreadFactory().newThread(runnable);\n    try {\n      result.setName(name);\n    } catch (SecurityException e) {\n      // OK if we can't set the name in this environment.\n    }\n    return result;\n  }\n\n  // TODO(lukes): provide overloads for ListeningExecutorService? ListeningScheduledExecutorService?\n  // TODO(lukes): provide overloads that take constant strings? Function<Runnable, String>s to\n  // calculate names?\n\n  /**\n   * Creates an {@link Executor} that renames the {@link Thread threads} that its tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param executor The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier) {\n    checkNotNull(executor);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try\n      return executor;\n    }\n    return new Executor() {\n      @Override public void execute(Runnable command) {\n        executor.execute(Callables.threadRenaming(command, nameSupplier));\n      }\n    };\n  }\n\n  /**\n   * Creates an {@link ExecutorService} that renames the {@link Thread threads} that its tasks run\n   * in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ExecutorService renamingDecorator(final ExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} that renames the {@link Thread threads} that its\n   * tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ScheduledExecutorService renamingDecorator(final ScheduledExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingScheduledExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Shuts down the given executor gradually, first disabling new submissions and later cancelling\n   * existing tasks.\n   *\n   * <p>The method takes the following steps:\n   * <ol>\n   *  <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n   *  <li>waits for half of the specified timeout.\n   *  <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n   *  pending tasks and interrupting running tasks.\n   *  <li>waits for the other half of the specified timeout.\n   * </ol>\n   *\n   * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n   * ExecutorService#shutdownNow()} and returns.\n   *\n   * @param service the {@code ExecutorService} to shut down\n   * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n   * @param unit the time unit of the timeout argument\n   * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n   *     the call timed out or was interrupted\n   * @since 17.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static boolean shutdownAndAwaitTermination(\n      ExecutorService service, long timeout, TimeUnit unit) {\n    checkNotNull(unit);\n    // Disable new tasks from being submitted\n    service.shutdown();\n    try {\n      long halfTimeoutNanos = TimeUnit.NANOSECONDS.convert(timeout, unit) / 2;\n      // Wait for half the duration of the timeout for existing tasks to terminate\n      if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {\n        // Cancel currently executing tasks\n        service.shutdownNow();\n        // Wait the other half of the timeout for tasks to respond to being cancelled\n        service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);\n      }\n    } catch (InterruptedException ie) {\n      // Preserve interrupt status\n      Thread.currentThread().interrupt();\n      // (Re-)Cancel if current thread also interrupted\n      service.shutdownNow();\n    }\n    return service.isTerminated();\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53071980,"label":true,"oracleId":1429,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"MoreExecutors","javadocTag":"@param timeUnit unit of time for the time parameter","methodJavadoc":"    /**\n   * Add a shutdown hook to wait for thread completion in the given\n   * {@link ExecutorService service}.  This is useful if the given service uses\n   * daemon threads, and we want to keep the JVM from exiting immediately on\n   * shutdown, instead giving these daemon threads a chance to terminate\n   * normally.\n   * @param service ExecutorService which uses daemon threads\n   * @param terminationTimeout how long to wait for the executor to finish\n   *        before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   */","methodSourceCode":"public static void addDelayedShutdownHook(ExecutorService service, long terminationTimeout, TimeUnit timeUnit){\n    new Application().addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n}","classJavadoc":"/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */","classSourceCode":"/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Queues;\nimport com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */\n@GwtCompatible(emulated = true)\npublic final class MoreExecutors {\n  private MoreExecutors() {}\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ExecutorService getExitingExecutorService(\n      ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ScheduledThreadPoolExecutor into a\n   * ScheduledExecutorService that exits when the application is complete.  It\n   * does so by using daemon threads and adding a shutdown hook to wait for\n   * their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingScheduledExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Add a shutdown hook to wait for thread completion in the given\n   * {@link ExecutorService service}.  This is useful if the given service uses\n   * daemon threads, and we want to keep the JVM from exiting immediately on\n   * shutdown, instead giving these daemon threads a chance to terminate\n   * normally.\n   * @param service ExecutorService which uses daemon threads\n   * @param terminationTimeout how long to wait for the executor to finish\n   *        before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static void addDelayedShutdownHook(\n      ExecutorService service, long terminationTimeout, TimeUnit timeUnit) {\n    new Application()\n        .addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n    return new Application().getExitingExecutorService(executor);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into a ScheduledExecutorService that\n   * exits when the application is complete.  It does so by using daemon threads\n   * and adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor) {\n    return new Application().getExitingScheduledExecutorService(executor);\n  }\n\n  /** Represents the current application to register shutdown hooks. */\n  @GwtIncompatible(\"TODO\")\n  @VisibleForTesting\n  static class Application {\n\n    final ExecutorService getExitingExecutorService(\n        ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ExecutorService service = Executors.unconfigurableExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ScheduledExecutorService service = Executors.unconfigurableScheduledExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final void addDelayedShutdownHook(\n        final ExecutorService service, final long terminationTimeout, final TimeUnit timeUnit) {\n      checkNotNull(service);\n      checkNotNull(timeUnit);\n      addShutdownHook(MoreExecutors.newThread(\"DelayedShutdownHook-for-\" + service, new Runnable() {\n        @Override\n        public void run() {\n          try {\n            // We'd like to log progress and failures that may arise in the\n            // following code, but unfortunately the behavior of logging\n            // is undefined in shutdown hooks.\n            // This is because the logging code installs a shutdown hook of its\n            // own. See Cleaner class inside {@link LogManager}.\n            service.shutdown();\n            service.awaitTermination(terminationTimeout, timeUnit);\n          } catch (InterruptedException ignored) {\n            // We're shutting down anyway, so just ignore.\n          }\n        }\n      }));\n    }\n\n    final ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n      return getExitingExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor) {\n      return getExitingScheduledExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    @VisibleForTesting void addShutdownHook(Thread hook) {\n      Runtime.getRuntime().addShutdownHook(hook);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static void useDaemonThreadFactory(ThreadPoolExecutor executor) {\n    executor.setThreadFactory(new ThreadFactoryBuilder()\n        .setDaemon(true)\n        .setThreadFactory(executor.getThreadFactory())\n        .build());\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}.  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 10.0 (<a href=\"https://github.com/google/guava/wiki/Compatibility\"\n   *        >mostly source-compatible</a> since 3.0)\n   * @deprecated Use {@link #directExecutor()} if you only require an {@link Executor} and\n   *     {@link #newDirectExecutorService()} if you need a {@link ListeningExecutorService}. This\n   *     method will be removed in August 2016.\n   */\n  @Deprecated\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService sameThreadExecutor() {\n    return new DirectExecutorService();\n  }\n\n  // See sameThreadExecutor javadoc for behavioral notes.\n  @GwtIncompatible(\"TODO\")\n  private static final class DirectExecutorService\n      extends AbstractListeningExecutorService {\n    /**\n     * Lock used whenever accessing the state variables\n     * (runningTasks, shutdown) of the executor\n     */\n    private final Object lock = new Object();\n\n    /*\n     * Conceptually, these two variables describe the executor being in\n     * one of three states:\n     *   - Active: shutdown == false\n     *   - Shutdown: runningTasks > 0 and shutdown == true\n     *   - Terminated: runningTasks == 0 and shutdown == true\n     */\n    @GuardedBy(\"lock\") private int runningTasks = 0;\n    @GuardedBy(\"lock\") private boolean shutdown = false;\n\n    @Override\n    public void execute(Runnable command) {\n      startTask();\n      try {\n        command.run();\n      } finally {\n        endTask();\n      }\n    }\n\n    @Override\n    public boolean isShutdown() {\n      synchronized (lock) {\n        return shutdown;\n      }\n    }\n\n    @Override\n    public void shutdown() {\n      synchronized (lock) {\n        shutdown = true;\n        if (runningTasks == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n\n    // See sameThreadExecutor javadoc for unusual behavior of this method.\n    @Override\n    public List<Runnable> shutdownNow() {\n      shutdown();\n      return Collections.emptyList();\n    }\n\n    @Override\n    public boolean isTerminated() {\n      synchronized (lock) {\n        return shutdown && runningTasks == 0;\n      }\n    }\n\n    @Override\n    public boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      long nanos = unit.toNanos(timeout);\n      synchronized (lock) {\n        for (;;) {\n          if (shutdown && runningTasks == 0) {\n            return true;\n          } else if (nanos <= 0) {\n            return false;\n          } else {\n            long now = System.nanoTime();\n            TimeUnit.NANOSECONDS.timedWait(lock, nanos);\n            nanos -= System.nanoTime() - now;  // subtract the actual time we waited\n          }\n        }\n      }\n    }\n\n    /**\n     * Checks if the executor has been shut down and increments the running\n     * task count.\n     *\n     * @throws RejectedExecutionException if the executor has been previously\n     *         shutdown\n     */\n    private void startTask() {\n      synchronized (lock) {\n        if (shutdown) {\n          throw new RejectedExecutionException(\"Executor already shutdown\");\n        }\n        runningTasks++;\n      }\n    }\n\n    /**\n     * Decrements the running task count.\n     */\n    private void endTask() {\n      synchronized (lock) {\n        int numRunning = --runningTasks;\n        if (numRunning == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 18.0 (present as MoreExecutors.sameThreadExecutor() since 10.0)\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService newDirectExecutorService() {\n    return new DirectExecutorService();\n  }\n\n  /**\n   * Returns an {@link Executor} that runs each task in the thread that invokes\n   * {@link Executor#execute execute}, as in {@link CallerRunsPolicy}.\n   *\n   * <p>This instance is equivalent to: <pre>   {@code\n   *   final class DirectExecutor implements Executor {\n   *     public void execute(Runnable r) {\n   *       r.run();\n   *     }\n   *   }}</pre>\n   *\n   * <p>This should be preferred to {@link #newDirectExecutorService()} because the implementing the\n   * {@link ExecutorService} subinterface necessitates significant performance overhead.\n   *\n   * @since 18.0\n   */\n  public static Executor directExecutor() {\n    return DirectExecutor.INSTANCE;\n  }\n\n  /** See {@link #directExecutor} for behavioral notes. */\n  private enum DirectExecutor implements Executor {\n    INSTANCE;\n    @Override public void execute(Runnable command) {\n      command.run();\n    }\n\n    @Override public String toString() {\n      return \"MoreExecutors.directExecutor()\";\n    }\n  }\n\n  /**\n   * Creates an {@link ExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code ListeningExecutorService}\n   * never calls the delegate's {@code submit}, {@code invokeAll}, and {@code\n   * invokeAny} methods, so any special handling of tasks must be implemented in\n   * the delegate's {@code execute} method or by wrapping the returned {@code\n   * ListeningExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningExecutorService}, it is returned untouched, and the rest of this\n   * documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService listeningDecorator(\n      ExecutorService delegate) {\n    return (delegate instanceof ListeningExecutorService)\n        ? (ListeningExecutorService) delegate\n        : (delegate instanceof ScheduledExecutorService)\n        ? new ScheduledListeningDecorator((ScheduledExecutorService) delegate)\n        : new ListeningDecorator(delegate);\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code\n   * ListeningScheduledExecutorService} never calls the delegate's {@code\n   * submit}, {@code invokeAll}, and {@code invokeAny} methods, so any special\n   * handling of tasks must be implemented in the delegate's {@code execute}\n   * method or by wrapping the returned {@code\n   * ListeningScheduledExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningScheduledExecutorService}, it is returned untouched, and the rest\n   * of this documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningScheduledExecutorService listeningDecorator(\n      ScheduledExecutorService delegate) {\n    return (delegate instanceof ListeningScheduledExecutorService)\n        ? (ListeningScheduledExecutorService) delegate\n        : new ScheduledListeningDecorator(delegate);\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static class ListeningDecorator\n      extends AbstractListeningExecutorService {\n    private final ExecutorService delegate;\n\n    ListeningDecorator(ExecutorService delegate) {\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public final boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      return delegate.awaitTermination(timeout, unit);\n    }\n\n    @Override\n    public final boolean isShutdown() {\n      return delegate.isShutdown();\n    }\n\n    @Override\n    public final boolean isTerminated() {\n      return delegate.isTerminated();\n    }\n\n    @Override\n    public final void shutdown() {\n      delegate.shutdown();\n    }\n\n    @Override\n    public final List<Runnable> shutdownNow() {\n      return delegate.shutdownNow();\n    }\n\n    @Override\n    public final void execute(Runnable command) {\n      delegate.execute(command);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static final class ScheduledListeningDecorator\n      extends ListeningDecorator implements ListeningScheduledExecutorService {\n    @SuppressWarnings(\"hiding\")\n    final ScheduledExecutorService delegate;\n\n    ScheduledListeningDecorator(ScheduledExecutorService delegate) {\n      super(delegate);\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> schedule(\n        Runnable command, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<Void> task =\n          TrustedListenableFutureTask.create(command, null);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public <V> ListenableScheduledFuture<V> schedule(\n        Callable<V> callable, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<V>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleAtFixedRate(\n        Runnable command, long initialDelay, long period, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleAtFixedRate(task, initialDelay, period, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleWithFixedDelay(\n        Runnable command, long initialDelay, long delay, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleWithFixedDelay(task, initialDelay, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    private static final class ListenableScheduledTask<V>\n        extends SimpleForwardingListenableFuture<V>\n        implements ListenableScheduledFuture<V> {\n\n      private final ScheduledFuture<?> scheduledDelegate;\n\n      public ListenableScheduledTask(\n          ListenableFuture<V> listenableDelegate,\n          ScheduledFuture<?> scheduledDelegate) {\n        super(listenableDelegate);\n        this.scheduledDelegate = scheduledDelegate;\n      }\n\n      @Override\n      public boolean cancel(boolean mayInterruptIfRunning) {\n        boolean cancelled = super.cancel(mayInterruptIfRunning);\n        if (cancelled) {\n          // Unless it is cancelled, the delegate may continue being scheduled\n          scheduledDelegate.cancel(mayInterruptIfRunning);\n\n          // TODO(user): Cancel \"this\" if \"scheduledDelegate\" is cancelled.\n        }\n        return cancelled;\n      }\n\n      @Override\n      public long getDelay(TimeUnit unit) {\n        return scheduledDelegate.getDelay(unit);\n      }\n\n      @Override\n      public int compareTo(Delayed other) {\n        return scheduledDelegate.compareTo(other);\n      }\n    }\n\n    @GwtIncompatible(\"TODO\")\n    private static final class NeverSuccessfulListenableFutureTask\n        extends AbstractFuture<Void>\n        implements Runnable {\n      private final Runnable delegate;\n\n      public NeverSuccessfulListenableFutureTask(Runnable delegate) {\n        this.delegate = checkNotNull(delegate);\n      }\n\n      @Override public void run() {\n        try {\n          delegate.run();\n        } catch (Throwable t) {\n          setException(t);\n          throw Throwables.propagate(t);\n        }\n      }\n    }\n  }\n\n  /*\n   * This following method is a modified version of one found in\n   * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/AbstractExecutorServiceTest.java?revision=1.30\n   * which contained the following notice:\n   *\n   * Written by Doug Lea with assistance from members of JCP JSR-166\n   * Expert Group and released to the public domain, as explained at\n   * http://creativecommons.org/publicdomain/zero/1.0/\n   * Other contributors include Andrew Wright, Jeffrey Hayes,\n   * Pat Fisher, Mike Judd.\n   */\n\n  /**\n   * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}\n   * implementations.\n   */ static <T> T invokeAnyImpl(ListeningExecutorService executorService,\n      Collection<? extends Callable<T>> tasks, boolean timed, long nanos)\n          throws InterruptedException, ExecutionException, TimeoutException {\n    checkNotNull(executorService);\n    int ntasks = tasks.size();\n    checkArgument(ntasks > 0);\n    List<Future<T>> futures = Lists.newArrayListWithCapacity(ntasks);\n    BlockingQueue<Future<T>> futureQueue = Queues.newLinkedBlockingQueue();\n\n    // For efficiency, especially in executors with limited\n    // parallelism, check to see if previously submitted tasks are\n    // done before submitting more of them. This interleaving\n    // plus the exception mechanics account for messiness of main\n    // loop.\n\n    try {\n      // Record exceptions so that if we fail to obtain any\n      // result, we can throw the last exception we got.\n      ExecutionException ee = null;\n      long lastTime = timed ? System.nanoTime() : 0;\n      Iterator<? extends Callable<T>> it = tasks.iterator();\n\n      futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n      --ntasks;\n      int active = 1;\n\n      for (;;) {\n        Future<T> f = futureQueue.poll();\n        if (f == null) {\n          if (ntasks > 0) {\n            --ntasks;\n            futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n            ++active;\n          } else if (active == 0) {\n            break;\n          } else if (timed) {\n            f = futureQueue.poll(nanos, TimeUnit.NANOSECONDS);\n            if (f == null) {\n              throw new TimeoutException();\n            }\n            long now = System.nanoTime();\n            nanos -= now - lastTime;\n            lastTime = now;\n          } else {\n            f = futureQueue.take();\n          }\n        }\n        if (f != null) {\n          --active;\n          try {\n            return f.get();\n          } catch (ExecutionException eex) {\n            ee = eex;\n          } catch (RuntimeException rex) {\n            ee = new ExecutionException(rex);\n          }\n        }\n      }\n\n      if (ee == null) {\n        ee = new ExecutionException(null);\n      }\n      throw ee;\n    } finally {\n      for (Future<T> f : futures) {\n        f.cancel(true);\n      }\n    }\n  }\n\n  /**\n   * Submits the task and adds a listener that adds the future to {@code queue} when it completes.\n   */\n  @GwtIncompatible(\"TODO\")\n  private static <T> ListenableFuture<T> submitAndAddQueueListener(\n      ListeningExecutorService executorService, Callable<T> task,\n      final BlockingQueue<Future<T>> queue) {\n    final ListenableFuture<T> future = executorService.submit(task);\n    future.addListener(new Runnable() {\n      @Override public void run() {\n        queue.add(future);\n      }\n    }, directExecutor());\n    return future;\n  }\n\n  /**\n   * Returns a default thread factory used to create new threads.\n   *\n   * <p>On AppEngine, returns {@code ThreadManager.currentRequestThreadFactory()}.\n   * Otherwise, returns {@link Executors#defaultThreadFactory()}.\n   *\n   * @since 14.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ThreadFactory platformThreadFactory() {\n    if (!isAppEngine()) {\n      return Executors.defaultThreadFactory();\n    }\n    try {\n      return (ThreadFactory) Class.forName(\"com.google.appengine.api.ThreadManager\")\n          .getMethod(\"currentRequestThreadFactory\")\n          .invoke(null);\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (ClassNotFoundException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (NoSuchMethodException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (InvocationTargetException e) {\n      throw Throwables.propagate(e.getCause());\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static boolean isAppEngine() {\n    if (System.getProperty(\"com.google.appengine.runtime.environment\") == null) {\n      return false;\n    }\n    try {\n      // If the current environment is null, we're not inside AppEngine.\n      return Class.forName(\"com.google.apphosting.api.ApiProxy\")\n          .getMethod(\"getCurrentEnvironment\")\n          .invoke(null) != null;\n    } catch (ClassNotFoundException e) {\n      // If ApiProxy doesn't exist, we're not on AppEngine at all.\n      return false;\n    } catch (InvocationTargetException e) {\n      // If ApiProxy throws an exception, we're not in a proper AppEngine environment.\n      return false;\n    } catch (IllegalAccessException e) {\n      // If the method isn't accessible, we're not on a supported version of AppEngine;\n      return false;\n    } catch (NoSuchMethodException e) {\n      // If the method doesn't exist, we're not on a supported version of AppEngine;\n      return false;\n    }\n  }\n\n  /**\n   * Creates a thread using {@link #platformThreadFactory}, and sets its name to {@code name}\n   * unless changing the name is forbidden by the security manager.\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Thread newThread(String name, Runnable runnable) {\n    checkNotNull(name);\n    checkNotNull(runnable);\n    Thread result = platformThreadFactory().newThread(runnable);\n    try {\n      result.setName(name);\n    } catch (SecurityException e) {\n      // OK if we can't set the name in this environment.\n    }\n    return result;\n  }\n\n  // TODO(lukes): provide overloads for ListeningExecutorService? ListeningScheduledExecutorService?\n  // TODO(lukes): provide overloads that take constant strings? Function<Runnable, String>s to\n  // calculate names?\n\n  /**\n   * Creates an {@link Executor} that renames the {@link Thread threads} that its tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param executor The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier) {\n    checkNotNull(executor);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try\n      return executor;\n    }\n    return new Executor() {\n      @Override public void execute(Runnable command) {\n        executor.execute(Callables.threadRenaming(command, nameSupplier));\n      }\n    };\n  }\n\n  /**\n   * Creates an {@link ExecutorService} that renames the {@link Thread threads} that its tasks run\n   * in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ExecutorService renamingDecorator(final ExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} that renames the {@link Thread threads} that its\n   * tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ScheduledExecutorService renamingDecorator(final ScheduledExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingScheduledExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Shuts down the given executor gradually, first disabling new submissions and later cancelling\n   * existing tasks.\n   *\n   * <p>The method takes the following steps:\n   * <ol>\n   *  <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n   *  <li>waits for half of the specified timeout.\n   *  <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n   *  pending tasks and interrupting running tasks.\n   *  <li>waits for the other half of the specified timeout.\n   * </ol>\n   *\n   * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n   * ExecutorService#shutdownNow()} and returns.\n   *\n   * @param service the {@code ExecutorService} to shut down\n   * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n   * @param unit the time unit of the timeout argument\n   * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n   *     the call timed out or was interrupted\n   * @since 17.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static boolean shutdownAndAwaitTermination(\n      ExecutorService service, long timeout, TimeUnit unit) {\n    checkNotNull(unit);\n    // Disable new tasks from being submitted\n    service.shutdown();\n    try {\n      long halfTimeoutNanos = TimeUnit.NANOSECONDS.convert(timeout, unit) / 2;\n      // Wait for half the duration of the timeout for existing tasks to terminate\n      if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {\n        // Cancel currently executing tasks\n        service.shutdownNow();\n        // Wait the other half of the timeout for tasks to respond to being cancelled\n        service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);\n      }\n    } catch (InterruptedException ie) {\n      // Preserve interrupt status\n      Thread.currentThread().interrupt();\n      // (Re-)Cancel if current thread also interrupted\n      service.shutdownNow();\n    }\n    return service.isTerminated();\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53072437,"label":true,"oracleId":1430,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"MoreExecutors","javadocTag":"@param executor the executor to modify to make sure it exits when the\n       application is finished","methodJavadoc":"    /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */","methodSourceCode":"public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor){\n    return new Application().getExitingExecutorService(executor);\n}","classJavadoc":"/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */","classSourceCode":"/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Queues;\nimport com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */\n@GwtCompatible(emulated = true)\npublic final class MoreExecutors {\n  private MoreExecutors() {}\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ExecutorService getExitingExecutorService(\n      ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ScheduledThreadPoolExecutor into a\n   * ScheduledExecutorService that exits when the application is complete.  It\n   * does so by using daemon threads and adding a shutdown hook to wait for\n   * their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingScheduledExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Add a shutdown hook to wait for thread completion in the given\n   * {@link ExecutorService service}.  This is useful if the given service uses\n   * daemon threads, and we want to keep the JVM from exiting immediately on\n   * shutdown, instead giving these daemon threads a chance to terminate\n   * normally.\n   * @param service ExecutorService which uses daemon threads\n   * @param terminationTimeout how long to wait for the executor to finish\n   *        before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static void addDelayedShutdownHook(\n      ExecutorService service, long terminationTimeout, TimeUnit timeUnit) {\n    new Application()\n        .addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n    return new Application().getExitingExecutorService(executor);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into a ScheduledExecutorService that\n   * exits when the application is complete.  It does so by using daemon threads\n   * and adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor) {\n    return new Application().getExitingScheduledExecutorService(executor);\n  }\n\n  /** Represents the current application to register shutdown hooks. */\n  @GwtIncompatible(\"TODO\")\n  @VisibleForTesting\n  static class Application {\n\n    final ExecutorService getExitingExecutorService(\n        ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ExecutorService service = Executors.unconfigurableExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ScheduledExecutorService service = Executors.unconfigurableScheduledExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final void addDelayedShutdownHook(\n        final ExecutorService service, final long terminationTimeout, final TimeUnit timeUnit) {\n      checkNotNull(service);\n      checkNotNull(timeUnit);\n      addShutdownHook(MoreExecutors.newThread(\"DelayedShutdownHook-for-\" + service, new Runnable() {\n        @Override\n        public void run() {\n          try {\n            // We'd like to log progress and failures that may arise in the\n            // following code, but unfortunately the behavior of logging\n            // is undefined in shutdown hooks.\n            // This is because the logging code installs a shutdown hook of its\n            // own. See Cleaner class inside {@link LogManager}.\n            service.shutdown();\n            service.awaitTermination(terminationTimeout, timeUnit);\n          } catch (InterruptedException ignored) {\n            // We're shutting down anyway, so just ignore.\n          }\n        }\n      }));\n    }\n\n    final ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n      return getExitingExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor) {\n      return getExitingScheduledExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    @VisibleForTesting void addShutdownHook(Thread hook) {\n      Runtime.getRuntime().addShutdownHook(hook);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static void useDaemonThreadFactory(ThreadPoolExecutor executor) {\n    executor.setThreadFactory(new ThreadFactoryBuilder()\n        .setDaemon(true)\n        .setThreadFactory(executor.getThreadFactory())\n        .build());\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}.  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 10.0 (<a href=\"https://github.com/google/guava/wiki/Compatibility\"\n   *        >mostly source-compatible</a> since 3.0)\n   * @deprecated Use {@link #directExecutor()} if you only require an {@link Executor} and\n   *     {@link #newDirectExecutorService()} if you need a {@link ListeningExecutorService}. This\n   *     method will be removed in August 2016.\n   */\n  @Deprecated\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService sameThreadExecutor() {\n    return new DirectExecutorService();\n  }\n\n  // See sameThreadExecutor javadoc for behavioral notes.\n  @GwtIncompatible(\"TODO\")\n  private static final class DirectExecutorService\n      extends AbstractListeningExecutorService {\n    /**\n     * Lock used whenever accessing the state variables\n     * (runningTasks, shutdown) of the executor\n     */\n    private final Object lock = new Object();\n\n    /*\n     * Conceptually, these two variables describe the executor being in\n     * one of three states:\n     *   - Active: shutdown == false\n     *   - Shutdown: runningTasks > 0 and shutdown == true\n     *   - Terminated: runningTasks == 0 and shutdown == true\n     */\n    @GuardedBy(\"lock\") private int runningTasks = 0;\n    @GuardedBy(\"lock\") private boolean shutdown = false;\n\n    @Override\n    public void execute(Runnable command) {\n      startTask();\n      try {\n        command.run();\n      } finally {\n        endTask();\n      }\n    }\n\n    @Override\n    public boolean isShutdown() {\n      synchronized (lock) {\n        return shutdown;\n      }\n    }\n\n    @Override\n    public void shutdown() {\n      synchronized (lock) {\n        shutdown = true;\n        if (runningTasks == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n\n    // See sameThreadExecutor javadoc for unusual behavior of this method.\n    @Override\n    public List<Runnable> shutdownNow() {\n      shutdown();\n      return Collections.emptyList();\n    }\n\n    @Override\n    public boolean isTerminated() {\n      synchronized (lock) {\n        return shutdown && runningTasks == 0;\n      }\n    }\n\n    @Override\n    public boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      long nanos = unit.toNanos(timeout);\n      synchronized (lock) {\n        for (;;) {\n          if (shutdown && runningTasks == 0) {\n            return true;\n          } else if (nanos <= 0) {\n            return false;\n          } else {\n            long now = System.nanoTime();\n            TimeUnit.NANOSECONDS.timedWait(lock, nanos);\n            nanos -= System.nanoTime() - now;  // subtract the actual time we waited\n          }\n        }\n      }\n    }\n\n    /**\n     * Checks if the executor has been shut down and increments the running\n     * task count.\n     *\n     * @throws RejectedExecutionException if the executor has been previously\n     *         shutdown\n     */\n    private void startTask() {\n      synchronized (lock) {\n        if (shutdown) {\n          throw new RejectedExecutionException(\"Executor already shutdown\");\n        }\n        runningTasks++;\n      }\n    }\n\n    /**\n     * Decrements the running task count.\n     */\n    private void endTask() {\n      synchronized (lock) {\n        int numRunning = --runningTasks;\n        if (numRunning == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 18.0 (present as MoreExecutors.sameThreadExecutor() since 10.0)\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService newDirectExecutorService() {\n    return new DirectExecutorService();\n  }\n\n  /**\n   * Returns an {@link Executor} that runs each task in the thread that invokes\n   * {@link Executor#execute execute}, as in {@link CallerRunsPolicy}.\n   *\n   * <p>This instance is equivalent to: <pre>   {@code\n   *   final class DirectExecutor implements Executor {\n   *     public void execute(Runnable r) {\n   *       r.run();\n   *     }\n   *   }}</pre>\n   *\n   * <p>This should be preferred to {@link #newDirectExecutorService()} because the implementing the\n   * {@link ExecutorService} subinterface necessitates significant performance overhead.\n   *\n   * @since 18.0\n   */\n  public static Executor directExecutor() {\n    return DirectExecutor.INSTANCE;\n  }\n\n  /** See {@link #directExecutor} for behavioral notes. */\n  private enum DirectExecutor implements Executor {\n    INSTANCE;\n    @Override public void execute(Runnable command) {\n      command.run();\n    }\n\n    @Override public String toString() {\n      return \"MoreExecutors.directExecutor()\";\n    }\n  }\n\n  /**\n   * Creates an {@link ExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code ListeningExecutorService}\n   * never calls the delegate's {@code submit}, {@code invokeAll}, and {@code\n   * invokeAny} methods, so any special handling of tasks must be implemented in\n   * the delegate's {@code execute} method or by wrapping the returned {@code\n   * ListeningExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningExecutorService}, it is returned untouched, and the rest of this\n   * documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService listeningDecorator(\n      ExecutorService delegate) {\n    return (delegate instanceof ListeningExecutorService)\n        ? (ListeningExecutorService) delegate\n        : (delegate instanceof ScheduledExecutorService)\n        ? new ScheduledListeningDecorator((ScheduledExecutorService) delegate)\n        : new ListeningDecorator(delegate);\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code\n   * ListeningScheduledExecutorService} never calls the delegate's {@code\n   * submit}, {@code invokeAll}, and {@code invokeAny} methods, so any special\n   * handling of tasks must be implemented in the delegate's {@code execute}\n   * method or by wrapping the returned {@code\n   * ListeningScheduledExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningScheduledExecutorService}, it is returned untouched, and the rest\n   * of this documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningScheduledExecutorService listeningDecorator(\n      ScheduledExecutorService delegate) {\n    return (delegate instanceof ListeningScheduledExecutorService)\n        ? (ListeningScheduledExecutorService) delegate\n        : new ScheduledListeningDecorator(delegate);\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static class ListeningDecorator\n      extends AbstractListeningExecutorService {\n    private final ExecutorService delegate;\n\n    ListeningDecorator(ExecutorService delegate) {\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public final boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      return delegate.awaitTermination(timeout, unit);\n    }\n\n    @Override\n    public final boolean isShutdown() {\n      return delegate.isShutdown();\n    }\n\n    @Override\n    public final boolean isTerminated() {\n      return delegate.isTerminated();\n    }\n\n    @Override\n    public final void shutdown() {\n      delegate.shutdown();\n    }\n\n    @Override\n    public final List<Runnable> shutdownNow() {\n      return delegate.shutdownNow();\n    }\n\n    @Override\n    public final void execute(Runnable command) {\n      delegate.execute(command);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static final class ScheduledListeningDecorator\n      extends ListeningDecorator implements ListeningScheduledExecutorService {\n    @SuppressWarnings(\"hiding\")\n    final ScheduledExecutorService delegate;\n\n    ScheduledListeningDecorator(ScheduledExecutorService delegate) {\n      super(delegate);\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> schedule(\n        Runnable command, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<Void> task =\n          TrustedListenableFutureTask.create(command, null);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public <V> ListenableScheduledFuture<V> schedule(\n        Callable<V> callable, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<V>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleAtFixedRate(\n        Runnable command, long initialDelay, long period, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleAtFixedRate(task, initialDelay, period, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleWithFixedDelay(\n        Runnable command, long initialDelay, long delay, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleWithFixedDelay(task, initialDelay, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    private static final class ListenableScheduledTask<V>\n        extends SimpleForwardingListenableFuture<V>\n        implements ListenableScheduledFuture<V> {\n\n      private final ScheduledFuture<?> scheduledDelegate;\n\n      public ListenableScheduledTask(\n          ListenableFuture<V> listenableDelegate,\n          ScheduledFuture<?> scheduledDelegate) {\n        super(listenableDelegate);\n        this.scheduledDelegate = scheduledDelegate;\n      }\n\n      @Override\n      public boolean cancel(boolean mayInterruptIfRunning) {\n        boolean cancelled = super.cancel(mayInterruptIfRunning);\n        if (cancelled) {\n          // Unless it is cancelled, the delegate may continue being scheduled\n          scheduledDelegate.cancel(mayInterruptIfRunning);\n\n          // TODO(user): Cancel \"this\" if \"scheduledDelegate\" is cancelled.\n        }\n        return cancelled;\n      }\n\n      @Override\n      public long getDelay(TimeUnit unit) {\n        return scheduledDelegate.getDelay(unit);\n      }\n\n      @Override\n      public int compareTo(Delayed other) {\n        return scheduledDelegate.compareTo(other);\n      }\n    }\n\n    @GwtIncompatible(\"TODO\")\n    private static final class NeverSuccessfulListenableFutureTask\n        extends AbstractFuture<Void>\n        implements Runnable {\n      private final Runnable delegate;\n\n      public NeverSuccessfulListenableFutureTask(Runnable delegate) {\n        this.delegate = checkNotNull(delegate);\n      }\n\n      @Override public void run() {\n        try {\n          delegate.run();\n        } catch (Throwable t) {\n          setException(t);\n          throw Throwables.propagate(t);\n        }\n      }\n    }\n  }\n\n  /*\n   * This following method is a modified version of one found in\n   * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/AbstractExecutorServiceTest.java?revision=1.30\n   * which contained the following notice:\n   *\n   * Written by Doug Lea with assistance from members of JCP JSR-166\n   * Expert Group and released to the public domain, as explained at\n   * http://creativecommons.org/publicdomain/zero/1.0/\n   * Other contributors include Andrew Wright, Jeffrey Hayes,\n   * Pat Fisher, Mike Judd.\n   */\n\n  /**\n   * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}\n   * implementations.\n   */ static <T> T invokeAnyImpl(ListeningExecutorService executorService,\n      Collection<? extends Callable<T>> tasks, boolean timed, long nanos)\n          throws InterruptedException, ExecutionException, TimeoutException {\n    checkNotNull(executorService);\n    int ntasks = tasks.size();\n    checkArgument(ntasks > 0);\n    List<Future<T>> futures = Lists.newArrayListWithCapacity(ntasks);\n    BlockingQueue<Future<T>> futureQueue = Queues.newLinkedBlockingQueue();\n\n    // For efficiency, especially in executors with limited\n    // parallelism, check to see if previously submitted tasks are\n    // done before submitting more of them. This interleaving\n    // plus the exception mechanics account for messiness of main\n    // loop.\n\n    try {\n      // Record exceptions so that if we fail to obtain any\n      // result, we can throw the last exception we got.\n      ExecutionException ee = null;\n      long lastTime = timed ? System.nanoTime() : 0;\n      Iterator<? extends Callable<T>> it = tasks.iterator();\n\n      futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n      --ntasks;\n      int active = 1;\n\n      for (;;) {\n        Future<T> f = futureQueue.poll();\n        if (f == null) {\n          if (ntasks > 0) {\n            --ntasks;\n            futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n            ++active;\n          } else if (active == 0) {\n            break;\n          } else if (timed) {\n            f = futureQueue.poll(nanos, TimeUnit.NANOSECONDS);\n            if (f == null) {\n              throw new TimeoutException();\n            }\n            long now = System.nanoTime();\n            nanos -= now - lastTime;\n            lastTime = now;\n          } else {\n            f = futureQueue.take();\n          }\n        }\n        if (f != null) {\n          --active;\n          try {\n            return f.get();\n          } catch (ExecutionException eex) {\n            ee = eex;\n          } catch (RuntimeException rex) {\n            ee = new ExecutionException(rex);\n          }\n        }\n      }\n\n      if (ee == null) {\n        ee = new ExecutionException(null);\n      }\n      throw ee;\n    } finally {\n      for (Future<T> f : futures) {\n        f.cancel(true);\n      }\n    }\n  }\n\n  /**\n   * Submits the task and adds a listener that adds the future to {@code queue} when it completes.\n   */\n  @GwtIncompatible(\"TODO\")\n  private static <T> ListenableFuture<T> submitAndAddQueueListener(\n      ListeningExecutorService executorService, Callable<T> task,\n      final BlockingQueue<Future<T>> queue) {\n    final ListenableFuture<T> future = executorService.submit(task);\n    future.addListener(new Runnable() {\n      @Override public void run() {\n        queue.add(future);\n      }\n    }, directExecutor());\n    return future;\n  }\n\n  /**\n   * Returns a default thread factory used to create new threads.\n   *\n   * <p>On AppEngine, returns {@code ThreadManager.currentRequestThreadFactory()}.\n   * Otherwise, returns {@link Executors#defaultThreadFactory()}.\n   *\n   * @since 14.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ThreadFactory platformThreadFactory() {\n    if (!isAppEngine()) {\n      return Executors.defaultThreadFactory();\n    }\n    try {\n      return (ThreadFactory) Class.forName(\"com.google.appengine.api.ThreadManager\")\n          .getMethod(\"currentRequestThreadFactory\")\n          .invoke(null);\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (ClassNotFoundException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (NoSuchMethodException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (InvocationTargetException e) {\n      throw Throwables.propagate(e.getCause());\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static boolean isAppEngine() {\n    if (System.getProperty(\"com.google.appengine.runtime.environment\") == null) {\n      return false;\n    }\n    try {\n      // If the current environment is null, we're not inside AppEngine.\n      return Class.forName(\"com.google.apphosting.api.ApiProxy\")\n          .getMethod(\"getCurrentEnvironment\")\n          .invoke(null) != null;\n    } catch (ClassNotFoundException e) {\n      // If ApiProxy doesn't exist, we're not on AppEngine at all.\n      return false;\n    } catch (InvocationTargetException e) {\n      // If ApiProxy throws an exception, we're not in a proper AppEngine environment.\n      return false;\n    } catch (IllegalAccessException e) {\n      // If the method isn't accessible, we're not on a supported version of AppEngine;\n      return false;\n    } catch (NoSuchMethodException e) {\n      // If the method doesn't exist, we're not on a supported version of AppEngine;\n      return false;\n    }\n  }\n\n  /**\n   * Creates a thread using {@link #platformThreadFactory}, and sets its name to {@code name}\n   * unless changing the name is forbidden by the security manager.\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Thread newThread(String name, Runnable runnable) {\n    checkNotNull(name);\n    checkNotNull(runnable);\n    Thread result = platformThreadFactory().newThread(runnable);\n    try {\n      result.setName(name);\n    } catch (SecurityException e) {\n      // OK if we can't set the name in this environment.\n    }\n    return result;\n  }\n\n  // TODO(lukes): provide overloads for ListeningExecutorService? ListeningScheduledExecutorService?\n  // TODO(lukes): provide overloads that take constant strings? Function<Runnable, String>s to\n  // calculate names?\n\n  /**\n   * Creates an {@link Executor} that renames the {@link Thread threads} that its tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param executor The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier) {\n    checkNotNull(executor);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try\n      return executor;\n    }\n    return new Executor() {\n      @Override public void execute(Runnable command) {\n        executor.execute(Callables.threadRenaming(command, nameSupplier));\n      }\n    };\n  }\n\n  /**\n   * Creates an {@link ExecutorService} that renames the {@link Thread threads} that its tasks run\n   * in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ExecutorService renamingDecorator(final ExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} that renames the {@link Thread threads} that its\n   * tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ScheduledExecutorService renamingDecorator(final ScheduledExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingScheduledExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Shuts down the given executor gradually, first disabling new submissions and later cancelling\n   * existing tasks.\n   *\n   * <p>The method takes the following steps:\n   * <ol>\n   *  <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n   *  <li>waits for half of the specified timeout.\n   *  <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n   *  pending tasks and interrupting running tasks.\n   *  <li>waits for the other half of the specified timeout.\n   * </ol>\n   *\n   * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n   * ExecutorService#shutdownNow()} and returns.\n   *\n   * @param service the {@code ExecutorService} to shut down\n   * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n   * @param unit the time unit of the timeout argument\n   * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n   *     the call timed out or was interrupted\n   * @since 17.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static boolean shutdownAndAwaitTermination(\n      ExecutorService service, long timeout, TimeUnit unit) {\n    checkNotNull(unit);\n    // Disable new tasks from being submitted\n    service.shutdown();\n    try {\n      long halfTimeoutNanos = TimeUnit.NANOSECONDS.convert(timeout, unit) / 2;\n      // Wait for half the duration of the timeout for existing tasks to terminate\n      if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {\n        // Cancel currently executing tasks\n        service.shutdownNow();\n        // Wait the other half of the timeout for tasks to respond to being cancelled\n        service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);\n      }\n    } catch (InterruptedException ie) {\n      // Preserve interrupt status\n      Thread.currentThread().interrupt();\n      // (Re-)Cancel if current thread also interrupted\n      service.shutdownNow();\n    }\n    return service.isTerminated();\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53072895,"label":true,"oracleId":1431,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"MoreExecutors","javadocTag":"@return an unmodifiable version of the input which will not hang the JVM","methodJavadoc":"    /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */","methodSourceCode":"public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor){\n    return new Application().getExitingExecutorService(executor);\n}","classJavadoc":"/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */","classSourceCode":"/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Queues;\nimport com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */\n@GwtCompatible(emulated = true)\npublic final class MoreExecutors {\n  private MoreExecutors() {}\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ExecutorService getExitingExecutorService(\n      ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ScheduledThreadPoolExecutor into a\n   * ScheduledExecutorService that exits when the application is complete.  It\n   * does so by using daemon threads and adding a shutdown hook to wait for\n   * their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingScheduledExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Add a shutdown hook to wait for thread completion in the given\n   * {@link ExecutorService service}.  This is useful if the given service uses\n   * daemon threads, and we want to keep the JVM from exiting immediately on\n   * shutdown, instead giving these daemon threads a chance to terminate\n   * normally.\n   * @param service ExecutorService which uses daemon threads\n   * @param terminationTimeout how long to wait for the executor to finish\n   *        before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static void addDelayedShutdownHook(\n      ExecutorService service, long terminationTimeout, TimeUnit timeUnit) {\n    new Application()\n        .addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n    return new Application().getExitingExecutorService(executor);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into a ScheduledExecutorService that\n   * exits when the application is complete.  It does so by using daemon threads\n   * and adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor) {\n    return new Application().getExitingScheduledExecutorService(executor);\n  }\n\n  /** Represents the current application to register shutdown hooks. */\n  @GwtIncompatible(\"TODO\")\n  @VisibleForTesting\n  static class Application {\n\n    final ExecutorService getExitingExecutorService(\n        ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ExecutorService service = Executors.unconfigurableExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ScheduledExecutorService service = Executors.unconfigurableScheduledExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final void addDelayedShutdownHook(\n        final ExecutorService service, final long terminationTimeout, final TimeUnit timeUnit) {\n      checkNotNull(service);\n      checkNotNull(timeUnit);\n      addShutdownHook(MoreExecutors.newThread(\"DelayedShutdownHook-for-\" + service, new Runnable() {\n        @Override\n        public void run() {\n          try {\n            // We'd like to log progress and failures that may arise in the\n            // following code, but unfortunately the behavior of logging\n            // is undefined in shutdown hooks.\n            // This is because the logging code installs a shutdown hook of its\n            // own. See Cleaner class inside {@link LogManager}.\n            service.shutdown();\n            service.awaitTermination(terminationTimeout, timeUnit);\n          } catch (InterruptedException ignored) {\n            // We're shutting down anyway, so just ignore.\n          }\n        }\n      }));\n    }\n\n    final ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n      return getExitingExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor) {\n      return getExitingScheduledExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    @VisibleForTesting void addShutdownHook(Thread hook) {\n      Runtime.getRuntime().addShutdownHook(hook);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static void useDaemonThreadFactory(ThreadPoolExecutor executor) {\n    executor.setThreadFactory(new ThreadFactoryBuilder()\n        .setDaemon(true)\n        .setThreadFactory(executor.getThreadFactory())\n        .build());\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}.  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 10.0 (<a href=\"https://github.com/google/guava/wiki/Compatibility\"\n   *        >mostly source-compatible</a> since 3.0)\n   * @deprecated Use {@link #directExecutor()} if you only require an {@link Executor} and\n   *     {@link #newDirectExecutorService()} if you need a {@link ListeningExecutorService}. This\n   *     method will be removed in August 2016.\n   */\n  @Deprecated\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService sameThreadExecutor() {\n    return new DirectExecutorService();\n  }\n\n  // See sameThreadExecutor javadoc for behavioral notes.\n  @GwtIncompatible(\"TODO\")\n  private static final class DirectExecutorService\n      extends AbstractListeningExecutorService {\n    /**\n     * Lock used whenever accessing the state variables\n     * (runningTasks, shutdown) of the executor\n     */\n    private final Object lock = new Object();\n\n    /*\n     * Conceptually, these two variables describe the executor being in\n     * one of three states:\n     *   - Active: shutdown == false\n     *   - Shutdown: runningTasks > 0 and shutdown == true\n     *   - Terminated: runningTasks == 0 and shutdown == true\n     */\n    @GuardedBy(\"lock\") private int runningTasks = 0;\n    @GuardedBy(\"lock\") private boolean shutdown = false;\n\n    @Override\n    public void execute(Runnable command) {\n      startTask();\n      try {\n        command.run();\n      } finally {\n        endTask();\n      }\n    }\n\n    @Override\n    public boolean isShutdown() {\n      synchronized (lock) {\n        return shutdown;\n      }\n    }\n\n    @Override\n    public void shutdown() {\n      synchronized (lock) {\n        shutdown = true;\n        if (runningTasks == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n\n    // See sameThreadExecutor javadoc for unusual behavior of this method.\n    @Override\n    public List<Runnable> shutdownNow() {\n      shutdown();\n      return Collections.emptyList();\n    }\n\n    @Override\n    public boolean isTerminated() {\n      synchronized (lock) {\n        return shutdown && runningTasks == 0;\n      }\n    }\n\n    @Override\n    public boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      long nanos = unit.toNanos(timeout);\n      synchronized (lock) {\n        for (;;) {\n          if (shutdown && runningTasks == 0) {\n            return true;\n          } else if (nanos <= 0) {\n            return false;\n          } else {\n            long now = System.nanoTime();\n            TimeUnit.NANOSECONDS.timedWait(lock, nanos);\n            nanos -= System.nanoTime() - now;  // subtract the actual time we waited\n          }\n        }\n      }\n    }\n\n    /**\n     * Checks if the executor has been shut down and increments the running\n     * task count.\n     *\n     * @throws RejectedExecutionException if the executor has been previously\n     *         shutdown\n     */\n    private void startTask() {\n      synchronized (lock) {\n        if (shutdown) {\n          throw new RejectedExecutionException(\"Executor already shutdown\");\n        }\n        runningTasks++;\n      }\n    }\n\n    /**\n     * Decrements the running task count.\n     */\n    private void endTask() {\n      synchronized (lock) {\n        int numRunning = --runningTasks;\n        if (numRunning == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 18.0 (present as MoreExecutors.sameThreadExecutor() since 10.0)\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService newDirectExecutorService() {\n    return new DirectExecutorService();\n  }\n\n  /**\n   * Returns an {@link Executor} that runs each task in the thread that invokes\n   * {@link Executor#execute execute}, as in {@link CallerRunsPolicy}.\n   *\n   * <p>This instance is equivalent to: <pre>   {@code\n   *   final class DirectExecutor implements Executor {\n   *     public void execute(Runnable r) {\n   *       r.run();\n   *     }\n   *   }}</pre>\n   *\n   * <p>This should be preferred to {@link #newDirectExecutorService()} because the implementing the\n   * {@link ExecutorService} subinterface necessitates significant performance overhead.\n   *\n   * @since 18.0\n   */\n  public static Executor directExecutor() {\n    return DirectExecutor.INSTANCE;\n  }\n\n  /** See {@link #directExecutor} for behavioral notes. */\n  private enum DirectExecutor implements Executor {\n    INSTANCE;\n    @Override public void execute(Runnable command) {\n      command.run();\n    }\n\n    @Override public String toString() {\n      return \"MoreExecutors.directExecutor()\";\n    }\n  }\n\n  /**\n   * Creates an {@link ExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code ListeningExecutorService}\n   * never calls the delegate's {@code submit}, {@code invokeAll}, and {@code\n   * invokeAny} methods, so any special handling of tasks must be implemented in\n   * the delegate's {@code execute} method or by wrapping the returned {@code\n   * ListeningExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningExecutorService}, it is returned untouched, and the rest of this\n   * documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService listeningDecorator(\n      ExecutorService delegate) {\n    return (delegate instanceof ListeningExecutorService)\n        ? (ListeningExecutorService) delegate\n        : (delegate instanceof ScheduledExecutorService)\n        ? new ScheduledListeningDecorator((ScheduledExecutorService) delegate)\n        : new ListeningDecorator(delegate);\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code\n   * ListeningScheduledExecutorService} never calls the delegate's {@code\n   * submit}, {@code invokeAll}, and {@code invokeAny} methods, so any special\n   * handling of tasks must be implemented in the delegate's {@code execute}\n   * method or by wrapping the returned {@code\n   * ListeningScheduledExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningScheduledExecutorService}, it is returned untouched, and the rest\n   * of this documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningScheduledExecutorService listeningDecorator(\n      ScheduledExecutorService delegate) {\n    return (delegate instanceof ListeningScheduledExecutorService)\n        ? (ListeningScheduledExecutorService) delegate\n        : new ScheduledListeningDecorator(delegate);\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static class ListeningDecorator\n      extends AbstractListeningExecutorService {\n    private final ExecutorService delegate;\n\n    ListeningDecorator(ExecutorService delegate) {\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public final boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      return delegate.awaitTermination(timeout, unit);\n    }\n\n    @Override\n    public final boolean isShutdown() {\n      return delegate.isShutdown();\n    }\n\n    @Override\n    public final boolean isTerminated() {\n      return delegate.isTerminated();\n    }\n\n    @Override\n    public final void shutdown() {\n      delegate.shutdown();\n    }\n\n    @Override\n    public final List<Runnable> shutdownNow() {\n      return delegate.shutdownNow();\n    }\n\n    @Override\n    public final void execute(Runnable command) {\n      delegate.execute(command);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static final class ScheduledListeningDecorator\n      extends ListeningDecorator implements ListeningScheduledExecutorService {\n    @SuppressWarnings(\"hiding\")\n    final ScheduledExecutorService delegate;\n\n    ScheduledListeningDecorator(ScheduledExecutorService delegate) {\n      super(delegate);\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> schedule(\n        Runnable command, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<Void> task =\n          TrustedListenableFutureTask.create(command, null);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public <V> ListenableScheduledFuture<V> schedule(\n        Callable<V> callable, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<V>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleAtFixedRate(\n        Runnable command, long initialDelay, long period, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleAtFixedRate(task, initialDelay, period, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleWithFixedDelay(\n        Runnable command, long initialDelay, long delay, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleWithFixedDelay(task, initialDelay, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    private static final class ListenableScheduledTask<V>\n        extends SimpleForwardingListenableFuture<V>\n        implements ListenableScheduledFuture<V> {\n\n      private final ScheduledFuture<?> scheduledDelegate;\n\n      public ListenableScheduledTask(\n          ListenableFuture<V> listenableDelegate,\n          ScheduledFuture<?> scheduledDelegate) {\n        super(listenableDelegate);\n        this.scheduledDelegate = scheduledDelegate;\n      }\n\n      @Override\n      public boolean cancel(boolean mayInterruptIfRunning) {\n        boolean cancelled = super.cancel(mayInterruptIfRunning);\n        if (cancelled) {\n          // Unless it is cancelled, the delegate may continue being scheduled\n          scheduledDelegate.cancel(mayInterruptIfRunning);\n\n          // TODO(user): Cancel \"this\" if \"scheduledDelegate\" is cancelled.\n        }\n        return cancelled;\n      }\n\n      @Override\n      public long getDelay(TimeUnit unit) {\n        return scheduledDelegate.getDelay(unit);\n      }\n\n      @Override\n      public int compareTo(Delayed other) {\n        return scheduledDelegate.compareTo(other);\n      }\n    }\n\n    @GwtIncompatible(\"TODO\")\n    private static final class NeverSuccessfulListenableFutureTask\n        extends AbstractFuture<Void>\n        implements Runnable {\n      private final Runnable delegate;\n\n      public NeverSuccessfulListenableFutureTask(Runnable delegate) {\n        this.delegate = checkNotNull(delegate);\n      }\n\n      @Override public void run() {\n        try {\n          delegate.run();\n        } catch (Throwable t) {\n          setException(t);\n          throw Throwables.propagate(t);\n        }\n      }\n    }\n  }\n\n  /*\n   * This following method is a modified version of one found in\n   * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/AbstractExecutorServiceTest.java?revision=1.30\n   * which contained the following notice:\n   *\n   * Written by Doug Lea with assistance from members of JCP JSR-166\n   * Expert Group and released to the public domain, as explained at\n   * http://creativecommons.org/publicdomain/zero/1.0/\n   * Other contributors include Andrew Wright, Jeffrey Hayes,\n   * Pat Fisher, Mike Judd.\n   */\n\n  /**\n   * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}\n   * implementations.\n   */ static <T> T invokeAnyImpl(ListeningExecutorService executorService,\n      Collection<? extends Callable<T>> tasks, boolean timed, long nanos)\n          throws InterruptedException, ExecutionException, TimeoutException {\n    checkNotNull(executorService);\n    int ntasks = tasks.size();\n    checkArgument(ntasks > 0);\n    List<Future<T>> futures = Lists.newArrayListWithCapacity(ntasks);\n    BlockingQueue<Future<T>> futureQueue = Queues.newLinkedBlockingQueue();\n\n    // For efficiency, especially in executors with limited\n    // parallelism, check to see if previously submitted tasks are\n    // done before submitting more of them. This interleaving\n    // plus the exception mechanics account for messiness of main\n    // loop.\n\n    try {\n      // Record exceptions so that if we fail to obtain any\n      // result, we can throw the last exception we got.\n      ExecutionException ee = null;\n      long lastTime = timed ? System.nanoTime() : 0;\n      Iterator<? extends Callable<T>> it = tasks.iterator();\n\n      futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n      --ntasks;\n      int active = 1;\n\n      for (;;) {\n        Future<T> f = futureQueue.poll();\n        if (f == null) {\n          if (ntasks > 0) {\n            --ntasks;\n            futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n            ++active;\n          } else if (active == 0) {\n            break;\n          } else if (timed) {\n            f = futureQueue.poll(nanos, TimeUnit.NANOSECONDS);\n            if (f == null) {\n              throw new TimeoutException();\n            }\n            long now = System.nanoTime();\n            nanos -= now - lastTime;\n            lastTime = now;\n          } else {\n            f = futureQueue.take();\n          }\n        }\n        if (f != null) {\n          --active;\n          try {\n            return f.get();\n          } catch (ExecutionException eex) {\n            ee = eex;\n          } catch (RuntimeException rex) {\n            ee = new ExecutionException(rex);\n          }\n        }\n      }\n\n      if (ee == null) {\n        ee = new ExecutionException(null);\n      }\n      throw ee;\n    } finally {\n      for (Future<T> f : futures) {\n        f.cancel(true);\n      }\n    }\n  }\n\n  /**\n   * Submits the task and adds a listener that adds the future to {@code queue} when it completes.\n   */\n  @GwtIncompatible(\"TODO\")\n  private static <T> ListenableFuture<T> submitAndAddQueueListener(\n      ListeningExecutorService executorService, Callable<T> task,\n      final BlockingQueue<Future<T>> queue) {\n    final ListenableFuture<T> future = executorService.submit(task);\n    future.addListener(new Runnable() {\n      @Override public void run() {\n        queue.add(future);\n      }\n    }, directExecutor());\n    return future;\n  }\n\n  /**\n   * Returns a default thread factory used to create new threads.\n   *\n   * <p>On AppEngine, returns {@code ThreadManager.currentRequestThreadFactory()}.\n   * Otherwise, returns {@link Executors#defaultThreadFactory()}.\n   *\n   * @since 14.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ThreadFactory platformThreadFactory() {\n    if (!isAppEngine()) {\n      return Executors.defaultThreadFactory();\n    }\n    try {\n      return (ThreadFactory) Class.forName(\"com.google.appengine.api.ThreadManager\")\n          .getMethod(\"currentRequestThreadFactory\")\n          .invoke(null);\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (ClassNotFoundException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (NoSuchMethodException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (InvocationTargetException e) {\n      throw Throwables.propagate(e.getCause());\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static boolean isAppEngine() {\n    if (System.getProperty(\"com.google.appengine.runtime.environment\") == null) {\n      return false;\n    }\n    try {\n      // If the current environment is null, we're not inside AppEngine.\n      return Class.forName(\"com.google.apphosting.api.ApiProxy\")\n          .getMethod(\"getCurrentEnvironment\")\n          .invoke(null) != null;\n    } catch (ClassNotFoundException e) {\n      // If ApiProxy doesn't exist, we're not on AppEngine at all.\n      return false;\n    } catch (InvocationTargetException e) {\n      // If ApiProxy throws an exception, we're not in a proper AppEngine environment.\n      return false;\n    } catch (IllegalAccessException e) {\n      // If the method isn't accessible, we're not on a supported version of AppEngine;\n      return false;\n    } catch (NoSuchMethodException e) {\n      // If the method doesn't exist, we're not on a supported version of AppEngine;\n      return false;\n    }\n  }\n\n  /**\n   * Creates a thread using {@link #platformThreadFactory}, and sets its name to {@code name}\n   * unless changing the name is forbidden by the security manager.\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Thread newThread(String name, Runnable runnable) {\n    checkNotNull(name);\n    checkNotNull(runnable);\n    Thread result = platformThreadFactory().newThread(runnable);\n    try {\n      result.setName(name);\n    } catch (SecurityException e) {\n      // OK if we can't set the name in this environment.\n    }\n    return result;\n  }\n\n  // TODO(lukes): provide overloads for ListeningExecutorService? ListeningScheduledExecutorService?\n  // TODO(lukes): provide overloads that take constant strings? Function<Runnable, String>s to\n  // calculate names?\n\n  /**\n   * Creates an {@link Executor} that renames the {@link Thread threads} that its tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param executor The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier) {\n    checkNotNull(executor);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try\n      return executor;\n    }\n    return new Executor() {\n      @Override public void execute(Runnable command) {\n        executor.execute(Callables.threadRenaming(command, nameSupplier));\n      }\n    };\n  }\n\n  /**\n   * Creates an {@link ExecutorService} that renames the {@link Thread threads} that its tasks run\n   * in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ExecutorService renamingDecorator(final ExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} that renames the {@link Thread threads} that its\n   * tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ScheduledExecutorService renamingDecorator(final ScheduledExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingScheduledExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Shuts down the given executor gradually, first disabling new submissions and later cancelling\n   * existing tasks.\n   *\n   * <p>The method takes the following steps:\n   * <ol>\n   *  <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n   *  <li>waits for half of the specified timeout.\n   *  <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n   *  pending tasks and interrupting running tasks.\n   *  <li>waits for the other half of the specified timeout.\n   * </ol>\n   *\n   * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n   * ExecutorService#shutdownNow()} and returns.\n   *\n   * @param service the {@code ExecutorService} to shut down\n   * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n   * @param unit the time unit of the timeout argument\n   * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n   *     the call timed out or was interrupted\n   * @since 17.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static boolean shutdownAndAwaitTermination(\n      ExecutorService service, long timeout, TimeUnit unit) {\n    checkNotNull(unit);\n    // Disable new tasks from being submitted\n    service.shutdown();\n    try {\n      long halfTimeoutNanos = TimeUnit.NANOSECONDS.convert(timeout, unit) / 2;\n      // Wait for half the duration of the timeout for existing tasks to terminate\n      if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {\n        // Cancel currently executing tasks\n        service.shutdownNow();\n        // Wait the other half of the timeout for tasks to respond to being cancelled\n        service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);\n      }\n    } catch (InterruptedException ie) {\n      // Preserve interrupt status\n      Thread.currentThread().interrupt();\n      // (Re-)Cancel if current thread also interrupted\n      service.shutdownNow();\n    }\n    return service.isTerminated();\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53073352,"label":true,"oracleId":1432,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"MoreExecutors","javadocTag":"@param executor the executor to modify to make sure it exits when the\n       application is finished","methodJavadoc":"    /**\n   * Converts the given ThreadPoolExecutor into a ScheduledExecutorService that\n   * exits when the application is complete.  It does so by using daemon threads\n   * and adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */","methodSourceCode":"public static ScheduledExecutorService getExitingScheduledExecutorService(ScheduledThreadPoolExecutor executor){\n    return new Application().getExitingScheduledExecutorService(executor);\n}","classJavadoc":"/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */","classSourceCode":"/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Queues;\nimport com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */\n@GwtCompatible(emulated = true)\npublic final class MoreExecutors {\n  private MoreExecutors() {}\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ExecutorService getExitingExecutorService(\n      ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ScheduledThreadPoolExecutor into a\n   * ScheduledExecutorService that exits when the application is complete.  It\n   * does so by using daemon threads and adding a shutdown hook to wait for\n   * their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingScheduledExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Add a shutdown hook to wait for thread completion in the given\n   * {@link ExecutorService service}.  This is useful if the given service uses\n   * daemon threads, and we want to keep the JVM from exiting immediately on\n   * shutdown, instead giving these daemon threads a chance to terminate\n   * normally.\n   * @param service ExecutorService which uses daemon threads\n   * @param terminationTimeout how long to wait for the executor to finish\n   *        before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static void addDelayedShutdownHook(\n      ExecutorService service, long terminationTimeout, TimeUnit timeUnit) {\n    new Application()\n        .addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n    return new Application().getExitingExecutorService(executor);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into a ScheduledExecutorService that\n   * exits when the application is complete.  It does so by using daemon threads\n   * and adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor) {\n    return new Application().getExitingScheduledExecutorService(executor);\n  }\n\n  /** Represents the current application to register shutdown hooks. */\n  @GwtIncompatible(\"TODO\")\n  @VisibleForTesting\n  static class Application {\n\n    final ExecutorService getExitingExecutorService(\n        ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ExecutorService service = Executors.unconfigurableExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ScheduledExecutorService service = Executors.unconfigurableScheduledExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final void addDelayedShutdownHook(\n        final ExecutorService service, final long terminationTimeout, final TimeUnit timeUnit) {\n      checkNotNull(service);\n      checkNotNull(timeUnit);\n      addShutdownHook(MoreExecutors.newThread(\"DelayedShutdownHook-for-\" + service, new Runnable() {\n        @Override\n        public void run() {\n          try {\n            // We'd like to log progress and failures that may arise in the\n            // following code, but unfortunately the behavior of logging\n            // is undefined in shutdown hooks.\n            // This is because the logging code installs a shutdown hook of its\n            // own. See Cleaner class inside {@link LogManager}.\n            service.shutdown();\n            service.awaitTermination(terminationTimeout, timeUnit);\n          } catch (InterruptedException ignored) {\n            // We're shutting down anyway, so just ignore.\n          }\n        }\n      }));\n    }\n\n    final ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n      return getExitingExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor) {\n      return getExitingScheduledExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    @VisibleForTesting void addShutdownHook(Thread hook) {\n      Runtime.getRuntime().addShutdownHook(hook);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static void useDaemonThreadFactory(ThreadPoolExecutor executor) {\n    executor.setThreadFactory(new ThreadFactoryBuilder()\n        .setDaemon(true)\n        .setThreadFactory(executor.getThreadFactory())\n        .build());\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}.  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 10.0 (<a href=\"https://github.com/google/guava/wiki/Compatibility\"\n   *        >mostly source-compatible</a> since 3.0)\n   * @deprecated Use {@link #directExecutor()} if you only require an {@link Executor} and\n   *     {@link #newDirectExecutorService()} if you need a {@link ListeningExecutorService}. This\n   *     method will be removed in August 2016.\n   */\n  @Deprecated\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService sameThreadExecutor() {\n    return new DirectExecutorService();\n  }\n\n  // See sameThreadExecutor javadoc for behavioral notes.\n  @GwtIncompatible(\"TODO\")\n  private static final class DirectExecutorService\n      extends AbstractListeningExecutorService {\n    /**\n     * Lock used whenever accessing the state variables\n     * (runningTasks, shutdown) of the executor\n     */\n    private final Object lock = new Object();\n\n    /*\n     * Conceptually, these two variables describe the executor being in\n     * one of three states:\n     *   - Active: shutdown == false\n     *   - Shutdown: runningTasks > 0 and shutdown == true\n     *   - Terminated: runningTasks == 0 and shutdown == true\n     */\n    @GuardedBy(\"lock\") private int runningTasks = 0;\n    @GuardedBy(\"lock\") private boolean shutdown = false;\n\n    @Override\n    public void execute(Runnable command) {\n      startTask();\n      try {\n        command.run();\n      } finally {\n        endTask();\n      }\n    }\n\n    @Override\n    public boolean isShutdown() {\n      synchronized (lock) {\n        return shutdown;\n      }\n    }\n\n    @Override\n    public void shutdown() {\n      synchronized (lock) {\n        shutdown = true;\n        if (runningTasks == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n\n    // See sameThreadExecutor javadoc for unusual behavior of this method.\n    @Override\n    public List<Runnable> shutdownNow() {\n      shutdown();\n      return Collections.emptyList();\n    }\n\n    @Override\n    public boolean isTerminated() {\n      synchronized (lock) {\n        return shutdown && runningTasks == 0;\n      }\n    }\n\n    @Override\n    public boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      long nanos = unit.toNanos(timeout);\n      synchronized (lock) {\n        for (;;) {\n          if (shutdown && runningTasks == 0) {\n            return true;\n          } else if (nanos <= 0) {\n            return false;\n          } else {\n            long now = System.nanoTime();\n            TimeUnit.NANOSECONDS.timedWait(lock, nanos);\n            nanos -= System.nanoTime() - now;  // subtract the actual time we waited\n          }\n        }\n      }\n    }\n\n    /**\n     * Checks if the executor has been shut down and increments the running\n     * task count.\n     *\n     * @throws RejectedExecutionException if the executor has been previously\n     *         shutdown\n     */\n    private void startTask() {\n      synchronized (lock) {\n        if (shutdown) {\n          throw new RejectedExecutionException(\"Executor already shutdown\");\n        }\n        runningTasks++;\n      }\n    }\n\n    /**\n     * Decrements the running task count.\n     */\n    private void endTask() {\n      synchronized (lock) {\n        int numRunning = --runningTasks;\n        if (numRunning == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 18.0 (present as MoreExecutors.sameThreadExecutor() since 10.0)\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService newDirectExecutorService() {\n    return new DirectExecutorService();\n  }\n\n  /**\n   * Returns an {@link Executor} that runs each task in the thread that invokes\n   * {@link Executor#execute execute}, as in {@link CallerRunsPolicy}.\n   *\n   * <p>This instance is equivalent to: <pre>   {@code\n   *   final class DirectExecutor implements Executor {\n   *     public void execute(Runnable r) {\n   *       r.run();\n   *     }\n   *   }}</pre>\n   *\n   * <p>This should be preferred to {@link #newDirectExecutorService()} because the implementing the\n   * {@link ExecutorService} subinterface necessitates significant performance overhead.\n   *\n   * @since 18.0\n   */\n  public static Executor directExecutor() {\n    return DirectExecutor.INSTANCE;\n  }\n\n  /** See {@link #directExecutor} for behavioral notes. */\n  private enum DirectExecutor implements Executor {\n    INSTANCE;\n    @Override public void execute(Runnable command) {\n      command.run();\n    }\n\n    @Override public String toString() {\n      return \"MoreExecutors.directExecutor()\";\n    }\n  }\n\n  /**\n   * Creates an {@link ExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code ListeningExecutorService}\n   * never calls the delegate's {@code submit}, {@code invokeAll}, and {@code\n   * invokeAny} methods, so any special handling of tasks must be implemented in\n   * the delegate's {@code execute} method or by wrapping the returned {@code\n   * ListeningExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningExecutorService}, it is returned untouched, and the rest of this\n   * documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService listeningDecorator(\n      ExecutorService delegate) {\n    return (delegate instanceof ListeningExecutorService)\n        ? (ListeningExecutorService) delegate\n        : (delegate instanceof ScheduledExecutorService)\n        ? new ScheduledListeningDecorator((ScheduledExecutorService) delegate)\n        : new ListeningDecorator(delegate);\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code\n   * ListeningScheduledExecutorService} never calls the delegate's {@code\n   * submit}, {@code invokeAll}, and {@code invokeAny} methods, so any special\n   * handling of tasks must be implemented in the delegate's {@code execute}\n   * method or by wrapping the returned {@code\n   * ListeningScheduledExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningScheduledExecutorService}, it is returned untouched, and the rest\n   * of this documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningScheduledExecutorService listeningDecorator(\n      ScheduledExecutorService delegate) {\n    return (delegate instanceof ListeningScheduledExecutorService)\n        ? (ListeningScheduledExecutorService) delegate\n        : new ScheduledListeningDecorator(delegate);\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static class ListeningDecorator\n      extends AbstractListeningExecutorService {\n    private final ExecutorService delegate;\n\n    ListeningDecorator(ExecutorService delegate) {\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public final boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      return delegate.awaitTermination(timeout, unit);\n    }\n\n    @Override\n    public final boolean isShutdown() {\n      return delegate.isShutdown();\n    }\n\n    @Override\n    public final boolean isTerminated() {\n      return delegate.isTerminated();\n    }\n\n    @Override\n    public final void shutdown() {\n      delegate.shutdown();\n    }\n\n    @Override\n    public final List<Runnable> shutdownNow() {\n      return delegate.shutdownNow();\n    }\n\n    @Override\n    public final void execute(Runnable command) {\n      delegate.execute(command);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static final class ScheduledListeningDecorator\n      extends ListeningDecorator implements ListeningScheduledExecutorService {\n    @SuppressWarnings(\"hiding\")\n    final ScheduledExecutorService delegate;\n\n    ScheduledListeningDecorator(ScheduledExecutorService delegate) {\n      super(delegate);\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> schedule(\n        Runnable command, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<Void> task =\n          TrustedListenableFutureTask.create(command, null);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public <V> ListenableScheduledFuture<V> schedule(\n        Callable<V> callable, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<V>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleAtFixedRate(\n        Runnable command, long initialDelay, long period, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleAtFixedRate(task, initialDelay, period, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleWithFixedDelay(\n        Runnable command, long initialDelay, long delay, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleWithFixedDelay(task, initialDelay, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    private static final class ListenableScheduledTask<V>\n        extends SimpleForwardingListenableFuture<V>\n        implements ListenableScheduledFuture<V> {\n\n      private final ScheduledFuture<?> scheduledDelegate;\n\n      public ListenableScheduledTask(\n          ListenableFuture<V> listenableDelegate,\n          ScheduledFuture<?> scheduledDelegate) {\n        super(listenableDelegate);\n        this.scheduledDelegate = scheduledDelegate;\n      }\n\n      @Override\n      public boolean cancel(boolean mayInterruptIfRunning) {\n        boolean cancelled = super.cancel(mayInterruptIfRunning);\n        if (cancelled) {\n          // Unless it is cancelled, the delegate may continue being scheduled\n          scheduledDelegate.cancel(mayInterruptIfRunning);\n\n          // TODO(user): Cancel \"this\" if \"scheduledDelegate\" is cancelled.\n        }\n        return cancelled;\n      }\n\n      @Override\n      public long getDelay(TimeUnit unit) {\n        return scheduledDelegate.getDelay(unit);\n      }\n\n      @Override\n      public int compareTo(Delayed other) {\n        return scheduledDelegate.compareTo(other);\n      }\n    }\n\n    @GwtIncompatible(\"TODO\")\n    private static final class NeverSuccessfulListenableFutureTask\n        extends AbstractFuture<Void>\n        implements Runnable {\n      private final Runnable delegate;\n\n      public NeverSuccessfulListenableFutureTask(Runnable delegate) {\n        this.delegate = checkNotNull(delegate);\n      }\n\n      @Override public void run() {\n        try {\n          delegate.run();\n        } catch (Throwable t) {\n          setException(t);\n          throw Throwables.propagate(t);\n        }\n      }\n    }\n  }\n\n  /*\n   * This following method is a modified version of one found in\n   * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/AbstractExecutorServiceTest.java?revision=1.30\n   * which contained the following notice:\n   *\n   * Written by Doug Lea with assistance from members of JCP JSR-166\n   * Expert Group and released to the public domain, as explained at\n   * http://creativecommons.org/publicdomain/zero/1.0/\n   * Other contributors include Andrew Wright, Jeffrey Hayes,\n   * Pat Fisher, Mike Judd.\n   */\n\n  /**\n   * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}\n   * implementations.\n   */ static <T> T invokeAnyImpl(ListeningExecutorService executorService,\n      Collection<? extends Callable<T>> tasks, boolean timed, long nanos)\n          throws InterruptedException, ExecutionException, TimeoutException {\n    checkNotNull(executorService);\n    int ntasks = tasks.size();\n    checkArgument(ntasks > 0);\n    List<Future<T>> futures = Lists.newArrayListWithCapacity(ntasks);\n    BlockingQueue<Future<T>> futureQueue = Queues.newLinkedBlockingQueue();\n\n    // For efficiency, especially in executors with limited\n    // parallelism, check to see if previously submitted tasks are\n    // done before submitting more of them. This interleaving\n    // plus the exception mechanics account for messiness of main\n    // loop.\n\n    try {\n      // Record exceptions so that if we fail to obtain any\n      // result, we can throw the last exception we got.\n      ExecutionException ee = null;\n      long lastTime = timed ? System.nanoTime() : 0;\n      Iterator<? extends Callable<T>> it = tasks.iterator();\n\n      futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n      --ntasks;\n      int active = 1;\n\n      for (;;) {\n        Future<T> f = futureQueue.poll();\n        if (f == null) {\n          if (ntasks > 0) {\n            --ntasks;\n            futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n            ++active;\n          } else if (active == 0) {\n            break;\n          } else if (timed) {\n            f = futureQueue.poll(nanos, TimeUnit.NANOSECONDS);\n            if (f == null) {\n              throw new TimeoutException();\n            }\n            long now = System.nanoTime();\n            nanos -= now - lastTime;\n            lastTime = now;\n          } else {\n            f = futureQueue.take();\n          }\n        }\n        if (f != null) {\n          --active;\n          try {\n            return f.get();\n          } catch (ExecutionException eex) {\n            ee = eex;\n          } catch (RuntimeException rex) {\n            ee = new ExecutionException(rex);\n          }\n        }\n      }\n\n      if (ee == null) {\n        ee = new ExecutionException(null);\n      }\n      throw ee;\n    } finally {\n      for (Future<T> f : futures) {\n        f.cancel(true);\n      }\n    }\n  }\n\n  /**\n   * Submits the task and adds a listener that adds the future to {@code queue} when it completes.\n   */\n  @GwtIncompatible(\"TODO\")\n  private static <T> ListenableFuture<T> submitAndAddQueueListener(\n      ListeningExecutorService executorService, Callable<T> task,\n      final BlockingQueue<Future<T>> queue) {\n    final ListenableFuture<T> future = executorService.submit(task);\n    future.addListener(new Runnable() {\n      @Override public void run() {\n        queue.add(future);\n      }\n    }, directExecutor());\n    return future;\n  }\n\n  /**\n   * Returns a default thread factory used to create new threads.\n   *\n   * <p>On AppEngine, returns {@code ThreadManager.currentRequestThreadFactory()}.\n   * Otherwise, returns {@link Executors#defaultThreadFactory()}.\n   *\n   * @since 14.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ThreadFactory platformThreadFactory() {\n    if (!isAppEngine()) {\n      return Executors.defaultThreadFactory();\n    }\n    try {\n      return (ThreadFactory) Class.forName(\"com.google.appengine.api.ThreadManager\")\n          .getMethod(\"currentRequestThreadFactory\")\n          .invoke(null);\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (ClassNotFoundException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (NoSuchMethodException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (InvocationTargetException e) {\n      throw Throwables.propagate(e.getCause());\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static boolean isAppEngine() {\n    if (System.getProperty(\"com.google.appengine.runtime.environment\") == null) {\n      return false;\n    }\n    try {\n      // If the current environment is null, we're not inside AppEngine.\n      return Class.forName(\"com.google.apphosting.api.ApiProxy\")\n          .getMethod(\"getCurrentEnvironment\")\n          .invoke(null) != null;\n    } catch (ClassNotFoundException e) {\n      // If ApiProxy doesn't exist, we're not on AppEngine at all.\n      return false;\n    } catch (InvocationTargetException e) {\n      // If ApiProxy throws an exception, we're not in a proper AppEngine environment.\n      return false;\n    } catch (IllegalAccessException e) {\n      // If the method isn't accessible, we're not on a supported version of AppEngine;\n      return false;\n    } catch (NoSuchMethodException e) {\n      // If the method doesn't exist, we're not on a supported version of AppEngine;\n      return false;\n    }\n  }\n\n  /**\n   * Creates a thread using {@link #platformThreadFactory}, and sets its name to {@code name}\n   * unless changing the name is forbidden by the security manager.\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Thread newThread(String name, Runnable runnable) {\n    checkNotNull(name);\n    checkNotNull(runnable);\n    Thread result = platformThreadFactory().newThread(runnable);\n    try {\n      result.setName(name);\n    } catch (SecurityException e) {\n      // OK if we can't set the name in this environment.\n    }\n    return result;\n  }\n\n  // TODO(lukes): provide overloads for ListeningExecutorService? ListeningScheduledExecutorService?\n  // TODO(lukes): provide overloads that take constant strings? Function<Runnable, String>s to\n  // calculate names?\n\n  /**\n   * Creates an {@link Executor} that renames the {@link Thread threads} that its tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param executor The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier) {\n    checkNotNull(executor);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try\n      return executor;\n    }\n    return new Executor() {\n      @Override public void execute(Runnable command) {\n        executor.execute(Callables.threadRenaming(command, nameSupplier));\n      }\n    };\n  }\n\n  /**\n   * Creates an {@link ExecutorService} that renames the {@link Thread threads} that its tasks run\n   * in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ExecutorService renamingDecorator(final ExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} that renames the {@link Thread threads} that its\n   * tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ScheduledExecutorService renamingDecorator(final ScheduledExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingScheduledExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Shuts down the given executor gradually, first disabling new submissions and later cancelling\n   * existing tasks.\n   *\n   * <p>The method takes the following steps:\n   * <ol>\n   *  <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n   *  <li>waits for half of the specified timeout.\n   *  <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n   *  pending tasks and interrupting running tasks.\n   *  <li>waits for the other half of the specified timeout.\n   * </ol>\n   *\n   * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n   * ExecutorService#shutdownNow()} and returns.\n   *\n   * @param service the {@code ExecutorService} to shut down\n   * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n   * @param unit the time unit of the timeout argument\n   * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n   *     the call timed out or was interrupted\n   * @since 17.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static boolean shutdownAndAwaitTermination(\n      ExecutorService service, long timeout, TimeUnit unit) {\n    checkNotNull(unit);\n    // Disable new tasks from being submitted\n    service.shutdown();\n    try {\n      long halfTimeoutNanos = TimeUnit.NANOSECONDS.convert(timeout, unit) / 2;\n      // Wait for half the duration of the timeout for existing tasks to terminate\n      if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {\n        // Cancel currently executing tasks\n        service.shutdownNow();\n        // Wait the other half of the timeout for tasks to respond to being cancelled\n        service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);\n      }\n    } catch (InterruptedException ie) {\n      // Preserve interrupt status\n      Thread.currentThread().interrupt();\n      // (Re-)Cancel if current thread also interrupted\n      service.shutdownNow();\n    }\n    return service.isTerminated();\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53073810,"label":true,"oracleId":1433,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"MoreExecutors","javadocTag":"@return an unmodifiable version of the input which will not hang the JVM","methodJavadoc":"    /**\n   * Converts the given ThreadPoolExecutor into a ScheduledExecutorService that\n   * exits when the application is complete.  It does so by using daemon threads\n   * and adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */","methodSourceCode":"public static ScheduledExecutorService getExitingScheduledExecutorService(ScheduledThreadPoolExecutor executor){\n    return new Application().getExitingScheduledExecutorService(executor);\n}","classJavadoc":"/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */","classSourceCode":"/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Queues;\nimport com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */\n@GwtCompatible(emulated = true)\npublic final class MoreExecutors {\n  private MoreExecutors() {}\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ExecutorService getExitingExecutorService(\n      ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ScheduledThreadPoolExecutor into a\n   * ScheduledExecutorService that exits when the application is complete.  It\n   * does so by using daemon threads and adding a shutdown hook to wait for\n   * their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingScheduledExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Add a shutdown hook to wait for thread completion in the given\n   * {@link ExecutorService service}.  This is useful if the given service uses\n   * daemon threads, and we want to keep the JVM from exiting immediately on\n   * shutdown, instead giving these daemon threads a chance to terminate\n   * normally.\n   * @param service ExecutorService which uses daemon threads\n   * @param terminationTimeout how long to wait for the executor to finish\n   *        before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static void addDelayedShutdownHook(\n      ExecutorService service, long terminationTimeout, TimeUnit timeUnit) {\n    new Application()\n        .addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n    return new Application().getExitingExecutorService(executor);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into a ScheduledExecutorService that\n   * exits when the application is complete.  It does so by using daemon threads\n   * and adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor) {\n    return new Application().getExitingScheduledExecutorService(executor);\n  }\n\n  /** Represents the current application to register shutdown hooks. */\n  @GwtIncompatible(\"TODO\")\n  @VisibleForTesting\n  static class Application {\n\n    final ExecutorService getExitingExecutorService(\n        ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ExecutorService service = Executors.unconfigurableExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ScheduledExecutorService service = Executors.unconfigurableScheduledExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final void addDelayedShutdownHook(\n        final ExecutorService service, final long terminationTimeout, final TimeUnit timeUnit) {\n      checkNotNull(service);\n      checkNotNull(timeUnit);\n      addShutdownHook(MoreExecutors.newThread(\"DelayedShutdownHook-for-\" + service, new Runnable() {\n        @Override\n        public void run() {\n          try {\n            // We'd like to log progress and failures that may arise in the\n            // following code, but unfortunately the behavior of logging\n            // is undefined in shutdown hooks.\n            // This is because the logging code installs a shutdown hook of its\n            // own. See Cleaner class inside {@link LogManager}.\n            service.shutdown();\n            service.awaitTermination(terminationTimeout, timeUnit);\n          } catch (InterruptedException ignored) {\n            // We're shutting down anyway, so just ignore.\n          }\n        }\n      }));\n    }\n\n    final ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n      return getExitingExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor) {\n      return getExitingScheduledExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    @VisibleForTesting void addShutdownHook(Thread hook) {\n      Runtime.getRuntime().addShutdownHook(hook);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static void useDaemonThreadFactory(ThreadPoolExecutor executor) {\n    executor.setThreadFactory(new ThreadFactoryBuilder()\n        .setDaemon(true)\n        .setThreadFactory(executor.getThreadFactory())\n        .build());\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}.  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 10.0 (<a href=\"https://github.com/google/guava/wiki/Compatibility\"\n   *        >mostly source-compatible</a> since 3.0)\n   * @deprecated Use {@link #directExecutor()} if you only require an {@link Executor} and\n   *     {@link #newDirectExecutorService()} if you need a {@link ListeningExecutorService}. This\n   *     method will be removed in August 2016.\n   */\n  @Deprecated\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService sameThreadExecutor() {\n    return new DirectExecutorService();\n  }\n\n  // See sameThreadExecutor javadoc for behavioral notes.\n  @GwtIncompatible(\"TODO\")\n  private static final class DirectExecutorService\n      extends AbstractListeningExecutorService {\n    /**\n     * Lock used whenever accessing the state variables\n     * (runningTasks, shutdown) of the executor\n     */\n    private final Object lock = new Object();\n\n    /*\n     * Conceptually, these two variables describe the executor being in\n     * one of three states:\n     *   - Active: shutdown == false\n     *   - Shutdown: runningTasks > 0 and shutdown == true\n     *   - Terminated: runningTasks == 0 and shutdown == true\n     */\n    @GuardedBy(\"lock\") private int runningTasks = 0;\n    @GuardedBy(\"lock\") private boolean shutdown = false;\n\n    @Override\n    public void execute(Runnable command) {\n      startTask();\n      try {\n        command.run();\n      } finally {\n        endTask();\n      }\n    }\n\n    @Override\n    public boolean isShutdown() {\n      synchronized (lock) {\n        return shutdown;\n      }\n    }\n\n    @Override\n    public void shutdown() {\n      synchronized (lock) {\n        shutdown = true;\n        if (runningTasks == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n\n    // See sameThreadExecutor javadoc for unusual behavior of this method.\n    @Override\n    public List<Runnable> shutdownNow() {\n      shutdown();\n      return Collections.emptyList();\n    }\n\n    @Override\n    public boolean isTerminated() {\n      synchronized (lock) {\n        return shutdown && runningTasks == 0;\n      }\n    }\n\n    @Override\n    public boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      long nanos = unit.toNanos(timeout);\n      synchronized (lock) {\n        for (;;) {\n          if (shutdown && runningTasks == 0) {\n            return true;\n          } else if (nanos <= 0) {\n            return false;\n          } else {\n            long now = System.nanoTime();\n            TimeUnit.NANOSECONDS.timedWait(lock, nanos);\n            nanos -= System.nanoTime() - now;  // subtract the actual time we waited\n          }\n        }\n      }\n    }\n\n    /**\n     * Checks if the executor has been shut down and increments the running\n     * task count.\n     *\n     * @throws RejectedExecutionException if the executor has been previously\n     *         shutdown\n     */\n    private void startTask() {\n      synchronized (lock) {\n        if (shutdown) {\n          throw new RejectedExecutionException(\"Executor already shutdown\");\n        }\n        runningTasks++;\n      }\n    }\n\n    /**\n     * Decrements the running task count.\n     */\n    private void endTask() {\n      synchronized (lock) {\n        int numRunning = --runningTasks;\n        if (numRunning == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 18.0 (present as MoreExecutors.sameThreadExecutor() since 10.0)\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService newDirectExecutorService() {\n    return new DirectExecutorService();\n  }\n\n  /**\n   * Returns an {@link Executor} that runs each task in the thread that invokes\n   * {@link Executor#execute execute}, as in {@link CallerRunsPolicy}.\n   *\n   * <p>This instance is equivalent to: <pre>   {@code\n   *   final class DirectExecutor implements Executor {\n   *     public void execute(Runnable r) {\n   *       r.run();\n   *     }\n   *   }}</pre>\n   *\n   * <p>This should be preferred to {@link #newDirectExecutorService()} because the implementing the\n   * {@link ExecutorService} subinterface necessitates significant performance overhead.\n   *\n   * @since 18.0\n   */\n  public static Executor directExecutor() {\n    return DirectExecutor.INSTANCE;\n  }\n\n  /** See {@link #directExecutor} for behavioral notes. */\n  private enum DirectExecutor implements Executor {\n    INSTANCE;\n    @Override public void execute(Runnable command) {\n      command.run();\n    }\n\n    @Override public String toString() {\n      return \"MoreExecutors.directExecutor()\";\n    }\n  }\n\n  /**\n   * Creates an {@link ExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code ListeningExecutorService}\n   * never calls the delegate's {@code submit}, {@code invokeAll}, and {@code\n   * invokeAny} methods, so any special handling of tasks must be implemented in\n   * the delegate's {@code execute} method or by wrapping the returned {@code\n   * ListeningExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningExecutorService}, it is returned untouched, and the rest of this\n   * documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService listeningDecorator(\n      ExecutorService delegate) {\n    return (delegate instanceof ListeningExecutorService)\n        ? (ListeningExecutorService) delegate\n        : (delegate instanceof ScheduledExecutorService)\n        ? new ScheduledListeningDecorator((ScheduledExecutorService) delegate)\n        : new ListeningDecorator(delegate);\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code\n   * ListeningScheduledExecutorService} never calls the delegate's {@code\n   * submit}, {@code invokeAll}, and {@code invokeAny} methods, so any special\n   * handling of tasks must be implemented in the delegate's {@code execute}\n   * method or by wrapping the returned {@code\n   * ListeningScheduledExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningScheduledExecutorService}, it is returned untouched, and the rest\n   * of this documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningScheduledExecutorService listeningDecorator(\n      ScheduledExecutorService delegate) {\n    return (delegate instanceof ListeningScheduledExecutorService)\n        ? (ListeningScheduledExecutorService) delegate\n        : new ScheduledListeningDecorator(delegate);\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static class ListeningDecorator\n      extends AbstractListeningExecutorService {\n    private final ExecutorService delegate;\n\n    ListeningDecorator(ExecutorService delegate) {\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public final boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      return delegate.awaitTermination(timeout, unit);\n    }\n\n    @Override\n    public final boolean isShutdown() {\n      return delegate.isShutdown();\n    }\n\n    @Override\n    public final boolean isTerminated() {\n      return delegate.isTerminated();\n    }\n\n    @Override\n    public final void shutdown() {\n      delegate.shutdown();\n    }\n\n    @Override\n    public final List<Runnable> shutdownNow() {\n      return delegate.shutdownNow();\n    }\n\n    @Override\n    public final void execute(Runnable command) {\n      delegate.execute(command);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static final class ScheduledListeningDecorator\n      extends ListeningDecorator implements ListeningScheduledExecutorService {\n    @SuppressWarnings(\"hiding\")\n    final ScheduledExecutorService delegate;\n\n    ScheduledListeningDecorator(ScheduledExecutorService delegate) {\n      super(delegate);\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> schedule(\n        Runnable command, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<Void> task =\n          TrustedListenableFutureTask.create(command, null);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public <V> ListenableScheduledFuture<V> schedule(\n        Callable<V> callable, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<V>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleAtFixedRate(\n        Runnable command, long initialDelay, long period, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleAtFixedRate(task, initialDelay, period, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleWithFixedDelay(\n        Runnable command, long initialDelay, long delay, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleWithFixedDelay(task, initialDelay, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    private static final class ListenableScheduledTask<V>\n        extends SimpleForwardingListenableFuture<V>\n        implements ListenableScheduledFuture<V> {\n\n      private final ScheduledFuture<?> scheduledDelegate;\n\n      public ListenableScheduledTask(\n          ListenableFuture<V> listenableDelegate,\n          ScheduledFuture<?> scheduledDelegate) {\n        super(listenableDelegate);\n        this.scheduledDelegate = scheduledDelegate;\n      }\n\n      @Override\n      public boolean cancel(boolean mayInterruptIfRunning) {\n        boolean cancelled = super.cancel(mayInterruptIfRunning);\n        if (cancelled) {\n          // Unless it is cancelled, the delegate may continue being scheduled\n          scheduledDelegate.cancel(mayInterruptIfRunning);\n\n          // TODO(user): Cancel \"this\" if \"scheduledDelegate\" is cancelled.\n        }\n        return cancelled;\n      }\n\n      @Override\n      public long getDelay(TimeUnit unit) {\n        return scheduledDelegate.getDelay(unit);\n      }\n\n      @Override\n      public int compareTo(Delayed other) {\n        return scheduledDelegate.compareTo(other);\n      }\n    }\n\n    @GwtIncompatible(\"TODO\")\n    private static final class NeverSuccessfulListenableFutureTask\n        extends AbstractFuture<Void>\n        implements Runnable {\n      private final Runnable delegate;\n\n      public NeverSuccessfulListenableFutureTask(Runnable delegate) {\n        this.delegate = checkNotNull(delegate);\n      }\n\n      @Override public void run() {\n        try {\n          delegate.run();\n        } catch (Throwable t) {\n          setException(t);\n          throw Throwables.propagate(t);\n        }\n      }\n    }\n  }\n\n  /*\n   * This following method is a modified version of one found in\n   * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/AbstractExecutorServiceTest.java?revision=1.30\n   * which contained the following notice:\n   *\n   * Written by Doug Lea with assistance from members of JCP JSR-166\n   * Expert Group and released to the public domain, as explained at\n   * http://creativecommons.org/publicdomain/zero/1.0/\n   * Other contributors include Andrew Wright, Jeffrey Hayes,\n   * Pat Fisher, Mike Judd.\n   */\n\n  /**\n   * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}\n   * implementations.\n   */ static <T> T invokeAnyImpl(ListeningExecutorService executorService,\n      Collection<? extends Callable<T>> tasks, boolean timed, long nanos)\n          throws InterruptedException, ExecutionException, TimeoutException {\n    checkNotNull(executorService);\n    int ntasks = tasks.size();\n    checkArgument(ntasks > 0);\n    List<Future<T>> futures = Lists.newArrayListWithCapacity(ntasks);\n    BlockingQueue<Future<T>> futureQueue = Queues.newLinkedBlockingQueue();\n\n    // For efficiency, especially in executors with limited\n    // parallelism, check to see if previously submitted tasks are\n    // done before submitting more of them. This interleaving\n    // plus the exception mechanics account for messiness of main\n    // loop.\n\n    try {\n      // Record exceptions so that if we fail to obtain any\n      // result, we can throw the last exception we got.\n      ExecutionException ee = null;\n      long lastTime = timed ? System.nanoTime() : 0;\n      Iterator<? extends Callable<T>> it = tasks.iterator();\n\n      futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n      --ntasks;\n      int active = 1;\n\n      for (;;) {\n        Future<T> f = futureQueue.poll();\n        if (f == null) {\n          if (ntasks > 0) {\n            --ntasks;\n            futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n            ++active;\n          } else if (active == 0) {\n            break;\n          } else if (timed) {\n            f = futureQueue.poll(nanos, TimeUnit.NANOSECONDS);\n            if (f == null) {\n              throw new TimeoutException();\n            }\n            long now = System.nanoTime();\n            nanos -= now - lastTime;\n            lastTime = now;\n          } else {\n            f = futureQueue.take();\n          }\n        }\n        if (f != null) {\n          --active;\n          try {\n            return f.get();\n          } catch (ExecutionException eex) {\n            ee = eex;\n          } catch (RuntimeException rex) {\n            ee = new ExecutionException(rex);\n          }\n        }\n      }\n\n      if (ee == null) {\n        ee = new ExecutionException(null);\n      }\n      throw ee;\n    } finally {\n      for (Future<T> f : futures) {\n        f.cancel(true);\n      }\n    }\n  }\n\n  /**\n   * Submits the task and adds a listener that adds the future to {@code queue} when it completes.\n   */\n  @GwtIncompatible(\"TODO\")\n  private static <T> ListenableFuture<T> submitAndAddQueueListener(\n      ListeningExecutorService executorService, Callable<T> task,\n      final BlockingQueue<Future<T>> queue) {\n    final ListenableFuture<T> future = executorService.submit(task);\n    future.addListener(new Runnable() {\n      @Override public void run() {\n        queue.add(future);\n      }\n    }, directExecutor());\n    return future;\n  }\n\n  /**\n   * Returns a default thread factory used to create new threads.\n   *\n   * <p>On AppEngine, returns {@code ThreadManager.currentRequestThreadFactory()}.\n   * Otherwise, returns {@link Executors#defaultThreadFactory()}.\n   *\n   * @since 14.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ThreadFactory platformThreadFactory() {\n    if (!isAppEngine()) {\n      return Executors.defaultThreadFactory();\n    }\n    try {\n      return (ThreadFactory) Class.forName(\"com.google.appengine.api.ThreadManager\")\n          .getMethod(\"currentRequestThreadFactory\")\n          .invoke(null);\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (ClassNotFoundException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (NoSuchMethodException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (InvocationTargetException e) {\n      throw Throwables.propagate(e.getCause());\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static boolean isAppEngine() {\n    if (System.getProperty(\"com.google.appengine.runtime.environment\") == null) {\n      return false;\n    }\n    try {\n      // If the current environment is null, we're not inside AppEngine.\n      return Class.forName(\"com.google.apphosting.api.ApiProxy\")\n          .getMethod(\"getCurrentEnvironment\")\n          .invoke(null) != null;\n    } catch (ClassNotFoundException e) {\n      // If ApiProxy doesn't exist, we're not on AppEngine at all.\n      return false;\n    } catch (InvocationTargetException e) {\n      // If ApiProxy throws an exception, we're not in a proper AppEngine environment.\n      return false;\n    } catch (IllegalAccessException e) {\n      // If the method isn't accessible, we're not on a supported version of AppEngine;\n      return false;\n    } catch (NoSuchMethodException e) {\n      // If the method doesn't exist, we're not on a supported version of AppEngine;\n      return false;\n    }\n  }\n\n  /**\n   * Creates a thread using {@link #platformThreadFactory}, and sets its name to {@code name}\n   * unless changing the name is forbidden by the security manager.\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Thread newThread(String name, Runnable runnable) {\n    checkNotNull(name);\n    checkNotNull(runnable);\n    Thread result = platformThreadFactory().newThread(runnable);\n    try {\n      result.setName(name);\n    } catch (SecurityException e) {\n      // OK if we can't set the name in this environment.\n    }\n    return result;\n  }\n\n  // TODO(lukes): provide overloads for ListeningExecutorService? ListeningScheduledExecutorService?\n  // TODO(lukes): provide overloads that take constant strings? Function<Runnable, String>s to\n  // calculate names?\n\n  /**\n   * Creates an {@link Executor} that renames the {@link Thread threads} that its tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param executor The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier) {\n    checkNotNull(executor);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try\n      return executor;\n    }\n    return new Executor() {\n      @Override public void execute(Runnable command) {\n        executor.execute(Callables.threadRenaming(command, nameSupplier));\n      }\n    };\n  }\n\n  /**\n   * Creates an {@link ExecutorService} that renames the {@link Thread threads} that its tasks run\n   * in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ExecutorService renamingDecorator(final ExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} that renames the {@link Thread threads} that its\n   * tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ScheduledExecutorService renamingDecorator(final ScheduledExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingScheduledExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Shuts down the given executor gradually, first disabling new submissions and later cancelling\n   * existing tasks.\n   *\n   * <p>The method takes the following steps:\n   * <ol>\n   *  <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n   *  <li>waits for half of the specified timeout.\n   *  <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n   *  pending tasks and interrupting running tasks.\n   *  <li>waits for the other half of the specified timeout.\n   * </ol>\n   *\n   * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n   * ExecutorService#shutdownNow()} and returns.\n   *\n   * @param service the {@code ExecutorService} to shut down\n   * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n   * @param unit the time unit of the timeout argument\n   * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n   *     the call timed out or was interrupted\n   * @since 17.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static boolean shutdownAndAwaitTermination(\n      ExecutorService service, long timeout, TimeUnit unit) {\n    checkNotNull(unit);\n    // Disable new tasks from being submitted\n    service.shutdown();\n    try {\n      long halfTimeoutNanos = TimeUnit.NANOSECONDS.convert(timeout, unit) / 2;\n      // Wait for half the duration of the timeout for existing tasks to terminate\n      if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {\n        // Cancel currently executing tasks\n        service.shutdownNow();\n        // Wait the other half of the timeout for tasks to respond to being cancelled\n        service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);\n      }\n    } catch (InterruptedException ie) {\n      // Preserve interrupt status\n      Thread.currentThread().interrupt();\n      // (Re-)Cancel if current thread also interrupted\n      service.shutdownNow();\n    }\n    return service.isTerminated();\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53074268,"label":true,"oracleId":1434,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"MoreExecutors","javadocTag":"@param executor The executor to decorate","methodJavadoc":"    /**\n   * Creates an {@link Executor} that renames the {@link Thread threads} that its tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param executor The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */","methodSourceCode":"static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier){\n    checkNotNull(executor);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n        // AppEngine doesn't support thread renaming, so don't even try\n        return executor;\n    }\n    return new Executor() {\n\n        @Override\n        public void execute(Runnable command) {\n            executor.execute(Callables.threadRenaming(command, nameSupplier));\n        }\n    };\n}","classJavadoc":"/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */","classSourceCode":"/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Queues;\nimport com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */\n@GwtCompatible(emulated = true)\npublic final class MoreExecutors {\n  private MoreExecutors() {}\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ExecutorService getExitingExecutorService(\n      ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ScheduledThreadPoolExecutor into a\n   * ScheduledExecutorService that exits when the application is complete.  It\n   * does so by using daemon threads and adding a shutdown hook to wait for\n   * their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingScheduledExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Add a shutdown hook to wait for thread completion in the given\n   * {@link ExecutorService service}.  This is useful if the given service uses\n   * daemon threads, and we want to keep the JVM from exiting immediately on\n   * shutdown, instead giving these daemon threads a chance to terminate\n   * normally.\n   * @param service ExecutorService which uses daemon threads\n   * @param terminationTimeout how long to wait for the executor to finish\n   *        before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static void addDelayedShutdownHook(\n      ExecutorService service, long terminationTimeout, TimeUnit timeUnit) {\n    new Application()\n        .addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n    return new Application().getExitingExecutorService(executor);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into a ScheduledExecutorService that\n   * exits when the application is complete.  It does so by using daemon threads\n   * and adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor) {\n    return new Application().getExitingScheduledExecutorService(executor);\n  }\n\n  /** Represents the current application to register shutdown hooks. */\n  @GwtIncompatible(\"TODO\")\n  @VisibleForTesting\n  static class Application {\n\n    final ExecutorService getExitingExecutorService(\n        ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ExecutorService service = Executors.unconfigurableExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ScheduledExecutorService service = Executors.unconfigurableScheduledExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final void addDelayedShutdownHook(\n        final ExecutorService service, final long terminationTimeout, final TimeUnit timeUnit) {\n      checkNotNull(service);\n      checkNotNull(timeUnit);\n      addShutdownHook(MoreExecutors.newThread(\"DelayedShutdownHook-for-\" + service, new Runnable() {\n        @Override\n        public void run() {\n          try {\n            // We'd like to log progress and failures that may arise in the\n            // following code, but unfortunately the behavior of logging\n            // is undefined in shutdown hooks.\n            // This is because the logging code installs a shutdown hook of its\n            // own. See Cleaner class inside {@link LogManager}.\n            service.shutdown();\n            service.awaitTermination(terminationTimeout, timeUnit);\n          } catch (InterruptedException ignored) {\n            // We're shutting down anyway, so just ignore.\n          }\n        }\n      }));\n    }\n\n    final ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n      return getExitingExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor) {\n      return getExitingScheduledExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    @VisibleForTesting void addShutdownHook(Thread hook) {\n      Runtime.getRuntime().addShutdownHook(hook);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static void useDaemonThreadFactory(ThreadPoolExecutor executor) {\n    executor.setThreadFactory(new ThreadFactoryBuilder()\n        .setDaemon(true)\n        .setThreadFactory(executor.getThreadFactory())\n        .build());\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}.  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 10.0 (<a href=\"https://github.com/google/guava/wiki/Compatibility\"\n   *        >mostly source-compatible</a> since 3.0)\n   * @deprecated Use {@link #directExecutor()} if you only require an {@link Executor} and\n   *     {@link #newDirectExecutorService()} if you need a {@link ListeningExecutorService}. This\n   *     method will be removed in August 2016.\n   */\n  @Deprecated\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService sameThreadExecutor() {\n    return new DirectExecutorService();\n  }\n\n  // See sameThreadExecutor javadoc for behavioral notes.\n  @GwtIncompatible(\"TODO\")\n  private static final class DirectExecutorService\n      extends AbstractListeningExecutorService {\n    /**\n     * Lock used whenever accessing the state variables\n     * (runningTasks, shutdown) of the executor\n     */\n    private final Object lock = new Object();\n\n    /*\n     * Conceptually, these two variables describe the executor being in\n     * one of three states:\n     *   - Active: shutdown == false\n     *   - Shutdown: runningTasks > 0 and shutdown == true\n     *   - Terminated: runningTasks == 0 and shutdown == true\n     */\n    @GuardedBy(\"lock\") private int runningTasks = 0;\n    @GuardedBy(\"lock\") private boolean shutdown = false;\n\n    @Override\n    public void execute(Runnable command) {\n      startTask();\n      try {\n        command.run();\n      } finally {\n        endTask();\n      }\n    }\n\n    @Override\n    public boolean isShutdown() {\n      synchronized (lock) {\n        return shutdown;\n      }\n    }\n\n    @Override\n    public void shutdown() {\n      synchronized (lock) {\n        shutdown = true;\n        if (runningTasks == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n\n    // See sameThreadExecutor javadoc for unusual behavior of this method.\n    @Override\n    public List<Runnable> shutdownNow() {\n      shutdown();\n      return Collections.emptyList();\n    }\n\n    @Override\n    public boolean isTerminated() {\n      synchronized (lock) {\n        return shutdown && runningTasks == 0;\n      }\n    }\n\n    @Override\n    public boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      long nanos = unit.toNanos(timeout);\n      synchronized (lock) {\n        for (;;) {\n          if (shutdown && runningTasks == 0) {\n            return true;\n          } else if (nanos <= 0) {\n            return false;\n          } else {\n            long now = System.nanoTime();\n            TimeUnit.NANOSECONDS.timedWait(lock, nanos);\n            nanos -= System.nanoTime() - now;  // subtract the actual time we waited\n          }\n        }\n      }\n    }\n\n    /**\n     * Checks if the executor has been shut down and increments the running\n     * task count.\n     *\n     * @throws RejectedExecutionException if the executor has been previously\n     *         shutdown\n     */\n    private void startTask() {\n      synchronized (lock) {\n        if (shutdown) {\n          throw new RejectedExecutionException(\"Executor already shutdown\");\n        }\n        runningTasks++;\n      }\n    }\n\n    /**\n     * Decrements the running task count.\n     */\n    private void endTask() {\n      synchronized (lock) {\n        int numRunning = --runningTasks;\n        if (numRunning == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 18.0 (present as MoreExecutors.sameThreadExecutor() since 10.0)\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService newDirectExecutorService() {\n    return new DirectExecutorService();\n  }\n\n  /**\n   * Returns an {@link Executor} that runs each task in the thread that invokes\n   * {@link Executor#execute execute}, as in {@link CallerRunsPolicy}.\n   *\n   * <p>This instance is equivalent to: <pre>   {@code\n   *   final class DirectExecutor implements Executor {\n   *     public void execute(Runnable r) {\n   *       r.run();\n   *     }\n   *   }}</pre>\n   *\n   * <p>This should be preferred to {@link #newDirectExecutorService()} because the implementing the\n   * {@link ExecutorService} subinterface necessitates significant performance overhead.\n   *\n   * @since 18.0\n   */\n  public static Executor directExecutor() {\n    return DirectExecutor.INSTANCE;\n  }\n\n  /** See {@link #directExecutor} for behavioral notes. */\n  private enum DirectExecutor implements Executor {\n    INSTANCE;\n    @Override public void execute(Runnable command) {\n      command.run();\n    }\n\n    @Override public String toString() {\n      return \"MoreExecutors.directExecutor()\";\n    }\n  }\n\n  /**\n   * Creates an {@link ExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code ListeningExecutorService}\n   * never calls the delegate's {@code submit}, {@code invokeAll}, and {@code\n   * invokeAny} methods, so any special handling of tasks must be implemented in\n   * the delegate's {@code execute} method or by wrapping the returned {@code\n   * ListeningExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningExecutorService}, it is returned untouched, and the rest of this\n   * documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService listeningDecorator(\n      ExecutorService delegate) {\n    return (delegate instanceof ListeningExecutorService)\n        ? (ListeningExecutorService) delegate\n        : (delegate instanceof ScheduledExecutorService)\n        ? new ScheduledListeningDecorator((ScheduledExecutorService) delegate)\n        : new ListeningDecorator(delegate);\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code\n   * ListeningScheduledExecutorService} never calls the delegate's {@code\n   * submit}, {@code invokeAll}, and {@code invokeAny} methods, so any special\n   * handling of tasks must be implemented in the delegate's {@code execute}\n   * method or by wrapping the returned {@code\n   * ListeningScheduledExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningScheduledExecutorService}, it is returned untouched, and the rest\n   * of this documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningScheduledExecutorService listeningDecorator(\n      ScheduledExecutorService delegate) {\n    return (delegate instanceof ListeningScheduledExecutorService)\n        ? (ListeningScheduledExecutorService) delegate\n        : new ScheduledListeningDecorator(delegate);\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static class ListeningDecorator\n      extends AbstractListeningExecutorService {\n    private final ExecutorService delegate;\n\n    ListeningDecorator(ExecutorService delegate) {\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public final boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      return delegate.awaitTermination(timeout, unit);\n    }\n\n    @Override\n    public final boolean isShutdown() {\n      return delegate.isShutdown();\n    }\n\n    @Override\n    public final boolean isTerminated() {\n      return delegate.isTerminated();\n    }\n\n    @Override\n    public final void shutdown() {\n      delegate.shutdown();\n    }\n\n    @Override\n    public final List<Runnable> shutdownNow() {\n      return delegate.shutdownNow();\n    }\n\n    @Override\n    public final void execute(Runnable command) {\n      delegate.execute(command);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static final class ScheduledListeningDecorator\n      extends ListeningDecorator implements ListeningScheduledExecutorService {\n    @SuppressWarnings(\"hiding\")\n    final ScheduledExecutorService delegate;\n\n    ScheduledListeningDecorator(ScheduledExecutorService delegate) {\n      super(delegate);\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> schedule(\n        Runnable command, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<Void> task =\n          TrustedListenableFutureTask.create(command, null);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public <V> ListenableScheduledFuture<V> schedule(\n        Callable<V> callable, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<V>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleAtFixedRate(\n        Runnable command, long initialDelay, long period, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleAtFixedRate(task, initialDelay, period, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleWithFixedDelay(\n        Runnable command, long initialDelay, long delay, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleWithFixedDelay(task, initialDelay, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    private static final class ListenableScheduledTask<V>\n        extends SimpleForwardingListenableFuture<V>\n        implements ListenableScheduledFuture<V> {\n\n      private final ScheduledFuture<?> scheduledDelegate;\n\n      public ListenableScheduledTask(\n          ListenableFuture<V> listenableDelegate,\n          ScheduledFuture<?> scheduledDelegate) {\n        super(listenableDelegate);\n        this.scheduledDelegate = scheduledDelegate;\n      }\n\n      @Override\n      public boolean cancel(boolean mayInterruptIfRunning) {\n        boolean cancelled = super.cancel(mayInterruptIfRunning);\n        if (cancelled) {\n          // Unless it is cancelled, the delegate may continue being scheduled\n          scheduledDelegate.cancel(mayInterruptIfRunning);\n\n          // TODO(user): Cancel \"this\" if \"scheduledDelegate\" is cancelled.\n        }\n        return cancelled;\n      }\n\n      @Override\n      public long getDelay(TimeUnit unit) {\n        return scheduledDelegate.getDelay(unit);\n      }\n\n      @Override\n      public int compareTo(Delayed other) {\n        return scheduledDelegate.compareTo(other);\n      }\n    }\n\n    @GwtIncompatible(\"TODO\")\n    private static final class NeverSuccessfulListenableFutureTask\n        extends AbstractFuture<Void>\n        implements Runnable {\n      private final Runnable delegate;\n\n      public NeverSuccessfulListenableFutureTask(Runnable delegate) {\n        this.delegate = checkNotNull(delegate);\n      }\n\n      @Override public void run() {\n        try {\n          delegate.run();\n        } catch (Throwable t) {\n          setException(t);\n          throw Throwables.propagate(t);\n        }\n      }\n    }\n  }\n\n  /*\n   * This following method is a modified version of one found in\n   * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/AbstractExecutorServiceTest.java?revision=1.30\n   * which contained the following notice:\n   *\n   * Written by Doug Lea with assistance from members of JCP JSR-166\n   * Expert Group and released to the public domain, as explained at\n   * http://creativecommons.org/publicdomain/zero/1.0/\n   * Other contributors include Andrew Wright, Jeffrey Hayes,\n   * Pat Fisher, Mike Judd.\n   */\n\n  /**\n   * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}\n   * implementations.\n   */ static <T> T invokeAnyImpl(ListeningExecutorService executorService,\n      Collection<? extends Callable<T>> tasks, boolean timed, long nanos)\n          throws InterruptedException, ExecutionException, TimeoutException {\n    checkNotNull(executorService);\n    int ntasks = tasks.size();\n    checkArgument(ntasks > 0);\n    List<Future<T>> futures = Lists.newArrayListWithCapacity(ntasks);\n    BlockingQueue<Future<T>> futureQueue = Queues.newLinkedBlockingQueue();\n\n    // For efficiency, especially in executors with limited\n    // parallelism, check to see if previously submitted tasks are\n    // done before submitting more of them. This interleaving\n    // plus the exception mechanics account for messiness of main\n    // loop.\n\n    try {\n      // Record exceptions so that if we fail to obtain any\n      // result, we can throw the last exception we got.\n      ExecutionException ee = null;\n      long lastTime = timed ? System.nanoTime() : 0;\n      Iterator<? extends Callable<T>> it = tasks.iterator();\n\n      futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n      --ntasks;\n      int active = 1;\n\n      for (;;) {\n        Future<T> f = futureQueue.poll();\n        if (f == null) {\n          if (ntasks > 0) {\n            --ntasks;\n            futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n            ++active;\n          } else if (active == 0) {\n            break;\n          } else if (timed) {\n            f = futureQueue.poll(nanos, TimeUnit.NANOSECONDS);\n            if (f == null) {\n              throw new TimeoutException();\n            }\n            long now = System.nanoTime();\n            nanos -= now - lastTime;\n            lastTime = now;\n          } else {\n            f = futureQueue.take();\n          }\n        }\n        if (f != null) {\n          --active;\n          try {\n            return f.get();\n          } catch (ExecutionException eex) {\n            ee = eex;\n          } catch (RuntimeException rex) {\n            ee = new ExecutionException(rex);\n          }\n        }\n      }\n\n      if (ee == null) {\n        ee = new ExecutionException(null);\n      }\n      throw ee;\n    } finally {\n      for (Future<T> f : futures) {\n        f.cancel(true);\n      }\n    }\n  }\n\n  /**\n   * Submits the task and adds a listener that adds the future to {@code queue} when it completes.\n   */\n  @GwtIncompatible(\"TODO\")\n  private static <T> ListenableFuture<T> submitAndAddQueueListener(\n      ListeningExecutorService executorService, Callable<T> task,\n      final BlockingQueue<Future<T>> queue) {\n    final ListenableFuture<T> future = executorService.submit(task);\n    future.addListener(new Runnable() {\n      @Override public void run() {\n        queue.add(future);\n      }\n    }, directExecutor());\n    return future;\n  }\n\n  /**\n   * Returns a default thread factory used to create new threads.\n   *\n   * <p>On AppEngine, returns {@code ThreadManager.currentRequestThreadFactory()}.\n   * Otherwise, returns {@link Executors#defaultThreadFactory()}.\n   *\n   * @since 14.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ThreadFactory platformThreadFactory() {\n    if (!isAppEngine()) {\n      return Executors.defaultThreadFactory();\n    }\n    try {\n      return (ThreadFactory) Class.forName(\"com.google.appengine.api.ThreadManager\")\n          .getMethod(\"currentRequestThreadFactory\")\n          .invoke(null);\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (ClassNotFoundException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (NoSuchMethodException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (InvocationTargetException e) {\n      throw Throwables.propagate(e.getCause());\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static boolean isAppEngine() {\n    if (System.getProperty(\"com.google.appengine.runtime.environment\") == null) {\n      return false;\n    }\n    try {\n      // If the current environment is null, we're not inside AppEngine.\n      return Class.forName(\"com.google.apphosting.api.ApiProxy\")\n          .getMethod(\"getCurrentEnvironment\")\n          .invoke(null) != null;\n    } catch (ClassNotFoundException e) {\n      // If ApiProxy doesn't exist, we're not on AppEngine at all.\n      return false;\n    } catch (InvocationTargetException e) {\n      // If ApiProxy throws an exception, we're not in a proper AppEngine environment.\n      return false;\n    } catch (IllegalAccessException e) {\n      // If the method isn't accessible, we're not on a supported version of AppEngine;\n      return false;\n    } catch (NoSuchMethodException e) {\n      // If the method doesn't exist, we're not on a supported version of AppEngine;\n      return false;\n    }\n  }\n\n  /**\n   * Creates a thread using {@link #platformThreadFactory}, and sets its name to {@code name}\n   * unless changing the name is forbidden by the security manager.\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Thread newThread(String name, Runnable runnable) {\n    checkNotNull(name);\n    checkNotNull(runnable);\n    Thread result = platformThreadFactory().newThread(runnable);\n    try {\n      result.setName(name);\n    } catch (SecurityException e) {\n      // OK if we can't set the name in this environment.\n    }\n    return result;\n  }\n\n  // TODO(lukes): provide overloads for ListeningExecutorService? ListeningScheduledExecutorService?\n  // TODO(lukes): provide overloads that take constant strings? Function<Runnable, String>s to\n  // calculate names?\n\n  /**\n   * Creates an {@link Executor} that renames the {@link Thread threads} that its tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param executor The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier) {\n    checkNotNull(executor);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try\n      return executor;\n    }\n    return new Executor() {\n      @Override public void execute(Runnable command) {\n        executor.execute(Callables.threadRenaming(command, nameSupplier));\n      }\n    };\n  }\n\n  /**\n   * Creates an {@link ExecutorService} that renames the {@link Thread threads} that its tasks run\n   * in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ExecutorService renamingDecorator(final ExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} that renames the {@link Thread threads} that its\n   * tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ScheduledExecutorService renamingDecorator(final ScheduledExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingScheduledExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Shuts down the given executor gradually, first disabling new submissions and later cancelling\n   * existing tasks.\n   *\n   * <p>The method takes the following steps:\n   * <ol>\n   *  <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n   *  <li>waits for half of the specified timeout.\n   *  <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n   *  pending tasks and interrupting running tasks.\n   *  <li>waits for the other half of the specified timeout.\n   * </ol>\n   *\n   * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n   * ExecutorService#shutdownNow()} and returns.\n   *\n   * @param service the {@code ExecutorService} to shut down\n   * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n   * @param unit the time unit of the timeout argument\n   * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n   *     the call timed out or was interrupted\n   * @since 17.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static boolean shutdownAndAwaitTermination(\n      ExecutorService service, long timeout, TimeUnit unit) {\n    checkNotNull(unit);\n    // Disable new tasks from being submitted\n    service.shutdown();\n    try {\n      long halfTimeoutNanos = TimeUnit.NANOSECONDS.convert(timeout, unit) / 2;\n      // Wait for half the duration of the timeout for existing tasks to terminate\n      if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {\n        // Cancel currently executing tasks\n        service.shutdownNow();\n        // Wait the other half of the timeout for tasks to respond to being cancelled\n        service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);\n      }\n    } catch (InterruptedException ie) {\n      // Preserve interrupt status\n      Thread.currentThread().interrupt();\n      // (Re-)Cancel if current thread also interrupted\n      service.shutdownNow();\n    }\n    return service.isTerminated();\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53074726,"label":true,"oracleId":1435,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"MoreExecutors","javadocTag":"@param nameSupplier The source of names for each task","methodJavadoc":"    /**\n   * Creates an {@link Executor} that renames the {@link Thread threads} that its tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param executor The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */","methodSourceCode":"static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier){\n    checkNotNull(executor);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n        // AppEngine doesn't support thread renaming, so don't even try\n        return executor;\n    }\n    return new Executor() {\n\n        @Override\n        public void execute(Runnable command) {\n            executor.execute(Callables.threadRenaming(command, nameSupplier));\n        }\n    };\n}","classJavadoc":"/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */","classSourceCode":"/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Queues;\nimport com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */\n@GwtCompatible(emulated = true)\npublic final class MoreExecutors {\n  private MoreExecutors() {}\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ExecutorService getExitingExecutorService(\n      ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ScheduledThreadPoolExecutor into a\n   * ScheduledExecutorService that exits when the application is complete.  It\n   * does so by using daemon threads and adding a shutdown hook to wait for\n   * their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingScheduledExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Add a shutdown hook to wait for thread completion in the given\n   * {@link ExecutorService service}.  This is useful if the given service uses\n   * daemon threads, and we want to keep the JVM from exiting immediately on\n   * shutdown, instead giving these daemon threads a chance to terminate\n   * normally.\n   * @param service ExecutorService which uses daemon threads\n   * @param terminationTimeout how long to wait for the executor to finish\n   *        before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static void addDelayedShutdownHook(\n      ExecutorService service, long terminationTimeout, TimeUnit timeUnit) {\n    new Application()\n        .addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n    return new Application().getExitingExecutorService(executor);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into a ScheduledExecutorService that\n   * exits when the application is complete.  It does so by using daemon threads\n   * and adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor) {\n    return new Application().getExitingScheduledExecutorService(executor);\n  }\n\n  /** Represents the current application to register shutdown hooks. */\n  @GwtIncompatible(\"TODO\")\n  @VisibleForTesting\n  static class Application {\n\n    final ExecutorService getExitingExecutorService(\n        ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ExecutorService service = Executors.unconfigurableExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ScheduledExecutorService service = Executors.unconfigurableScheduledExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final void addDelayedShutdownHook(\n        final ExecutorService service, final long terminationTimeout, final TimeUnit timeUnit) {\n      checkNotNull(service);\n      checkNotNull(timeUnit);\n      addShutdownHook(MoreExecutors.newThread(\"DelayedShutdownHook-for-\" + service, new Runnable() {\n        @Override\n        public void run() {\n          try {\n            // We'd like to log progress and failures that may arise in the\n            // following code, but unfortunately the behavior of logging\n            // is undefined in shutdown hooks.\n            // This is because the logging code installs a shutdown hook of its\n            // own. See Cleaner class inside {@link LogManager}.\n            service.shutdown();\n            service.awaitTermination(terminationTimeout, timeUnit);\n          } catch (InterruptedException ignored) {\n            // We're shutting down anyway, so just ignore.\n          }\n        }\n      }));\n    }\n\n    final ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n      return getExitingExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor) {\n      return getExitingScheduledExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    @VisibleForTesting void addShutdownHook(Thread hook) {\n      Runtime.getRuntime().addShutdownHook(hook);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static void useDaemonThreadFactory(ThreadPoolExecutor executor) {\n    executor.setThreadFactory(new ThreadFactoryBuilder()\n        .setDaemon(true)\n        .setThreadFactory(executor.getThreadFactory())\n        .build());\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}.  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 10.0 (<a href=\"https://github.com/google/guava/wiki/Compatibility\"\n   *        >mostly source-compatible</a> since 3.0)\n   * @deprecated Use {@link #directExecutor()} if you only require an {@link Executor} and\n   *     {@link #newDirectExecutorService()} if you need a {@link ListeningExecutorService}. This\n   *     method will be removed in August 2016.\n   */\n  @Deprecated\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService sameThreadExecutor() {\n    return new DirectExecutorService();\n  }\n\n  // See sameThreadExecutor javadoc for behavioral notes.\n  @GwtIncompatible(\"TODO\")\n  private static final class DirectExecutorService\n      extends AbstractListeningExecutorService {\n    /**\n     * Lock used whenever accessing the state variables\n     * (runningTasks, shutdown) of the executor\n     */\n    private final Object lock = new Object();\n\n    /*\n     * Conceptually, these two variables describe the executor being in\n     * one of three states:\n     *   - Active: shutdown == false\n     *   - Shutdown: runningTasks > 0 and shutdown == true\n     *   - Terminated: runningTasks == 0 and shutdown == true\n     */\n    @GuardedBy(\"lock\") private int runningTasks = 0;\n    @GuardedBy(\"lock\") private boolean shutdown = false;\n\n    @Override\n    public void execute(Runnable command) {\n      startTask();\n      try {\n        command.run();\n      } finally {\n        endTask();\n      }\n    }\n\n    @Override\n    public boolean isShutdown() {\n      synchronized (lock) {\n        return shutdown;\n      }\n    }\n\n    @Override\n    public void shutdown() {\n      synchronized (lock) {\n        shutdown = true;\n        if (runningTasks == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n\n    // See sameThreadExecutor javadoc for unusual behavior of this method.\n    @Override\n    public List<Runnable> shutdownNow() {\n      shutdown();\n      return Collections.emptyList();\n    }\n\n    @Override\n    public boolean isTerminated() {\n      synchronized (lock) {\n        return shutdown && runningTasks == 0;\n      }\n    }\n\n    @Override\n    public boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      long nanos = unit.toNanos(timeout);\n      synchronized (lock) {\n        for (;;) {\n          if (shutdown && runningTasks == 0) {\n            return true;\n          } else if (nanos <= 0) {\n            return false;\n          } else {\n            long now = System.nanoTime();\n            TimeUnit.NANOSECONDS.timedWait(lock, nanos);\n            nanos -= System.nanoTime() - now;  // subtract the actual time we waited\n          }\n        }\n      }\n    }\n\n    /**\n     * Checks if the executor has been shut down and increments the running\n     * task count.\n     *\n     * @throws RejectedExecutionException if the executor has been previously\n     *         shutdown\n     */\n    private void startTask() {\n      synchronized (lock) {\n        if (shutdown) {\n          throw new RejectedExecutionException(\"Executor already shutdown\");\n        }\n        runningTasks++;\n      }\n    }\n\n    /**\n     * Decrements the running task count.\n     */\n    private void endTask() {\n      synchronized (lock) {\n        int numRunning = --runningTasks;\n        if (numRunning == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 18.0 (present as MoreExecutors.sameThreadExecutor() since 10.0)\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService newDirectExecutorService() {\n    return new DirectExecutorService();\n  }\n\n  /**\n   * Returns an {@link Executor} that runs each task in the thread that invokes\n   * {@link Executor#execute execute}, as in {@link CallerRunsPolicy}.\n   *\n   * <p>This instance is equivalent to: <pre>   {@code\n   *   final class DirectExecutor implements Executor {\n   *     public void execute(Runnable r) {\n   *       r.run();\n   *     }\n   *   }}</pre>\n   *\n   * <p>This should be preferred to {@link #newDirectExecutorService()} because the implementing the\n   * {@link ExecutorService} subinterface necessitates significant performance overhead.\n   *\n   * @since 18.0\n   */\n  public static Executor directExecutor() {\n    return DirectExecutor.INSTANCE;\n  }\n\n  /** See {@link #directExecutor} for behavioral notes. */\n  private enum DirectExecutor implements Executor {\n    INSTANCE;\n    @Override public void execute(Runnable command) {\n      command.run();\n    }\n\n    @Override public String toString() {\n      return \"MoreExecutors.directExecutor()\";\n    }\n  }\n\n  /**\n   * Creates an {@link ExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code ListeningExecutorService}\n   * never calls the delegate's {@code submit}, {@code invokeAll}, and {@code\n   * invokeAny} methods, so any special handling of tasks must be implemented in\n   * the delegate's {@code execute} method or by wrapping the returned {@code\n   * ListeningExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningExecutorService}, it is returned untouched, and the rest of this\n   * documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService listeningDecorator(\n      ExecutorService delegate) {\n    return (delegate instanceof ListeningExecutorService)\n        ? (ListeningExecutorService) delegate\n        : (delegate instanceof ScheduledExecutorService)\n        ? new ScheduledListeningDecorator((ScheduledExecutorService) delegate)\n        : new ListeningDecorator(delegate);\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code\n   * ListeningScheduledExecutorService} never calls the delegate's {@code\n   * submit}, {@code invokeAll}, and {@code invokeAny} methods, so any special\n   * handling of tasks must be implemented in the delegate's {@code execute}\n   * method or by wrapping the returned {@code\n   * ListeningScheduledExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningScheduledExecutorService}, it is returned untouched, and the rest\n   * of this documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningScheduledExecutorService listeningDecorator(\n      ScheduledExecutorService delegate) {\n    return (delegate instanceof ListeningScheduledExecutorService)\n        ? (ListeningScheduledExecutorService) delegate\n        : new ScheduledListeningDecorator(delegate);\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static class ListeningDecorator\n      extends AbstractListeningExecutorService {\n    private final ExecutorService delegate;\n\n    ListeningDecorator(ExecutorService delegate) {\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public final boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      return delegate.awaitTermination(timeout, unit);\n    }\n\n    @Override\n    public final boolean isShutdown() {\n      return delegate.isShutdown();\n    }\n\n    @Override\n    public final boolean isTerminated() {\n      return delegate.isTerminated();\n    }\n\n    @Override\n    public final void shutdown() {\n      delegate.shutdown();\n    }\n\n    @Override\n    public final List<Runnable> shutdownNow() {\n      return delegate.shutdownNow();\n    }\n\n    @Override\n    public final void execute(Runnable command) {\n      delegate.execute(command);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static final class ScheduledListeningDecorator\n      extends ListeningDecorator implements ListeningScheduledExecutorService {\n    @SuppressWarnings(\"hiding\")\n    final ScheduledExecutorService delegate;\n\n    ScheduledListeningDecorator(ScheduledExecutorService delegate) {\n      super(delegate);\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> schedule(\n        Runnable command, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<Void> task =\n          TrustedListenableFutureTask.create(command, null);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public <V> ListenableScheduledFuture<V> schedule(\n        Callable<V> callable, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<V>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleAtFixedRate(\n        Runnable command, long initialDelay, long period, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleAtFixedRate(task, initialDelay, period, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleWithFixedDelay(\n        Runnable command, long initialDelay, long delay, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleWithFixedDelay(task, initialDelay, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    private static final class ListenableScheduledTask<V>\n        extends SimpleForwardingListenableFuture<V>\n        implements ListenableScheduledFuture<V> {\n\n      private final ScheduledFuture<?> scheduledDelegate;\n\n      public ListenableScheduledTask(\n          ListenableFuture<V> listenableDelegate,\n          ScheduledFuture<?> scheduledDelegate) {\n        super(listenableDelegate);\n        this.scheduledDelegate = scheduledDelegate;\n      }\n\n      @Override\n      public boolean cancel(boolean mayInterruptIfRunning) {\n        boolean cancelled = super.cancel(mayInterruptIfRunning);\n        if (cancelled) {\n          // Unless it is cancelled, the delegate may continue being scheduled\n          scheduledDelegate.cancel(mayInterruptIfRunning);\n\n          // TODO(user): Cancel \"this\" if \"scheduledDelegate\" is cancelled.\n        }\n        return cancelled;\n      }\n\n      @Override\n      public long getDelay(TimeUnit unit) {\n        return scheduledDelegate.getDelay(unit);\n      }\n\n      @Override\n      public int compareTo(Delayed other) {\n        return scheduledDelegate.compareTo(other);\n      }\n    }\n\n    @GwtIncompatible(\"TODO\")\n    private static final class NeverSuccessfulListenableFutureTask\n        extends AbstractFuture<Void>\n        implements Runnable {\n      private final Runnable delegate;\n\n      public NeverSuccessfulListenableFutureTask(Runnable delegate) {\n        this.delegate = checkNotNull(delegate);\n      }\n\n      @Override public void run() {\n        try {\n          delegate.run();\n        } catch (Throwable t) {\n          setException(t);\n          throw Throwables.propagate(t);\n        }\n      }\n    }\n  }\n\n  /*\n   * This following method is a modified version of one found in\n   * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/AbstractExecutorServiceTest.java?revision=1.30\n   * which contained the following notice:\n   *\n   * Written by Doug Lea with assistance from members of JCP JSR-166\n   * Expert Group and released to the public domain, as explained at\n   * http://creativecommons.org/publicdomain/zero/1.0/\n   * Other contributors include Andrew Wright, Jeffrey Hayes,\n   * Pat Fisher, Mike Judd.\n   */\n\n  /**\n   * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}\n   * implementations.\n   */ static <T> T invokeAnyImpl(ListeningExecutorService executorService,\n      Collection<? extends Callable<T>> tasks, boolean timed, long nanos)\n          throws InterruptedException, ExecutionException, TimeoutException {\n    checkNotNull(executorService);\n    int ntasks = tasks.size();\n    checkArgument(ntasks > 0);\n    List<Future<T>> futures = Lists.newArrayListWithCapacity(ntasks);\n    BlockingQueue<Future<T>> futureQueue = Queues.newLinkedBlockingQueue();\n\n    // For efficiency, especially in executors with limited\n    // parallelism, check to see if previously submitted tasks are\n    // done before submitting more of them. This interleaving\n    // plus the exception mechanics account for messiness of main\n    // loop.\n\n    try {\n      // Record exceptions so that if we fail to obtain any\n      // result, we can throw the last exception we got.\n      ExecutionException ee = null;\n      long lastTime = timed ? System.nanoTime() : 0;\n      Iterator<? extends Callable<T>> it = tasks.iterator();\n\n      futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n      --ntasks;\n      int active = 1;\n\n      for (;;) {\n        Future<T> f = futureQueue.poll();\n        if (f == null) {\n          if (ntasks > 0) {\n            --ntasks;\n            futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n            ++active;\n          } else if (active == 0) {\n            break;\n          } else if (timed) {\n            f = futureQueue.poll(nanos, TimeUnit.NANOSECONDS);\n            if (f == null) {\n              throw new TimeoutException();\n            }\n            long now = System.nanoTime();\n            nanos -= now - lastTime;\n            lastTime = now;\n          } else {\n            f = futureQueue.take();\n          }\n        }\n        if (f != null) {\n          --active;\n          try {\n            return f.get();\n          } catch (ExecutionException eex) {\n            ee = eex;\n          } catch (RuntimeException rex) {\n            ee = new ExecutionException(rex);\n          }\n        }\n      }\n\n      if (ee == null) {\n        ee = new ExecutionException(null);\n      }\n      throw ee;\n    } finally {\n      for (Future<T> f : futures) {\n        f.cancel(true);\n      }\n    }\n  }\n\n  /**\n   * Submits the task and adds a listener that adds the future to {@code queue} when it completes.\n   */\n  @GwtIncompatible(\"TODO\")\n  private static <T> ListenableFuture<T> submitAndAddQueueListener(\n      ListeningExecutorService executorService, Callable<T> task,\n      final BlockingQueue<Future<T>> queue) {\n    final ListenableFuture<T> future = executorService.submit(task);\n    future.addListener(new Runnable() {\n      @Override public void run() {\n        queue.add(future);\n      }\n    }, directExecutor());\n    return future;\n  }\n\n  /**\n   * Returns a default thread factory used to create new threads.\n   *\n   * <p>On AppEngine, returns {@code ThreadManager.currentRequestThreadFactory()}.\n   * Otherwise, returns {@link Executors#defaultThreadFactory()}.\n   *\n   * @since 14.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ThreadFactory platformThreadFactory() {\n    if (!isAppEngine()) {\n      return Executors.defaultThreadFactory();\n    }\n    try {\n      return (ThreadFactory) Class.forName(\"com.google.appengine.api.ThreadManager\")\n          .getMethod(\"currentRequestThreadFactory\")\n          .invoke(null);\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (ClassNotFoundException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (NoSuchMethodException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (InvocationTargetException e) {\n      throw Throwables.propagate(e.getCause());\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static boolean isAppEngine() {\n    if (System.getProperty(\"com.google.appengine.runtime.environment\") == null) {\n      return false;\n    }\n    try {\n      // If the current environment is null, we're not inside AppEngine.\n      return Class.forName(\"com.google.apphosting.api.ApiProxy\")\n          .getMethod(\"getCurrentEnvironment\")\n          .invoke(null) != null;\n    } catch (ClassNotFoundException e) {\n      // If ApiProxy doesn't exist, we're not on AppEngine at all.\n      return false;\n    } catch (InvocationTargetException e) {\n      // If ApiProxy throws an exception, we're not in a proper AppEngine environment.\n      return false;\n    } catch (IllegalAccessException e) {\n      // If the method isn't accessible, we're not on a supported version of AppEngine;\n      return false;\n    } catch (NoSuchMethodException e) {\n      // If the method doesn't exist, we're not on a supported version of AppEngine;\n      return false;\n    }\n  }\n\n  /**\n   * Creates a thread using {@link #platformThreadFactory}, and sets its name to {@code name}\n   * unless changing the name is forbidden by the security manager.\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Thread newThread(String name, Runnable runnable) {\n    checkNotNull(name);\n    checkNotNull(runnable);\n    Thread result = platformThreadFactory().newThread(runnable);\n    try {\n      result.setName(name);\n    } catch (SecurityException e) {\n      // OK if we can't set the name in this environment.\n    }\n    return result;\n  }\n\n  // TODO(lukes): provide overloads for ListeningExecutorService? ListeningScheduledExecutorService?\n  // TODO(lukes): provide overloads that take constant strings? Function<Runnable, String>s to\n  // calculate names?\n\n  /**\n   * Creates an {@link Executor} that renames the {@link Thread threads} that its tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param executor The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier) {\n    checkNotNull(executor);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try\n      return executor;\n    }\n    return new Executor() {\n      @Override public void execute(Runnable command) {\n        executor.execute(Callables.threadRenaming(command, nameSupplier));\n      }\n    };\n  }\n\n  /**\n   * Creates an {@link ExecutorService} that renames the {@link Thread threads} that its tasks run\n   * in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ExecutorService renamingDecorator(final ExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} that renames the {@link Thread threads} that its\n   * tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ScheduledExecutorService renamingDecorator(final ScheduledExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingScheduledExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Shuts down the given executor gradually, first disabling new submissions and later cancelling\n   * existing tasks.\n   *\n   * <p>The method takes the following steps:\n   * <ol>\n   *  <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n   *  <li>waits for half of the specified timeout.\n   *  <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n   *  pending tasks and interrupting running tasks.\n   *  <li>waits for the other half of the specified timeout.\n   * </ol>\n   *\n   * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n   * ExecutorService#shutdownNow()} and returns.\n   *\n   * @param service the {@code ExecutorService} to shut down\n   * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n   * @param unit the time unit of the timeout argument\n   * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n   *     the call timed out or was interrupted\n   * @since 17.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static boolean shutdownAndAwaitTermination(\n      ExecutorService service, long timeout, TimeUnit unit) {\n    checkNotNull(unit);\n    // Disable new tasks from being submitted\n    service.shutdown();\n    try {\n      long halfTimeoutNanos = TimeUnit.NANOSECONDS.convert(timeout, unit) / 2;\n      // Wait for half the duration of the timeout for existing tasks to terminate\n      if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {\n        // Cancel currently executing tasks\n        service.shutdownNow();\n        // Wait the other half of the timeout for tasks to respond to being cancelled\n        service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);\n      }\n    } catch (InterruptedException ie) {\n      // Preserve interrupt status\n      Thread.currentThread().interrupt();\n      // (Re-)Cancel if current thread also interrupted\n      service.shutdownNow();\n    }\n    return service.isTerminated();\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53075184,"label":true,"oracleId":1436,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"MoreExecutors","javadocTag":"@param service The executor to decorate","methodJavadoc":"    /**\n   * Creates an {@link ExecutorService} that renames the {@link Thread threads} that its tasks run\n   * in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */","methodSourceCode":"static ExecutorService renamingDecorator(final ExecutorService service, final Supplier<String> nameSupplier){\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n        // AppEngine doesn't support thread renaming, so don't even try.\n        return service;\n    }\n    return new WrappingExecutorService(service) {\n\n        @Override\n        protected <T> Callable<T> wrapTask(Callable<T> callable) {\n            return Callables.threadRenaming(callable, nameSupplier);\n        }\n\n        @Override\n        protected Runnable wrapTask(Runnable command) {\n            return Callables.threadRenaming(command, nameSupplier);\n        }\n    };\n}","classJavadoc":"/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */","classSourceCode":"/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Queues;\nimport com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */\n@GwtCompatible(emulated = true)\npublic final class MoreExecutors {\n  private MoreExecutors() {}\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ExecutorService getExitingExecutorService(\n      ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ScheduledThreadPoolExecutor into a\n   * ScheduledExecutorService that exits when the application is complete.  It\n   * does so by using daemon threads and adding a shutdown hook to wait for\n   * their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingScheduledExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Add a shutdown hook to wait for thread completion in the given\n   * {@link ExecutorService service}.  This is useful if the given service uses\n   * daemon threads, and we want to keep the JVM from exiting immediately on\n   * shutdown, instead giving these daemon threads a chance to terminate\n   * normally.\n   * @param service ExecutorService which uses daemon threads\n   * @param terminationTimeout how long to wait for the executor to finish\n   *        before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static void addDelayedShutdownHook(\n      ExecutorService service, long terminationTimeout, TimeUnit timeUnit) {\n    new Application()\n        .addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n    return new Application().getExitingExecutorService(executor);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into a ScheduledExecutorService that\n   * exits when the application is complete.  It does so by using daemon threads\n   * and adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor) {\n    return new Application().getExitingScheduledExecutorService(executor);\n  }\n\n  /** Represents the current application to register shutdown hooks. */\n  @GwtIncompatible(\"TODO\")\n  @VisibleForTesting\n  static class Application {\n\n    final ExecutorService getExitingExecutorService(\n        ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ExecutorService service = Executors.unconfigurableExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ScheduledExecutorService service = Executors.unconfigurableScheduledExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final void addDelayedShutdownHook(\n        final ExecutorService service, final long terminationTimeout, final TimeUnit timeUnit) {\n      checkNotNull(service);\n      checkNotNull(timeUnit);\n      addShutdownHook(MoreExecutors.newThread(\"DelayedShutdownHook-for-\" + service, new Runnable() {\n        @Override\n        public void run() {\n          try {\n            // We'd like to log progress and failures that may arise in the\n            // following code, but unfortunately the behavior of logging\n            // is undefined in shutdown hooks.\n            // This is because the logging code installs a shutdown hook of its\n            // own. See Cleaner class inside {@link LogManager}.\n            service.shutdown();\n            service.awaitTermination(terminationTimeout, timeUnit);\n          } catch (InterruptedException ignored) {\n            // We're shutting down anyway, so just ignore.\n          }\n        }\n      }));\n    }\n\n    final ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n      return getExitingExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor) {\n      return getExitingScheduledExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    @VisibleForTesting void addShutdownHook(Thread hook) {\n      Runtime.getRuntime().addShutdownHook(hook);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static void useDaemonThreadFactory(ThreadPoolExecutor executor) {\n    executor.setThreadFactory(new ThreadFactoryBuilder()\n        .setDaemon(true)\n        .setThreadFactory(executor.getThreadFactory())\n        .build());\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}.  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 10.0 (<a href=\"https://github.com/google/guava/wiki/Compatibility\"\n   *        >mostly source-compatible</a> since 3.0)\n   * @deprecated Use {@link #directExecutor()} if you only require an {@link Executor} and\n   *     {@link #newDirectExecutorService()} if you need a {@link ListeningExecutorService}. This\n   *     method will be removed in August 2016.\n   */\n  @Deprecated\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService sameThreadExecutor() {\n    return new DirectExecutorService();\n  }\n\n  // See sameThreadExecutor javadoc for behavioral notes.\n  @GwtIncompatible(\"TODO\")\n  private static final class DirectExecutorService\n      extends AbstractListeningExecutorService {\n    /**\n     * Lock used whenever accessing the state variables\n     * (runningTasks, shutdown) of the executor\n     */\n    private final Object lock = new Object();\n\n    /*\n     * Conceptually, these two variables describe the executor being in\n     * one of three states:\n     *   - Active: shutdown == false\n     *   - Shutdown: runningTasks > 0 and shutdown == true\n     *   - Terminated: runningTasks == 0 and shutdown == true\n     */\n    @GuardedBy(\"lock\") private int runningTasks = 0;\n    @GuardedBy(\"lock\") private boolean shutdown = false;\n\n    @Override\n    public void execute(Runnable command) {\n      startTask();\n      try {\n        command.run();\n      } finally {\n        endTask();\n      }\n    }\n\n    @Override\n    public boolean isShutdown() {\n      synchronized (lock) {\n        return shutdown;\n      }\n    }\n\n    @Override\n    public void shutdown() {\n      synchronized (lock) {\n        shutdown = true;\n        if (runningTasks == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n\n    // See sameThreadExecutor javadoc for unusual behavior of this method.\n    @Override\n    public List<Runnable> shutdownNow() {\n      shutdown();\n      return Collections.emptyList();\n    }\n\n    @Override\n    public boolean isTerminated() {\n      synchronized (lock) {\n        return shutdown && runningTasks == 0;\n      }\n    }\n\n    @Override\n    public boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      long nanos = unit.toNanos(timeout);\n      synchronized (lock) {\n        for (;;) {\n          if (shutdown && runningTasks == 0) {\n            return true;\n          } else if (nanos <= 0) {\n            return false;\n          } else {\n            long now = System.nanoTime();\n            TimeUnit.NANOSECONDS.timedWait(lock, nanos);\n            nanos -= System.nanoTime() - now;  // subtract the actual time we waited\n          }\n        }\n      }\n    }\n\n    /**\n     * Checks if the executor has been shut down and increments the running\n     * task count.\n     *\n     * @throws RejectedExecutionException if the executor has been previously\n     *         shutdown\n     */\n    private void startTask() {\n      synchronized (lock) {\n        if (shutdown) {\n          throw new RejectedExecutionException(\"Executor already shutdown\");\n        }\n        runningTasks++;\n      }\n    }\n\n    /**\n     * Decrements the running task count.\n     */\n    private void endTask() {\n      synchronized (lock) {\n        int numRunning = --runningTasks;\n        if (numRunning == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 18.0 (present as MoreExecutors.sameThreadExecutor() since 10.0)\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService newDirectExecutorService() {\n    return new DirectExecutorService();\n  }\n\n  /**\n   * Returns an {@link Executor} that runs each task in the thread that invokes\n   * {@link Executor#execute execute}, as in {@link CallerRunsPolicy}.\n   *\n   * <p>This instance is equivalent to: <pre>   {@code\n   *   final class DirectExecutor implements Executor {\n   *     public void execute(Runnable r) {\n   *       r.run();\n   *     }\n   *   }}</pre>\n   *\n   * <p>This should be preferred to {@link #newDirectExecutorService()} because the implementing the\n   * {@link ExecutorService} subinterface necessitates significant performance overhead.\n   *\n   * @since 18.0\n   */\n  public static Executor directExecutor() {\n    return DirectExecutor.INSTANCE;\n  }\n\n  /** See {@link #directExecutor} for behavioral notes. */\n  private enum DirectExecutor implements Executor {\n    INSTANCE;\n    @Override public void execute(Runnable command) {\n      command.run();\n    }\n\n    @Override public String toString() {\n      return \"MoreExecutors.directExecutor()\";\n    }\n  }\n\n  /**\n   * Creates an {@link ExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code ListeningExecutorService}\n   * never calls the delegate's {@code submit}, {@code invokeAll}, and {@code\n   * invokeAny} methods, so any special handling of tasks must be implemented in\n   * the delegate's {@code execute} method or by wrapping the returned {@code\n   * ListeningExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningExecutorService}, it is returned untouched, and the rest of this\n   * documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService listeningDecorator(\n      ExecutorService delegate) {\n    return (delegate instanceof ListeningExecutorService)\n        ? (ListeningExecutorService) delegate\n        : (delegate instanceof ScheduledExecutorService)\n        ? new ScheduledListeningDecorator((ScheduledExecutorService) delegate)\n        : new ListeningDecorator(delegate);\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code\n   * ListeningScheduledExecutorService} never calls the delegate's {@code\n   * submit}, {@code invokeAll}, and {@code invokeAny} methods, so any special\n   * handling of tasks must be implemented in the delegate's {@code execute}\n   * method or by wrapping the returned {@code\n   * ListeningScheduledExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningScheduledExecutorService}, it is returned untouched, and the rest\n   * of this documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningScheduledExecutorService listeningDecorator(\n      ScheduledExecutorService delegate) {\n    return (delegate instanceof ListeningScheduledExecutorService)\n        ? (ListeningScheduledExecutorService) delegate\n        : new ScheduledListeningDecorator(delegate);\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static class ListeningDecorator\n      extends AbstractListeningExecutorService {\n    private final ExecutorService delegate;\n\n    ListeningDecorator(ExecutorService delegate) {\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public final boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      return delegate.awaitTermination(timeout, unit);\n    }\n\n    @Override\n    public final boolean isShutdown() {\n      return delegate.isShutdown();\n    }\n\n    @Override\n    public final boolean isTerminated() {\n      return delegate.isTerminated();\n    }\n\n    @Override\n    public final void shutdown() {\n      delegate.shutdown();\n    }\n\n    @Override\n    public final List<Runnable> shutdownNow() {\n      return delegate.shutdownNow();\n    }\n\n    @Override\n    public final void execute(Runnable command) {\n      delegate.execute(command);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static final class ScheduledListeningDecorator\n      extends ListeningDecorator implements ListeningScheduledExecutorService {\n    @SuppressWarnings(\"hiding\")\n    final ScheduledExecutorService delegate;\n\n    ScheduledListeningDecorator(ScheduledExecutorService delegate) {\n      super(delegate);\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> schedule(\n        Runnable command, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<Void> task =\n          TrustedListenableFutureTask.create(command, null);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public <V> ListenableScheduledFuture<V> schedule(\n        Callable<V> callable, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<V>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleAtFixedRate(\n        Runnable command, long initialDelay, long period, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleAtFixedRate(task, initialDelay, period, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleWithFixedDelay(\n        Runnable command, long initialDelay, long delay, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleWithFixedDelay(task, initialDelay, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    private static final class ListenableScheduledTask<V>\n        extends SimpleForwardingListenableFuture<V>\n        implements ListenableScheduledFuture<V> {\n\n      private final ScheduledFuture<?> scheduledDelegate;\n\n      public ListenableScheduledTask(\n          ListenableFuture<V> listenableDelegate,\n          ScheduledFuture<?> scheduledDelegate) {\n        super(listenableDelegate);\n        this.scheduledDelegate = scheduledDelegate;\n      }\n\n      @Override\n      public boolean cancel(boolean mayInterruptIfRunning) {\n        boolean cancelled = super.cancel(mayInterruptIfRunning);\n        if (cancelled) {\n          // Unless it is cancelled, the delegate may continue being scheduled\n          scheduledDelegate.cancel(mayInterruptIfRunning);\n\n          // TODO(user): Cancel \"this\" if \"scheduledDelegate\" is cancelled.\n        }\n        return cancelled;\n      }\n\n      @Override\n      public long getDelay(TimeUnit unit) {\n        return scheduledDelegate.getDelay(unit);\n      }\n\n      @Override\n      public int compareTo(Delayed other) {\n        return scheduledDelegate.compareTo(other);\n      }\n    }\n\n    @GwtIncompatible(\"TODO\")\n    private static final class NeverSuccessfulListenableFutureTask\n        extends AbstractFuture<Void>\n        implements Runnable {\n      private final Runnable delegate;\n\n      public NeverSuccessfulListenableFutureTask(Runnable delegate) {\n        this.delegate = checkNotNull(delegate);\n      }\n\n      @Override public void run() {\n        try {\n          delegate.run();\n        } catch (Throwable t) {\n          setException(t);\n          throw Throwables.propagate(t);\n        }\n      }\n    }\n  }\n\n  /*\n   * This following method is a modified version of one found in\n   * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/AbstractExecutorServiceTest.java?revision=1.30\n   * which contained the following notice:\n   *\n   * Written by Doug Lea with assistance from members of JCP JSR-166\n   * Expert Group and released to the public domain, as explained at\n   * http://creativecommons.org/publicdomain/zero/1.0/\n   * Other contributors include Andrew Wright, Jeffrey Hayes,\n   * Pat Fisher, Mike Judd.\n   */\n\n  /**\n   * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}\n   * implementations.\n   */ static <T> T invokeAnyImpl(ListeningExecutorService executorService,\n      Collection<? extends Callable<T>> tasks, boolean timed, long nanos)\n          throws InterruptedException, ExecutionException, TimeoutException {\n    checkNotNull(executorService);\n    int ntasks = tasks.size();\n    checkArgument(ntasks > 0);\n    List<Future<T>> futures = Lists.newArrayListWithCapacity(ntasks);\n    BlockingQueue<Future<T>> futureQueue = Queues.newLinkedBlockingQueue();\n\n    // For efficiency, especially in executors with limited\n    // parallelism, check to see if previously submitted tasks are\n    // done before submitting more of them. This interleaving\n    // plus the exception mechanics account for messiness of main\n    // loop.\n\n    try {\n      // Record exceptions so that if we fail to obtain any\n      // result, we can throw the last exception we got.\n      ExecutionException ee = null;\n      long lastTime = timed ? System.nanoTime() : 0;\n      Iterator<? extends Callable<T>> it = tasks.iterator();\n\n      futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n      --ntasks;\n      int active = 1;\n\n      for (;;) {\n        Future<T> f = futureQueue.poll();\n        if (f == null) {\n          if (ntasks > 0) {\n            --ntasks;\n            futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n            ++active;\n          } else if (active == 0) {\n            break;\n          } else if (timed) {\n            f = futureQueue.poll(nanos, TimeUnit.NANOSECONDS);\n            if (f == null) {\n              throw new TimeoutException();\n            }\n            long now = System.nanoTime();\n            nanos -= now - lastTime;\n            lastTime = now;\n          } else {\n            f = futureQueue.take();\n          }\n        }\n        if (f != null) {\n          --active;\n          try {\n            return f.get();\n          } catch (ExecutionException eex) {\n            ee = eex;\n          } catch (RuntimeException rex) {\n            ee = new ExecutionException(rex);\n          }\n        }\n      }\n\n      if (ee == null) {\n        ee = new ExecutionException(null);\n      }\n      throw ee;\n    } finally {\n      for (Future<T> f : futures) {\n        f.cancel(true);\n      }\n    }\n  }\n\n  /**\n   * Submits the task and adds a listener that adds the future to {@code queue} when it completes.\n   */\n  @GwtIncompatible(\"TODO\")\n  private static <T> ListenableFuture<T> submitAndAddQueueListener(\n      ListeningExecutorService executorService, Callable<T> task,\n      final BlockingQueue<Future<T>> queue) {\n    final ListenableFuture<T> future = executorService.submit(task);\n    future.addListener(new Runnable() {\n      @Override public void run() {\n        queue.add(future);\n      }\n    }, directExecutor());\n    return future;\n  }\n\n  /**\n   * Returns a default thread factory used to create new threads.\n   *\n   * <p>On AppEngine, returns {@code ThreadManager.currentRequestThreadFactory()}.\n   * Otherwise, returns {@link Executors#defaultThreadFactory()}.\n   *\n   * @since 14.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ThreadFactory platformThreadFactory() {\n    if (!isAppEngine()) {\n      return Executors.defaultThreadFactory();\n    }\n    try {\n      return (ThreadFactory) Class.forName(\"com.google.appengine.api.ThreadManager\")\n          .getMethod(\"currentRequestThreadFactory\")\n          .invoke(null);\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (ClassNotFoundException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (NoSuchMethodException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (InvocationTargetException e) {\n      throw Throwables.propagate(e.getCause());\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static boolean isAppEngine() {\n    if (System.getProperty(\"com.google.appengine.runtime.environment\") == null) {\n      return false;\n    }\n    try {\n      // If the current environment is null, we're not inside AppEngine.\n      return Class.forName(\"com.google.apphosting.api.ApiProxy\")\n          .getMethod(\"getCurrentEnvironment\")\n          .invoke(null) != null;\n    } catch (ClassNotFoundException e) {\n      // If ApiProxy doesn't exist, we're not on AppEngine at all.\n      return false;\n    } catch (InvocationTargetException e) {\n      // If ApiProxy throws an exception, we're not in a proper AppEngine environment.\n      return false;\n    } catch (IllegalAccessException e) {\n      // If the method isn't accessible, we're not on a supported version of AppEngine;\n      return false;\n    } catch (NoSuchMethodException e) {\n      // If the method doesn't exist, we're not on a supported version of AppEngine;\n      return false;\n    }\n  }\n\n  /**\n   * Creates a thread using {@link #platformThreadFactory}, and sets its name to {@code name}\n   * unless changing the name is forbidden by the security manager.\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Thread newThread(String name, Runnable runnable) {\n    checkNotNull(name);\n    checkNotNull(runnable);\n    Thread result = platformThreadFactory().newThread(runnable);\n    try {\n      result.setName(name);\n    } catch (SecurityException e) {\n      // OK if we can't set the name in this environment.\n    }\n    return result;\n  }\n\n  // TODO(lukes): provide overloads for ListeningExecutorService? ListeningScheduledExecutorService?\n  // TODO(lukes): provide overloads that take constant strings? Function<Runnable, String>s to\n  // calculate names?\n\n  /**\n   * Creates an {@link Executor} that renames the {@link Thread threads} that its tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param executor The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier) {\n    checkNotNull(executor);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try\n      return executor;\n    }\n    return new Executor() {\n      @Override public void execute(Runnable command) {\n        executor.execute(Callables.threadRenaming(command, nameSupplier));\n      }\n    };\n  }\n\n  /**\n   * Creates an {@link ExecutorService} that renames the {@link Thread threads} that its tasks run\n   * in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ExecutorService renamingDecorator(final ExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} that renames the {@link Thread threads} that its\n   * tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ScheduledExecutorService renamingDecorator(final ScheduledExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingScheduledExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Shuts down the given executor gradually, first disabling new submissions and later cancelling\n   * existing tasks.\n   *\n   * <p>The method takes the following steps:\n   * <ol>\n   *  <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n   *  <li>waits for half of the specified timeout.\n   *  <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n   *  pending tasks and interrupting running tasks.\n   *  <li>waits for the other half of the specified timeout.\n   * </ol>\n   *\n   * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n   * ExecutorService#shutdownNow()} and returns.\n   *\n   * @param service the {@code ExecutorService} to shut down\n   * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n   * @param unit the time unit of the timeout argument\n   * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n   *     the call timed out or was interrupted\n   * @since 17.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static boolean shutdownAndAwaitTermination(\n      ExecutorService service, long timeout, TimeUnit unit) {\n    checkNotNull(unit);\n    // Disable new tasks from being submitted\n    service.shutdown();\n    try {\n      long halfTimeoutNanos = TimeUnit.NANOSECONDS.convert(timeout, unit) / 2;\n      // Wait for half the duration of the timeout for existing tasks to terminate\n      if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {\n        // Cancel currently executing tasks\n        service.shutdownNow();\n        // Wait the other half of the timeout for tasks to respond to being cancelled\n        service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);\n      }\n    } catch (InterruptedException ie) {\n      // Preserve interrupt status\n      Thread.currentThread().interrupt();\n      // (Re-)Cancel if current thread also interrupted\n      service.shutdownNow();\n    }\n    return service.isTerminated();\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53075642,"label":true,"oracleId":1437,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"MoreExecutors","javadocTag":"@param nameSupplier The source of names for each task","methodJavadoc":"    /**\n   * Creates an {@link ExecutorService} that renames the {@link Thread threads} that its tasks run\n   * in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */","methodSourceCode":"static ExecutorService renamingDecorator(final ExecutorService service, final Supplier<String> nameSupplier){\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n        // AppEngine doesn't support thread renaming, so don't even try.\n        return service;\n    }\n    return new WrappingExecutorService(service) {\n\n        @Override\n        protected <T> Callable<T> wrapTask(Callable<T> callable) {\n            return Callables.threadRenaming(callable, nameSupplier);\n        }\n\n        @Override\n        protected Runnable wrapTask(Runnable command) {\n            return Callables.threadRenaming(command, nameSupplier);\n        }\n    };\n}","classJavadoc":"/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */","classSourceCode":"/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Queues;\nimport com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */\n@GwtCompatible(emulated = true)\npublic final class MoreExecutors {\n  private MoreExecutors() {}\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ExecutorService getExitingExecutorService(\n      ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ScheduledThreadPoolExecutor into a\n   * ScheduledExecutorService that exits when the application is complete.  It\n   * does so by using daemon threads and adding a shutdown hook to wait for\n   * their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingScheduledExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Add a shutdown hook to wait for thread completion in the given\n   * {@link ExecutorService service}.  This is useful if the given service uses\n   * daemon threads, and we want to keep the JVM from exiting immediately on\n   * shutdown, instead giving these daemon threads a chance to terminate\n   * normally.\n   * @param service ExecutorService which uses daemon threads\n   * @param terminationTimeout how long to wait for the executor to finish\n   *        before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static void addDelayedShutdownHook(\n      ExecutorService service, long terminationTimeout, TimeUnit timeUnit) {\n    new Application()\n        .addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n    return new Application().getExitingExecutorService(executor);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into a ScheduledExecutorService that\n   * exits when the application is complete.  It does so by using daemon threads\n   * and adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor) {\n    return new Application().getExitingScheduledExecutorService(executor);\n  }\n\n  /** Represents the current application to register shutdown hooks. */\n  @GwtIncompatible(\"TODO\")\n  @VisibleForTesting\n  static class Application {\n\n    final ExecutorService getExitingExecutorService(\n        ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ExecutorService service = Executors.unconfigurableExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ScheduledExecutorService service = Executors.unconfigurableScheduledExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final void addDelayedShutdownHook(\n        final ExecutorService service, final long terminationTimeout, final TimeUnit timeUnit) {\n      checkNotNull(service);\n      checkNotNull(timeUnit);\n      addShutdownHook(MoreExecutors.newThread(\"DelayedShutdownHook-for-\" + service, new Runnable() {\n        @Override\n        public void run() {\n          try {\n            // We'd like to log progress and failures that may arise in the\n            // following code, but unfortunately the behavior of logging\n            // is undefined in shutdown hooks.\n            // This is because the logging code installs a shutdown hook of its\n            // own. See Cleaner class inside {@link LogManager}.\n            service.shutdown();\n            service.awaitTermination(terminationTimeout, timeUnit);\n          } catch (InterruptedException ignored) {\n            // We're shutting down anyway, so just ignore.\n          }\n        }\n      }));\n    }\n\n    final ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n      return getExitingExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor) {\n      return getExitingScheduledExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    @VisibleForTesting void addShutdownHook(Thread hook) {\n      Runtime.getRuntime().addShutdownHook(hook);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static void useDaemonThreadFactory(ThreadPoolExecutor executor) {\n    executor.setThreadFactory(new ThreadFactoryBuilder()\n        .setDaemon(true)\n        .setThreadFactory(executor.getThreadFactory())\n        .build());\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}.  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 10.0 (<a href=\"https://github.com/google/guava/wiki/Compatibility\"\n   *        >mostly source-compatible</a> since 3.0)\n   * @deprecated Use {@link #directExecutor()} if you only require an {@link Executor} and\n   *     {@link #newDirectExecutorService()} if you need a {@link ListeningExecutorService}. This\n   *     method will be removed in August 2016.\n   */\n  @Deprecated\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService sameThreadExecutor() {\n    return new DirectExecutorService();\n  }\n\n  // See sameThreadExecutor javadoc for behavioral notes.\n  @GwtIncompatible(\"TODO\")\n  private static final class DirectExecutorService\n      extends AbstractListeningExecutorService {\n    /**\n     * Lock used whenever accessing the state variables\n     * (runningTasks, shutdown) of the executor\n     */\n    private final Object lock = new Object();\n\n    /*\n     * Conceptually, these two variables describe the executor being in\n     * one of three states:\n     *   - Active: shutdown == false\n     *   - Shutdown: runningTasks > 0 and shutdown == true\n     *   - Terminated: runningTasks == 0 and shutdown == true\n     */\n    @GuardedBy(\"lock\") private int runningTasks = 0;\n    @GuardedBy(\"lock\") private boolean shutdown = false;\n\n    @Override\n    public void execute(Runnable command) {\n      startTask();\n      try {\n        command.run();\n      } finally {\n        endTask();\n      }\n    }\n\n    @Override\n    public boolean isShutdown() {\n      synchronized (lock) {\n        return shutdown;\n      }\n    }\n\n    @Override\n    public void shutdown() {\n      synchronized (lock) {\n        shutdown = true;\n        if (runningTasks == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n\n    // See sameThreadExecutor javadoc for unusual behavior of this method.\n    @Override\n    public List<Runnable> shutdownNow() {\n      shutdown();\n      return Collections.emptyList();\n    }\n\n    @Override\n    public boolean isTerminated() {\n      synchronized (lock) {\n        return shutdown && runningTasks == 0;\n      }\n    }\n\n    @Override\n    public boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      long nanos = unit.toNanos(timeout);\n      synchronized (lock) {\n        for (;;) {\n          if (shutdown && runningTasks == 0) {\n            return true;\n          } else if (nanos <= 0) {\n            return false;\n          } else {\n            long now = System.nanoTime();\n            TimeUnit.NANOSECONDS.timedWait(lock, nanos);\n            nanos -= System.nanoTime() - now;  // subtract the actual time we waited\n          }\n        }\n      }\n    }\n\n    /**\n     * Checks if the executor has been shut down and increments the running\n     * task count.\n     *\n     * @throws RejectedExecutionException if the executor has been previously\n     *         shutdown\n     */\n    private void startTask() {\n      synchronized (lock) {\n        if (shutdown) {\n          throw new RejectedExecutionException(\"Executor already shutdown\");\n        }\n        runningTasks++;\n      }\n    }\n\n    /**\n     * Decrements the running task count.\n     */\n    private void endTask() {\n      synchronized (lock) {\n        int numRunning = --runningTasks;\n        if (numRunning == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 18.0 (present as MoreExecutors.sameThreadExecutor() since 10.0)\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService newDirectExecutorService() {\n    return new DirectExecutorService();\n  }\n\n  /**\n   * Returns an {@link Executor} that runs each task in the thread that invokes\n   * {@link Executor#execute execute}, as in {@link CallerRunsPolicy}.\n   *\n   * <p>This instance is equivalent to: <pre>   {@code\n   *   final class DirectExecutor implements Executor {\n   *     public void execute(Runnable r) {\n   *       r.run();\n   *     }\n   *   }}</pre>\n   *\n   * <p>This should be preferred to {@link #newDirectExecutorService()} because the implementing the\n   * {@link ExecutorService} subinterface necessitates significant performance overhead.\n   *\n   * @since 18.0\n   */\n  public static Executor directExecutor() {\n    return DirectExecutor.INSTANCE;\n  }\n\n  /** See {@link #directExecutor} for behavioral notes. */\n  private enum DirectExecutor implements Executor {\n    INSTANCE;\n    @Override public void execute(Runnable command) {\n      command.run();\n    }\n\n    @Override public String toString() {\n      return \"MoreExecutors.directExecutor()\";\n    }\n  }\n\n  /**\n   * Creates an {@link ExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code ListeningExecutorService}\n   * never calls the delegate's {@code submit}, {@code invokeAll}, and {@code\n   * invokeAny} methods, so any special handling of tasks must be implemented in\n   * the delegate's {@code execute} method or by wrapping the returned {@code\n   * ListeningExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningExecutorService}, it is returned untouched, and the rest of this\n   * documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService listeningDecorator(\n      ExecutorService delegate) {\n    return (delegate instanceof ListeningExecutorService)\n        ? (ListeningExecutorService) delegate\n        : (delegate instanceof ScheduledExecutorService)\n        ? new ScheduledListeningDecorator((ScheduledExecutorService) delegate)\n        : new ListeningDecorator(delegate);\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code\n   * ListeningScheduledExecutorService} never calls the delegate's {@code\n   * submit}, {@code invokeAll}, and {@code invokeAny} methods, so any special\n   * handling of tasks must be implemented in the delegate's {@code execute}\n   * method or by wrapping the returned {@code\n   * ListeningScheduledExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningScheduledExecutorService}, it is returned untouched, and the rest\n   * of this documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningScheduledExecutorService listeningDecorator(\n      ScheduledExecutorService delegate) {\n    return (delegate instanceof ListeningScheduledExecutorService)\n        ? (ListeningScheduledExecutorService) delegate\n        : new ScheduledListeningDecorator(delegate);\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static class ListeningDecorator\n      extends AbstractListeningExecutorService {\n    private final ExecutorService delegate;\n\n    ListeningDecorator(ExecutorService delegate) {\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public final boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      return delegate.awaitTermination(timeout, unit);\n    }\n\n    @Override\n    public final boolean isShutdown() {\n      return delegate.isShutdown();\n    }\n\n    @Override\n    public final boolean isTerminated() {\n      return delegate.isTerminated();\n    }\n\n    @Override\n    public final void shutdown() {\n      delegate.shutdown();\n    }\n\n    @Override\n    public final List<Runnable> shutdownNow() {\n      return delegate.shutdownNow();\n    }\n\n    @Override\n    public final void execute(Runnable command) {\n      delegate.execute(command);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static final class ScheduledListeningDecorator\n      extends ListeningDecorator implements ListeningScheduledExecutorService {\n    @SuppressWarnings(\"hiding\")\n    final ScheduledExecutorService delegate;\n\n    ScheduledListeningDecorator(ScheduledExecutorService delegate) {\n      super(delegate);\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> schedule(\n        Runnable command, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<Void> task =\n          TrustedListenableFutureTask.create(command, null);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public <V> ListenableScheduledFuture<V> schedule(\n        Callable<V> callable, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<V>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleAtFixedRate(\n        Runnable command, long initialDelay, long period, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleAtFixedRate(task, initialDelay, period, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleWithFixedDelay(\n        Runnable command, long initialDelay, long delay, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleWithFixedDelay(task, initialDelay, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    private static final class ListenableScheduledTask<V>\n        extends SimpleForwardingListenableFuture<V>\n        implements ListenableScheduledFuture<V> {\n\n      private final ScheduledFuture<?> scheduledDelegate;\n\n      public ListenableScheduledTask(\n          ListenableFuture<V> listenableDelegate,\n          ScheduledFuture<?> scheduledDelegate) {\n        super(listenableDelegate);\n        this.scheduledDelegate = scheduledDelegate;\n      }\n\n      @Override\n      public boolean cancel(boolean mayInterruptIfRunning) {\n        boolean cancelled = super.cancel(mayInterruptIfRunning);\n        if (cancelled) {\n          // Unless it is cancelled, the delegate may continue being scheduled\n          scheduledDelegate.cancel(mayInterruptIfRunning);\n\n          // TODO(user): Cancel \"this\" if \"scheduledDelegate\" is cancelled.\n        }\n        return cancelled;\n      }\n\n      @Override\n      public long getDelay(TimeUnit unit) {\n        return scheduledDelegate.getDelay(unit);\n      }\n\n      @Override\n      public int compareTo(Delayed other) {\n        return scheduledDelegate.compareTo(other);\n      }\n    }\n\n    @GwtIncompatible(\"TODO\")\n    private static final class NeverSuccessfulListenableFutureTask\n        extends AbstractFuture<Void>\n        implements Runnable {\n      private final Runnable delegate;\n\n      public NeverSuccessfulListenableFutureTask(Runnable delegate) {\n        this.delegate = checkNotNull(delegate);\n      }\n\n      @Override public void run() {\n        try {\n          delegate.run();\n        } catch (Throwable t) {\n          setException(t);\n          throw Throwables.propagate(t);\n        }\n      }\n    }\n  }\n\n  /*\n   * This following method is a modified version of one found in\n   * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/AbstractExecutorServiceTest.java?revision=1.30\n   * which contained the following notice:\n   *\n   * Written by Doug Lea with assistance from members of JCP JSR-166\n   * Expert Group and released to the public domain, as explained at\n   * http://creativecommons.org/publicdomain/zero/1.0/\n   * Other contributors include Andrew Wright, Jeffrey Hayes,\n   * Pat Fisher, Mike Judd.\n   */\n\n  /**\n   * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}\n   * implementations.\n   */ static <T> T invokeAnyImpl(ListeningExecutorService executorService,\n      Collection<? extends Callable<T>> tasks, boolean timed, long nanos)\n          throws InterruptedException, ExecutionException, TimeoutException {\n    checkNotNull(executorService);\n    int ntasks = tasks.size();\n    checkArgument(ntasks > 0);\n    List<Future<T>> futures = Lists.newArrayListWithCapacity(ntasks);\n    BlockingQueue<Future<T>> futureQueue = Queues.newLinkedBlockingQueue();\n\n    // For efficiency, especially in executors with limited\n    // parallelism, check to see if previously submitted tasks are\n    // done before submitting more of them. This interleaving\n    // plus the exception mechanics account for messiness of main\n    // loop.\n\n    try {\n      // Record exceptions so that if we fail to obtain any\n      // result, we can throw the last exception we got.\n      ExecutionException ee = null;\n      long lastTime = timed ? System.nanoTime() : 0;\n      Iterator<? extends Callable<T>> it = tasks.iterator();\n\n      futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n      --ntasks;\n      int active = 1;\n\n      for (;;) {\n        Future<T> f = futureQueue.poll();\n        if (f == null) {\n          if (ntasks > 0) {\n            --ntasks;\n            futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n            ++active;\n          } else if (active == 0) {\n            break;\n          } else if (timed) {\n            f = futureQueue.poll(nanos, TimeUnit.NANOSECONDS);\n            if (f == null) {\n              throw new TimeoutException();\n            }\n            long now = System.nanoTime();\n            nanos -= now - lastTime;\n            lastTime = now;\n          } else {\n            f = futureQueue.take();\n          }\n        }\n        if (f != null) {\n          --active;\n          try {\n            return f.get();\n          } catch (ExecutionException eex) {\n            ee = eex;\n          } catch (RuntimeException rex) {\n            ee = new ExecutionException(rex);\n          }\n        }\n      }\n\n      if (ee == null) {\n        ee = new ExecutionException(null);\n      }\n      throw ee;\n    } finally {\n      for (Future<T> f : futures) {\n        f.cancel(true);\n      }\n    }\n  }\n\n  /**\n   * Submits the task and adds a listener that adds the future to {@code queue} when it completes.\n   */\n  @GwtIncompatible(\"TODO\")\n  private static <T> ListenableFuture<T> submitAndAddQueueListener(\n      ListeningExecutorService executorService, Callable<T> task,\n      final BlockingQueue<Future<T>> queue) {\n    final ListenableFuture<T> future = executorService.submit(task);\n    future.addListener(new Runnable() {\n      @Override public void run() {\n        queue.add(future);\n      }\n    }, directExecutor());\n    return future;\n  }\n\n  /**\n   * Returns a default thread factory used to create new threads.\n   *\n   * <p>On AppEngine, returns {@code ThreadManager.currentRequestThreadFactory()}.\n   * Otherwise, returns {@link Executors#defaultThreadFactory()}.\n   *\n   * @since 14.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ThreadFactory platformThreadFactory() {\n    if (!isAppEngine()) {\n      return Executors.defaultThreadFactory();\n    }\n    try {\n      return (ThreadFactory) Class.forName(\"com.google.appengine.api.ThreadManager\")\n          .getMethod(\"currentRequestThreadFactory\")\n          .invoke(null);\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (ClassNotFoundException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (NoSuchMethodException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (InvocationTargetException e) {\n      throw Throwables.propagate(e.getCause());\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static boolean isAppEngine() {\n    if (System.getProperty(\"com.google.appengine.runtime.environment\") == null) {\n      return false;\n    }\n    try {\n      // If the current environment is null, we're not inside AppEngine.\n      return Class.forName(\"com.google.apphosting.api.ApiProxy\")\n          .getMethod(\"getCurrentEnvironment\")\n          .invoke(null) != null;\n    } catch (ClassNotFoundException e) {\n      // If ApiProxy doesn't exist, we're not on AppEngine at all.\n      return false;\n    } catch (InvocationTargetException e) {\n      // If ApiProxy throws an exception, we're not in a proper AppEngine environment.\n      return false;\n    } catch (IllegalAccessException e) {\n      // If the method isn't accessible, we're not on a supported version of AppEngine;\n      return false;\n    } catch (NoSuchMethodException e) {\n      // If the method doesn't exist, we're not on a supported version of AppEngine;\n      return false;\n    }\n  }\n\n  /**\n   * Creates a thread using {@link #platformThreadFactory}, and sets its name to {@code name}\n   * unless changing the name is forbidden by the security manager.\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Thread newThread(String name, Runnable runnable) {\n    checkNotNull(name);\n    checkNotNull(runnable);\n    Thread result = platformThreadFactory().newThread(runnable);\n    try {\n      result.setName(name);\n    } catch (SecurityException e) {\n      // OK if we can't set the name in this environment.\n    }\n    return result;\n  }\n\n  // TODO(lukes): provide overloads for ListeningExecutorService? ListeningScheduledExecutorService?\n  // TODO(lukes): provide overloads that take constant strings? Function<Runnable, String>s to\n  // calculate names?\n\n  /**\n   * Creates an {@link Executor} that renames the {@link Thread threads} that its tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param executor The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier) {\n    checkNotNull(executor);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try\n      return executor;\n    }\n    return new Executor() {\n      @Override public void execute(Runnable command) {\n        executor.execute(Callables.threadRenaming(command, nameSupplier));\n      }\n    };\n  }\n\n  /**\n   * Creates an {@link ExecutorService} that renames the {@link Thread threads} that its tasks run\n   * in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ExecutorService renamingDecorator(final ExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} that renames the {@link Thread threads} that its\n   * tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ScheduledExecutorService renamingDecorator(final ScheduledExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingScheduledExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Shuts down the given executor gradually, first disabling new submissions and later cancelling\n   * existing tasks.\n   *\n   * <p>The method takes the following steps:\n   * <ol>\n   *  <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n   *  <li>waits for half of the specified timeout.\n   *  <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n   *  pending tasks and interrupting running tasks.\n   *  <li>waits for the other half of the specified timeout.\n   * </ol>\n   *\n   * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n   * ExecutorService#shutdownNow()} and returns.\n   *\n   * @param service the {@code ExecutorService} to shut down\n   * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n   * @param unit the time unit of the timeout argument\n   * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n   *     the call timed out or was interrupted\n   * @since 17.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static boolean shutdownAndAwaitTermination(\n      ExecutorService service, long timeout, TimeUnit unit) {\n    checkNotNull(unit);\n    // Disable new tasks from being submitted\n    service.shutdown();\n    try {\n      long halfTimeoutNanos = TimeUnit.NANOSECONDS.convert(timeout, unit) / 2;\n      // Wait for half the duration of the timeout for existing tasks to terminate\n      if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {\n        // Cancel currently executing tasks\n        service.shutdownNow();\n        // Wait the other half of the timeout for tasks to respond to being cancelled\n        service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);\n      }\n    } catch (InterruptedException ie) {\n      // Preserve interrupt status\n      Thread.currentThread().interrupt();\n      // (Re-)Cancel if current thread also interrupted\n      service.shutdownNow();\n    }\n    return service.isTerminated();\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53076100,"label":true,"oracleId":1438,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"MoreExecutors","javadocTag":"@param service The executor to decorate","methodJavadoc":"    /**\n   * Creates a {@link ScheduledExecutorService} that renames the {@link Thread threads} that its\n   * tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */","methodSourceCode":"static ScheduledExecutorService renamingDecorator(final ScheduledExecutorService service, final Supplier<String> nameSupplier){\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n        // AppEngine doesn't support thread renaming, so don't even try.\n        return service;\n    }\n    return new WrappingScheduledExecutorService(service) {\n\n        @Override\n        protected <T> Callable<T> wrapTask(Callable<T> callable) {\n            return Callables.threadRenaming(callable, nameSupplier);\n        }\n\n        @Override\n        protected Runnable wrapTask(Runnable command) {\n            return Callables.threadRenaming(command, nameSupplier);\n        }\n    };\n}","classJavadoc":"/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */","classSourceCode":"/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Queues;\nimport com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */\n@GwtCompatible(emulated = true)\npublic final class MoreExecutors {\n  private MoreExecutors() {}\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ExecutorService getExitingExecutorService(\n      ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ScheduledThreadPoolExecutor into a\n   * ScheduledExecutorService that exits when the application is complete.  It\n   * does so by using daemon threads and adding a shutdown hook to wait for\n   * their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingScheduledExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Add a shutdown hook to wait for thread completion in the given\n   * {@link ExecutorService service}.  This is useful if the given service uses\n   * daemon threads, and we want to keep the JVM from exiting immediately on\n   * shutdown, instead giving these daemon threads a chance to terminate\n   * normally.\n   * @param service ExecutorService which uses daemon threads\n   * @param terminationTimeout how long to wait for the executor to finish\n   *        before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static void addDelayedShutdownHook(\n      ExecutorService service, long terminationTimeout, TimeUnit timeUnit) {\n    new Application()\n        .addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n    return new Application().getExitingExecutorService(executor);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into a ScheduledExecutorService that\n   * exits when the application is complete.  It does so by using daemon threads\n   * and adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor) {\n    return new Application().getExitingScheduledExecutorService(executor);\n  }\n\n  /** Represents the current application to register shutdown hooks. */\n  @GwtIncompatible(\"TODO\")\n  @VisibleForTesting\n  static class Application {\n\n    final ExecutorService getExitingExecutorService(\n        ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ExecutorService service = Executors.unconfigurableExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ScheduledExecutorService service = Executors.unconfigurableScheduledExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final void addDelayedShutdownHook(\n        final ExecutorService service, final long terminationTimeout, final TimeUnit timeUnit) {\n      checkNotNull(service);\n      checkNotNull(timeUnit);\n      addShutdownHook(MoreExecutors.newThread(\"DelayedShutdownHook-for-\" + service, new Runnable() {\n        @Override\n        public void run() {\n          try {\n            // We'd like to log progress and failures that may arise in the\n            // following code, but unfortunately the behavior of logging\n            // is undefined in shutdown hooks.\n            // This is because the logging code installs a shutdown hook of its\n            // own. See Cleaner class inside {@link LogManager}.\n            service.shutdown();\n            service.awaitTermination(terminationTimeout, timeUnit);\n          } catch (InterruptedException ignored) {\n            // We're shutting down anyway, so just ignore.\n          }\n        }\n      }));\n    }\n\n    final ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n      return getExitingExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor) {\n      return getExitingScheduledExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    @VisibleForTesting void addShutdownHook(Thread hook) {\n      Runtime.getRuntime().addShutdownHook(hook);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static void useDaemonThreadFactory(ThreadPoolExecutor executor) {\n    executor.setThreadFactory(new ThreadFactoryBuilder()\n        .setDaemon(true)\n        .setThreadFactory(executor.getThreadFactory())\n        .build());\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}.  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 10.0 (<a href=\"https://github.com/google/guava/wiki/Compatibility\"\n   *        >mostly source-compatible</a> since 3.0)\n   * @deprecated Use {@link #directExecutor()} if you only require an {@link Executor} and\n   *     {@link #newDirectExecutorService()} if you need a {@link ListeningExecutorService}. This\n   *     method will be removed in August 2016.\n   */\n  @Deprecated\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService sameThreadExecutor() {\n    return new DirectExecutorService();\n  }\n\n  // See sameThreadExecutor javadoc for behavioral notes.\n  @GwtIncompatible(\"TODO\")\n  private static final class DirectExecutorService\n      extends AbstractListeningExecutorService {\n    /**\n     * Lock used whenever accessing the state variables\n     * (runningTasks, shutdown) of the executor\n     */\n    private final Object lock = new Object();\n\n    /*\n     * Conceptually, these two variables describe the executor being in\n     * one of three states:\n     *   - Active: shutdown == false\n     *   - Shutdown: runningTasks > 0 and shutdown == true\n     *   - Terminated: runningTasks == 0 and shutdown == true\n     */\n    @GuardedBy(\"lock\") private int runningTasks = 0;\n    @GuardedBy(\"lock\") private boolean shutdown = false;\n\n    @Override\n    public void execute(Runnable command) {\n      startTask();\n      try {\n        command.run();\n      } finally {\n        endTask();\n      }\n    }\n\n    @Override\n    public boolean isShutdown() {\n      synchronized (lock) {\n        return shutdown;\n      }\n    }\n\n    @Override\n    public void shutdown() {\n      synchronized (lock) {\n        shutdown = true;\n        if (runningTasks == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n\n    // See sameThreadExecutor javadoc for unusual behavior of this method.\n    @Override\n    public List<Runnable> shutdownNow() {\n      shutdown();\n      return Collections.emptyList();\n    }\n\n    @Override\n    public boolean isTerminated() {\n      synchronized (lock) {\n        return shutdown && runningTasks == 0;\n      }\n    }\n\n    @Override\n    public boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      long nanos = unit.toNanos(timeout);\n      synchronized (lock) {\n        for (;;) {\n          if (shutdown && runningTasks == 0) {\n            return true;\n          } else if (nanos <= 0) {\n            return false;\n          } else {\n            long now = System.nanoTime();\n            TimeUnit.NANOSECONDS.timedWait(lock, nanos);\n            nanos -= System.nanoTime() - now;  // subtract the actual time we waited\n          }\n        }\n      }\n    }\n\n    /**\n     * Checks if the executor has been shut down and increments the running\n     * task count.\n     *\n     * @throws RejectedExecutionException if the executor has been previously\n     *         shutdown\n     */\n    private void startTask() {\n      synchronized (lock) {\n        if (shutdown) {\n          throw new RejectedExecutionException(\"Executor already shutdown\");\n        }\n        runningTasks++;\n      }\n    }\n\n    /**\n     * Decrements the running task count.\n     */\n    private void endTask() {\n      synchronized (lock) {\n        int numRunning = --runningTasks;\n        if (numRunning == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 18.0 (present as MoreExecutors.sameThreadExecutor() since 10.0)\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService newDirectExecutorService() {\n    return new DirectExecutorService();\n  }\n\n  /**\n   * Returns an {@link Executor} that runs each task in the thread that invokes\n   * {@link Executor#execute execute}, as in {@link CallerRunsPolicy}.\n   *\n   * <p>This instance is equivalent to: <pre>   {@code\n   *   final class DirectExecutor implements Executor {\n   *     public void execute(Runnable r) {\n   *       r.run();\n   *     }\n   *   }}</pre>\n   *\n   * <p>This should be preferred to {@link #newDirectExecutorService()} because the implementing the\n   * {@link ExecutorService} subinterface necessitates significant performance overhead.\n   *\n   * @since 18.0\n   */\n  public static Executor directExecutor() {\n    return DirectExecutor.INSTANCE;\n  }\n\n  /** See {@link #directExecutor} for behavioral notes. */\n  private enum DirectExecutor implements Executor {\n    INSTANCE;\n    @Override public void execute(Runnable command) {\n      command.run();\n    }\n\n    @Override public String toString() {\n      return \"MoreExecutors.directExecutor()\";\n    }\n  }\n\n  /**\n   * Creates an {@link ExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code ListeningExecutorService}\n   * never calls the delegate's {@code submit}, {@code invokeAll}, and {@code\n   * invokeAny} methods, so any special handling of tasks must be implemented in\n   * the delegate's {@code execute} method or by wrapping the returned {@code\n   * ListeningExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningExecutorService}, it is returned untouched, and the rest of this\n   * documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService listeningDecorator(\n      ExecutorService delegate) {\n    return (delegate instanceof ListeningExecutorService)\n        ? (ListeningExecutorService) delegate\n        : (delegate instanceof ScheduledExecutorService)\n        ? new ScheduledListeningDecorator((ScheduledExecutorService) delegate)\n        : new ListeningDecorator(delegate);\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code\n   * ListeningScheduledExecutorService} never calls the delegate's {@code\n   * submit}, {@code invokeAll}, and {@code invokeAny} methods, so any special\n   * handling of tasks must be implemented in the delegate's {@code execute}\n   * method or by wrapping the returned {@code\n   * ListeningScheduledExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningScheduledExecutorService}, it is returned untouched, and the rest\n   * of this documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningScheduledExecutorService listeningDecorator(\n      ScheduledExecutorService delegate) {\n    return (delegate instanceof ListeningScheduledExecutorService)\n        ? (ListeningScheduledExecutorService) delegate\n        : new ScheduledListeningDecorator(delegate);\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static class ListeningDecorator\n      extends AbstractListeningExecutorService {\n    private final ExecutorService delegate;\n\n    ListeningDecorator(ExecutorService delegate) {\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public final boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      return delegate.awaitTermination(timeout, unit);\n    }\n\n    @Override\n    public final boolean isShutdown() {\n      return delegate.isShutdown();\n    }\n\n    @Override\n    public final boolean isTerminated() {\n      return delegate.isTerminated();\n    }\n\n    @Override\n    public final void shutdown() {\n      delegate.shutdown();\n    }\n\n    @Override\n    public final List<Runnable> shutdownNow() {\n      return delegate.shutdownNow();\n    }\n\n    @Override\n    public final void execute(Runnable command) {\n      delegate.execute(command);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static final class ScheduledListeningDecorator\n      extends ListeningDecorator implements ListeningScheduledExecutorService {\n    @SuppressWarnings(\"hiding\")\n    final ScheduledExecutorService delegate;\n\n    ScheduledListeningDecorator(ScheduledExecutorService delegate) {\n      super(delegate);\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> schedule(\n        Runnable command, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<Void> task =\n          TrustedListenableFutureTask.create(command, null);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public <V> ListenableScheduledFuture<V> schedule(\n        Callable<V> callable, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<V>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleAtFixedRate(\n        Runnable command, long initialDelay, long period, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleAtFixedRate(task, initialDelay, period, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleWithFixedDelay(\n        Runnable command, long initialDelay, long delay, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleWithFixedDelay(task, initialDelay, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    private static final class ListenableScheduledTask<V>\n        extends SimpleForwardingListenableFuture<V>\n        implements ListenableScheduledFuture<V> {\n\n      private final ScheduledFuture<?> scheduledDelegate;\n\n      public ListenableScheduledTask(\n          ListenableFuture<V> listenableDelegate,\n          ScheduledFuture<?> scheduledDelegate) {\n        super(listenableDelegate);\n        this.scheduledDelegate = scheduledDelegate;\n      }\n\n      @Override\n      public boolean cancel(boolean mayInterruptIfRunning) {\n        boolean cancelled = super.cancel(mayInterruptIfRunning);\n        if (cancelled) {\n          // Unless it is cancelled, the delegate may continue being scheduled\n          scheduledDelegate.cancel(mayInterruptIfRunning);\n\n          // TODO(user): Cancel \"this\" if \"scheduledDelegate\" is cancelled.\n        }\n        return cancelled;\n      }\n\n      @Override\n      public long getDelay(TimeUnit unit) {\n        return scheduledDelegate.getDelay(unit);\n      }\n\n      @Override\n      public int compareTo(Delayed other) {\n        return scheduledDelegate.compareTo(other);\n      }\n    }\n\n    @GwtIncompatible(\"TODO\")\n    private static final class NeverSuccessfulListenableFutureTask\n        extends AbstractFuture<Void>\n        implements Runnable {\n      private final Runnable delegate;\n\n      public NeverSuccessfulListenableFutureTask(Runnable delegate) {\n        this.delegate = checkNotNull(delegate);\n      }\n\n      @Override public void run() {\n        try {\n          delegate.run();\n        } catch (Throwable t) {\n          setException(t);\n          throw Throwables.propagate(t);\n        }\n      }\n    }\n  }\n\n  /*\n   * This following method is a modified version of one found in\n   * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/AbstractExecutorServiceTest.java?revision=1.30\n   * which contained the following notice:\n   *\n   * Written by Doug Lea with assistance from members of JCP JSR-166\n   * Expert Group and released to the public domain, as explained at\n   * http://creativecommons.org/publicdomain/zero/1.0/\n   * Other contributors include Andrew Wright, Jeffrey Hayes,\n   * Pat Fisher, Mike Judd.\n   */\n\n  /**\n   * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}\n   * implementations.\n   */ static <T> T invokeAnyImpl(ListeningExecutorService executorService,\n      Collection<? extends Callable<T>> tasks, boolean timed, long nanos)\n          throws InterruptedException, ExecutionException, TimeoutException {\n    checkNotNull(executorService);\n    int ntasks = tasks.size();\n    checkArgument(ntasks > 0);\n    List<Future<T>> futures = Lists.newArrayListWithCapacity(ntasks);\n    BlockingQueue<Future<T>> futureQueue = Queues.newLinkedBlockingQueue();\n\n    // For efficiency, especially in executors with limited\n    // parallelism, check to see if previously submitted tasks are\n    // done before submitting more of them. This interleaving\n    // plus the exception mechanics account for messiness of main\n    // loop.\n\n    try {\n      // Record exceptions so that if we fail to obtain any\n      // result, we can throw the last exception we got.\n      ExecutionException ee = null;\n      long lastTime = timed ? System.nanoTime() : 0;\n      Iterator<? extends Callable<T>> it = tasks.iterator();\n\n      futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n      --ntasks;\n      int active = 1;\n\n      for (;;) {\n        Future<T> f = futureQueue.poll();\n        if (f == null) {\n          if (ntasks > 0) {\n            --ntasks;\n            futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n            ++active;\n          } else if (active == 0) {\n            break;\n          } else if (timed) {\n            f = futureQueue.poll(nanos, TimeUnit.NANOSECONDS);\n            if (f == null) {\n              throw new TimeoutException();\n            }\n            long now = System.nanoTime();\n            nanos -= now - lastTime;\n            lastTime = now;\n          } else {\n            f = futureQueue.take();\n          }\n        }\n        if (f != null) {\n          --active;\n          try {\n            return f.get();\n          } catch (ExecutionException eex) {\n            ee = eex;\n          } catch (RuntimeException rex) {\n            ee = new ExecutionException(rex);\n          }\n        }\n      }\n\n      if (ee == null) {\n        ee = new ExecutionException(null);\n      }\n      throw ee;\n    } finally {\n      for (Future<T> f : futures) {\n        f.cancel(true);\n      }\n    }\n  }\n\n  /**\n   * Submits the task and adds a listener that adds the future to {@code queue} when it completes.\n   */\n  @GwtIncompatible(\"TODO\")\n  private static <T> ListenableFuture<T> submitAndAddQueueListener(\n      ListeningExecutorService executorService, Callable<T> task,\n      final BlockingQueue<Future<T>> queue) {\n    final ListenableFuture<T> future = executorService.submit(task);\n    future.addListener(new Runnable() {\n      @Override public void run() {\n        queue.add(future);\n      }\n    }, directExecutor());\n    return future;\n  }\n\n  /**\n   * Returns a default thread factory used to create new threads.\n   *\n   * <p>On AppEngine, returns {@code ThreadManager.currentRequestThreadFactory()}.\n   * Otherwise, returns {@link Executors#defaultThreadFactory()}.\n   *\n   * @since 14.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ThreadFactory platformThreadFactory() {\n    if (!isAppEngine()) {\n      return Executors.defaultThreadFactory();\n    }\n    try {\n      return (ThreadFactory) Class.forName(\"com.google.appengine.api.ThreadManager\")\n          .getMethod(\"currentRequestThreadFactory\")\n          .invoke(null);\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (ClassNotFoundException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (NoSuchMethodException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (InvocationTargetException e) {\n      throw Throwables.propagate(e.getCause());\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static boolean isAppEngine() {\n    if (System.getProperty(\"com.google.appengine.runtime.environment\") == null) {\n      return false;\n    }\n    try {\n      // If the current environment is null, we're not inside AppEngine.\n      return Class.forName(\"com.google.apphosting.api.ApiProxy\")\n          .getMethod(\"getCurrentEnvironment\")\n          .invoke(null) != null;\n    } catch (ClassNotFoundException e) {\n      // If ApiProxy doesn't exist, we're not on AppEngine at all.\n      return false;\n    } catch (InvocationTargetException e) {\n      // If ApiProxy throws an exception, we're not in a proper AppEngine environment.\n      return false;\n    } catch (IllegalAccessException e) {\n      // If the method isn't accessible, we're not on a supported version of AppEngine;\n      return false;\n    } catch (NoSuchMethodException e) {\n      // If the method doesn't exist, we're not on a supported version of AppEngine;\n      return false;\n    }\n  }\n\n  /**\n   * Creates a thread using {@link #platformThreadFactory}, and sets its name to {@code name}\n   * unless changing the name is forbidden by the security manager.\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Thread newThread(String name, Runnable runnable) {\n    checkNotNull(name);\n    checkNotNull(runnable);\n    Thread result = platformThreadFactory().newThread(runnable);\n    try {\n      result.setName(name);\n    } catch (SecurityException e) {\n      // OK if we can't set the name in this environment.\n    }\n    return result;\n  }\n\n  // TODO(lukes): provide overloads for ListeningExecutorService? ListeningScheduledExecutorService?\n  // TODO(lukes): provide overloads that take constant strings? Function<Runnable, String>s to\n  // calculate names?\n\n  /**\n   * Creates an {@link Executor} that renames the {@link Thread threads} that its tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param executor The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier) {\n    checkNotNull(executor);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try\n      return executor;\n    }\n    return new Executor() {\n      @Override public void execute(Runnable command) {\n        executor.execute(Callables.threadRenaming(command, nameSupplier));\n      }\n    };\n  }\n\n  /**\n   * Creates an {@link ExecutorService} that renames the {@link Thread threads} that its tasks run\n   * in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ExecutorService renamingDecorator(final ExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} that renames the {@link Thread threads} that its\n   * tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ScheduledExecutorService renamingDecorator(final ScheduledExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingScheduledExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Shuts down the given executor gradually, first disabling new submissions and later cancelling\n   * existing tasks.\n   *\n   * <p>The method takes the following steps:\n   * <ol>\n   *  <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n   *  <li>waits for half of the specified timeout.\n   *  <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n   *  pending tasks and interrupting running tasks.\n   *  <li>waits for the other half of the specified timeout.\n   * </ol>\n   *\n   * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n   * ExecutorService#shutdownNow()} and returns.\n   *\n   * @param service the {@code ExecutorService} to shut down\n   * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n   * @param unit the time unit of the timeout argument\n   * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n   *     the call timed out or was interrupted\n   * @since 17.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static boolean shutdownAndAwaitTermination(\n      ExecutorService service, long timeout, TimeUnit unit) {\n    checkNotNull(unit);\n    // Disable new tasks from being submitted\n    service.shutdown();\n    try {\n      long halfTimeoutNanos = TimeUnit.NANOSECONDS.convert(timeout, unit) / 2;\n      // Wait for half the duration of the timeout for existing tasks to terminate\n      if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {\n        // Cancel currently executing tasks\n        service.shutdownNow();\n        // Wait the other half of the timeout for tasks to respond to being cancelled\n        service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);\n      }\n    } catch (InterruptedException ie) {\n      // Preserve interrupt status\n      Thread.currentThread().interrupt();\n      // (Re-)Cancel if current thread also interrupted\n      service.shutdownNow();\n    }\n    return service.isTerminated();\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53076558,"label":true,"oracleId":1439,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"MoreExecutors","javadocTag":"@param nameSupplier The source of names for each task","methodJavadoc":"    /**\n   * Creates a {@link ScheduledExecutorService} that renames the {@link Thread threads} that its\n   * tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */","methodSourceCode":"static ScheduledExecutorService renamingDecorator(final ScheduledExecutorService service, final Supplier<String> nameSupplier){\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n        // AppEngine doesn't support thread renaming, so don't even try.\n        return service;\n    }\n    return new WrappingScheduledExecutorService(service) {\n\n        @Override\n        protected <T> Callable<T> wrapTask(Callable<T> callable) {\n            return Callables.threadRenaming(callable, nameSupplier);\n        }\n\n        @Override\n        protected Runnable wrapTask(Runnable command) {\n            return Callables.threadRenaming(command, nameSupplier);\n        }\n    };\n}","classJavadoc":"/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */","classSourceCode":"/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Queues;\nimport com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */\n@GwtCompatible(emulated = true)\npublic final class MoreExecutors {\n  private MoreExecutors() {}\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ExecutorService getExitingExecutorService(\n      ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ScheduledThreadPoolExecutor into a\n   * ScheduledExecutorService that exits when the application is complete.  It\n   * does so by using daemon threads and adding a shutdown hook to wait for\n   * their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingScheduledExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Add a shutdown hook to wait for thread completion in the given\n   * {@link ExecutorService service}.  This is useful if the given service uses\n   * daemon threads, and we want to keep the JVM from exiting immediately on\n   * shutdown, instead giving these daemon threads a chance to terminate\n   * normally.\n   * @param service ExecutorService which uses daemon threads\n   * @param terminationTimeout how long to wait for the executor to finish\n   *        before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static void addDelayedShutdownHook(\n      ExecutorService service, long terminationTimeout, TimeUnit timeUnit) {\n    new Application()\n        .addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n    return new Application().getExitingExecutorService(executor);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into a ScheduledExecutorService that\n   * exits when the application is complete.  It does so by using daemon threads\n   * and adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor) {\n    return new Application().getExitingScheduledExecutorService(executor);\n  }\n\n  /** Represents the current application to register shutdown hooks. */\n  @GwtIncompatible(\"TODO\")\n  @VisibleForTesting\n  static class Application {\n\n    final ExecutorService getExitingExecutorService(\n        ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ExecutorService service = Executors.unconfigurableExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ScheduledExecutorService service = Executors.unconfigurableScheduledExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final void addDelayedShutdownHook(\n        final ExecutorService service, final long terminationTimeout, final TimeUnit timeUnit) {\n      checkNotNull(service);\n      checkNotNull(timeUnit);\n      addShutdownHook(MoreExecutors.newThread(\"DelayedShutdownHook-for-\" + service, new Runnable() {\n        @Override\n        public void run() {\n          try {\n            // We'd like to log progress and failures that may arise in the\n            // following code, but unfortunately the behavior of logging\n            // is undefined in shutdown hooks.\n            // This is because the logging code installs a shutdown hook of its\n            // own. See Cleaner class inside {@link LogManager}.\n            service.shutdown();\n            service.awaitTermination(terminationTimeout, timeUnit);\n          } catch (InterruptedException ignored) {\n            // We're shutting down anyway, so just ignore.\n          }\n        }\n      }));\n    }\n\n    final ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n      return getExitingExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor) {\n      return getExitingScheduledExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    @VisibleForTesting void addShutdownHook(Thread hook) {\n      Runtime.getRuntime().addShutdownHook(hook);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static void useDaemonThreadFactory(ThreadPoolExecutor executor) {\n    executor.setThreadFactory(new ThreadFactoryBuilder()\n        .setDaemon(true)\n        .setThreadFactory(executor.getThreadFactory())\n        .build());\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}.  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 10.0 (<a href=\"https://github.com/google/guava/wiki/Compatibility\"\n   *        >mostly source-compatible</a> since 3.0)\n   * @deprecated Use {@link #directExecutor()} if you only require an {@link Executor} and\n   *     {@link #newDirectExecutorService()} if you need a {@link ListeningExecutorService}. This\n   *     method will be removed in August 2016.\n   */\n  @Deprecated\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService sameThreadExecutor() {\n    return new DirectExecutorService();\n  }\n\n  // See sameThreadExecutor javadoc for behavioral notes.\n  @GwtIncompatible(\"TODO\")\n  private static final class DirectExecutorService\n      extends AbstractListeningExecutorService {\n    /**\n     * Lock used whenever accessing the state variables\n     * (runningTasks, shutdown) of the executor\n     */\n    private final Object lock = new Object();\n\n    /*\n     * Conceptually, these two variables describe the executor being in\n     * one of three states:\n     *   - Active: shutdown == false\n     *   - Shutdown: runningTasks > 0 and shutdown == true\n     *   - Terminated: runningTasks == 0 and shutdown == true\n     */\n    @GuardedBy(\"lock\") private int runningTasks = 0;\n    @GuardedBy(\"lock\") private boolean shutdown = false;\n\n    @Override\n    public void execute(Runnable command) {\n      startTask();\n      try {\n        command.run();\n      } finally {\n        endTask();\n      }\n    }\n\n    @Override\n    public boolean isShutdown() {\n      synchronized (lock) {\n        return shutdown;\n      }\n    }\n\n    @Override\n    public void shutdown() {\n      synchronized (lock) {\n        shutdown = true;\n        if (runningTasks == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n\n    // See sameThreadExecutor javadoc for unusual behavior of this method.\n    @Override\n    public List<Runnable> shutdownNow() {\n      shutdown();\n      return Collections.emptyList();\n    }\n\n    @Override\n    public boolean isTerminated() {\n      synchronized (lock) {\n        return shutdown && runningTasks == 0;\n      }\n    }\n\n    @Override\n    public boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      long nanos = unit.toNanos(timeout);\n      synchronized (lock) {\n        for (;;) {\n          if (shutdown && runningTasks == 0) {\n            return true;\n          } else if (nanos <= 0) {\n            return false;\n          } else {\n            long now = System.nanoTime();\n            TimeUnit.NANOSECONDS.timedWait(lock, nanos);\n            nanos -= System.nanoTime() - now;  // subtract the actual time we waited\n          }\n        }\n      }\n    }\n\n    /**\n     * Checks if the executor has been shut down and increments the running\n     * task count.\n     *\n     * @throws RejectedExecutionException if the executor has been previously\n     *         shutdown\n     */\n    private void startTask() {\n      synchronized (lock) {\n        if (shutdown) {\n          throw new RejectedExecutionException(\"Executor already shutdown\");\n        }\n        runningTasks++;\n      }\n    }\n\n    /**\n     * Decrements the running task count.\n     */\n    private void endTask() {\n      synchronized (lock) {\n        int numRunning = --runningTasks;\n        if (numRunning == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 18.0 (present as MoreExecutors.sameThreadExecutor() since 10.0)\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService newDirectExecutorService() {\n    return new DirectExecutorService();\n  }\n\n  /**\n   * Returns an {@link Executor} that runs each task in the thread that invokes\n   * {@link Executor#execute execute}, as in {@link CallerRunsPolicy}.\n   *\n   * <p>This instance is equivalent to: <pre>   {@code\n   *   final class DirectExecutor implements Executor {\n   *     public void execute(Runnable r) {\n   *       r.run();\n   *     }\n   *   }}</pre>\n   *\n   * <p>This should be preferred to {@link #newDirectExecutorService()} because the implementing the\n   * {@link ExecutorService} subinterface necessitates significant performance overhead.\n   *\n   * @since 18.0\n   */\n  public static Executor directExecutor() {\n    return DirectExecutor.INSTANCE;\n  }\n\n  /** See {@link #directExecutor} for behavioral notes. */\n  private enum DirectExecutor implements Executor {\n    INSTANCE;\n    @Override public void execute(Runnable command) {\n      command.run();\n    }\n\n    @Override public String toString() {\n      return \"MoreExecutors.directExecutor()\";\n    }\n  }\n\n  /**\n   * Creates an {@link ExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code ListeningExecutorService}\n   * never calls the delegate's {@code submit}, {@code invokeAll}, and {@code\n   * invokeAny} methods, so any special handling of tasks must be implemented in\n   * the delegate's {@code execute} method or by wrapping the returned {@code\n   * ListeningExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningExecutorService}, it is returned untouched, and the rest of this\n   * documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService listeningDecorator(\n      ExecutorService delegate) {\n    return (delegate instanceof ListeningExecutorService)\n        ? (ListeningExecutorService) delegate\n        : (delegate instanceof ScheduledExecutorService)\n        ? new ScheduledListeningDecorator((ScheduledExecutorService) delegate)\n        : new ListeningDecorator(delegate);\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code\n   * ListeningScheduledExecutorService} never calls the delegate's {@code\n   * submit}, {@code invokeAll}, and {@code invokeAny} methods, so any special\n   * handling of tasks must be implemented in the delegate's {@code execute}\n   * method or by wrapping the returned {@code\n   * ListeningScheduledExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningScheduledExecutorService}, it is returned untouched, and the rest\n   * of this documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningScheduledExecutorService listeningDecorator(\n      ScheduledExecutorService delegate) {\n    return (delegate instanceof ListeningScheduledExecutorService)\n        ? (ListeningScheduledExecutorService) delegate\n        : new ScheduledListeningDecorator(delegate);\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static class ListeningDecorator\n      extends AbstractListeningExecutorService {\n    private final ExecutorService delegate;\n\n    ListeningDecorator(ExecutorService delegate) {\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public final boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      return delegate.awaitTermination(timeout, unit);\n    }\n\n    @Override\n    public final boolean isShutdown() {\n      return delegate.isShutdown();\n    }\n\n    @Override\n    public final boolean isTerminated() {\n      return delegate.isTerminated();\n    }\n\n    @Override\n    public final void shutdown() {\n      delegate.shutdown();\n    }\n\n    @Override\n    public final List<Runnable> shutdownNow() {\n      return delegate.shutdownNow();\n    }\n\n    @Override\n    public final void execute(Runnable command) {\n      delegate.execute(command);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static final class ScheduledListeningDecorator\n      extends ListeningDecorator implements ListeningScheduledExecutorService {\n    @SuppressWarnings(\"hiding\")\n    final ScheduledExecutorService delegate;\n\n    ScheduledListeningDecorator(ScheduledExecutorService delegate) {\n      super(delegate);\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> schedule(\n        Runnable command, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<Void> task =\n          TrustedListenableFutureTask.create(command, null);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public <V> ListenableScheduledFuture<V> schedule(\n        Callable<V> callable, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<V>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleAtFixedRate(\n        Runnable command, long initialDelay, long period, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleAtFixedRate(task, initialDelay, period, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleWithFixedDelay(\n        Runnable command, long initialDelay, long delay, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleWithFixedDelay(task, initialDelay, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    private static final class ListenableScheduledTask<V>\n        extends SimpleForwardingListenableFuture<V>\n        implements ListenableScheduledFuture<V> {\n\n      private final ScheduledFuture<?> scheduledDelegate;\n\n      public ListenableScheduledTask(\n          ListenableFuture<V> listenableDelegate,\n          ScheduledFuture<?> scheduledDelegate) {\n        super(listenableDelegate);\n        this.scheduledDelegate = scheduledDelegate;\n      }\n\n      @Override\n      public boolean cancel(boolean mayInterruptIfRunning) {\n        boolean cancelled = super.cancel(mayInterruptIfRunning);\n        if (cancelled) {\n          // Unless it is cancelled, the delegate may continue being scheduled\n          scheduledDelegate.cancel(mayInterruptIfRunning);\n\n          // TODO(user): Cancel \"this\" if \"scheduledDelegate\" is cancelled.\n        }\n        return cancelled;\n      }\n\n      @Override\n      public long getDelay(TimeUnit unit) {\n        return scheduledDelegate.getDelay(unit);\n      }\n\n      @Override\n      public int compareTo(Delayed other) {\n        return scheduledDelegate.compareTo(other);\n      }\n    }\n\n    @GwtIncompatible(\"TODO\")\n    private static final class NeverSuccessfulListenableFutureTask\n        extends AbstractFuture<Void>\n        implements Runnable {\n      private final Runnable delegate;\n\n      public NeverSuccessfulListenableFutureTask(Runnable delegate) {\n        this.delegate = checkNotNull(delegate);\n      }\n\n      @Override public void run() {\n        try {\n          delegate.run();\n        } catch (Throwable t) {\n          setException(t);\n          throw Throwables.propagate(t);\n        }\n      }\n    }\n  }\n\n  /*\n   * This following method is a modified version of one found in\n   * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/AbstractExecutorServiceTest.java?revision=1.30\n   * which contained the following notice:\n   *\n   * Written by Doug Lea with assistance from members of JCP JSR-166\n   * Expert Group and released to the public domain, as explained at\n   * http://creativecommons.org/publicdomain/zero/1.0/\n   * Other contributors include Andrew Wright, Jeffrey Hayes,\n   * Pat Fisher, Mike Judd.\n   */\n\n  /**\n   * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}\n   * implementations.\n   */ static <T> T invokeAnyImpl(ListeningExecutorService executorService,\n      Collection<? extends Callable<T>> tasks, boolean timed, long nanos)\n          throws InterruptedException, ExecutionException, TimeoutException {\n    checkNotNull(executorService);\n    int ntasks = tasks.size();\n    checkArgument(ntasks > 0);\n    List<Future<T>> futures = Lists.newArrayListWithCapacity(ntasks);\n    BlockingQueue<Future<T>> futureQueue = Queues.newLinkedBlockingQueue();\n\n    // For efficiency, especially in executors with limited\n    // parallelism, check to see if previously submitted tasks are\n    // done before submitting more of them. This interleaving\n    // plus the exception mechanics account for messiness of main\n    // loop.\n\n    try {\n      // Record exceptions so that if we fail to obtain any\n      // result, we can throw the last exception we got.\n      ExecutionException ee = null;\n      long lastTime = timed ? System.nanoTime() : 0;\n      Iterator<? extends Callable<T>> it = tasks.iterator();\n\n      futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n      --ntasks;\n      int active = 1;\n\n      for (;;) {\n        Future<T> f = futureQueue.poll();\n        if (f == null) {\n          if (ntasks > 0) {\n            --ntasks;\n            futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n            ++active;\n          } else if (active == 0) {\n            break;\n          } else if (timed) {\n            f = futureQueue.poll(nanos, TimeUnit.NANOSECONDS);\n            if (f == null) {\n              throw new TimeoutException();\n            }\n            long now = System.nanoTime();\n            nanos -= now - lastTime;\n            lastTime = now;\n          } else {\n            f = futureQueue.take();\n          }\n        }\n        if (f != null) {\n          --active;\n          try {\n            return f.get();\n          } catch (ExecutionException eex) {\n            ee = eex;\n          } catch (RuntimeException rex) {\n            ee = new ExecutionException(rex);\n          }\n        }\n      }\n\n      if (ee == null) {\n        ee = new ExecutionException(null);\n      }\n      throw ee;\n    } finally {\n      for (Future<T> f : futures) {\n        f.cancel(true);\n      }\n    }\n  }\n\n  /**\n   * Submits the task and adds a listener that adds the future to {@code queue} when it completes.\n   */\n  @GwtIncompatible(\"TODO\")\n  private static <T> ListenableFuture<T> submitAndAddQueueListener(\n      ListeningExecutorService executorService, Callable<T> task,\n      final BlockingQueue<Future<T>> queue) {\n    final ListenableFuture<T> future = executorService.submit(task);\n    future.addListener(new Runnable() {\n      @Override public void run() {\n        queue.add(future);\n      }\n    }, directExecutor());\n    return future;\n  }\n\n  /**\n   * Returns a default thread factory used to create new threads.\n   *\n   * <p>On AppEngine, returns {@code ThreadManager.currentRequestThreadFactory()}.\n   * Otherwise, returns {@link Executors#defaultThreadFactory()}.\n   *\n   * @since 14.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ThreadFactory platformThreadFactory() {\n    if (!isAppEngine()) {\n      return Executors.defaultThreadFactory();\n    }\n    try {\n      return (ThreadFactory) Class.forName(\"com.google.appengine.api.ThreadManager\")\n          .getMethod(\"currentRequestThreadFactory\")\n          .invoke(null);\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (ClassNotFoundException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (NoSuchMethodException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (InvocationTargetException e) {\n      throw Throwables.propagate(e.getCause());\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static boolean isAppEngine() {\n    if (System.getProperty(\"com.google.appengine.runtime.environment\") == null) {\n      return false;\n    }\n    try {\n      // If the current environment is null, we're not inside AppEngine.\n      return Class.forName(\"com.google.apphosting.api.ApiProxy\")\n          .getMethod(\"getCurrentEnvironment\")\n          .invoke(null) != null;\n    } catch (ClassNotFoundException e) {\n      // If ApiProxy doesn't exist, we're not on AppEngine at all.\n      return false;\n    } catch (InvocationTargetException e) {\n      // If ApiProxy throws an exception, we're not in a proper AppEngine environment.\n      return false;\n    } catch (IllegalAccessException e) {\n      // If the method isn't accessible, we're not on a supported version of AppEngine;\n      return false;\n    } catch (NoSuchMethodException e) {\n      // If the method doesn't exist, we're not on a supported version of AppEngine;\n      return false;\n    }\n  }\n\n  /**\n   * Creates a thread using {@link #platformThreadFactory}, and sets its name to {@code name}\n   * unless changing the name is forbidden by the security manager.\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Thread newThread(String name, Runnable runnable) {\n    checkNotNull(name);\n    checkNotNull(runnable);\n    Thread result = platformThreadFactory().newThread(runnable);\n    try {\n      result.setName(name);\n    } catch (SecurityException e) {\n      // OK if we can't set the name in this environment.\n    }\n    return result;\n  }\n\n  // TODO(lukes): provide overloads for ListeningExecutorService? ListeningScheduledExecutorService?\n  // TODO(lukes): provide overloads that take constant strings? Function<Runnable, String>s to\n  // calculate names?\n\n  /**\n   * Creates an {@link Executor} that renames the {@link Thread threads} that its tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param executor The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier) {\n    checkNotNull(executor);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try\n      return executor;\n    }\n    return new Executor() {\n      @Override public void execute(Runnable command) {\n        executor.execute(Callables.threadRenaming(command, nameSupplier));\n      }\n    };\n  }\n\n  /**\n   * Creates an {@link ExecutorService} that renames the {@link Thread threads} that its tasks run\n   * in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ExecutorService renamingDecorator(final ExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} that renames the {@link Thread threads} that its\n   * tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ScheduledExecutorService renamingDecorator(final ScheduledExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingScheduledExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Shuts down the given executor gradually, first disabling new submissions and later cancelling\n   * existing tasks.\n   *\n   * <p>The method takes the following steps:\n   * <ol>\n   *  <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n   *  <li>waits for half of the specified timeout.\n   *  <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n   *  pending tasks and interrupting running tasks.\n   *  <li>waits for the other half of the specified timeout.\n   * </ol>\n   *\n   * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n   * ExecutorService#shutdownNow()} and returns.\n   *\n   * @param service the {@code ExecutorService} to shut down\n   * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n   * @param unit the time unit of the timeout argument\n   * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n   *     the call timed out or was interrupted\n   * @since 17.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static boolean shutdownAndAwaitTermination(\n      ExecutorService service, long timeout, TimeUnit unit) {\n    checkNotNull(unit);\n    // Disable new tasks from being submitted\n    service.shutdown();\n    try {\n      long halfTimeoutNanos = TimeUnit.NANOSECONDS.convert(timeout, unit) / 2;\n      // Wait for half the duration of the timeout for existing tasks to terminate\n      if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {\n        // Cancel currently executing tasks\n        service.shutdownNow();\n        // Wait the other half of the timeout for tasks to respond to being cancelled\n        service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);\n      }\n    } catch (InterruptedException ie) {\n      // Preserve interrupt status\n      Thread.currentThread().interrupt();\n      // (Re-)Cancel if current thread also interrupted\n      service.shutdownNow();\n    }\n    return service.isTerminated();\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53077017,"label":true,"oracleId":1440,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"MoreExecutors","javadocTag":"@param service the {@code ExecutorService} to shut down","methodJavadoc":"    /**\n   * Shuts down the given executor gradually, first disabling new submissions and later cancelling\n   * existing tasks.\n   *\n   * <p>The method takes the following steps:\n   * <ol>\n   *  <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n   *  <li>waits for half of the specified timeout.\n   *  <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n   *  pending tasks and interrupting running tasks.\n   *  <li>waits for the other half of the specified timeout.\n   * </ol>\n   *\n   * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n   * ExecutorService#shutdownNow()} and returns.\n   *\n   * @param service the {@code ExecutorService} to shut down\n   * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n   * @param unit the time unit of the timeout argument\n   * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n   *     the call timed out or was interrupted\n   * @since 17.0\n   */","methodSourceCode":"public static boolean shutdownAndAwaitTermination(ExecutorService service, long timeout, TimeUnit unit){\n    checkNotNull(unit);\n    // Disable new tasks from being submitted\n    service.shutdown();\n    try {\n        long halfTimeoutNanos = TimeUnit.NANOSECONDS.convert(timeout, unit) / 2;\n        // Wait for half the duration of the timeout for existing tasks to terminate\n        if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {\n            // Cancel currently executing tasks\n            service.shutdownNow();\n            // Wait the other half of the timeout for tasks to respond to being cancelled\n            service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);\n        }\n    } catch (InterruptedException ie) {\n        // Preserve interrupt status\n        Thread.currentThread().interrupt();\n        // (Re-)Cancel if current thread also interrupted\n        service.shutdownNow();\n    }\n    return service.isTerminated();\n}","classJavadoc":"/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */","classSourceCode":"/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Queues;\nimport com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */\n@GwtCompatible(emulated = true)\npublic final class MoreExecutors {\n  private MoreExecutors() {}\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ExecutorService getExitingExecutorService(\n      ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ScheduledThreadPoolExecutor into a\n   * ScheduledExecutorService that exits when the application is complete.  It\n   * does so by using daemon threads and adding a shutdown hook to wait for\n   * their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingScheduledExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Add a shutdown hook to wait for thread completion in the given\n   * {@link ExecutorService service}.  This is useful if the given service uses\n   * daemon threads, and we want to keep the JVM from exiting immediately on\n   * shutdown, instead giving these daemon threads a chance to terminate\n   * normally.\n   * @param service ExecutorService which uses daemon threads\n   * @param terminationTimeout how long to wait for the executor to finish\n   *        before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static void addDelayedShutdownHook(\n      ExecutorService service, long terminationTimeout, TimeUnit timeUnit) {\n    new Application()\n        .addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n    return new Application().getExitingExecutorService(executor);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into a ScheduledExecutorService that\n   * exits when the application is complete.  It does so by using daemon threads\n   * and adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor) {\n    return new Application().getExitingScheduledExecutorService(executor);\n  }\n\n  /** Represents the current application to register shutdown hooks. */\n  @GwtIncompatible(\"TODO\")\n  @VisibleForTesting\n  static class Application {\n\n    final ExecutorService getExitingExecutorService(\n        ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ExecutorService service = Executors.unconfigurableExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ScheduledExecutorService service = Executors.unconfigurableScheduledExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final void addDelayedShutdownHook(\n        final ExecutorService service, final long terminationTimeout, final TimeUnit timeUnit) {\n      checkNotNull(service);\n      checkNotNull(timeUnit);\n      addShutdownHook(MoreExecutors.newThread(\"DelayedShutdownHook-for-\" + service, new Runnable() {\n        @Override\n        public void run() {\n          try {\n            // We'd like to log progress and failures that may arise in the\n            // following code, but unfortunately the behavior of logging\n            // is undefined in shutdown hooks.\n            // This is because the logging code installs a shutdown hook of its\n            // own. See Cleaner class inside {@link LogManager}.\n            service.shutdown();\n            service.awaitTermination(terminationTimeout, timeUnit);\n          } catch (InterruptedException ignored) {\n            // We're shutting down anyway, so just ignore.\n          }\n        }\n      }));\n    }\n\n    final ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n      return getExitingExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor) {\n      return getExitingScheduledExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    @VisibleForTesting void addShutdownHook(Thread hook) {\n      Runtime.getRuntime().addShutdownHook(hook);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static void useDaemonThreadFactory(ThreadPoolExecutor executor) {\n    executor.setThreadFactory(new ThreadFactoryBuilder()\n        .setDaemon(true)\n        .setThreadFactory(executor.getThreadFactory())\n        .build());\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}.  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 10.0 (<a href=\"https://github.com/google/guava/wiki/Compatibility\"\n   *        >mostly source-compatible</a> since 3.0)\n   * @deprecated Use {@link #directExecutor()} if you only require an {@link Executor} and\n   *     {@link #newDirectExecutorService()} if you need a {@link ListeningExecutorService}. This\n   *     method will be removed in August 2016.\n   */\n  @Deprecated\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService sameThreadExecutor() {\n    return new DirectExecutorService();\n  }\n\n  // See sameThreadExecutor javadoc for behavioral notes.\n  @GwtIncompatible(\"TODO\")\n  private static final class DirectExecutorService\n      extends AbstractListeningExecutorService {\n    /**\n     * Lock used whenever accessing the state variables\n     * (runningTasks, shutdown) of the executor\n     */\n    private final Object lock = new Object();\n\n    /*\n     * Conceptually, these two variables describe the executor being in\n     * one of three states:\n     *   - Active: shutdown == false\n     *   - Shutdown: runningTasks > 0 and shutdown == true\n     *   - Terminated: runningTasks == 0 and shutdown == true\n     */\n    @GuardedBy(\"lock\") private int runningTasks = 0;\n    @GuardedBy(\"lock\") private boolean shutdown = false;\n\n    @Override\n    public void execute(Runnable command) {\n      startTask();\n      try {\n        command.run();\n      } finally {\n        endTask();\n      }\n    }\n\n    @Override\n    public boolean isShutdown() {\n      synchronized (lock) {\n        return shutdown;\n      }\n    }\n\n    @Override\n    public void shutdown() {\n      synchronized (lock) {\n        shutdown = true;\n        if (runningTasks == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n\n    // See sameThreadExecutor javadoc for unusual behavior of this method.\n    @Override\n    public List<Runnable> shutdownNow() {\n      shutdown();\n      return Collections.emptyList();\n    }\n\n    @Override\n    public boolean isTerminated() {\n      synchronized (lock) {\n        return shutdown && runningTasks == 0;\n      }\n    }\n\n    @Override\n    public boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      long nanos = unit.toNanos(timeout);\n      synchronized (lock) {\n        for (;;) {\n          if (shutdown && runningTasks == 0) {\n            return true;\n          } else if (nanos <= 0) {\n            return false;\n          } else {\n            long now = System.nanoTime();\n            TimeUnit.NANOSECONDS.timedWait(lock, nanos);\n            nanos -= System.nanoTime() - now;  // subtract the actual time we waited\n          }\n        }\n      }\n    }\n\n    /**\n     * Checks if the executor has been shut down and increments the running\n     * task count.\n     *\n     * @throws RejectedExecutionException if the executor has been previously\n     *         shutdown\n     */\n    private void startTask() {\n      synchronized (lock) {\n        if (shutdown) {\n          throw new RejectedExecutionException(\"Executor already shutdown\");\n        }\n        runningTasks++;\n      }\n    }\n\n    /**\n     * Decrements the running task count.\n     */\n    private void endTask() {\n      synchronized (lock) {\n        int numRunning = --runningTasks;\n        if (numRunning == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 18.0 (present as MoreExecutors.sameThreadExecutor() since 10.0)\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService newDirectExecutorService() {\n    return new DirectExecutorService();\n  }\n\n  /**\n   * Returns an {@link Executor} that runs each task in the thread that invokes\n   * {@link Executor#execute execute}, as in {@link CallerRunsPolicy}.\n   *\n   * <p>This instance is equivalent to: <pre>   {@code\n   *   final class DirectExecutor implements Executor {\n   *     public void execute(Runnable r) {\n   *       r.run();\n   *     }\n   *   }}</pre>\n   *\n   * <p>This should be preferred to {@link #newDirectExecutorService()} because the implementing the\n   * {@link ExecutorService} subinterface necessitates significant performance overhead.\n   *\n   * @since 18.0\n   */\n  public static Executor directExecutor() {\n    return DirectExecutor.INSTANCE;\n  }\n\n  /** See {@link #directExecutor} for behavioral notes. */\n  private enum DirectExecutor implements Executor {\n    INSTANCE;\n    @Override public void execute(Runnable command) {\n      command.run();\n    }\n\n    @Override public String toString() {\n      return \"MoreExecutors.directExecutor()\";\n    }\n  }\n\n  /**\n   * Creates an {@link ExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code ListeningExecutorService}\n   * never calls the delegate's {@code submit}, {@code invokeAll}, and {@code\n   * invokeAny} methods, so any special handling of tasks must be implemented in\n   * the delegate's {@code execute} method or by wrapping the returned {@code\n   * ListeningExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningExecutorService}, it is returned untouched, and the rest of this\n   * documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService listeningDecorator(\n      ExecutorService delegate) {\n    return (delegate instanceof ListeningExecutorService)\n        ? (ListeningExecutorService) delegate\n        : (delegate instanceof ScheduledExecutorService)\n        ? new ScheduledListeningDecorator((ScheduledExecutorService) delegate)\n        : new ListeningDecorator(delegate);\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code\n   * ListeningScheduledExecutorService} never calls the delegate's {@code\n   * submit}, {@code invokeAll}, and {@code invokeAny} methods, so any special\n   * handling of tasks must be implemented in the delegate's {@code execute}\n   * method or by wrapping the returned {@code\n   * ListeningScheduledExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningScheduledExecutorService}, it is returned untouched, and the rest\n   * of this documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningScheduledExecutorService listeningDecorator(\n      ScheduledExecutorService delegate) {\n    return (delegate instanceof ListeningScheduledExecutorService)\n        ? (ListeningScheduledExecutorService) delegate\n        : new ScheduledListeningDecorator(delegate);\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static class ListeningDecorator\n      extends AbstractListeningExecutorService {\n    private final ExecutorService delegate;\n\n    ListeningDecorator(ExecutorService delegate) {\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public final boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      return delegate.awaitTermination(timeout, unit);\n    }\n\n    @Override\n    public final boolean isShutdown() {\n      return delegate.isShutdown();\n    }\n\n    @Override\n    public final boolean isTerminated() {\n      return delegate.isTerminated();\n    }\n\n    @Override\n    public final void shutdown() {\n      delegate.shutdown();\n    }\n\n    @Override\n    public final List<Runnable> shutdownNow() {\n      return delegate.shutdownNow();\n    }\n\n    @Override\n    public final void execute(Runnable command) {\n      delegate.execute(command);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static final class ScheduledListeningDecorator\n      extends ListeningDecorator implements ListeningScheduledExecutorService {\n    @SuppressWarnings(\"hiding\")\n    final ScheduledExecutorService delegate;\n\n    ScheduledListeningDecorator(ScheduledExecutorService delegate) {\n      super(delegate);\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> schedule(\n        Runnable command, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<Void> task =\n          TrustedListenableFutureTask.create(command, null);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public <V> ListenableScheduledFuture<V> schedule(\n        Callable<V> callable, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<V>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleAtFixedRate(\n        Runnable command, long initialDelay, long period, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleAtFixedRate(task, initialDelay, period, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleWithFixedDelay(\n        Runnable command, long initialDelay, long delay, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleWithFixedDelay(task, initialDelay, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    private static final class ListenableScheduledTask<V>\n        extends SimpleForwardingListenableFuture<V>\n        implements ListenableScheduledFuture<V> {\n\n      private final ScheduledFuture<?> scheduledDelegate;\n\n      public ListenableScheduledTask(\n          ListenableFuture<V> listenableDelegate,\n          ScheduledFuture<?> scheduledDelegate) {\n        super(listenableDelegate);\n        this.scheduledDelegate = scheduledDelegate;\n      }\n\n      @Override\n      public boolean cancel(boolean mayInterruptIfRunning) {\n        boolean cancelled = super.cancel(mayInterruptIfRunning);\n        if (cancelled) {\n          // Unless it is cancelled, the delegate may continue being scheduled\n          scheduledDelegate.cancel(mayInterruptIfRunning);\n\n          // TODO(user): Cancel \"this\" if \"scheduledDelegate\" is cancelled.\n        }\n        return cancelled;\n      }\n\n      @Override\n      public long getDelay(TimeUnit unit) {\n        return scheduledDelegate.getDelay(unit);\n      }\n\n      @Override\n      public int compareTo(Delayed other) {\n        return scheduledDelegate.compareTo(other);\n      }\n    }\n\n    @GwtIncompatible(\"TODO\")\n    private static final class NeverSuccessfulListenableFutureTask\n        extends AbstractFuture<Void>\n        implements Runnable {\n      private final Runnable delegate;\n\n      public NeverSuccessfulListenableFutureTask(Runnable delegate) {\n        this.delegate = checkNotNull(delegate);\n      }\n\n      @Override public void run() {\n        try {\n          delegate.run();\n        } catch (Throwable t) {\n          setException(t);\n          throw Throwables.propagate(t);\n        }\n      }\n    }\n  }\n\n  /*\n   * This following method is a modified version of one found in\n   * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/AbstractExecutorServiceTest.java?revision=1.30\n   * which contained the following notice:\n   *\n   * Written by Doug Lea with assistance from members of JCP JSR-166\n   * Expert Group and released to the public domain, as explained at\n   * http://creativecommons.org/publicdomain/zero/1.0/\n   * Other contributors include Andrew Wright, Jeffrey Hayes,\n   * Pat Fisher, Mike Judd.\n   */\n\n  /**\n   * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}\n   * implementations.\n   */ static <T> T invokeAnyImpl(ListeningExecutorService executorService,\n      Collection<? extends Callable<T>> tasks, boolean timed, long nanos)\n          throws InterruptedException, ExecutionException, TimeoutException {\n    checkNotNull(executorService);\n    int ntasks = tasks.size();\n    checkArgument(ntasks > 0);\n    List<Future<T>> futures = Lists.newArrayListWithCapacity(ntasks);\n    BlockingQueue<Future<T>> futureQueue = Queues.newLinkedBlockingQueue();\n\n    // For efficiency, especially in executors with limited\n    // parallelism, check to see if previously submitted tasks are\n    // done before submitting more of them. This interleaving\n    // plus the exception mechanics account for messiness of main\n    // loop.\n\n    try {\n      // Record exceptions so that if we fail to obtain any\n      // result, we can throw the last exception we got.\n      ExecutionException ee = null;\n      long lastTime = timed ? System.nanoTime() : 0;\n      Iterator<? extends Callable<T>> it = tasks.iterator();\n\n      futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n      --ntasks;\n      int active = 1;\n\n      for (;;) {\n        Future<T> f = futureQueue.poll();\n        if (f == null) {\n          if (ntasks > 0) {\n            --ntasks;\n            futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n            ++active;\n          } else if (active == 0) {\n            break;\n          } else if (timed) {\n            f = futureQueue.poll(nanos, TimeUnit.NANOSECONDS);\n            if (f == null) {\n              throw new TimeoutException();\n            }\n            long now = System.nanoTime();\n            nanos -= now - lastTime;\n            lastTime = now;\n          } else {\n            f = futureQueue.take();\n          }\n        }\n        if (f != null) {\n          --active;\n          try {\n            return f.get();\n          } catch (ExecutionException eex) {\n            ee = eex;\n          } catch (RuntimeException rex) {\n            ee = new ExecutionException(rex);\n          }\n        }\n      }\n\n      if (ee == null) {\n        ee = new ExecutionException(null);\n      }\n      throw ee;\n    } finally {\n      for (Future<T> f : futures) {\n        f.cancel(true);\n      }\n    }\n  }\n\n  /**\n   * Submits the task and adds a listener that adds the future to {@code queue} when it completes.\n   */\n  @GwtIncompatible(\"TODO\")\n  private static <T> ListenableFuture<T> submitAndAddQueueListener(\n      ListeningExecutorService executorService, Callable<T> task,\n      final BlockingQueue<Future<T>> queue) {\n    final ListenableFuture<T> future = executorService.submit(task);\n    future.addListener(new Runnable() {\n      @Override public void run() {\n        queue.add(future);\n      }\n    }, directExecutor());\n    return future;\n  }\n\n  /**\n   * Returns a default thread factory used to create new threads.\n   *\n   * <p>On AppEngine, returns {@code ThreadManager.currentRequestThreadFactory()}.\n   * Otherwise, returns {@link Executors#defaultThreadFactory()}.\n   *\n   * @since 14.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ThreadFactory platformThreadFactory() {\n    if (!isAppEngine()) {\n      return Executors.defaultThreadFactory();\n    }\n    try {\n      return (ThreadFactory) Class.forName(\"com.google.appengine.api.ThreadManager\")\n          .getMethod(\"currentRequestThreadFactory\")\n          .invoke(null);\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (ClassNotFoundException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (NoSuchMethodException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (InvocationTargetException e) {\n      throw Throwables.propagate(e.getCause());\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static boolean isAppEngine() {\n    if (System.getProperty(\"com.google.appengine.runtime.environment\") == null) {\n      return false;\n    }\n    try {\n      // If the current environment is null, we're not inside AppEngine.\n      return Class.forName(\"com.google.apphosting.api.ApiProxy\")\n          .getMethod(\"getCurrentEnvironment\")\n          .invoke(null) != null;\n    } catch (ClassNotFoundException e) {\n      // If ApiProxy doesn't exist, we're not on AppEngine at all.\n      return false;\n    } catch (InvocationTargetException e) {\n      // If ApiProxy throws an exception, we're not in a proper AppEngine environment.\n      return false;\n    } catch (IllegalAccessException e) {\n      // If the method isn't accessible, we're not on a supported version of AppEngine;\n      return false;\n    } catch (NoSuchMethodException e) {\n      // If the method doesn't exist, we're not on a supported version of AppEngine;\n      return false;\n    }\n  }\n\n  /**\n   * Creates a thread using {@link #platformThreadFactory}, and sets its name to {@code name}\n   * unless changing the name is forbidden by the security manager.\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Thread newThread(String name, Runnable runnable) {\n    checkNotNull(name);\n    checkNotNull(runnable);\n    Thread result = platformThreadFactory().newThread(runnable);\n    try {\n      result.setName(name);\n    } catch (SecurityException e) {\n      // OK if we can't set the name in this environment.\n    }\n    return result;\n  }\n\n  // TODO(lukes): provide overloads for ListeningExecutorService? ListeningScheduledExecutorService?\n  // TODO(lukes): provide overloads that take constant strings? Function<Runnable, String>s to\n  // calculate names?\n\n  /**\n   * Creates an {@link Executor} that renames the {@link Thread threads} that its tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param executor The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier) {\n    checkNotNull(executor);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try\n      return executor;\n    }\n    return new Executor() {\n      @Override public void execute(Runnable command) {\n        executor.execute(Callables.threadRenaming(command, nameSupplier));\n      }\n    };\n  }\n\n  /**\n   * Creates an {@link ExecutorService} that renames the {@link Thread threads} that its tasks run\n   * in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ExecutorService renamingDecorator(final ExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} that renames the {@link Thread threads} that its\n   * tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ScheduledExecutorService renamingDecorator(final ScheduledExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingScheduledExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Shuts down the given executor gradually, first disabling new submissions and later cancelling\n   * existing tasks.\n   *\n   * <p>The method takes the following steps:\n   * <ol>\n   *  <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n   *  <li>waits for half of the specified timeout.\n   *  <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n   *  pending tasks and interrupting running tasks.\n   *  <li>waits for the other half of the specified timeout.\n   * </ol>\n   *\n   * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n   * ExecutorService#shutdownNow()} and returns.\n   *\n   * @param service the {@code ExecutorService} to shut down\n   * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n   * @param unit the time unit of the timeout argument\n   * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n   *     the call timed out or was interrupted\n   * @since 17.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static boolean shutdownAndAwaitTermination(\n      ExecutorService service, long timeout, TimeUnit unit) {\n    checkNotNull(unit);\n    // Disable new tasks from being submitted\n    service.shutdown();\n    try {\n      long halfTimeoutNanos = TimeUnit.NANOSECONDS.convert(timeout, unit) / 2;\n      // Wait for half the duration of the timeout for existing tasks to terminate\n      if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {\n        // Cancel currently executing tasks\n        service.shutdownNow();\n        // Wait the other half of the timeout for tasks to respond to being cancelled\n        service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);\n      }\n    } catch (InterruptedException ie) {\n      // Preserve interrupt status\n      Thread.currentThread().interrupt();\n      // (Re-)Cancel if current thread also interrupted\n      service.shutdownNow();\n    }\n    return service.isTerminated();\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53077476,"label":true,"oracleId":1441,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"MoreExecutors","javadocTag":"@param timeout the maximum time to wait for the {@code ExecutorService} to terminate","methodJavadoc":"    /**\n   * Shuts down the given executor gradually, first disabling new submissions and later cancelling\n   * existing tasks.\n   *\n   * <p>The method takes the following steps:\n   * <ol>\n   *  <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n   *  <li>waits for half of the specified timeout.\n   *  <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n   *  pending tasks and interrupting running tasks.\n   *  <li>waits for the other half of the specified timeout.\n   * </ol>\n   *\n   * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n   * ExecutorService#shutdownNow()} and returns.\n   *\n   * @param service the {@code ExecutorService} to shut down\n   * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n   * @param unit the time unit of the timeout argument\n   * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n   *     the call timed out or was interrupted\n   * @since 17.0\n   */","methodSourceCode":"public static boolean shutdownAndAwaitTermination(ExecutorService service, long timeout, TimeUnit unit){\n    checkNotNull(unit);\n    // Disable new tasks from being submitted\n    service.shutdown();\n    try {\n        long halfTimeoutNanos = TimeUnit.NANOSECONDS.convert(timeout, unit) / 2;\n        // Wait for half the duration of the timeout for existing tasks to terminate\n        if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {\n            // Cancel currently executing tasks\n            service.shutdownNow();\n            // Wait the other half of the timeout for tasks to respond to being cancelled\n            service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);\n        }\n    } catch (InterruptedException ie) {\n        // Preserve interrupt status\n        Thread.currentThread().interrupt();\n        // (Re-)Cancel if current thread also interrupted\n        service.shutdownNow();\n    }\n    return service.isTerminated();\n}","classJavadoc":"/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */","classSourceCode":"/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Queues;\nimport com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */\n@GwtCompatible(emulated = true)\npublic final class MoreExecutors {\n  private MoreExecutors() {}\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ExecutorService getExitingExecutorService(\n      ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ScheduledThreadPoolExecutor into a\n   * ScheduledExecutorService that exits when the application is complete.  It\n   * does so by using daemon threads and adding a shutdown hook to wait for\n   * their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingScheduledExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Add a shutdown hook to wait for thread completion in the given\n   * {@link ExecutorService service}.  This is useful if the given service uses\n   * daemon threads, and we want to keep the JVM from exiting immediately on\n   * shutdown, instead giving these daemon threads a chance to terminate\n   * normally.\n   * @param service ExecutorService which uses daemon threads\n   * @param terminationTimeout how long to wait for the executor to finish\n   *        before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static void addDelayedShutdownHook(\n      ExecutorService service, long terminationTimeout, TimeUnit timeUnit) {\n    new Application()\n        .addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n    return new Application().getExitingExecutorService(executor);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into a ScheduledExecutorService that\n   * exits when the application is complete.  It does so by using daemon threads\n   * and adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor) {\n    return new Application().getExitingScheduledExecutorService(executor);\n  }\n\n  /** Represents the current application to register shutdown hooks. */\n  @GwtIncompatible(\"TODO\")\n  @VisibleForTesting\n  static class Application {\n\n    final ExecutorService getExitingExecutorService(\n        ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ExecutorService service = Executors.unconfigurableExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ScheduledExecutorService service = Executors.unconfigurableScheduledExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final void addDelayedShutdownHook(\n        final ExecutorService service, final long terminationTimeout, final TimeUnit timeUnit) {\n      checkNotNull(service);\n      checkNotNull(timeUnit);\n      addShutdownHook(MoreExecutors.newThread(\"DelayedShutdownHook-for-\" + service, new Runnable() {\n        @Override\n        public void run() {\n          try {\n            // We'd like to log progress and failures that may arise in the\n            // following code, but unfortunately the behavior of logging\n            // is undefined in shutdown hooks.\n            // This is because the logging code installs a shutdown hook of its\n            // own. See Cleaner class inside {@link LogManager}.\n            service.shutdown();\n            service.awaitTermination(terminationTimeout, timeUnit);\n          } catch (InterruptedException ignored) {\n            // We're shutting down anyway, so just ignore.\n          }\n        }\n      }));\n    }\n\n    final ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n      return getExitingExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor) {\n      return getExitingScheduledExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    @VisibleForTesting void addShutdownHook(Thread hook) {\n      Runtime.getRuntime().addShutdownHook(hook);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static void useDaemonThreadFactory(ThreadPoolExecutor executor) {\n    executor.setThreadFactory(new ThreadFactoryBuilder()\n        .setDaemon(true)\n        .setThreadFactory(executor.getThreadFactory())\n        .build());\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}.  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 10.0 (<a href=\"https://github.com/google/guava/wiki/Compatibility\"\n   *        >mostly source-compatible</a> since 3.0)\n   * @deprecated Use {@link #directExecutor()} if you only require an {@link Executor} and\n   *     {@link #newDirectExecutorService()} if you need a {@link ListeningExecutorService}. This\n   *     method will be removed in August 2016.\n   */\n  @Deprecated\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService sameThreadExecutor() {\n    return new DirectExecutorService();\n  }\n\n  // See sameThreadExecutor javadoc for behavioral notes.\n  @GwtIncompatible(\"TODO\")\n  private static final class DirectExecutorService\n      extends AbstractListeningExecutorService {\n    /**\n     * Lock used whenever accessing the state variables\n     * (runningTasks, shutdown) of the executor\n     */\n    private final Object lock = new Object();\n\n    /*\n     * Conceptually, these two variables describe the executor being in\n     * one of three states:\n     *   - Active: shutdown == false\n     *   - Shutdown: runningTasks > 0 and shutdown == true\n     *   - Terminated: runningTasks == 0 and shutdown == true\n     */\n    @GuardedBy(\"lock\") private int runningTasks = 0;\n    @GuardedBy(\"lock\") private boolean shutdown = false;\n\n    @Override\n    public void execute(Runnable command) {\n      startTask();\n      try {\n        command.run();\n      } finally {\n        endTask();\n      }\n    }\n\n    @Override\n    public boolean isShutdown() {\n      synchronized (lock) {\n        return shutdown;\n      }\n    }\n\n    @Override\n    public void shutdown() {\n      synchronized (lock) {\n        shutdown = true;\n        if (runningTasks == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n\n    // See sameThreadExecutor javadoc for unusual behavior of this method.\n    @Override\n    public List<Runnable> shutdownNow() {\n      shutdown();\n      return Collections.emptyList();\n    }\n\n    @Override\n    public boolean isTerminated() {\n      synchronized (lock) {\n        return shutdown && runningTasks == 0;\n      }\n    }\n\n    @Override\n    public boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      long nanos = unit.toNanos(timeout);\n      synchronized (lock) {\n        for (;;) {\n          if (shutdown && runningTasks == 0) {\n            return true;\n          } else if (nanos <= 0) {\n            return false;\n          } else {\n            long now = System.nanoTime();\n            TimeUnit.NANOSECONDS.timedWait(lock, nanos);\n            nanos -= System.nanoTime() - now;  // subtract the actual time we waited\n          }\n        }\n      }\n    }\n\n    /**\n     * Checks if the executor has been shut down and increments the running\n     * task count.\n     *\n     * @throws RejectedExecutionException if the executor has been previously\n     *         shutdown\n     */\n    private void startTask() {\n      synchronized (lock) {\n        if (shutdown) {\n          throw new RejectedExecutionException(\"Executor already shutdown\");\n        }\n        runningTasks++;\n      }\n    }\n\n    /**\n     * Decrements the running task count.\n     */\n    private void endTask() {\n      synchronized (lock) {\n        int numRunning = --runningTasks;\n        if (numRunning == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 18.0 (present as MoreExecutors.sameThreadExecutor() since 10.0)\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService newDirectExecutorService() {\n    return new DirectExecutorService();\n  }\n\n  /**\n   * Returns an {@link Executor} that runs each task in the thread that invokes\n   * {@link Executor#execute execute}, as in {@link CallerRunsPolicy}.\n   *\n   * <p>This instance is equivalent to: <pre>   {@code\n   *   final class DirectExecutor implements Executor {\n   *     public void execute(Runnable r) {\n   *       r.run();\n   *     }\n   *   }}</pre>\n   *\n   * <p>This should be preferred to {@link #newDirectExecutorService()} because the implementing the\n   * {@link ExecutorService} subinterface necessitates significant performance overhead.\n   *\n   * @since 18.0\n   */\n  public static Executor directExecutor() {\n    return DirectExecutor.INSTANCE;\n  }\n\n  /** See {@link #directExecutor} for behavioral notes. */\n  private enum DirectExecutor implements Executor {\n    INSTANCE;\n    @Override public void execute(Runnable command) {\n      command.run();\n    }\n\n    @Override public String toString() {\n      return \"MoreExecutors.directExecutor()\";\n    }\n  }\n\n  /**\n   * Creates an {@link ExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code ListeningExecutorService}\n   * never calls the delegate's {@code submit}, {@code invokeAll}, and {@code\n   * invokeAny} methods, so any special handling of tasks must be implemented in\n   * the delegate's {@code execute} method or by wrapping the returned {@code\n   * ListeningExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningExecutorService}, it is returned untouched, and the rest of this\n   * documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService listeningDecorator(\n      ExecutorService delegate) {\n    return (delegate instanceof ListeningExecutorService)\n        ? (ListeningExecutorService) delegate\n        : (delegate instanceof ScheduledExecutorService)\n        ? new ScheduledListeningDecorator((ScheduledExecutorService) delegate)\n        : new ListeningDecorator(delegate);\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code\n   * ListeningScheduledExecutorService} never calls the delegate's {@code\n   * submit}, {@code invokeAll}, and {@code invokeAny} methods, so any special\n   * handling of tasks must be implemented in the delegate's {@code execute}\n   * method or by wrapping the returned {@code\n   * ListeningScheduledExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningScheduledExecutorService}, it is returned untouched, and the rest\n   * of this documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningScheduledExecutorService listeningDecorator(\n      ScheduledExecutorService delegate) {\n    return (delegate instanceof ListeningScheduledExecutorService)\n        ? (ListeningScheduledExecutorService) delegate\n        : new ScheduledListeningDecorator(delegate);\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static class ListeningDecorator\n      extends AbstractListeningExecutorService {\n    private final ExecutorService delegate;\n\n    ListeningDecorator(ExecutorService delegate) {\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public final boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      return delegate.awaitTermination(timeout, unit);\n    }\n\n    @Override\n    public final boolean isShutdown() {\n      return delegate.isShutdown();\n    }\n\n    @Override\n    public final boolean isTerminated() {\n      return delegate.isTerminated();\n    }\n\n    @Override\n    public final void shutdown() {\n      delegate.shutdown();\n    }\n\n    @Override\n    public final List<Runnable> shutdownNow() {\n      return delegate.shutdownNow();\n    }\n\n    @Override\n    public final void execute(Runnable command) {\n      delegate.execute(command);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static final class ScheduledListeningDecorator\n      extends ListeningDecorator implements ListeningScheduledExecutorService {\n    @SuppressWarnings(\"hiding\")\n    final ScheduledExecutorService delegate;\n\n    ScheduledListeningDecorator(ScheduledExecutorService delegate) {\n      super(delegate);\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> schedule(\n        Runnable command, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<Void> task =\n          TrustedListenableFutureTask.create(command, null);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public <V> ListenableScheduledFuture<V> schedule(\n        Callable<V> callable, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<V>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleAtFixedRate(\n        Runnable command, long initialDelay, long period, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleAtFixedRate(task, initialDelay, period, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleWithFixedDelay(\n        Runnable command, long initialDelay, long delay, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleWithFixedDelay(task, initialDelay, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    private static final class ListenableScheduledTask<V>\n        extends SimpleForwardingListenableFuture<V>\n        implements ListenableScheduledFuture<V> {\n\n      private final ScheduledFuture<?> scheduledDelegate;\n\n      public ListenableScheduledTask(\n          ListenableFuture<V> listenableDelegate,\n          ScheduledFuture<?> scheduledDelegate) {\n        super(listenableDelegate);\n        this.scheduledDelegate = scheduledDelegate;\n      }\n\n      @Override\n      public boolean cancel(boolean mayInterruptIfRunning) {\n        boolean cancelled = super.cancel(mayInterruptIfRunning);\n        if (cancelled) {\n          // Unless it is cancelled, the delegate may continue being scheduled\n          scheduledDelegate.cancel(mayInterruptIfRunning);\n\n          // TODO(user): Cancel \"this\" if \"scheduledDelegate\" is cancelled.\n        }\n        return cancelled;\n      }\n\n      @Override\n      public long getDelay(TimeUnit unit) {\n        return scheduledDelegate.getDelay(unit);\n      }\n\n      @Override\n      public int compareTo(Delayed other) {\n        return scheduledDelegate.compareTo(other);\n      }\n    }\n\n    @GwtIncompatible(\"TODO\")\n    private static final class NeverSuccessfulListenableFutureTask\n        extends AbstractFuture<Void>\n        implements Runnable {\n      private final Runnable delegate;\n\n      public NeverSuccessfulListenableFutureTask(Runnable delegate) {\n        this.delegate = checkNotNull(delegate);\n      }\n\n      @Override public void run() {\n        try {\n          delegate.run();\n        } catch (Throwable t) {\n          setException(t);\n          throw Throwables.propagate(t);\n        }\n      }\n    }\n  }\n\n  /*\n   * This following method is a modified version of one found in\n   * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/AbstractExecutorServiceTest.java?revision=1.30\n   * which contained the following notice:\n   *\n   * Written by Doug Lea with assistance from members of JCP JSR-166\n   * Expert Group and released to the public domain, as explained at\n   * http://creativecommons.org/publicdomain/zero/1.0/\n   * Other contributors include Andrew Wright, Jeffrey Hayes,\n   * Pat Fisher, Mike Judd.\n   */\n\n  /**\n   * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}\n   * implementations.\n   */ static <T> T invokeAnyImpl(ListeningExecutorService executorService,\n      Collection<? extends Callable<T>> tasks, boolean timed, long nanos)\n          throws InterruptedException, ExecutionException, TimeoutException {\n    checkNotNull(executorService);\n    int ntasks = tasks.size();\n    checkArgument(ntasks > 0);\n    List<Future<T>> futures = Lists.newArrayListWithCapacity(ntasks);\n    BlockingQueue<Future<T>> futureQueue = Queues.newLinkedBlockingQueue();\n\n    // For efficiency, especially in executors with limited\n    // parallelism, check to see if previously submitted tasks are\n    // done before submitting more of them. This interleaving\n    // plus the exception mechanics account for messiness of main\n    // loop.\n\n    try {\n      // Record exceptions so that if we fail to obtain any\n      // result, we can throw the last exception we got.\n      ExecutionException ee = null;\n      long lastTime = timed ? System.nanoTime() : 0;\n      Iterator<? extends Callable<T>> it = tasks.iterator();\n\n      futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n      --ntasks;\n      int active = 1;\n\n      for (;;) {\n        Future<T> f = futureQueue.poll();\n        if (f == null) {\n          if (ntasks > 0) {\n            --ntasks;\n            futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n            ++active;\n          } else if (active == 0) {\n            break;\n          } else if (timed) {\n            f = futureQueue.poll(nanos, TimeUnit.NANOSECONDS);\n            if (f == null) {\n              throw new TimeoutException();\n            }\n            long now = System.nanoTime();\n            nanos -= now - lastTime;\n            lastTime = now;\n          } else {\n            f = futureQueue.take();\n          }\n        }\n        if (f != null) {\n          --active;\n          try {\n            return f.get();\n          } catch (ExecutionException eex) {\n            ee = eex;\n          } catch (RuntimeException rex) {\n            ee = new ExecutionException(rex);\n          }\n        }\n      }\n\n      if (ee == null) {\n        ee = new ExecutionException(null);\n      }\n      throw ee;\n    } finally {\n      for (Future<T> f : futures) {\n        f.cancel(true);\n      }\n    }\n  }\n\n  /**\n   * Submits the task and adds a listener that adds the future to {@code queue} when it completes.\n   */\n  @GwtIncompatible(\"TODO\")\n  private static <T> ListenableFuture<T> submitAndAddQueueListener(\n      ListeningExecutorService executorService, Callable<T> task,\n      final BlockingQueue<Future<T>> queue) {\n    final ListenableFuture<T> future = executorService.submit(task);\n    future.addListener(new Runnable() {\n      @Override public void run() {\n        queue.add(future);\n      }\n    }, directExecutor());\n    return future;\n  }\n\n  /**\n   * Returns a default thread factory used to create new threads.\n   *\n   * <p>On AppEngine, returns {@code ThreadManager.currentRequestThreadFactory()}.\n   * Otherwise, returns {@link Executors#defaultThreadFactory()}.\n   *\n   * @since 14.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ThreadFactory platformThreadFactory() {\n    if (!isAppEngine()) {\n      return Executors.defaultThreadFactory();\n    }\n    try {\n      return (ThreadFactory) Class.forName(\"com.google.appengine.api.ThreadManager\")\n          .getMethod(\"currentRequestThreadFactory\")\n          .invoke(null);\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (ClassNotFoundException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (NoSuchMethodException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (InvocationTargetException e) {\n      throw Throwables.propagate(e.getCause());\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static boolean isAppEngine() {\n    if (System.getProperty(\"com.google.appengine.runtime.environment\") == null) {\n      return false;\n    }\n    try {\n      // If the current environment is null, we're not inside AppEngine.\n      return Class.forName(\"com.google.apphosting.api.ApiProxy\")\n          .getMethod(\"getCurrentEnvironment\")\n          .invoke(null) != null;\n    } catch (ClassNotFoundException e) {\n      // If ApiProxy doesn't exist, we're not on AppEngine at all.\n      return false;\n    } catch (InvocationTargetException e) {\n      // If ApiProxy throws an exception, we're not in a proper AppEngine environment.\n      return false;\n    } catch (IllegalAccessException e) {\n      // If the method isn't accessible, we're not on a supported version of AppEngine;\n      return false;\n    } catch (NoSuchMethodException e) {\n      // If the method doesn't exist, we're not on a supported version of AppEngine;\n      return false;\n    }\n  }\n\n  /**\n   * Creates a thread using {@link #platformThreadFactory}, and sets its name to {@code name}\n   * unless changing the name is forbidden by the security manager.\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Thread newThread(String name, Runnable runnable) {\n    checkNotNull(name);\n    checkNotNull(runnable);\n    Thread result = platformThreadFactory().newThread(runnable);\n    try {\n      result.setName(name);\n    } catch (SecurityException e) {\n      // OK if we can't set the name in this environment.\n    }\n    return result;\n  }\n\n  // TODO(lukes): provide overloads for ListeningExecutorService? ListeningScheduledExecutorService?\n  // TODO(lukes): provide overloads that take constant strings? Function<Runnable, String>s to\n  // calculate names?\n\n  /**\n   * Creates an {@link Executor} that renames the {@link Thread threads} that its tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param executor The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier) {\n    checkNotNull(executor);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try\n      return executor;\n    }\n    return new Executor() {\n      @Override public void execute(Runnable command) {\n        executor.execute(Callables.threadRenaming(command, nameSupplier));\n      }\n    };\n  }\n\n  /**\n   * Creates an {@link ExecutorService} that renames the {@link Thread threads} that its tasks run\n   * in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ExecutorService renamingDecorator(final ExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} that renames the {@link Thread threads} that its\n   * tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ScheduledExecutorService renamingDecorator(final ScheduledExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingScheduledExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Shuts down the given executor gradually, first disabling new submissions and later cancelling\n   * existing tasks.\n   *\n   * <p>The method takes the following steps:\n   * <ol>\n   *  <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n   *  <li>waits for half of the specified timeout.\n   *  <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n   *  pending tasks and interrupting running tasks.\n   *  <li>waits for the other half of the specified timeout.\n   * </ol>\n   *\n   * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n   * ExecutorService#shutdownNow()} and returns.\n   *\n   * @param service the {@code ExecutorService} to shut down\n   * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n   * @param unit the time unit of the timeout argument\n   * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n   *     the call timed out or was interrupted\n   * @since 17.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static boolean shutdownAndAwaitTermination(\n      ExecutorService service, long timeout, TimeUnit unit) {\n    checkNotNull(unit);\n    // Disable new tasks from being submitted\n    service.shutdown();\n    try {\n      long halfTimeoutNanos = TimeUnit.NANOSECONDS.convert(timeout, unit) / 2;\n      // Wait for half the duration of the timeout for existing tasks to terminate\n      if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {\n        // Cancel currently executing tasks\n        service.shutdownNow();\n        // Wait the other half of the timeout for tasks to respond to being cancelled\n        service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);\n      }\n    } catch (InterruptedException ie) {\n      // Preserve interrupt status\n      Thread.currentThread().interrupt();\n      // (Re-)Cancel if current thread also interrupted\n      service.shutdownNow();\n    }\n    return service.isTerminated();\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53077935,"label":true,"oracleId":1442,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"MoreExecutors","javadocTag":"@param unit the time unit of the timeout argument","methodJavadoc":"    /**\n   * Shuts down the given executor gradually, first disabling new submissions and later cancelling\n   * existing tasks.\n   *\n   * <p>The method takes the following steps:\n   * <ol>\n   *  <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n   *  <li>waits for half of the specified timeout.\n   *  <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n   *  pending tasks and interrupting running tasks.\n   *  <li>waits for the other half of the specified timeout.\n   * </ol>\n   *\n   * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n   * ExecutorService#shutdownNow()} and returns.\n   *\n   * @param service the {@code ExecutorService} to shut down\n   * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n   * @param unit the time unit of the timeout argument\n   * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n   *     the call timed out or was interrupted\n   * @since 17.0\n   */","methodSourceCode":"public static boolean shutdownAndAwaitTermination(ExecutorService service, long timeout, TimeUnit unit){\n    checkNotNull(unit);\n    // Disable new tasks from being submitted\n    service.shutdown();\n    try {\n        long halfTimeoutNanos = TimeUnit.NANOSECONDS.convert(timeout, unit) / 2;\n        // Wait for half the duration of the timeout for existing tasks to terminate\n        if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {\n            // Cancel currently executing tasks\n            service.shutdownNow();\n            // Wait the other half of the timeout for tasks to respond to being cancelled\n            service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);\n        }\n    } catch (InterruptedException ie) {\n        // Preserve interrupt status\n        Thread.currentThread().interrupt();\n        // (Re-)Cancel if current thread also interrupted\n        service.shutdownNow();\n    }\n    return service.isTerminated();\n}","classJavadoc":"/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */","classSourceCode":"/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Queues;\nimport com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */\n@GwtCompatible(emulated = true)\npublic final class MoreExecutors {\n  private MoreExecutors() {}\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ExecutorService getExitingExecutorService(\n      ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ScheduledThreadPoolExecutor into a\n   * ScheduledExecutorService that exits when the application is complete.  It\n   * does so by using daemon threads and adding a shutdown hook to wait for\n   * their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingScheduledExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Add a shutdown hook to wait for thread completion in the given\n   * {@link ExecutorService service}.  This is useful if the given service uses\n   * daemon threads, and we want to keep the JVM from exiting immediately on\n   * shutdown, instead giving these daemon threads a chance to terminate\n   * normally.\n   * @param service ExecutorService which uses daemon threads\n   * @param terminationTimeout how long to wait for the executor to finish\n   *        before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static void addDelayedShutdownHook(\n      ExecutorService service, long terminationTimeout, TimeUnit timeUnit) {\n    new Application()\n        .addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n    return new Application().getExitingExecutorService(executor);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into a ScheduledExecutorService that\n   * exits when the application is complete.  It does so by using daemon threads\n   * and adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor) {\n    return new Application().getExitingScheduledExecutorService(executor);\n  }\n\n  /** Represents the current application to register shutdown hooks. */\n  @GwtIncompatible(\"TODO\")\n  @VisibleForTesting\n  static class Application {\n\n    final ExecutorService getExitingExecutorService(\n        ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ExecutorService service = Executors.unconfigurableExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ScheduledExecutorService service = Executors.unconfigurableScheduledExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final void addDelayedShutdownHook(\n        final ExecutorService service, final long terminationTimeout, final TimeUnit timeUnit) {\n      checkNotNull(service);\n      checkNotNull(timeUnit);\n      addShutdownHook(MoreExecutors.newThread(\"DelayedShutdownHook-for-\" + service, new Runnable() {\n        @Override\n        public void run() {\n          try {\n            // We'd like to log progress and failures that may arise in the\n            // following code, but unfortunately the behavior of logging\n            // is undefined in shutdown hooks.\n            // This is because the logging code installs a shutdown hook of its\n            // own. See Cleaner class inside {@link LogManager}.\n            service.shutdown();\n            service.awaitTermination(terminationTimeout, timeUnit);\n          } catch (InterruptedException ignored) {\n            // We're shutting down anyway, so just ignore.\n          }\n        }\n      }));\n    }\n\n    final ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n      return getExitingExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor) {\n      return getExitingScheduledExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    @VisibleForTesting void addShutdownHook(Thread hook) {\n      Runtime.getRuntime().addShutdownHook(hook);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static void useDaemonThreadFactory(ThreadPoolExecutor executor) {\n    executor.setThreadFactory(new ThreadFactoryBuilder()\n        .setDaemon(true)\n        .setThreadFactory(executor.getThreadFactory())\n        .build());\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}.  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 10.0 (<a href=\"https://github.com/google/guava/wiki/Compatibility\"\n   *        >mostly source-compatible</a> since 3.0)\n   * @deprecated Use {@link #directExecutor()} if you only require an {@link Executor} and\n   *     {@link #newDirectExecutorService()} if you need a {@link ListeningExecutorService}. This\n   *     method will be removed in August 2016.\n   */\n  @Deprecated\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService sameThreadExecutor() {\n    return new DirectExecutorService();\n  }\n\n  // See sameThreadExecutor javadoc for behavioral notes.\n  @GwtIncompatible(\"TODO\")\n  private static final class DirectExecutorService\n      extends AbstractListeningExecutorService {\n    /**\n     * Lock used whenever accessing the state variables\n     * (runningTasks, shutdown) of the executor\n     */\n    private final Object lock = new Object();\n\n    /*\n     * Conceptually, these two variables describe the executor being in\n     * one of three states:\n     *   - Active: shutdown == false\n     *   - Shutdown: runningTasks > 0 and shutdown == true\n     *   - Terminated: runningTasks == 0 and shutdown == true\n     */\n    @GuardedBy(\"lock\") private int runningTasks = 0;\n    @GuardedBy(\"lock\") private boolean shutdown = false;\n\n    @Override\n    public void execute(Runnable command) {\n      startTask();\n      try {\n        command.run();\n      } finally {\n        endTask();\n      }\n    }\n\n    @Override\n    public boolean isShutdown() {\n      synchronized (lock) {\n        return shutdown;\n      }\n    }\n\n    @Override\n    public void shutdown() {\n      synchronized (lock) {\n        shutdown = true;\n        if (runningTasks == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n\n    // See sameThreadExecutor javadoc for unusual behavior of this method.\n    @Override\n    public List<Runnable> shutdownNow() {\n      shutdown();\n      return Collections.emptyList();\n    }\n\n    @Override\n    public boolean isTerminated() {\n      synchronized (lock) {\n        return shutdown && runningTasks == 0;\n      }\n    }\n\n    @Override\n    public boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      long nanos = unit.toNanos(timeout);\n      synchronized (lock) {\n        for (;;) {\n          if (shutdown && runningTasks == 0) {\n            return true;\n          } else if (nanos <= 0) {\n            return false;\n          } else {\n            long now = System.nanoTime();\n            TimeUnit.NANOSECONDS.timedWait(lock, nanos);\n            nanos -= System.nanoTime() - now;  // subtract the actual time we waited\n          }\n        }\n      }\n    }\n\n    /**\n     * Checks if the executor has been shut down and increments the running\n     * task count.\n     *\n     * @throws RejectedExecutionException if the executor has been previously\n     *         shutdown\n     */\n    private void startTask() {\n      synchronized (lock) {\n        if (shutdown) {\n          throw new RejectedExecutionException(\"Executor already shutdown\");\n        }\n        runningTasks++;\n      }\n    }\n\n    /**\n     * Decrements the running task count.\n     */\n    private void endTask() {\n      synchronized (lock) {\n        int numRunning = --runningTasks;\n        if (numRunning == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 18.0 (present as MoreExecutors.sameThreadExecutor() since 10.0)\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService newDirectExecutorService() {\n    return new DirectExecutorService();\n  }\n\n  /**\n   * Returns an {@link Executor} that runs each task in the thread that invokes\n   * {@link Executor#execute execute}, as in {@link CallerRunsPolicy}.\n   *\n   * <p>This instance is equivalent to: <pre>   {@code\n   *   final class DirectExecutor implements Executor {\n   *     public void execute(Runnable r) {\n   *       r.run();\n   *     }\n   *   }}</pre>\n   *\n   * <p>This should be preferred to {@link #newDirectExecutorService()} because the implementing the\n   * {@link ExecutorService} subinterface necessitates significant performance overhead.\n   *\n   * @since 18.0\n   */\n  public static Executor directExecutor() {\n    return DirectExecutor.INSTANCE;\n  }\n\n  /** See {@link #directExecutor} for behavioral notes. */\n  private enum DirectExecutor implements Executor {\n    INSTANCE;\n    @Override public void execute(Runnable command) {\n      command.run();\n    }\n\n    @Override public String toString() {\n      return \"MoreExecutors.directExecutor()\";\n    }\n  }\n\n  /**\n   * Creates an {@link ExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code ListeningExecutorService}\n   * never calls the delegate's {@code submit}, {@code invokeAll}, and {@code\n   * invokeAny} methods, so any special handling of tasks must be implemented in\n   * the delegate's {@code execute} method or by wrapping the returned {@code\n   * ListeningExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningExecutorService}, it is returned untouched, and the rest of this\n   * documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService listeningDecorator(\n      ExecutorService delegate) {\n    return (delegate instanceof ListeningExecutorService)\n        ? (ListeningExecutorService) delegate\n        : (delegate instanceof ScheduledExecutorService)\n        ? new ScheduledListeningDecorator((ScheduledExecutorService) delegate)\n        : new ListeningDecorator(delegate);\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code\n   * ListeningScheduledExecutorService} never calls the delegate's {@code\n   * submit}, {@code invokeAll}, and {@code invokeAny} methods, so any special\n   * handling of tasks must be implemented in the delegate's {@code execute}\n   * method or by wrapping the returned {@code\n   * ListeningScheduledExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningScheduledExecutorService}, it is returned untouched, and the rest\n   * of this documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningScheduledExecutorService listeningDecorator(\n      ScheduledExecutorService delegate) {\n    return (delegate instanceof ListeningScheduledExecutorService)\n        ? (ListeningScheduledExecutorService) delegate\n        : new ScheduledListeningDecorator(delegate);\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static class ListeningDecorator\n      extends AbstractListeningExecutorService {\n    private final ExecutorService delegate;\n\n    ListeningDecorator(ExecutorService delegate) {\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public final boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      return delegate.awaitTermination(timeout, unit);\n    }\n\n    @Override\n    public final boolean isShutdown() {\n      return delegate.isShutdown();\n    }\n\n    @Override\n    public final boolean isTerminated() {\n      return delegate.isTerminated();\n    }\n\n    @Override\n    public final void shutdown() {\n      delegate.shutdown();\n    }\n\n    @Override\n    public final List<Runnable> shutdownNow() {\n      return delegate.shutdownNow();\n    }\n\n    @Override\n    public final void execute(Runnable command) {\n      delegate.execute(command);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static final class ScheduledListeningDecorator\n      extends ListeningDecorator implements ListeningScheduledExecutorService {\n    @SuppressWarnings(\"hiding\")\n    final ScheduledExecutorService delegate;\n\n    ScheduledListeningDecorator(ScheduledExecutorService delegate) {\n      super(delegate);\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> schedule(\n        Runnable command, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<Void> task =\n          TrustedListenableFutureTask.create(command, null);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public <V> ListenableScheduledFuture<V> schedule(\n        Callable<V> callable, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<V>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleAtFixedRate(\n        Runnable command, long initialDelay, long period, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleAtFixedRate(task, initialDelay, period, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleWithFixedDelay(\n        Runnable command, long initialDelay, long delay, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleWithFixedDelay(task, initialDelay, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    private static final class ListenableScheduledTask<V>\n        extends SimpleForwardingListenableFuture<V>\n        implements ListenableScheduledFuture<V> {\n\n      private final ScheduledFuture<?> scheduledDelegate;\n\n      public ListenableScheduledTask(\n          ListenableFuture<V> listenableDelegate,\n          ScheduledFuture<?> scheduledDelegate) {\n        super(listenableDelegate);\n        this.scheduledDelegate = scheduledDelegate;\n      }\n\n      @Override\n      public boolean cancel(boolean mayInterruptIfRunning) {\n        boolean cancelled = super.cancel(mayInterruptIfRunning);\n        if (cancelled) {\n          // Unless it is cancelled, the delegate may continue being scheduled\n          scheduledDelegate.cancel(mayInterruptIfRunning);\n\n          // TODO(user): Cancel \"this\" if \"scheduledDelegate\" is cancelled.\n        }\n        return cancelled;\n      }\n\n      @Override\n      public long getDelay(TimeUnit unit) {\n        return scheduledDelegate.getDelay(unit);\n      }\n\n      @Override\n      public int compareTo(Delayed other) {\n        return scheduledDelegate.compareTo(other);\n      }\n    }\n\n    @GwtIncompatible(\"TODO\")\n    private static final class NeverSuccessfulListenableFutureTask\n        extends AbstractFuture<Void>\n        implements Runnable {\n      private final Runnable delegate;\n\n      public NeverSuccessfulListenableFutureTask(Runnable delegate) {\n        this.delegate = checkNotNull(delegate);\n      }\n\n      @Override public void run() {\n        try {\n          delegate.run();\n        } catch (Throwable t) {\n          setException(t);\n          throw Throwables.propagate(t);\n        }\n      }\n    }\n  }\n\n  /*\n   * This following method is a modified version of one found in\n   * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/AbstractExecutorServiceTest.java?revision=1.30\n   * which contained the following notice:\n   *\n   * Written by Doug Lea with assistance from members of JCP JSR-166\n   * Expert Group and released to the public domain, as explained at\n   * http://creativecommons.org/publicdomain/zero/1.0/\n   * Other contributors include Andrew Wright, Jeffrey Hayes,\n   * Pat Fisher, Mike Judd.\n   */\n\n  /**\n   * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}\n   * implementations.\n   */ static <T> T invokeAnyImpl(ListeningExecutorService executorService,\n      Collection<? extends Callable<T>> tasks, boolean timed, long nanos)\n          throws InterruptedException, ExecutionException, TimeoutException {\n    checkNotNull(executorService);\n    int ntasks = tasks.size();\n    checkArgument(ntasks > 0);\n    List<Future<T>> futures = Lists.newArrayListWithCapacity(ntasks);\n    BlockingQueue<Future<T>> futureQueue = Queues.newLinkedBlockingQueue();\n\n    // For efficiency, especially in executors with limited\n    // parallelism, check to see if previously submitted tasks are\n    // done before submitting more of them. This interleaving\n    // plus the exception mechanics account for messiness of main\n    // loop.\n\n    try {\n      // Record exceptions so that if we fail to obtain any\n      // result, we can throw the last exception we got.\n      ExecutionException ee = null;\n      long lastTime = timed ? System.nanoTime() : 0;\n      Iterator<? extends Callable<T>> it = tasks.iterator();\n\n      futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n      --ntasks;\n      int active = 1;\n\n      for (;;) {\n        Future<T> f = futureQueue.poll();\n        if (f == null) {\n          if (ntasks > 0) {\n            --ntasks;\n            futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n            ++active;\n          } else if (active == 0) {\n            break;\n          } else if (timed) {\n            f = futureQueue.poll(nanos, TimeUnit.NANOSECONDS);\n            if (f == null) {\n              throw new TimeoutException();\n            }\n            long now = System.nanoTime();\n            nanos -= now - lastTime;\n            lastTime = now;\n          } else {\n            f = futureQueue.take();\n          }\n        }\n        if (f != null) {\n          --active;\n          try {\n            return f.get();\n          } catch (ExecutionException eex) {\n            ee = eex;\n          } catch (RuntimeException rex) {\n            ee = new ExecutionException(rex);\n          }\n        }\n      }\n\n      if (ee == null) {\n        ee = new ExecutionException(null);\n      }\n      throw ee;\n    } finally {\n      for (Future<T> f : futures) {\n        f.cancel(true);\n      }\n    }\n  }\n\n  /**\n   * Submits the task and adds a listener that adds the future to {@code queue} when it completes.\n   */\n  @GwtIncompatible(\"TODO\")\n  private static <T> ListenableFuture<T> submitAndAddQueueListener(\n      ListeningExecutorService executorService, Callable<T> task,\n      final BlockingQueue<Future<T>> queue) {\n    final ListenableFuture<T> future = executorService.submit(task);\n    future.addListener(new Runnable() {\n      @Override public void run() {\n        queue.add(future);\n      }\n    }, directExecutor());\n    return future;\n  }\n\n  /**\n   * Returns a default thread factory used to create new threads.\n   *\n   * <p>On AppEngine, returns {@code ThreadManager.currentRequestThreadFactory()}.\n   * Otherwise, returns {@link Executors#defaultThreadFactory()}.\n   *\n   * @since 14.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ThreadFactory platformThreadFactory() {\n    if (!isAppEngine()) {\n      return Executors.defaultThreadFactory();\n    }\n    try {\n      return (ThreadFactory) Class.forName(\"com.google.appengine.api.ThreadManager\")\n          .getMethod(\"currentRequestThreadFactory\")\n          .invoke(null);\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (ClassNotFoundException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (NoSuchMethodException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (InvocationTargetException e) {\n      throw Throwables.propagate(e.getCause());\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static boolean isAppEngine() {\n    if (System.getProperty(\"com.google.appengine.runtime.environment\") == null) {\n      return false;\n    }\n    try {\n      // If the current environment is null, we're not inside AppEngine.\n      return Class.forName(\"com.google.apphosting.api.ApiProxy\")\n          .getMethod(\"getCurrentEnvironment\")\n          .invoke(null) != null;\n    } catch (ClassNotFoundException e) {\n      // If ApiProxy doesn't exist, we're not on AppEngine at all.\n      return false;\n    } catch (InvocationTargetException e) {\n      // If ApiProxy throws an exception, we're not in a proper AppEngine environment.\n      return false;\n    } catch (IllegalAccessException e) {\n      // If the method isn't accessible, we're not on a supported version of AppEngine;\n      return false;\n    } catch (NoSuchMethodException e) {\n      // If the method doesn't exist, we're not on a supported version of AppEngine;\n      return false;\n    }\n  }\n\n  /**\n   * Creates a thread using {@link #platformThreadFactory}, and sets its name to {@code name}\n   * unless changing the name is forbidden by the security manager.\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Thread newThread(String name, Runnable runnable) {\n    checkNotNull(name);\n    checkNotNull(runnable);\n    Thread result = platformThreadFactory().newThread(runnable);\n    try {\n      result.setName(name);\n    } catch (SecurityException e) {\n      // OK if we can't set the name in this environment.\n    }\n    return result;\n  }\n\n  // TODO(lukes): provide overloads for ListeningExecutorService? ListeningScheduledExecutorService?\n  // TODO(lukes): provide overloads that take constant strings? Function<Runnable, String>s to\n  // calculate names?\n\n  /**\n   * Creates an {@link Executor} that renames the {@link Thread threads} that its tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param executor The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier) {\n    checkNotNull(executor);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try\n      return executor;\n    }\n    return new Executor() {\n      @Override public void execute(Runnable command) {\n        executor.execute(Callables.threadRenaming(command, nameSupplier));\n      }\n    };\n  }\n\n  /**\n   * Creates an {@link ExecutorService} that renames the {@link Thread threads} that its tasks run\n   * in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ExecutorService renamingDecorator(final ExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} that renames the {@link Thread threads} that its\n   * tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ScheduledExecutorService renamingDecorator(final ScheduledExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingScheduledExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Shuts down the given executor gradually, first disabling new submissions and later cancelling\n   * existing tasks.\n   *\n   * <p>The method takes the following steps:\n   * <ol>\n   *  <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n   *  <li>waits for half of the specified timeout.\n   *  <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n   *  pending tasks and interrupting running tasks.\n   *  <li>waits for the other half of the specified timeout.\n   * </ol>\n   *\n   * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n   * ExecutorService#shutdownNow()} and returns.\n   *\n   * @param service the {@code ExecutorService} to shut down\n   * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n   * @param unit the time unit of the timeout argument\n   * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n   *     the call timed out or was interrupted\n   * @since 17.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static boolean shutdownAndAwaitTermination(\n      ExecutorService service, long timeout, TimeUnit unit) {\n    checkNotNull(unit);\n    // Disable new tasks from being submitted\n    service.shutdown();\n    try {\n      long halfTimeoutNanos = TimeUnit.NANOSECONDS.convert(timeout, unit) / 2;\n      // Wait for half the duration of the timeout for existing tasks to terminate\n      if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {\n        // Cancel currently executing tasks\n        service.shutdownNow();\n        // Wait the other half of the timeout for tasks to respond to being cancelled\n        service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);\n      }\n    } catch (InterruptedException ie) {\n      // Preserve interrupt status\n      Thread.currentThread().interrupt();\n      // (Re-)Cancel if current thread also interrupted\n      service.shutdownNow();\n    }\n    return service.isTerminated();\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53078395,"label":true,"oracleId":1443,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"MoreExecutors","javadocTag":"@return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n    the call timed out or was interrupted","methodJavadoc":"    /**\n   * Shuts down the given executor gradually, first disabling new submissions and later cancelling\n   * existing tasks.\n   *\n   * <p>The method takes the following steps:\n   * <ol>\n   *  <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n   *  <li>waits for half of the specified timeout.\n   *  <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n   *  pending tasks and interrupting running tasks.\n   *  <li>waits for the other half of the specified timeout.\n   * </ol>\n   *\n   * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n   * ExecutorService#shutdownNow()} and returns.\n   *\n   * @param service the {@code ExecutorService} to shut down\n   * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n   * @param unit the time unit of the timeout argument\n   * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n   *     the call timed out or was interrupted\n   * @since 17.0\n   */","methodSourceCode":"public static boolean shutdownAndAwaitTermination(ExecutorService service, long timeout, TimeUnit unit){\n    checkNotNull(unit);\n    // Disable new tasks from being submitted\n    service.shutdown();\n    try {\n        long halfTimeoutNanos = TimeUnit.NANOSECONDS.convert(timeout, unit) / 2;\n        // Wait for half the duration of the timeout for existing tasks to terminate\n        if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {\n            // Cancel currently executing tasks\n            service.shutdownNow();\n            // Wait the other half of the timeout for tasks to respond to being cancelled\n            service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);\n        }\n    } catch (InterruptedException ie) {\n        // Preserve interrupt status\n        Thread.currentThread().interrupt();\n        // (Re-)Cancel if current thread also interrupted\n        service.shutdownNow();\n    }\n    return service.isTerminated();\n}","classJavadoc":"/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */","classSourceCode":"/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Queues;\nimport com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n * ExecutorService}, and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */\n@GwtCompatible(emulated = true)\npublic final class MoreExecutors {\n  private MoreExecutors() {}\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ExecutorService getExitingExecutorService(\n      ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ScheduledThreadPoolExecutor into a\n   * ScheduledExecutorService that exits when the application is complete.  It\n   * does so by using daemon threads and adding a shutdown hook to wait for\n   * their completion.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @param terminationTimeout how long to wait for the executor to\n   *        finish before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n    return new Application()\n        .getExitingScheduledExecutorService(executor, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Add a shutdown hook to wait for thread completion in the given\n   * {@link ExecutorService service}.  This is useful if the given service uses\n   * daemon threads, and we want to keep the JVM from exiting immediately on\n   * shutdown, instead giving these daemon threads a chance to terminate\n   * normally.\n   * @param service ExecutorService which uses daemon threads\n   * @param terminationTimeout how long to wait for the executor to finish\n   *        before terminating the JVM\n   * @param timeUnit unit of time for the time parameter\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static void addDelayedShutdownHook(\n      ExecutorService service, long terminationTimeout, TimeUnit timeUnit) {\n    new Application()\n        .addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into an ExecutorService that exits\n   * when the application is complete.  It does so by using daemon threads and\n   * adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newFixedThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n    return new Application().getExitingExecutorService(executor);\n  }\n\n  /**\n   * Converts the given ThreadPoolExecutor into a ScheduledExecutorService that\n   * exits when the application is complete.  It does so by using daemon threads\n   * and adding a shutdown hook to wait for their completion.\n   *\n   * <p>This method waits 120 seconds before continuing with JVM termination,\n   * even if the executor has not finished its work.\n   *\n   * <p>This is mainly for fixed thread pools.\n   * See {@link Executors#newScheduledThreadPool(int)}.\n   *\n   * @param executor the executor to modify to make sure it exits when the\n   *        application is finished\n   * @return an unmodifiable version of the input which will not hang the JVM\n   */\n  @Beta\n  @GwtIncompatible(\"TODO\")\n  public static ScheduledExecutorService getExitingScheduledExecutorService(\n      ScheduledThreadPoolExecutor executor) {\n    return new Application().getExitingScheduledExecutorService(executor);\n  }\n\n  /** Represents the current application to register shutdown hooks. */\n  @GwtIncompatible(\"TODO\")\n  @VisibleForTesting\n  static class Application {\n\n    final ExecutorService getExitingExecutorService(\n        ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ExecutorService service = Executors.unconfigurableExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {\n      useDaemonThreadFactory(executor);\n      ScheduledExecutorService service = Executors.unconfigurableScheduledExecutorService(executor);\n      addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n      return service;\n    }\n\n    final void addDelayedShutdownHook(\n        final ExecutorService service, final long terminationTimeout, final TimeUnit timeUnit) {\n      checkNotNull(service);\n      checkNotNull(timeUnit);\n      addShutdownHook(MoreExecutors.newThread(\"DelayedShutdownHook-for-\" + service, new Runnable() {\n        @Override\n        public void run() {\n          try {\n            // We'd like to log progress and failures that may arise in the\n            // following code, but unfortunately the behavior of logging\n            // is undefined in shutdown hooks.\n            // This is because the logging code installs a shutdown hook of its\n            // own. See Cleaner class inside {@link LogManager}.\n            service.shutdown();\n            service.awaitTermination(terminationTimeout, timeUnit);\n          } catch (InterruptedException ignored) {\n            // We're shutting down anyway, so just ignore.\n          }\n        }\n      }));\n    }\n\n    final ExecutorService getExitingExecutorService(ThreadPoolExecutor executor) {\n      return getExitingExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    final ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor) {\n      return getExitingScheduledExecutorService(executor, 120, TimeUnit.SECONDS);\n    }\n\n    @VisibleForTesting void addShutdownHook(Thread hook) {\n      Runtime.getRuntime().addShutdownHook(hook);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static void useDaemonThreadFactory(ThreadPoolExecutor executor) {\n    executor.setThreadFactory(new ThreadFactoryBuilder()\n        .setDaemon(true)\n        .setThreadFactory(executor.getThreadFactory())\n        .build());\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}.  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 10.0 (<a href=\"https://github.com/google/guava/wiki/Compatibility\"\n   *        >mostly source-compatible</a> since 3.0)\n   * @deprecated Use {@link #directExecutor()} if you only require an {@link Executor} and\n   *     {@link #newDirectExecutorService()} if you need a {@link ListeningExecutorService}. This\n   *     method will be removed in August 2016.\n   */\n  @Deprecated\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService sameThreadExecutor() {\n    return new DirectExecutorService();\n  }\n\n  // See sameThreadExecutor javadoc for behavioral notes.\n  @GwtIncompatible(\"TODO\")\n  private static final class DirectExecutorService\n      extends AbstractListeningExecutorService {\n    /**\n     * Lock used whenever accessing the state variables\n     * (runningTasks, shutdown) of the executor\n     */\n    private final Object lock = new Object();\n\n    /*\n     * Conceptually, these two variables describe the executor being in\n     * one of three states:\n     *   - Active: shutdown == false\n     *   - Shutdown: runningTasks > 0 and shutdown == true\n     *   - Terminated: runningTasks == 0 and shutdown == true\n     */\n    @GuardedBy(\"lock\") private int runningTasks = 0;\n    @GuardedBy(\"lock\") private boolean shutdown = false;\n\n    @Override\n    public void execute(Runnable command) {\n      startTask();\n      try {\n        command.run();\n      } finally {\n        endTask();\n      }\n    }\n\n    @Override\n    public boolean isShutdown() {\n      synchronized (lock) {\n        return shutdown;\n      }\n    }\n\n    @Override\n    public void shutdown() {\n      synchronized (lock) {\n        shutdown = true;\n        if (runningTasks == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n\n    // See sameThreadExecutor javadoc for unusual behavior of this method.\n    @Override\n    public List<Runnable> shutdownNow() {\n      shutdown();\n      return Collections.emptyList();\n    }\n\n    @Override\n    public boolean isTerminated() {\n      synchronized (lock) {\n        return shutdown && runningTasks == 0;\n      }\n    }\n\n    @Override\n    public boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      long nanos = unit.toNanos(timeout);\n      synchronized (lock) {\n        for (;;) {\n          if (shutdown && runningTasks == 0) {\n            return true;\n          } else if (nanos <= 0) {\n            return false;\n          } else {\n            long now = System.nanoTime();\n            TimeUnit.NANOSECONDS.timedWait(lock, nanos);\n            nanos -= System.nanoTime() - now;  // subtract the actual time we waited\n          }\n        }\n      }\n    }\n\n    /**\n     * Checks if the executor has been shut down and increments the running\n     * task count.\n     *\n     * @throws RejectedExecutionException if the executor has been previously\n     *         shutdown\n     */\n    private void startTask() {\n      synchronized (lock) {\n        if (shutdown) {\n          throw new RejectedExecutionException(\"Executor already shutdown\");\n        }\n        runningTasks++;\n      }\n    }\n\n    /**\n     * Decrements the running task count.\n     */\n    private void endTask() {\n      synchronized (lock) {\n        int numRunning = --runningTasks;\n        if (numRunning == 0) {\n          lock.notifyAll();\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates an executor service that runs each task in the thread\n   * that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}  This\n   * applies both to individually submitted tasks and to collections of tasks\n   * submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,\n   * tasks will run serially on the calling thread.  Tasks are run to\n   * completion before a {@code Future} is returned to the caller (unless the\n   * executor has been shutdown).\n   *\n   * <p>Although all tasks are immediately executed in the thread that\n   * submitted the task, this {@code ExecutorService} imposes a small\n   * locking overhead on each task submission in order to implement shutdown\n   * and termination behavior.\n   *\n   * <p>The implementation deviates from the {@code ExecutorService}\n   * specification with regards to the {@code shutdownNow} method.  First,\n   * \"best-effort\" with regards to canceling running tasks is implemented\n   * as \"no-effort\".  No interrupts or other attempts are made to stop\n   * threads executing tasks.  Second, the returned list will always be empty,\n   * as any submitted task is considered to have started execution.\n   * This applies also to tasks given to {@code invokeAll} or {@code invokeAny}\n   * which are pending serial execution, even the subset of the tasks that\n   * have not yet started execution.  It is unclear from the\n   * {@code ExecutorService} specification if these should be included, and\n   * it's much easier to implement the interpretation that they not be.\n   * Finally, a call to {@code shutdown} or {@code shutdownNow} may result\n   * in concurrent calls to {@code invokeAll/invokeAny} throwing\n   * RejectedExecutionException, although a subset of the tasks may already\n   * have been executed.\n   *\n   * @since 18.0 (present as MoreExecutors.sameThreadExecutor() since 10.0)\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService newDirectExecutorService() {\n    return new DirectExecutorService();\n  }\n\n  /**\n   * Returns an {@link Executor} that runs each task in the thread that invokes\n   * {@link Executor#execute execute}, as in {@link CallerRunsPolicy}.\n   *\n   * <p>This instance is equivalent to: <pre>   {@code\n   *   final class DirectExecutor implements Executor {\n   *     public void execute(Runnable r) {\n   *       r.run();\n   *     }\n   *   }}</pre>\n   *\n   * <p>This should be preferred to {@link #newDirectExecutorService()} because the implementing the\n   * {@link ExecutorService} subinterface necessitates significant performance overhead.\n   *\n   * @since 18.0\n   */\n  public static Executor directExecutor() {\n    return DirectExecutor.INSTANCE;\n  }\n\n  /** See {@link #directExecutor} for behavioral notes. */\n  private enum DirectExecutor implements Executor {\n    INSTANCE;\n    @Override public void execute(Runnable command) {\n      command.run();\n    }\n\n    @Override public String toString() {\n      return \"MoreExecutors.directExecutor()\";\n    }\n  }\n\n  /**\n   * Creates an {@link ExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code ListeningExecutorService}\n   * never calls the delegate's {@code submit}, {@code invokeAll}, and {@code\n   * invokeAny} methods, so any special handling of tasks must be implemented in\n   * the delegate's {@code execute} method or by wrapping the returned {@code\n   * ListeningExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningExecutorService}, it is returned untouched, and the rest of this\n   * documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningExecutorService listeningDecorator(\n      ExecutorService delegate) {\n    return (delegate instanceof ListeningExecutorService)\n        ? (ListeningExecutorService) delegate\n        : (delegate instanceof ScheduledExecutorService)\n        ? new ScheduledListeningDecorator((ScheduledExecutorService) delegate)\n        : new ListeningDecorator(delegate);\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} whose {@code submit} and {@code\n   * invokeAll} methods submit {@link ListenableFutureTask} instances to the\n   * given delegate executor. Those methods, as well as {@code execute} and\n   * {@code invokeAny}, are implemented in terms of calls to {@code\n   * delegate.execute}. All other methods are forwarded unchanged to the\n   * delegate. This implies that the returned {@code\n   * ListeningScheduledExecutorService} never calls the delegate's {@code\n   * submit}, {@code invokeAll}, and {@code invokeAny} methods, so any special\n   * handling of tasks must be implemented in the delegate's {@code execute}\n   * method or by wrapping the returned {@code\n   * ListeningScheduledExecutorService}.\n   *\n   * <p>If the delegate executor was already an instance of {@code\n   * ListeningScheduledExecutorService}, it is returned untouched, and the rest\n   * of this documentation does not apply.\n   *\n   * @since 10.0\n   */\n  @GwtIncompatible(\"TODO\")\n  public static ListeningScheduledExecutorService listeningDecorator(\n      ScheduledExecutorService delegate) {\n    return (delegate instanceof ListeningScheduledExecutorService)\n        ? (ListeningScheduledExecutorService) delegate\n        : new ScheduledListeningDecorator(delegate);\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static class ListeningDecorator\n      extends AbstractListeningExecutorService {\n    private final ExecutorService delegate;\n\n    ListeningDecorator(ExecutorService delegate) {\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public final boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      return delegate.awaitTermination(timeout, unit);\n    }\n\n    @Override\n    public final boolean isShutdown() {\n      return delegate.isShutdown();\n    }\n\n    @Override\n    public final boolean isTerminated() {\n      return delegate.isTerminated();\n    }\n\n    @Override\n    public final void shutdown() {\n      delegate.shutdown();\n    }\n\n    @Override\n    public final List<Runnable> shutdownNow() {\n      return delegate.shutdownNow();\n    }\n\n    @Override\n    public final void execute(Runnable command) {\n      delegate.execute(command);\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static final class ScheduledListeningDecorator\n      extends ListeningDecorator implements ListeningScheduledExecutorService {\n    @SuppressWarnings(\"hiding\")\n    final ScheduledExecutorService delegate;\n\n    ScheduledListeningDecorator(ScheduledExecutorService delegate) {\n      super(delegate);\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> schedule(\n        Runnable command, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<Void> task =\n          TrustedListenableFutureTask.create(command, null);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public <V> ListenableScheduledFuture<V> schedule(\n        Callable<V> callable, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<V>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleAtFixedRate(\n        Runnable command, long initialDelay, long period, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleAtFixedRate(task, initialDelay, period, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    @Override\n    public ListenableScheduledFuture<?> scheduleWithFixedDelay(\n        Runnable command, long initialDelay, long delay, TimeUnit unit) {\n      NeverSuccessfulListenableFutureTask task =\n          new NeverSuccessfulListenableFutureTask(command);\n      ScheduledFuture<?> scheduled =\n          delegate.scheduleWithFixedDelay(task, initialDelay, delay, unit);\n      return new ListenableScheduledTask<Void>(task, scheduled);\n    }\n\n    private static final class ListenableScheduledTask<V>\n        extends SimpleForwardingListenableFuture<V>\n        implements ListenableScheduledFuture<V> {\n\n      private final ScheduledFuture<?> scheduledDelegate;\n\n      public ListenableScheduledTask(\n          ListenableFuture<V> listenableDelegate,\n          ScheduledFuture<?> scheduledDelegate) {\n        super(listenableDelegate);\n        this.scheduledDelegate = scheduledDelegate;\n      }\n\n      @Override\n      public boolean cancel(boolean mayInterruptIfRunning) {\n        boolean cancelled = super.cancel(mayInterruptIfRunning);\n        if (cancelled) {\n          // Unless it is cancelled, the delegate may continue being scheduled\n          scheduledDelegate.cancel(mayInterruptIfRunning);\n\n          // TODO(user): Cancel \"this\" if \"scheduledDelegate\" is cancelled.\n        }\n        return cancelled;\n      }\n\n      @Override\n      public long getDelay(TimeUnit unit) {\n        return scheduledDelegate.getDelay(unit);\n      }\n\n      @Override\n      public int compareTo(Delayed other) {\n        return scheduledDelegate.compareTo(other);\n      }\n    }\n\n    @GwtIncompatible(\"TODO\")\n    private static final class NeverSuccessfulListenableFutureTask\n        extends AbstractFuture<Void>\n        implements Runnable {\n      private final Runnable delegate;\n\n      public NeverSuccessfulListenableFutureTask(Runnable delegate) {\n        this.delegate = checkNotNull(delegate);\n      }\n\n      @Override public void run() {\n        try {\n          delegate.run();\n        } catch (Throwable t) {\n          setException(t);\n          throw Throwables.propagate(t);\n        }\n      }\n    }\n  }\n\n  /*\n   * This following method is a modified version of one found in\n   * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/AbstractExecutorServiceTest.java?revision=1.30\n   * which contained the following notice:\n   *\n   * Written by Doug Lea with assistance from members of JCP JSR-166\n   * Expert Group and released to the public domain, as explained at\n   * http://creativecommons.org/publicdomain/zero/1.0/\n   * Other contributors include Andrew Wright, Jeffrey Hayes,\n   * Pat Fisher, Mike Judd.\n   */\n\n  /**\n   * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}\n   * implementations.\n   */ static <T> T invokeAnyImpl(ListeningExecutorService executorService,\n      Collection<? extends Callable<T>> tasks, boolean timed, long nanos)\n          throws InterruptedException, ExecutionException, TimeoutException {\n    checkNotNull(executorService);\n    int ntasks = tasks.size();\n    checkArgument(ntasks > 0);\n    List<Future<T>> futures = Lists.newArrayListWithCapacity(ntasks);\n    BlockingQueue<Future<T>> futureQueue = Queues.newLinkedBlockingQueue();\n\n    // For efficiency, especially in executors with limited\n    // parallelism, check to see if previously submitted tasks are\n    // done before submitting more of them. This interleaving\n    // plus the exception mechanics account for messiness of main\n    // loop.\n\n    try {\n      // Record exceptions so that if we fail to obtain any\n      // result, we can throw the last exception we got.\n      ExecutionException ee = null;\n      long lastTime = timed ? System.nanoTime() : 0;\n      Iterator<? extends Callable<T>> it = tasks.iterator();\n\n      futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n      --ntasks;\n      int active = 1;\n\n      for (;;) {\n        Future<T> f = futureQueue.poll();\n        if (f == null) {\n          if (ntasks > 0) {\n            --ntasks;\n            futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n            ++active;\n          } else if (active == 0) {\n            break;\n          } else if (timed) {\n            f = futureQueue.poll(nanos, TimeUnit.NANOSECONDS);\n            if (f == null) {\n              throw new TimeoutException();\n            }\n            long now = System.nanoTime();\n            nanos -= now - lastTime;\n            lastTime = now;\n          } else {\n            f = futureQueue.take();\n          }\n        }\n        if (f != null) {\n          --active;\n          try {\n            return f.get();\n          } catch (ExecutionException eex) {\n            ee = eex;\n          } catch (RuntimeException rex) {\n            ee = new ExecutionException(rex);\n          }\n        }\n      }\n\n      if (ee == null) {\n        ee = new ExecutionException(null);\n      }\n      throw ee;\n    } finally {\n      for (Future<T> f : futures) {\n        f.cancel(true);\n      }\n    }\n  }\n\n  /**\n   * Submits the task and adds a listener that adds the future to {@code queue} when it completes.\n   */\n  @GwtIncompatible(\"TODO\")\n  private static <T> ListenableFuture<T> submitAndAddQueueListener(\n      ListeningExecutorService executorService, Callable<T> task,\n      final BlockingQueue<Future<T>> queue) {\n    final ListenableFuture<T> future = executorService.submit(task);\n    future.addListener(new Runnable() {\n      @Override public void run() {\n        queue.add(future);\n      }\n    }, directExecutor());\n    return future;\n  }\n\n  /**\n   * Returns a default thread factory used to create new threads.\n   *\n   * <p>On AppEngine, returns {@code ThreadManager.currentRequestThreadFactory()}.\n   * Otherwise, returns {@link Executors#defaultThreadFactory()}.\n   *\n   * @since 14.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static ThreadFactory platformThreadFactory() {\n    if (!isAppEngine()) {\n      return Executors.defaultThreadFactory();\n    }\n    try {\n      return (ThreadFactory) Class.forName(\"com.google.appengine.api.ThreadManager\")\n          .getMethod(\"currentRequestThreadFactory\")\n          .invoke(null);\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (ClassNotFoundException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (NoSuchMethodException e) {\n      throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n    } catch (InvocationTargetException e) {\n      throw Throwables.propagate(e.getCause());\n    }\n  }\n\n  @GwtIncompatible(\"TODO\")\n  private static boolean isAppEngine() {\n    if (System.getProperty(\"com.google.appengine.runtime.environment\") == null) {\n      return false;\n    }\n    try {\n      // If the current environment is null, we're not inside AppEngine.\n      return Class.forName(\"com.google.apphosting.api.ApiProxy\")\n          .getMethod(\"getCurrentEnvironment\")\n          .invoke(null) != null;\n    } catch (ClassNotFoundException e) {\n      // If ApiProxy doesn't exist, we're not on AppEngine at all.\n      return false;\n    } catch (InvocationTargetException e) {\n      // If ApiProxy throws an exception, we're not in a proper AppEngine environment.\n      return false;\n    } catch (IllegalAccessException e) {\n      // If the method isn't accessible, we're not on a supported version of AppEngine;\n      return false;\n    } catch (NoSuchMethodException e) {\n      // If the method doesn't exist, we're not on a supported version of AppEngine;\n      return false;\n    }\n  }\n\n  /**\n   * Creates a thread using {@link #platformThreadFactory}, and sets its name to {@code name}\n   * unless changing the name is forbidden by the security manager.\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Thread newThread(String name, Runnable runnable) {\n    checkNotNull(name);\n    checkNotNull(runnable);\n    Thread result = platformThreadFactory().newThread(runnable);\n    try {\n      result.setName(name);\n    } catch (SecurityException e) {\n      // OK if we can't set the name in this environment.\n    }\n    return result;\n  }\n\n  // TODO(lukes): provide overloads for ListeningExecutorService? ListeningScheduledExecutorService?\n  // TODO(lukes): provide overloads that take constant strings? Function<Runnable, String>s to\n  // calculate names?\n\n  /**\n   * Creates an {@link Executor} that renames the {@link Thread threads} that its tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param executor The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier) {\n    checkNotNull(executor);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try\n      return executor;\n    }\n    return new Executor() {\n      @Override public void execute(Runnable command) {\n        executor.execute(Callables.threadRenaming(command, nameSupplier));\n      }\n    };\n  }\n\n  /**\n   * Creates an {@link ExecutorService} that renames the {@link Thread threads} that its tasks run\n   * in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ExecutorService renamingDecorator(final ExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Creates a {@link ScheduledExecutorService} that renames the {@link Thread threads} that its\n   * tasks run in.\n   *\n   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n   * right before each task is run.  The renaming is best effort, if a {@link SecurityManager}\n   * prevents the renaming then it will be skipped but the tasks will still execute.\n   *\n   *\n   * @param service The executor to decorate\n   * @param nameSupplier The source of names for each task\n   */\n  @GwtIncompatible(\"concurrency\")\n  static ScheduledExecutorService renamingDecorator(final ScheduledExecutorService service,\n      final Supplier<String> nameSupplier) {\n    checkNotNull(service);\n    checkNotNull(nameSupplier);\n    if (isAppEngine()) {\n      // AppEngine doesn't support thread renaming, so don't even try.\n      return service;\n    }\n    return new WrappingScheduledExecutorService(service) {\n      @Override protected <T> Callable<T> wrapTask(Callable<T> callable) {\n        return Callables.threadRenaming(callable, nameSupplier);\n      }\n      @Override protected Runnable wrapTask(Runnable command) {\n        return Callables.threadRenaming(command, nameSupplier);\n      }\n    };\n  }\n\n  /**\n   * Shuts down the given executor gradually, first disabling new submissions and later cancelling\n   * existing tasks.\n   *\n   * <p>The method takes the following steps:\n   * <ol>\n   *  <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n   *  <li>waits for half of the specified timeout.\n   *  <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n   *  pending tasks and interrupting running tasks.\n   *  <li>waits for the other half of the specified timeout.\n   * </ol>\n   *\n   * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n   * ExecutorService#shutdownNow()} and returns.\n   *\n   * @param service the {@code ExecutorService} to shut down\n   * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n   * @param unit the time unit of the timeout argument\n   * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n   *     the call timed out or was interrupted\n   * @since 17.0\n   */\n  @Beta\n  @GwtIncompatible(\"concurrency\")\n  public static boolean shutdownAndAwaitTermination(\n      ExecutorService service, long timeout, TimeUnit unit) {\n    checkNotNull(unit);\n    // Disable new tasks from being submitted\n    service.shutdown();\n    try {\n      long halfTimeoutNanos = TimeUnit.NANOSECONDS.convert(timeout, unit) / 2;\n      // Wait for half the duration of the timeout for existing tasks to terminate\n      if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {\n        // Cancel currently executing tasks\n        service.shutdownNow();\n        // Wait the other half of the timeout for tasks to respond to being cancelled\n        service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);\n      }\n    } catch (InterruptedException ie) {\n      // Preserve interrupt status\n      Thread.currentThread().interrupt();\n      // (Re-)Cancel if current thread also interrupted\n      service.shutdownNow();\n    }\n    return service.isTerminated();\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53078854,"label":true,"oracleId":1444,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"ServiceManager","javadocTag":"@param listener the listener to run when the manager changes state","methodJavadoc":"    /**\n   * Registers a {@link Listener} to be {@linkplain Executor#execute executed} on the given\n   * executor. The listener will not have previous state changes replayed, so it is\n   * suggested that listeners are added before any of the managed services are\n   * {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged. Any exception thrown\n   * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException}) will be caught and\n   * logged.\n   *\n   * <p> For fast, lightweight listeners that would be safe to execute in any thread, consider\n   * calling {@link #addListener(Listener)}.\n   *\n   * @param listener the listener to run when the manager changes state\n   * @param executor the executor in which the listeners callback methods will be run.\n   */","methodSourceCode":"public void addListener(Listener listener, Executor executor){\n    state.addListener(listener, executor);\n}","classJavadoc":"/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */","classSourceCode":"/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Predicates.equalTo;\nimport static com.google.common.base.Predicates.in;\nimport static com.google.common.base.Predicates.instanceOf;\nimport static com.google.common.base.Predicates.not;\nimport static com.google.common.util.concurrent.MoreExecutors.directExecutor;\nimport static com.google.common.util.concurrent.Service.State.FAILED;\nimport static com.google.common.util.concurrent.Service.State.NEW;\nimport static com.google.common.util.concurrent.Service.State.RUNNING;\nimport static com.google.common.util.concurrent.Service.State.STARTING;\nimport static com.google.common.util.concurrent.Service.State.STOPPING;\nimport static com.google.common.util.concurrent.Service.State.TERMINATED;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.base.Function;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Stopwatch;\nimport com.google.common.collect.Collections2;\nimport com.google.common.collect.ImmutableCollection;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableMultimap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSetMultimap;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.MultimapBuilder;\nimport com.google.common.collect.Multimaps;\nimport com.google.common.collect.Multiset;\nimport com.google.common.collect.Ordering;\nimport com.google.common.collect.SetMultimap;\nimport com.google.common.util.concurrent.ListenerCallQueue.Callback;\nimport com.google.common.util.concurrent.Service.State;\nimport com.google.j2objc.annotations.WeakOuter;\n\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */\n@Beta\npublic final class ServiceManager {\n  private static final Logger logger = Logger.getLogger(ServiceManager.class.getName());\n  private static final Callback<Listener> HEALTHY_CALLBACK = new Callback<Listener>(\"healthy()\") {\n    @Override void call(Listener listener) {\n      listener.healthy();\n    }\n  };\n  private static final Callback<Listener> STOPPED_CALLBACK = new Callback<Listener>(\"stopped()\") {\n    @Override void call(Listener listener) {\n      listener.stopped();\n    }\n  };\n\n  /**\n   * A listener for the aggregate state changes of the services that are under management. Users\n   * that need to listen to more fine-grained events (such as when each particular {@linkplain\n   * Service service} starts, or terminates), should attach {@linkplain Service.Listener service\n   * listeners} to each individual service.\n   *\n   * @author Luke Sandberg\n   * @since 15.0 (present as an interface in 14.0)\n   */\n  @Beta  // Should come out of Beta when ServiceManager does\n  public abstract static class Listener {\n    /**\n     * Called when the service initially becomes healthy.\n     *\n     * <p>This will be called at most once after all the services have entered the\n     * {@linkplain State#RUNNING running} state. If any services fail during start up or\n     * {@linkplain State#FAILED fail}/{@linkplain State#TERMINATED terminate} before all other\n     * services have started {@linkplain State#RUNNING running} then this method will not be called.\n     */\n    public void healthy() {}\n\n    /**\n     * Called when the all of the component services have reached a terminal state, either\n     * {@linkplain State#TERMINATED terminated} or {@linkplain State#FAILED failed}.\n     */\n    public void stopped() {}\n\n    /**\n     * Called when a component service has {@linkplain State#FAILED failed}.\n     *\n     * @param service The service that failed.\n     */\n    public void failure(Service service) {}\n  }\n\n  /**\n   * An encapsulation of all of the state that is accessed by the {@linkplain ServiceListener\n   * service listeners}.  This is extracted into its own object so that {@link ServiceListener}\n   * could be made {@code static} and its instances can be safely constructed and added in the\n   * {@link ServiceManager} constructor without having to close over the partially constructed\n   * {@link ServiceManager} instance (i.e. avoid leaking a pointer to {@code this}).\n   */\n  private final ServiceManagerState state;\n  private final ImmutableList<Service> services;\n\n  /**\n   * Constructs a new instance for managing the given services.\n   *\n   * @param services The services to manage\n   *\n   * @throws IllegalArgumentException if not all services are {@linkplain State#NEW new} or if there\n   * are any duplicate services.\n   */\n  public ServiceManager(Iterable<? extends Service> services) {\n    ImmutableList<Service> copy = ImmutableList.copyOf(services);\n    if (copy.isEmpty()) {\n      // Having no services causes the manager to behave strangely. Notably, listeners are never\n      // fired.  To avoid this we substitute a placeholder service.\n      logger.log(Level.WARNING,\n          \"ServiceManager configured with no services.  Is your application configured properly?\",\n          new EmptyServiceManagerWarning());\n      copy = ImmutableList.<Service>of(new NoOpService());\n    }\n    this.state = new ServiceManagerState(copy);\n    this.services = copy;\n    WeakReference<ServiceManagerState> stateReference =\n        new WeakReference<ServiceManagerState>(state);\n    for (Service service : copy) {\n      service.addListener(new ServiceListener(service, stateReference), directExecutor());\n      // We check the state after adding the listener as a way to ensure that our listener was added\n      // to a NEW service.\n      checkArgument(service.state() == NEW, \"Can only manage NEW services, %s\", service);\n    }\n    // We have installed all of our listeners and after this point any state transition should be\n    // correct.\n    this.state.markReady();\n  }\n\n  /**\n   * Registers a {@link Listener} to be {@linkplain Executor#execute executed} on the given\n   * executor. The listener will not have previous state changes replayed, so it is\n   * suggested that listeners are added before any of the managed services are\n   * {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged. Any exception thrown\n   * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException}) will be caught and\n   * logged.\n   *\n   * <p> For fast, lightweight listeners that would be safe to execute in any thread, consider\n   * calling {@link #addListener(Listener)}.\n   *\n   * @param listener the listener to run when the manager changes state\n   * @param executor the executor in which the listeners callback methods will be run.\n   */\n  public void addListener(Listener listener, Executor executor) {\n    state.addListener(listener, executor);\n  }\n\n  /**\n   * Registers a {@link Listener} to be run when this {@link ServiceManager} changes state. The\n   * listener will not have previous state changes replayed, so it is suggested that listeners are\n   * added before any of the managed services are {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged.\n   *\n   * @param listener the listener to run when the manager changes state\n   */\n  public void addListener(Listener listener) {\n    state.addListener(listener, directExecutor());\n  }\n\n  /**\n   * Initiates service {@linkplain Service#startAsync startup} on all the services being managed.\n   * It is only valid to call this method if all of the services are {@linkplain State#NEW new}.\n   *\n   * @return this\n   * @throws IllegalStateException if any of the Services are not {@link State#NEW new} when the\n   *     method is called.\n   */\n  public ServiceManager startAsync() {\n    for (Service service : services) {\n      State state = service.state();\n      checkState(state == NEW, \"Service %s is %s, cannot start it.\", service, state);\n    }\n    for (Service service : services) {\n      try {\n        state.tryStartTiming(service);\n        service.startAsync();\n      } catch (IllegalStateException e) {\n        // This can happen if the service has already been started or stopped (e.g. by another\n        // service or listener). Our contract says it is safe to call this method if\n        // all services were NEW when it was called, and this has already been verified above, so we\n        // don't propagate the exception.\n        logger.log(Level.WARNING, \"Unable to start Service \" + service, e);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy}.  The manager\n   * will become healthy after all the component services have reached the {@linkplain State#RUNNING\n   * running} state.\n   *\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy() {\n    state.awaitHealthy();\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy} for no more\n   * than the given time.  The manager will become healthy after all the component services have\n   * reached the {@linkplain State#RUNNING running} state.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have finished starting within the deadline\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitHealthy(timeout, unit);\n  }\n\n  /**\n   * Initiates service {@linkplain Service#stopAsync shutdown} if necessary on all the services\n   * being managed.\n   *\n   * @return this\n   */\n  public ServiceManager stopAsync() {\n    for (Service service : services) {\n      service.stopAsync();\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state. After this method returns all\n   * services will either be {@linkplain Service.State#TERMINATED terminated} or {@linkplain\n   * Service.State#FAILED failed}.\n   */\n  public void awaitStopped() {\n    state.awaitStopped();\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state for no more than the given time. After\n   * this method returns all services will either be {@linkplain Service.State#TERMINATED\n   * terminated} or {@linkplain Service.State#FAILED failed}.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have stopped within the deadline\n   */\n  public void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitStopped(timeout, unit);\n  }\n\n  /**\n   * Returns true if all services are currently in the {@linkplain State#RUNNING running} state.\n   *\n   * <p>Users who want more detailed information should use the {@link #servicesByState} method to\n   * get detailed information about which services are not running.\n   */\n  public boolean isHealthy() {\n    for (Service service : services) {\n      if (!service.isRunning()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Provides a snapshot of the current state of all the services under management.\n   *\n   * <p>N.B. This snapshot is guaranteed to be consistent, i.e. the set of states returned will\n   * correspond to a point in time view of the services.\n   */\n  public ImmutableMultimap<State, Service> servicesByState() {\n    return state.servicesByState();\n  }\n\n  /**\n   * Returns the service load times. This value will only return startup times for services that\n   * have finished starting.\n   *\n   * @return Map of services and their corresponding startup time in millis, the map entries will be\n   *     ordered by startup time.\n   */\n  public ImmutableMap<Service, Long> startupTimes() {\n    return state.startupTimes();\n  }\n\n  @Override public String toString() {\n    return MoreObjects.toStringHelper(ServiceManager.class)\n        .add(\"services\", Collections2.filter(services, not(instanceOf(NoOpService.class))))\n        .toString();\n  }\n\n  /**\n   * An encapsulation of all the mutable state of the {@link ServiceManager} that needs to be\n   * accessed by instances of {@link ServiceListener}.\n   */\n  private static final class ServiceManagerState {\n    final Monitor monitor = new Monitor();\n\n    @GuardedBy(\"monitor\")\n    final SetMultimap<State, Service> servicesByState =\n        MultimapBuilder.enumKeys(State.class).linkedHashSetValues().build();\n\n    @GuardedBy(\"monitor\")\n    final Multiset<State> states = servicesByState.keys();\n\n    @GuardedBy(\"monitor\")\n    final Map<Service, Stopwatch> startupTimers = Maps.newIdentityHashMap();\n\n    /**\n     * These two booleans are used to mark the state as ready to start.\n     * {@link #ready}: is set by {@link #markReady} to indicate that all listeners have been\n     *     correctly installed\n     * {@link #transitioned}: is set by {@link #transitionService} to indicate that some transition\n     *     has been performed.\n     *\n     * <p>Together, they allow us to enforce that all services have their listeners installed prior\n     * to any service performing a transition, then we can fail in the ServiceManager constructor\n     * rather than in a Service.Listener callback.\n     */\n    @GuardedBy(\"monitor\")\n    boolean ready;\n\n    @GuardedBy(\"monitor\")\n    boolean transitioned;\n\n    final int numberOfServices;\n\n    /**\n     * Controls how long to wait for all the services to either become healthy or reach a\n     * state from which it is guaranteed that it can never become healthy.\n     */\n    final Monitor.Guard awaitHealthGuard = new AwaitHealthGuard();\n\n    @WeakOuter\n    final class AwaitHealthGuard extends Monitor.Guard {\n      AwaitHealthGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        // All services have started or some service has terminated/failed.\n        return states.count(RUNNING) == numberOfServices\n            || states.contains(STOPPING)\n            || states.contains(TERMINATED)\n            || states.contains(FAILED);\n      }\n    }\n\n    /**\n     * Controls how long to wait for all services to reach a terminal state.\n     */\n    final Monitor.Guard stoppedGuard = new StoppedGuard();\n\n    @WeakOuter\n    final class StoppedGuard extends Monitor.Guard {\n      StoppedGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        return states.count(TERMINATED) + states.count(FAILED) == numberOfServices;\n      }\n    }\n\n    /** The listeners to notify during a state transition. */\n    @GuardedBy(\"monitor\")\n    final List<ListenerCallQueue<Listener>> listeners =\n        Collections.synchronizedList(new ArrayList<ListenerCallQueue<Listener>>());\n\n    /**\n     * It is implicitly assumed that all the services are NEW and that they will all remain NEW\n     * until all the Listeners are installed and {@link #markReady()} is called.  It is our caller's\n     * responsibility to only call {@link #markReady()} if all services were new at the time this\n     * method was called and when all the listeners were installed.\n     */\n    ServiceManagerState(ImmutableCollection<Service> services) {\n      this.numberOfServices = services.size();\n      servicesByState.putAll(NEW, services);\n    }\n\n    /**\n     * Attempts to start the timer immediately prior to the service being started via\n     * {@link Service#startAsync()}.\n     */\n    void tryStartTiming(Service service) {\n      monitor.enter();\n      try {\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          startupTimers.put(service, Stopwatch.createStarted());\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    /**\n     * Marks the {@link State} as ready to receive transitions. Returns true if no transitions have\n     * been observed yet.\n     */\n    void markReady() {\n      monitor.enter();\n      try {\n        if (!transitioned) {\n          // nothing has transitioned since construction, good.\n          ready = true;\n        } else {\n          // This should be an extremely rare race condition.\n          List<Service> servicesInBadStates = Lists.newArrayList();\n          for (Service service : servicesByState().values()) {\n            if (service.state() != NEW) {\n              servicesInBadStates.add(service);\n            }\n          }\n          throw new IllegalArgumentException(\"Services started transitioning asynchronously before \"\n              + \"the ServiceManager was constructed: \" + servicesInBadStates);\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void addListener(Listener listener, Executor executor) {\n      checkNotNull(listener, \"listener\");\n      checkNotNull(executor, \"executor\");\n      monitor.enter();\n      try {\n        // no point in adding a listener that will never be called\n        if (!stoppedGuard.isSatisfied()) {\n          listeners.add(new ListenerCallQueue<Listener>(listener, executor));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy() {\n      monitor.enterWhenUninterruptibly(awaitHealthGuard);\n      try {\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(awaitHealthGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to become healthy. The \"\n              + \"following services have not started: \"\n              + Multimaps.filterKeys(servicesByState, in(ImmutableSet.of(NEW, STARTING))));\n        }\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitStopped() {\n      monitor.enterWhenUninterruptibly(stoppedGuard);\n      monitor.leave();\n    }\n\n    void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(stoppedGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to stop. The following \"\n              + \"services have not stopped: \"\n              + Multimaps.filterKeys(servicesByState,\n                  not(in(EnumSet.of(TERMINATED, FAILED)))));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    ImmutableMultimap<State, Service> servicesByState() {\n      ImmutableSetMultimap.Builder<State, Service> builder = ImmutableSetMultimap.builder();\n      monitor.enter();\n      try {\n        for (Entry<State, Service> entry : servicesByState.entries()) {\n          if (!(entry.getValue() instanceof NoOpService)) {\n            builder.put(entry);\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      return builder.build();\n    }\n\n    ImmutableMap<Service, Long> startupTimes() {\n      List<Entry<Service, Long>> loadTimes;\n      monitor.enter();\n      try {\n        loadTimes = Lists.newArrayListWithCapacity(startupTimers.size());\n        // N.B. There will only be an entry in the map if the service has started\n        for (Entry<Service, Stopwatch> entry : startupTimers.entrySet()) {\n          Service service = entry.getKey();\n          Stopwatch stopWatch = entry.getValue();\n          if (!stopWatch.isRunning() && !(service instanceof NoOpService)) {\n            loadTimes.add(Maps.immutableEntry(service, stopWatch.elapsed(MILLISECONDS)));\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      Collections.sort(loadTimes, Ordering.natural()\n          .onResultOf(new Function<Entry<Service, Long>, Long>() {\n            @Override public Long apply(Map.Entry<Service, Long> input) {\n              return input.getValue();\n            }\n          }));\n      return ImmutableMap.copyOf(loadTimes);\n    }\n\n    /**\n     * Updates the state with the given service transition.\n     *\n     * <p>This method performs the main logic of ServiceManager in the following steps.\n     * <ol>\n     *      <li>Update the {@link #servicesByState()}\n     *      <li>Update the {@link #startupTimers}\n     *      <li>Based on the new state queue listeners to run\n     *      <li>Run the listeners (outside of the lock)\n     * </ol>\n     */\n    void transitionService(final Service service, State from, State to) {\n      checkNotNull(service);\n      checkArgument(from != to);\n      monitor.enter();\n      try {\n        transitioned = true;\n        if (!ready) {\n          return;\n        }\n        // Update state.\n        checkState(servicesByState.remove(from, service),\n            \"Service %s not at the expected location in the state map %s\", service, from);\n        checkState(servicesByState.put(to, service),\n            \"Service %s in the state map unexpectedly at %s\", service, to);\n        // Update the timer\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          // This means the service was started by some means other than ServiceManager.startAsync\n          stopwatch = Stopwatch.createStarted();\n          startupTimers.put(service, stopwatch);\n        }\n        if (to.compareTo(RUNNING) >= 0 && stopwatch.isRunning()) {\n          // N.B. if we miss the STARTING event then we may never record a startup time.\n          stopwatch.stop();\n          if (!(service instanceof NoOpService)) {\n            logger.log(Level.FINE, \"Started {0} in {1}.\", new Object[] {service, stopwatch});\n          }\n        }\n        // Queue our listeners\n\n        // Did a service fail?\n        if (to == FAILED) {\n          fireFailedListeners(service);\n        }\n\n        if (states.count(RUNNING) == numberOfServices) {\n          // This means that the manager is currently healthy. N.B. If other threads call isHealthy\n          // they are not guaranteed to get 'true', because any service could fail right now.\n          fireHealthyListeners();\n        } else if (states.count(TERMINATED) + states.count(FAILED) == numberOfServices) {\n          fireStoppedListeners();\n        }\n      } finally {\n        monitor.leave();\n        // Run our executors outside of the lock\n        executeListeners();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireStoppedListeners() {\n      STOPPED_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireHealthyListeners() {\n      HEALTHY_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireFailedListeners(final Service service) {\n      new Callback<Listener>(\"failed({service=\" + service + \"})\") {\n        @Override void call(Listener listener) {\n          listener.failure(service);\n        }\n      }.enqueueOn(listeners);\n    }\n\n    /** Attempts to execute all the listeners in {@link #listeners}. */\n    void executeListeners() {\n      checkState(!monitor.isOccupiedByCurrentThread(),\n          \"It is incorrect to execute listeners with the monitor held.\");\n      // iterate by index to avoid concurrent modification exceptions\n      for (int i = 0; i < listeners.size(); i++) {\n        listeners.get(i).execute();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void checkHealthy() {\n      if (states.count(RUNNING) != numberOfServices) {\n        IllegalStateException exception = new IllegalStateException(\n            \"Expected to be healthy after starting. The following services are not running: \"\n                + Multimaps.filterKeys(servicesByState, not(equalTo(RUNNING))));\n        throw exception;\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} that wraps another service and times how long it takes for it to start and\n   * also calls the {@link ServiceManagerState#transitionService(Service, State, State)},\n   * to record the state transitions.\n   */\n  private static final class ServiceListener extends Service.Listener {\n    final Service service;\n    // We store the state in a weak reference to ensure that if something went wrong while\n    // constructing the ServiceManager we don't pointlessly keep updating the state.\n    final WeakReference<ServiceManagerState> state;\n\n    ServiceListener(Service service, WeakReference<ServiceManagerState> state) {\n      this.service = service;\n      this.state = state;\n    }\n\n    @Override public void starting() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, NEW, STARTING);\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Starting {0}.\", service);\n        }\n      }\n    }\n\n    @Override public void running() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, STARTING, RUNNING);\n      }\n    }\n\n    @Override public void stopping(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, from, STOPPING);\n      }\n    }\n\n    @Override public void terminated(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Service {0} has terminated. Previous state was: {1}\",\n              new Object[] {service, from});\n        }\n        state.transitionService(service, from, TERMINATED);\n      }\n    }\n\n    @Override public void failed(State from, Throwable failure) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        // Log before the transition, so that if the process exits in response to server failure,\n        // there is a higher likelihood that the cause will be in the logs.\n        if (!(service instanceof NoOpService) ) {\n          logger.log(Level.SEVERE, \"Service \" + service + \" has failed in the \" + from + \" state.\",\n              failure);\n        }\n        state.transitionService(service, from, FAILED);\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} instance that does nothing.  This is only useful as a placeholder to\n   * ensure that the {@link ServiceManager} functions properly even when it is managing no services.\n   *\n   * <p>The use of this class is considered an implementation detail of ServiceManager and as such\n   * it is excluded from {@link #servicesByState}, {@link #startupTimes}, {@link #toString} and all\n   * logging statements.\n   */\n  private static final class NoOpService extends AbstractService {\n    @Override protected void doStart() { notifyStarted(); }\n    @Override protected void doStop() { notifyStopped(); }\n  }\n\n  /** This is never thrown but only used for logging. */\n  private static final class EmptyServiceManagerWarning extends Throwable {}\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53079313,"label":true,"oracleId":1445,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"ServiceManager","javadocTag":"@param executor the executor in which the listeners callback methods will be run.","methodJavadoc":"    /**\n   * Registers a {@link Listener} to be {@linkplain Executor#execute executed} on the given\n   * executor. The listener will not have previous state changes replayed, so it is\n   * suggested that listeners are added before any of the managed services are\n   * {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged. Any exception thrown\n   * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException}) will be caught and\n   * logged.\n   *\n   * <p> For fast, lightweight listeners that would be safe to execute in any thread, consider\n   * calling {@link #addListener(Listener)}.\n   *\n   * @param listener the listener to run when the manager changes state\n   * @param executor the executor in which the listeners callback methods will be run.\n   */","methodSourceCode":"public void addListener(Listener listener, Executor executor){\n    state.addListener(listener, executor);\n}","classJavadoc":"/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */","classSourceCode":"/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Predicates.equalTo;\nimport static com.google.common.base.Predicates.in;\nimport static com.google.common.base.Predicates.instanceOf;\nimport static com.google.common.base.Predicates.not;\nimport static com.google.common.util.concurrent.MoreExecutors.directExecutor;\nimport static com.google.common.util.concurrent.Service.State.FAILED;\nimport static com.google.common.util.concurrent.Service.State.NEW;\nimport static com.google.common.util.concurrent.Service.State.RUNNING;\nimport static com.google.common.util.concurrent.Service.State.STARTING;\nimport static com.google.common.util.concurrent.Service.State.STOPPING;\nimport static com.google.common.util.concurrent.Service.State.TERMINATED;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.base.Function;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Stopwatch;\nimport com.google.common.collect.Collections2;\nimport com.google.common.collect.ImmutableCollection;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableMultimap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSetMultimap;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.MultimapBuilder;\nimport com.google.common.collect.Multimaps;\nimport com.google.common.collect.Multiset;\nimport com.google.common.collect.Ordering;\nimport com.google.common.collect.SetMultimap;\nimport com.google.common.util.concurrent.ListenerCallQueue.Callback;\nimport com.google.common.util.concurrent.Service.State;\nimport com.google.j2objc.annotations.WeakOuter;\n\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */\n@Beta\npublic final class ServiceManager {\n  private static final Logger logger = Logger.getLogger(ServiceManager.class.getName());\n  private static final Callback<Listener> HEALTHY_CALLBACK = new Callback<Listener>(\"healthy()\") {\n    @Override void call(Listener listener) {\n      listener.healthy();\n    }\n  };\n  private static final Callback<Listener> STOPPED_CALLBACK = new Callback<Listener>(\"stopped()\") {\n    @Override void call(Listener listener) {\n      listener.stopped();\n    }\n  };\n\n  /**\n   * A listener for the aggregate state changes of the services that are under management. Users\n   * that need to listen to more fine-grained events (such as when each particular {@linkplain\n   * Service service} starts, or terminates), should attach {@linkplain Service.Listener service\n   * listeners} to each individual service.\n   *\n   * @author Luke Sandberg\n   * @since 15.0 (present as an interface in 14.0)\n   */\n  @Beta  // Should come out of Beta when ServiceManager does\n  public abstract static class Listener {\n    /**\n     * Called when the service initially becomes healthy.\n     *\n     * <p>This will be called at most once after all the services have entered the\n     * {@linkplain State#RUNNING running} state. If any services fail during start up or\n     * {@linkplain State#FAILED fail}/{@linkplain State#TERMINATED terminate} before all other\n     * services have started {@linkplain State#RUNNING running} then this method will not be called.\n     */\n    public void healthy() {}\n\n    /**\n     * Called when the all of the component services have reached a terminal state, either\n     * {@linkplain State#TERMINATED terminated} or {@linkplain State#FAILED failed}.\n     */\n    public void stopped() {}\n\n    /**\n     * Called when a component service has {@linkplain State#FAILED failed}.\n     *\n     * @param service The service that failed.\n     */\n    public void failure(Service service) {}\n  }\n\n  /**\n   * An encapsulation of all of the state that is accessed by the {@linkplain ServiceListener\n   * service listeners}.  This is extracted into its own object so that {@link ServiceListener}\n   * could be made {@code static} and its instances can be safely constructed and added in the\n   * {@link ServiceManager} constructor without having to close over the partially constructed\n   * {@link ServiceManager} instance (i.e. avoid leaking a pointer to {@code this}).\n   */\n  private final ServiceManagerState state;\n  private final ImmutableList<Service> services;\n\n  /**\n   * Constructs a new instance for managing the given services.\n   *\n   * @param services The services to manage\n   *\n   * @throws IllegalArgumentException if not all services are {@linkplain State#NEW new} or if there\n   * are any duplicate services.\n   */\n  public ServiceManager(Iterable<? extends Service> services) {\n    ImmutableList<Service> copy = ImmutableList.copyOf(services);\n    if (copy.isEmpty()) {\n      // Having no services causes the manager to behave strangely. Notably, listeners are never\n      // fired.  To avoid this we substitute a placeholder service.\n      logger.log(Level.WARNING,\n          \"ServiceManager configured with no services.  Is your application configured properly?\",\n          new EmptyServiceManagerWarning());\n      copy = ImmutableList.<Service>of(new NoOpService());\n    }\n    this.state = new ServiceManagerState(copy);\n    this.services = copy;\n    WeakReference<ServiceManagerState> stateReference =\n        new WeakReference<ServiceManagerState>(state);\n    for (Service service : copy) {\n      service.addListener(new ServiceListener(service, stateReference), directExecutor());\n      // We check the state after adding the listener as a way to ensure that our listener was added\n      // to a NEW service.\n      checkArgument(service.state() == NEW, \"Can only manage NEW services, %s\", service);\n    }\n    // We have installed all of our listeners and after this point any state transition should be\n    // correct.\n    this.state.markReady();\n  }\n\n  /**\n   * Registers a {@link Listener} to be {@linkplain Executor#execute executed} on the given\n   * executor. The listener will not have previous state changes replayed, so it is\n   * suggested that listeners are added before any of the managed services are\n   * {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged. Any exception thrown\n   * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException}) will be caught and\n   * logged.\n   *\n   * <p> For fast, lightweight listeners that would be safe to execute in any thread, consider\n   * calling {@link #addListener(Listener)}.\n   *\n   * @param listener the listener to run when the manager changes state\n   * @param executor the executor in which the listeners callback methods will be run.\n   */\n  public void addListener(Listener listener, Executor executor) {\n    state.addListener(listener, executor);\n  }\n\n  /**\n   * Registers a {@link Listener} to be run when this {@link ServiceManager} changes state. The\n   * listener will not have previous state changes replayed, so it is suggested that listeners are\n   * added before any of the managed services are {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged.\n   *\n   * @param listener the listener to run when the manager changes state\n   */\n  public void addListener(Listener listener) {\n    state.addListener(listener, directExecutor());\n  }\n\n  /**\n   * Initiates service {@linkplain Service#startAsync startup} on all the services being managed.\n   * It is only valid to call this method if all of the services are {@linkplain State#NEW new}.\n   *\n   * @return this\n   * @throws IllegalStateException if any of the Services are not {@link State#NEW new} when the\n   *     method is called.\n   */\n  public ServiceManager startAsync() {\n    for (Service service : services) {\n      State state = service.state();\n      checkState(state == NEW, \"Service %s is %s, cannot start it.\", service, state);\n    }\n    for (Service service : services) {\n      try {\n        state.tryStartTiming(service);\n        service.startAsync();\n      } catch (IllegalStateException e) {\n        // This can happen if the service has already been started or stopped (e.g. by another\n        // service or listener). Our contract says it is safe to call this method if\n        // all services were NEW when it was called, and this has already been verified above, so we\n        // don't propagate the exception.\n        logger.log(Level.WARNING, \"Unable to start Service \" + service, e);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy}.  The manager\n   * will become healthy after all the component services have reached the {@linkplain State#RUNNING\n   * running} state.\n   *\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy() {\n    state.awaitHealthy();\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy} for no more\n   * than the given time.  The manager will become healthy after all the component services have\n   * reached the {@linkplain State#RUNNING running} state.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have finished starting within the deadline\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitHealthy(timeout, unit);\n  }\n\n  /**\n   * Initiates service {@linkplain Service#stopAsync shutdown} if necessary on all the services\n   * being managed.\n   *\n   * @return this\n   */\n  public ServiceManager stopAsync() {\n    for (Service service : services) {\n      service.stopAsync();\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state. After this method returns all\n   * services will either be {@linkplain Service.State#TERMINATED terminated} or {@linkplain\n   * Service.State#FAILED failed}.\n   */\n  public void awaitStopped() {\n    state.awaitStopped();\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state for no more than the given time. After\n   * this method returns all services will either be {@linkplain Service.State#TERMINATED\n   * terminated} or {@linkplain Service.State#FAILED failed}.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have stopped within the deadline\n   */\n  public void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitStopped(timeout, unit);\n  }\n\n  /**\n   * Returns true if all services are currently in the {@linkplain State#RUNNING running} state.\n   *\n   * <p>Users who want more detailed information should use the {@link #servicesByState} method to\n   * get detailed information about which services are not running.\n   */\n  public boolean isHealthy() {\n    for (Service service : services) {\n      if (!service.isRunning()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Provides a snapshot of the current state of all the services under management.\n   *\n   * <p>N.B. This snapshot is guaranteed to be consistent, i.e. the set of states returned will\n   * correspond to a point in time view of the services.\n   */\n  public ImmutableMultimap<State, Service> servicesByState() {\n    return state.servicesByState();\n  }\n\n  /**\n   * Returns the service load times. This value will only return startup times for services that\n   * have finished starting.\n   *\n   * @return Map of services and their corresponding startup time in millis, the map entries will be\n   *     ordered by startup time.\n   */\n  public ImmutableMap<Service, Long> startupTimes() {\n    return state.startupTimes();\n  }\n\n  @Override public String toString() {\n    return MoreObjects.toStringHelper(ServiceManager.class)\n        .add(\"services\", Collections2.filter(services, not(instanceOf(NoOpService.class))))\n        .toString();\n  }\n\n  /**\n   * An encapsulation of all the mutable state of the {@link ServiceManager} that needs to be\n   * accessed by instances of {@link ServiceListener}.\n   */\n  private static final class ServiceManagerState {\n    final Monitor monitor = new Monitor();\n\n    @GuardedBy(\"monitor\")\n    final SetMultimap<State, Service> servicesByState =\n        MultimapBuilder.enumKeys(State.class).linkedHashSetValues().build();\n\n    @GuardedBy(\"monitor\")\n    final Multiset<State> states = servicesByState.keys();\n\n    @GuardedBy(\"monitor\")\n    final Map<Service, Stopwatch> startupTimers = Maps.newIdentityHashMap();\n\n    /**\n     * These two booleans are used to mark the state as ready to start.\n     * {@link #ready}: is set by {@link #markReady} to indicate that all listeners have been\n     *     correctly installed\n     * {@link #transitioned}: is set by {@link #transitionService} to indicate that some transition\n     *     has been performed.\n     *\n     * <p>Together, they allow us to enforce that all services have their listeners installed prior\n     * to any service performing a transition, then we can fail in the ServiceManager constructor\n     * rather than in a Service.Listener callback.\n     */\n    @GuardedBy(\"monitor\")\n    boolean ready;\n\n    @GuardedBy(\"monitor\")\n    boolean transitioned;\n\n    final int numberOfServices;\n\n    /**\n     * Controls how long to wait for all the services to either become healthy or reach a\n     * state from which it is guaranteed that it can never become healthy.\n     */\n    final Monitor.Guard awaitHealthGuard = new AwaitHealthGuard();\n\n    @WeakOuter\n    final class AwaitHealthGuard extends Monitor.Guard {\n      AwaitHealthGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        // All services have started or some service has terminated/failed.\n        return states.count(RUNNING) == numberOfServices\n            || states.contains(STOPPING)\n            || states.contains(TERMINATED)\n            || states.contains(FAILED);\n      }\n    }\n\n    /**\n     * Controls how long to wait for all services to reach a terminal state.\n     */\n    final Monitor.Guard stoppedGuard = new StoppedGuard();\n\n    @WeakOuter\n    final class StoppedGuard extends Monitor.Guard {\n      StoppedGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        return states.count(TERMINATED) + states.count(FAILED) == numberOfServices;\n      }\n    }\n\n    /** The listeners to notify during a state transition. */\n    @GuardedBy(\"monitor\")\n    final List<ListenerCallQueue<Listener>> listeners =\n        Collections.synchronizedList(new ArrayList<ListenerCallQueue<Listener>>());\n\n    /**\n     * It is implicitly assumed that all the services are NEW and that they will all remain NEW\n     * until all the Listeners are installed and {@link #markReady()} is called.  It is our caller's\n     * responsibility to only call {@link #markReady()} if all services were new at the time this\n     * method was called and when all the listeners were installed.\n     */\n    ServiceManagerState(ImmutableCollection<Service> services) {\n      this.numberOfServices = services.size();\n      servicesByState.putAll(NEW, services);\n    }\n\n    /**\n     * Attempts to start the timer immediately prior to the service being started via\n     * {@link Service#startAsync()}.\n     */\n    void tryStartTiming(Service service) {\n      monitor.enter();\n      try {\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          startupTimers.put(service, Stopwatch.createStarted());\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    /**\n     * Marks the {@link State} as ready to receive transitions. Returns true if no transitions have\n     * been observed yet.\n     */\n    void markReady() {\n      monitor.enter();\n      try {\n        if (!transitioned) {\n          // nothing has transitioned since construction, good.\n          ready = true;\n        } else {\n          // This should be an extremely rare race condition.\n          List<Service> servicesInBadStates = Lists.newArrayList();\n          for (Service service : servicesByState().values()) {\n            if (service.state() != NEW) {\n              servicesInBadStates.add(service);\n            }\n          }\n          throw new IllegalArgumentException(\"Services started transitioning asynchronously before \"\n              + \"the ServiceManager was constructed: \" + servicesInBadStates);\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void addListener(Listener listener, Executor executor) {\n      checkNotNull(listener, \"listener\");\n      checkNotNull(executor, \"executor\");\n      monitor.enter();\n      try {\n        // no point in adding a listener that will never be called\n        if (!stoppedGuard.isSatisfied()) {\n          listeners.add(new ListenerCallQueue<Listener>(listener, executor));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy() {\n      monitor.enterWhenUninterruptibly(awaitHealthGuard);\n      try {\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(awaitHealthGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to become healthy. The \"\n              + \"following services have not started: \"\n              + Multimaps.filterKeys(servicesByState, in(ImmutableSet.of(NEW, STARTING))));\n        }\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitStopped() {\n      monitor.enterWhenUninterruptibly(stoppedGuard);\n      monitor.leave();\n    }\n\n    void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(stoppedGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to stop. The following \"\n              + \"services have not stopped: \"\n              + Multimaps.filterKeys(servicesByState,\n                  not(in(EnumSet.of(TERMINATED, FAILED)))));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    ImmutableMultimap<State, Service> servicesByState() {\n      ImmutableSetMultimap.Builder<State, Service> builder = ImmutableSetMultimap.builder();\n      monitor.enter();\n      try {\n        for (Entry<State, Service> entry : servicesByState.entries()) {\n          if (!(entry.getValue() instanceof NoOpService)) {\n            builder.put(entry);\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      return builder.build();\n    }\n\n    ImmutableMap<Service, Long> startupTimes() {\n      List<Entry<Service, Long>> loadTimes;\n      monitor.enter();\n      try {\n        loadTimes = Lists.newArrayListWithCapacity(startupTimers.size());\n        // N.B. There will only be an entry in the map if the service has started\n        for (Entry<Service, Stopwatch> entry : startupTimers.entrySet()) {\n          Service service = entry.getKey();\n          Stopwatch stopWatch = entry.getValue();\n          if (!stopWatch.isRunning() && !(service instanceof NoOpService)) {\n            loadTimes.add(Maps.immutableEntry(service, stopWatch.elapsed(MILLISECONDS)));\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      Collections.sort(loadTimes, Ordering.natural()\n          .onResultOf(new Function<Entry<Service, Long>, Long>() {\n            @Override public Long apply(Map.Entry<Service, Long> input) {\n              return input.getValue();\n            }\n          }));\n      return ImmutableMap.copyOf(loadTimes);\n    }\n\n    /**\n     * Updates the state with the given service transition.\n     *\n     * <p>This method performs the main logic of ServiceManager in the following steps.\n     * <ol>\n     *      <li>Update the {@link #servicesByState()}\n     *      <li>Update the {@link #startupTimers}\n     *      <li>Based on the new state queue listeners to run\n     *      <li>Run the listeners (outside of the lock)\n     * </ol>\n     */\n    void transitionService(final Service service, State from, State to) {\n      checkNotNull(service);\n      checkArgument(from != to);\n      monitor.enter();\n      try {\n        transitioned = true;\n        if (!ready) {\n          return;\n        }\n        // Update state.\n        checkState(servicesByState.remove(from, service),\n            \"Service %s not at the expected location in the state map %s\", service, from);\n        checkState(servicesByState.put(to, service),\n            \"Service %s in the state map unexpectedly at %s\", service, to);\n        // Update the timer\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          // This means the service was started by some means other than ServiceManager.startAsync\n          stopwatch = Stopwatch.createStarted();\n          startupTimers.put(service, stopwatch);\n        }\n        if (to.compareTo(RUNNING) >= 0 && stopwatch.isRunning()) {\n          // N.B. if we miss the STARTING event then we may never record a startup time.\n          stopwatch.stop();\n          if (!(service instanceof NoOpService)) {\n            logger.log(Level.FINE, \"Started {0} in {1}.\", new Object[] {service, stopwatch});\n          }\n        }\n        // Queue our listeners\n\n        // Did a service fail?\n        if (to == FAILED) {\n          fireFailedListeners(service);\n        }\n\n        if (states.count(RUNNING) == numberOfServices) {\n          // This means that the manager is currently healthy. N.B. If other threads call isHealthy\n          // they are not guaranteed to get 'true', because any service could fail right now.\n          fireHealthyListeners();\n        } else if (states.count(TERMINATED) + states.count(FAILED) == numberOfServices) {\n          fireStoppedListeners();\n        }\n      } finally {\n        monitor.leave();\n        // Run our executors outside of the lock\n        executeListeners();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireStoppedListeners() {\n      STOPPED_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireHealthyListeners() {\n      HEALTHY_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireFailedListeners(final Service service) {\n      new Callback<Listener>(\"failed({service=\" + service + \"})\") {\n        @Override void call(Listener listener) {\n          listener.failure(service);\n        }\n      }.enqueueOn(listeners);\n    }\n\n    /** Attempts to execute all the listeners in {@link #listeners}. */\n    void executeListeners() {\n      checkState(!monitor.isOccupiedByCurrentThread(),\n          \"It is incorrect to execute listeners with the monitor held.\");\n      // iterate by index to avoid concurrent modification exceptions\n      for (int i = 0; i < listeners.size(); i++) {\n        listeners.get(i).execute();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void checkHealthy() {\n      if (states.count(RUNNING) != numberOfServices) {\n        IllegalStateException exception = new IllegalStateException(\n            \"Expected to be healthy after starting. The following services are not running: \"\n                + Multimaps.filterKeys(servicesByState, not(equalTo(RUNNING))));\n        throw exception;\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} that wraps another service and times how long it takes for it to start and\n   * also calls the {@link ServiceManagerState#transitionService(Service, State, State)},\n   * to record the state transitions.\n   */\n  private static final class ServiceListener extends Service.Listener {\n    final Service service;\n    // We store the state in a weak reference to ensure that if something went wrong while\n    // constructing the ServiceManager we don't pointlessly keep updating the state.\n    final WeakReference<ServiceManagerState> state;\n\n    ServiceListener(Service service, WeakReference<ServiceManagerState> state) {\n      this.service = service;\n      this.state = state;\n    }\n\n    @Override public void starting() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, NEW, STARTING);\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Starting {0}.\", service);\n        }\n      }\n    }\n\n    @Override public void running() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, STARTING, RUNNING);\n      }\n    }\n\n    @Override public void stopping(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, from, STOPPING);\n      }\n    }\n\n    @Override public void terminated(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Service {0} has terminated. Previous state was: {1}\",\n              new Object[] {service, from});\n        }\n        state.transitionService(service, from, TERMINATED);\n      }\n    }\n\n    @Override public void failed(State from, Throwable failure) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        // Log before the transition, so that if the process exits in response to server failure,\n        // there is a higher likelihood that the cause will be in the logs.\n        if (!(service instanceof NoOpService) ) {\n          logger.log(Level.SEVERE, \"Service \" + service + \" has failed in the \" + from + \" state.\",\n              failure);\n        }\n        state.transitionService(service, from, FAILED);\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} instance that does nothing.  This is only useful as a placeholder to\n   * ensure that the {@link ServiceManager} functions properly even when it is managing no services.\n   *\n   * <p>The use of this class is considered an implementation detail of ServiceManager and as such\n   * it is excluded from {@link #servicesByState}, {@link #startupTimes}, {@link #toString} and all\n   * logging statements.\n   */\n  private static final class NoOpService extends AbstractService {\n    @Override protected void doStart() { notifyStarted(); }\n    @Override protected void doStop() { notifyStopped(); }\n  }\n\n  /** This is never thrown but only used for logging. */\n  private static final class EmptyServiceManagerWarning extends Throwable {}\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53079771,"label":true,"oracleId":1446,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"ServiceManager","javadocTag":"@param listener the listener to run when the manager changes state","methodJavadoc":"    /**\n   * Registers a {@link Listener} to be run when this {@link ServiceManager} changes state. The\n   * listener will not have previous state changes replayed, so it is suggested that listeners are\n   * added before any of the managed services are {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged.\n   *\n   * @param listener the listener to run when the manager changes state\n   */","methodSourceCode":"public void addListener(Listener listener){\n    state.addListener(listener, directExecutor());\n}","classJavadoc":"/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */","classSourceCode":"/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Predicates.equalTo;\nimport static com.google.common.base.Predicates.in;\nimport static com.google.common.base.Predicates.instanceOf;\nimport static com.google.common.base.Predicates.not;\nimport static com.google.common.util.concurrent.MoreExecutors.directExecutor;\nimport static com.google.common.util.concurrent.Service.State.FAILED;\nimport static com.google.common.util.concurrent.Service.State.NEW;\nimport static com.google.common.util.concurrent.Service.State.RUNNING;\nimport static com.google.common.util.concurrent.Service.State.STARTING;\nimport static com.google.common.util.concurrent.Service.State.STOPPING;\nimport static com.google.common.util.concurrent.Service.State.TERMINATED;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.base.Function;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Stopwatch;\nimport com.google.common.collect.Collections2;\nimport com.google.common.collect.ImmutableCollection;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableMultimap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSetMultimap;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.MultimapBuilder;\nimport com.google.common.collect.Multimaps;\nimport com.google.common.collect.Multiset;\nimport com.google.common.collect.Ordering;\nimport com.google.common.collect.SetMultimap;\nimport com.google.common.util.concurrent.ListenerCallQueue.Callback;\nimport com.google.common.util.concurrent.Service.State;\nimport com.google.j2objc.annotations.WeakOuter;\n\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */\n@Beta\npublic final class ServiceManager {\n  private static final Logger logger = Logger.getLogger(ServiceManager.class.getName());\n  private static final Callback<Listener> HEALTHY_CALLBACK = new Callback<Listener>(\"healthy()\") {\n    @Override void call(Listener listener) {\n      listener.healthy();\n    }\n  };\n  private static final Callback<Listener> STOPPED_CALLBACK = new Callback<Listener>(\"stopped()\") {\n    @Override void call(Listener listener) {\n      listener.stopped();\n    }\n  };\n\n  /**\n   * A listener for the aggregate state changes of the services that are under management. Users\n   * that need to listen to more fine-grained events (such as when each particular {@linkplain\n   * Service service} starts, or terminates), should attach {@linkplain Service.Listener service\n   * listeners} to each individual service.\n   *\n   * @author Luke Sandberg\n   * @since 15.0 (present as an interface in 14.0)\n   */\n  @Beta  // Should come out of Beta when ServiceManager does\n  public abstract static class Listener {\n    /**\n     * Called when the service initially becomes healthy.\n     *\n     * <p>This will be called at most once after all the services have entered the\n     * {@linkplain State#RUNNING running} state. If any services fail during start up or\n     * {@linkplain State#FAILED fail}/{@linkplain State#TERMINATED terminate} before all other\n     * services have started {@linkplain State#RUNNING running} then this method will not be called.\n     */\n    public void healthy() {}\n\n    /**\n     * Called when the all of the component services have reached a terminal state, either\n     * {@linkplain State#TERMINATED terminated} or {@linkplain State#FAILED failed}.\n     */\n    public void stopped() {}\n\n    /**\n     * Called when a component service has {@linkplain State#FAILED failed}.\n     *\n     * @param service The service that failed.\n     */\n    public void failure(Service service) {}\n  }\n\n  /**\n   * An encapsulation of all of the state that is accessed by the {@linkplain ServiceListener\n   * service listeners}.  This is extracted into its own object so that {@link ServiceListener}\n   * could be made {@code static} and its instances can be safely constructed and added in the\n   * {@link ServiceManager} constructor without having to close over the partially constructed\n   * {@link ServiceManager} instance (i.e. avoid leaking a pointer to {@code this}).\n   */\n  private final ServiceManagerState state;\n  private final ImmutableList<Service> services;\n\n  /**\n   * Constructs a new instance for managing the given services.\n   *\n   * @param services The services to manage\n   *\n   * @throws IllegalArgumentException if not all services are {@linkplain State#NEW new} or if there\n   * are any duplicate services.\n   */\n  public ServiceManager(Iterable<? extends Service> services) {\n    ImmutableList<Service> copy = ImmutableList.copyOf(services);\n    if (copy.isEmpty()) {\n      // Having no services causes the manager to behave strangely. Notably, listeners are never\n      // fired.  To avoid this we substitute a placeholder service.\n      logger.log(Level.WARNING,\n          \"ServiceManager configured with no services.  Is your application configured properly?\",\n          new EmptyServiceManagerWarning());\n      copy = ImmutableList.<Service>of(new NoOpService());\n    }\n    this.state = new ServiceManagerState(copy);\n    this.services = copy;\n    WeakReference<ServiceManagerState> stateReference =\n        new WeakReference<ServiceManagerState>(state);\n    for (Service service : copy) {\n      service.addListener(new ServiceListener(service, stateReference), directExecutor());\n      // We check the state after adding the listener as a way to ensure that our listener was added\n      // to a NEW service.\n      checkArgument(service.state() == NEW, \"Can only manage NEW services, %s\", service);\n    }\n    // We have installed all of our listeners and after this point any state transition should be\n    // correct.\n    this.state.markReady();\n  }\n\n  /**\n   * Registers a {@link Listener} to be {@linkplain Executor#execute executed} on the given\n   * executor. The listener will not have previous state changes replayed, so it is\n   * suggested that listeners are added before any of the managed services are\n   * {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged. Any exception thrown\n   * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException}) will be caught and\n   * logged.\n   *\n   * <p> For fast, lightweight listeners that would be safe to execute in any thread, consider\n   * calling {@link #addListener(Listener)}.\n   *\n   * @param listener the listener to run when the manager changes state\n   * @param executor the executor in which the listeners callback methods will be run.\n   */\n  public void addListener(Listener listener, Executor executor) {\n    state.addListener(listener, executor);\n  }\n\n  /**\n   * Registers a {@link Listener} to be run when this {@link ServiceManager} changes state. The\n   * listener will not have previous state changes replayed, so it is suggested that listeners are\n   * added before any of the managed services are {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged.\n   *\n   * @param listener the listener to run when the manager changes state\n   */\n  public void addListener(Listener listener) {\n    state.addListener(listener, directExecutor());\n  }\n\n  /**\n   * Initiates service {@linkplain Service#startAsync startup} on all the services being managed.\n   * It is only valid to call this method if all of the services are {@linkplain State#NEW new}.\n   *\n   * @return this\n   * @throws IllegalStateException if any of the Services are not {@link State#NEW new} when the\n   *     method is called.\n   */\n  public ServiceManager startAsync() {\n    for (Service service : services) {\n      State state = service.state();\n      checkState(state == NEW, \"Service %s is %s, cannot start it.\", service, state);\n    }\n    for (Service service : services) {\n      try {\n        state.tryStartTiming(service);\n        service.startAsync();\n      } catch (IllegalStateException e) {\n        // This can happen if the service has already been started or stopped (e.g. by another\n        // service or listener). Our contract says it is safe to call this method if\n        // all services were NEW when it was called, and this has already been verified above, so we\n        // don't propagate the exception.\n        logger.log(Level.WARNING, \"Unable to start Service \" + service, e);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy}.  The manager\n   * will become healthy after all the component services have reached the {@linkplain State#RUNNING\n   * running} state.\n   *\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy() {\n    state.awaitHealthy();\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy} for no more\n   * than the given time.  The manager will become healthy after all the component services have\n   * reached the {@linkplain State#RUNNING running} state.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have finished starting within the deadline\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitHealthy(timeout, unit);\n  }\n\n  /**\n   * Initiates service {@linkplain Service#stopAsync shutdown} if necessary on all the services\n   * being managed.\n   *\n   * @return this\n   */\n  public ServiceManager stopAsync() {\n    for (Service service : services) {\n      service.stopAsync();\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state. After this method returns all\n   * services will either be {@linkplain Service.State#TERMINATED terminated} or {@linkplain\n   * Service.State#FAILED failed}.\n   */\n  public void awaitStopped() {\n    state.awaitStopped();\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state for no more than the given time. After\n   * this method returns all services will either be {@linkplain Service.State#TERMINATED\n   * terminated} or {@linkplain Service.State#FAILED failed}.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have stopped within the deadline\n   */\n  public void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitStopped(timeout, unit);\n  }\n\n  /**\n   * Returns true if all services are currently in the {@linkplain State#RUNNING running} state.\n   *\n   * <p>Users who want more detailed information should use the {@link #servicesByState} method to\n   * get detailed information about which services are not running.\n   */\n  public boolean isHealthy() {\n    for (Service service : services) {\n      if (!service.isRunning()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Provides a snapshot of the current state of all the services under management.\n   *\n   * <p>N.B. This snapshot is guaranteed to be consistent, i.e. the set of states returned will\n   * correspond to a point in time view of the services.\n   */\n  public ImmutableMultimap<State, Service> servicesByState() {\n    return state.servicesByState();\n  }\n\n  /**\n   * Returns the service load times. This value will only return startup times for services that\n   * have finished starting.\n   *\n   * @return Map of services and their corresponding startup time in millis, the map entries will be\n   *     ordered by startup time.\n   */\n  public ImmutableMap<Service, Long> startupTimes() {\n    return state.startupTimes();\n  }\n\n  @Override public String toString() {\n    return MoreObjects.toStringHelper(ServiceManager.class)\n        .add(\"services\", Collections2.filter(services, not(instanceOf(NoOpService.class))))\n        .toString();\n  }\n\n  /**\n   * An encapsulation of all the mutable state of the {@link ServiceManager} that needs to be\n   * accessed by instances of {@link ServiceListener}.\n   */\n  private static final class ServiceManagerState {\n    final Monitor monitor = new Monitor();\n\n    @GuardedBy(\"monitor\")\n    final SetMultimap<State, Service> servicesByState =\n        MultimapBuilder.enumKeys(State.class).linkedHashSetValues().build();\n\n    @GuardedBy(\"monitor\")\n    final Multiset<State> states = servicesByState.keys();\n\n    @GuardedBy(\"monitor\")\n    final Map<Service, Stopwatch> startupTimers = Maps.newIdentityHashMap();\n\n    /**\n     * These two booleans are used to mark the state as ready to start.\n     * {@link #ready}: is set by {@link #markReady} to indicate that all listeners have been\n     *     correctly installed\n     * {@link #transitioned}: is set by {@link #transitionService} to indicate that some transition\n     *     has been performed.\n     *\n     * <p>Together, they allow us to enforce that all services have their listeners installed prior\n     * to any service performing a transition, then we can fail in the ServiceManager constructor\n     * rather than in a Service.Listener callback.\n     */\n    @GuardedBy(\"monitor\")\n    boolean ready;\n\n    @GuardedBy(\"monitor\")\n    boolean transitioned;\n\n    final int numberOfServices;\n\n    /**\n     * Controls how long to wait for all the services to either become healthy or reach a\n     * state from which it is guaranteed that it can never become healthy.\n     */\n    final Monitor.Guard awaitHealthGuard = new AwaitHealthGuard();\n\n    @WeakOuter\n    final class AwaitHealthGuard extends Monitor.Guard {\n      AwaitHealthGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        // All services have started or some service has terminated/failed.\n        return states.count(RUNNING) == numberOfServices\n            || states.contains(STOPPING)\n            || states.contains(TERMINATED)\n            || states.contains(FAILED);\n      }\n    }\n\n    /**\n     * Controls how long to wait for all services to reach a terminal state.\n     */\n    final Monitor.Guard stoppedGuard = new StoppedGuard();\n\n    @WeakOuter\n    final class StoppedGuard extends Monitor.Guard {\n      StoppedGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        return states.count(TERMINATED) + states.count(FAILED) == numberOfServices;\n      }\n    }\n\n    /** The listeners to notify during a state transition. */\n    @GuardedBy(\"monitor\")\n    final List<ListenerCallQueue<Listener>> listeners =\n        Collections.synchronizedList(new ArrayList<ListenerCallQueue<Listener>>());\n\n    /**\n     * It is implicitly assumed that all the services are NEW and that they will all remain NEW\n     * until all the Listeners are installed and {@link #markReady()} is called.  It is our caller's\n     * responsibility to only call {@link #markReady()} if all services were new at the time this\n     * method was called and when all the listeners were installed.\n     */\n    ServiceManagerState(ImmutableCollection<Service> services) {\n      this.numberOfServices = services.size();\n      servicesByState.putAll(NEW, services);\n    }\n\n    /**\n     * Attempts to start the timer immediately prior to the service being started via\n     * {@link Service#startAsync()}.\n     */\n    void tryStartTiming(Service service) {\n      monitor.enter();\n      try {\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          startupTimers.put(service, Stopwatch.createStarted());\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    /**\n     * Marks the {@link State} as ready to receive transitions. Returns true if no transitions have\n     * been observed yet.\n     */\n    void markReady() {\n      monitor.enter();\n      try {\n        if (!transitioned) {\n          // nothing has transitioned since construction, good.\n          ready = true;\n        } else {\n          // This should be an extremely rare race condition.\n          List<Service> servicesInBadStates = Lists.newArrayList();\n          for (Service service : servicesByState().values()) {\n            if (service.state() != NEW) {\n              servicesInBadStates.add(service);\n            }\n          }\n          throw new IllegalArgumentException(\"Services started transitioning asynchronously before \"\n              + \"the ServiceManager was constructed: \" + servicesInBadStates);\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void addListener(Listener listener, Executor executor) {\n      checkNotNull(listener, \"listener\");\n      checkNotNull(executor, \"executor\");\n      monitor.enter();\n      try {\n        // no point in adding a listener that will never be called\n        if (!stoppedGuard.isSatisfied()) {\n          listeners.add(new ListenerCallQueue<Listener>(listener, executor));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy() {\n      monitor.enterWhenUninterruptibly(awaitHealthGuard);\n      try {\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(awaitHealthGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to become healthy. The \"\n              + \"following services have not started: \"\n              + Multimaps.filterKeys(servicesByState, in(ImmutableSet.of(NEW, STARTING))));\n        }\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitStopped() {\n      monitor.enterWhenUninterruptibly(stoppedGuard);\n      monitor.leave();\n    }\n\n    void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(stoppedGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to stop. The following \"\n              + \"services have not stopped: \"\n              + Multimaps.filterKeys(servicesByState,\n                  not(in(EnumSet.of(TERMINATED, FAILED)))));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    ImmutableMultimap<State, Service> servicesByState() {\n      ImmutableSetMultimap.Builder<State, Service> builder = ImmutableSetMultimap.builder();\n      monitor.enter();\n      try {\n        for (Entry<State, Service> entry : servicesByState.entries()) {\n          if (!(entry.getValue() instanceof NoOpService)) {\n            builder.put(entry);\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      return builder.build();\n    }\n\n    ImmutableMap<Service, Long> startupTimes() {\n      List<Entry<Service, Long>> loadTimes;\n      monitor.enter();\n      try {\n        loadTimes = Lists.newArrayListWithCapacity(startupTimers.size());\n        // N.B. There will only be an entry in the map if the service has started\n        for (Entry<Service, Stopwatch> entry : startupTimers.entrySet()) {\n          Service service = entry.getKey();\n          Stopwatch stopWatch = entry.getValue();\n          if (!stopWatch.isRunning() && !(service instanceof NoOpService)) {\n            loadTimes.add(Maps.immutableEntry(service, stopWatch.elapsed(MILLISECONDS)));\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      Collections.sort(loadTimes, Ordering.natural()\n          .onResultOf(new Function<Entry<Service, Long>, Long>() {\n            @Override public Long apply(Map.Entry<Service, Long> input) {\n              return input.getValue();\n            }\n          }));\n      return ImmutableMap.copyOf(loadTimes);\n    }\n\n    /**\n     * Updates the state with the given service transition.\n     *\n     * <p>This method performs the main logic of ServiceManager in the following steps.\n     * <ol>\n     *      <li>Update the {@link #servicesByState()}\n     *      <li>Update the {@link #startupTimers}\n     *      <li>Based on the new state queue listeners to run\n     *      <li>Run the listeners (outside of the lock)\n     * </ol>\n     */\n    void transitionService(final Service service, State from, State to) {\n      checkNotNull(service);\n      checkArgument(from != to);\n      monitor.enter();\n      try {\n        transitioned = true;\n        if (!ready) {\n          return;\n        }\n        // Update state.\n        checkState(servicesByState.remove(from, service),\n            \"Service %s not at the expected location in the state map %s\", service, from);\n        checkState(servicesByState.put(to, service),\n            \"Service %s in the state map unexpectedly at %s\", service, to);\n        // Update the timer\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          // This means the service was started by some means other than ServiceManager.startAsync\n          stopwatch = Stopwatch.createStarted();\n          startupTimers.put(service, stopwatch);\n        }\n        if (to.compareTo(RUNNING) >= 0 && stopwatch.isRunning()) {\n          // N.B. if we miss the STARTING event then we may never record a startup time.\n          stopwatch.stop();\n          if (!(service instanceof NoOpService)) {\n            logger.log(Level.FINE, \"Started {0} in {1}.\", new Object[] {service, stopwatch});\n          }\n        }\n        // Queue our listeners\n\n        // Did a service fail?\n        if (to == FAILED) {\n          fireFailedListeners(service);\n        }\n\n        if (states.count(RUNNING) == numberOfServices) {\n          // This means that the manager is currently healthy. N.B. If other threads call isHealthy\n          // they are not guaranteed to get 'true', because any service could fail right now.\n          fireHealthyListeners();\n        } else if (states.count(TERMINATED) + states.count(FAILED) == numberOfServices) {\n          fireStoppedListeners();\n        }\n      } finally {\n        monitor.leave();\n        // Run our executors outside of the lock\n        executeListeners();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireStoppedListeners() {\n      STOPPED_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireHealthyListeners() {\n      HEALTHY_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireFailedListeners(final Service service) {\n      new Callback<Listener>(\"failed({service=\" + service + \"})\") {\n        @Override void call(Listener listener) {\n          listener.failure(service);\n        }\n      }.enqueueOn(listeners);\n    }\n\n    /** Attempts to execute all the listeners in {@link #listeners}. */\n    void executeListeners() {\n      checkState(!monitor.isOccupiedByCurrentThread(),\n          \"It is incorrect to execute listeners with the monitor held.\");\n      // iterate by index to avoid concurrent modification exceptions\n      for (int i = 0; i < listeners.size(); i++) {\n        listeners.get(i).execute();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void checkHealthy() {\n      if (states.count(RUNNING) != numberOfServices) {\n        IllegalStateException exception = new IllegalStateException(\n            \"Expected to be healthy after starting. The following services are not running: \"\n                + Multimaps.filterKeys(servicesByState, not(equalTo(RUNNING))));\n        throw exception;\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} that wraps another service and times how long it takes for it to start and\n   * also calls the {@link ServiceManagerState#transitionService(Service, State, State)},\n   * to record the state transitions.\n   */\n  private static final class ServiceListener extends Service.Listener {\n    final Service service;\n    // We store the state in a weak reference to ensure that if something went wrong while\n    // constructing the ServiceManager we don't pointlessly keep updating the state.\n    final WeakReference<ServiceManagerState> state;\n\n    ServiceListener(Service service, WeakReference<ServiceManagerState> state) {\n      this.service = service;\n      this.state = state;\n    }\n\n    @Override public void starting() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, NEW, STARTING);\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Starting {0}.\", service);\n        }\n      }\n    }\n\n    @Override public void running() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, STARTING, RUNNING);\n      }\n    }\n\n    @Override public void stopping(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, from, STOPPING);\n      }\n    }\n\n    @Override public void terminated(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Service {0} has terminated. Previous state was: {1}\",\n              new Object[] {service, from});\n        }\n        state.transitionService(service, from, TERMINATED);\n      }\n    }\n\n    @Override public void failed(State from, Throwable failure) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        // Log before the transition, so that if the process exits in response to server failure,\n        // there is a higher likelihood that the cause will be in the logs.\n        if (!(service instanceof NoOpService) ) {\n          logger.log(Level.SEVERE, \"Service \" + service + \" has failed in the \" + from + \" state.\",\n              failure);\n        }\n        state.transitionService(service, from, FAILED);\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} instance that does nothing.  This is only useful as a placeholder to\n   * ensure that the {@link ServiceManager} functions properly even when it is managing no services.\n   *\n   * <p>The use of this class is considered an implementation detail of ServiceManager and as such\n   * it is excluded from {@link #servicesByState}, {@link #startupTimes}, {@link #toString} and all\n   * logging statements.\n   */\n  private static final class NoOpService extends AbstractService {\n    @Override protected void doStart() { notifyStarted(); }\n    @Override protected void doStop() { notifyStopped(); }\n  }\n\n  /** This is never thrown but only used for logging. */\n  private static final class EmptyServiceManagerWarning extends Throwable {}\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53080229,"label":true,"oracleId":1447,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"ServiceManager","javadocTag":"@return this","methodJavadoc":"    /**\n   * Initiates service {@linkplain Service#startAsync startup} on all the services being managed.\n   * It is only valid to call this method if all of the services are {@linkplain State#NEW new}.\n   *\n   * @return this\n   * @throws IllegalStateException if any of the Services are not {@link State#NEW new} when the\n   *     method is called.\n   */","methodSourceCode":"public ServiceManager startAsync(){\n    for (Service service : services) {\n        State state = service.state();\n        checkState(state == NEW, \"Service %s is %s, cannot start it.\", service, state);\n    }\n    for (Service service : services) {\n        try {\n            state.tryStartTiming(service);\n            service.startAsync();\n        } catch (IllegalStateException e) {\n            // This can happen if the service has already been started or stopped (e.g. by another\n            // service or listener). Our contract says it is safe to call this method if\n            // all services were NEW when it was called, and this has already been verified above, so we\n            // don't propagate the exception.\n            logger.log(Level.WARNING, \"Unable to start Service \" + service, e);\n        }\n    }\n    return this;\n}","classJavadoc":"/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */","classSourceCode":"/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Predicates.equalTo;\nimport static com.google.common.base.Predicates.in;\nimport static com.google.common.base.Predicates.instanceOf;\nimport static com.google.common.base.Predicates.not;\nimport static com.google.common.util.concurrent.MoreExecutors.directExecutor;\nimport static com.google.common.util.concurrent.Service.State.FAILED;\nimport static com.google.common.util.concurrent.Service.State.NEW;\nimport static com.google.common.util.concurrent.Service.State.RUNNING;\nimport static com.google.common.util.concurrent.Service.State.STARTING;\nimport static com.google.common.util.concurrent.Service.State.STOPPING;\nimport static com.google.common.util.concurrent.Service.State.TERMINATED;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.base.Function;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Stopwatch;\nimport com.google.common.collect.Collections2;\nimport com.google.common.collect.ImmutableCollection;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableMultimap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSetMultimap;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.MultimapBuilder;\nimport com.google.common.collect.Multimaps;\nimport com.google.common.collect.Multiset;\nimport com.google.common.collect.Ordering;\nimport com.google.common.collect.SetMultimap;\nimport com.google.common.util.concurrent.ListenerCallQueue.Callback;\nimport com.google.common.util.concurrent.Service.State;\nimport com.google.j2objc.annotations.WeakOuter;\n\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */\n@Beta\npublic final class ServiceManager {\n  private static final Logger logger = Logger.getLogger(ServiceManager.class.getName());\n  private static final Callback<Listener> HEALTHY_CALLBACK = new Callback<Listener>(\"healthy()\") {\n    @Override void call(Listener listener) {\n      listener.healthy();\n    }\n  };\n  private static final Callback<Listener> STOPPED_CALLBACK = new Callback<Listener>(\"stopped()\") {\n    @Override void call(Listener listener) {\n      listener.stopped();\n    }\n  };\n\n  /**\n   * A listener for the aggregate state changes of the services that are under management. Users\n   * that need to listen to more fine-grained events (such as when each particular {@linkplain\n   * Service service} starts, or terminates), should attach {@linkplain Service.Listener service\n   * listeners} to each individual service.\n   *\n   * @author Luke Sandberg\n   * @since 15.0 (present as an interface in 14.0)\n   */\n  @Beta  // Should come out of Beta when ServiceManager does\n  public abstract static class Listener {\n    /**\n     * Called when the service initially becomes healthy.\n     *\n     * <p>This will be called at most once after all the services have entered the\n     * {@linkplain State#RUNNING running} state. If any services fail during start up or\n     * {@linkplain State#FAILED fail}/{@linkplain State#TERMINATED terminate} before all other\n     * services have started {@linkplain State#RUNNING running} then this method will not be called.\n     */\n    public void healthy() {}\n\n    /**\n     * Called when the all of the component services have reached a terminal state, either\n     * {@linkplain State#TERMINATED terminated} or {@linkplain State#FAILED failed}.\n     */\n    public void stopped() {}\n\n    /**\n     * Called when a component service has {@linkplain State#FAILED failed}.\n     *\n     * @param service The service that failed.\n     */\n    public void failure(Service service) {}\n  }\n\n  /**\n   * An encapsulation of all of the state that is accessed by the {@linkplain ServiceListener\n   * service listeners}.  This is extracted into its own object so that {@link ServiceListener}\n   * could be made {@code static} and its instances can be safely constructed and added in the\n   * {@link ServiceManager} constructor without having to close over the partially constructed\n   * {@link ServiceManager} instance (i.e. avoid leaking a pointer to {@code this}).\n   */\n  private final ServiceManagerState state;\n  private final ImmutableList<Service> services;\n\n  /**\n   * Constructs a new instance for managing the given services.\n   *\n   * @param services The services to manage\n   *\n   * @throws IllegalArgumentException if not all services are {@linkplain State#NEW new} or if there\n   * are any duplicate services.\n   */\n  public ServiceManager(Iterable<? extends Service> services) {\n    ImmutableList<Service> copy = ImmutableList.copyOf(services);\n    if (copy.isEmpty()) {\n      // Having no services causes the manager to behave strangely. Notably, listeners are never\n      // fired.  To avoid this we substitute a placeholder service.\n      logger.log(Level.WARNING,\n          \"ServiceManager configured with no services.  Is your application configured properly?\",\n          new EmptyServiceManagerWarning());\n      copy = ImmutableList.<Service>of(new NoOpService());\n    }\n    this.state = new ServiceManagerState(copy);\n    this.services = copy;\n    WeakReference<ServiceManagerState> stateReference =\n        new WeakReference<ServiceManagerState>(state);\n    for (Service service : copy) {\n      service.addListener(new ServiceListener(service, stateReference), directExecutor());\n      // We check the state after adding the listener as a way to ensure that our listener was added\n      // to a NEW service.\n      checkArgument(service.state() == NEW, \"Can only manage NEW services, %s\", service);\n    }\n    // We have installed all of our listeners and after this point any state transition should be\n    // correct.\n    this.state.markReady();\n  }\n\n  /**\n   * Registers a {@link Listener} to be {@linkplain Executor#execute executed} on the given\n   * executor. The listener will not have previous state changes replayed, so it is\n   * suggested that listeners are added before any of the managed services are\n   * {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged. Any exception thrown\n   * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException}) will be caught and\n   * logged.\n   *\n   * <p> For fast, lightweight listeners that would be safe to execute in any thread, consider\n   * calling {@link #addListener(Listener)}.\n   *\n   * @param listener the listener to run when the manager changes state\n   * @param executor the executor in which the listeners callback methods will be run.\n   */\n  public void addListener(Listener listener, Executor executor) {\n    state.addListener(listener, executor);\n  }\n\n  /**\n   * Registers a {@link Listener} to be run when this {@link ServiceManager} changes state. The\n   * listener will not have previous state changes replayed, so it is suggested that listeners are\n   * added before any of the managed services are {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged.\n   *\n   * @param listener the listener to run when the manager changes state\n   */\n  public void addListener(Listener listener) {\n    state.addListener(listener, directExecutor());\n  }\n\n  /**\n   * Initiates service {@linkplain Service#startAsync startup} on all the services being managed.\n   * It is only valid to call this method if all of the services are {@linkplain State#NEW new}.\n   *\n   * @return this\n   * @throws IllegalStateException if any of the Services are not {@link State#NEW new} when the\n   *     method is called.\n   */\n  public ServiceManager startAsync() {\n    for (Service service : services) {\n      State state = service.state();\n      checkState(state == NEW, \"Service %s is %s, cannot start it.\", service, state);\n    }\n    for (Service service : services) {\n      try {\n        state.tryStartTiming(service);\n        service.startAsync();\n      } catch (IllegalStateException e) {\n        // This can happen if the service has already been started or stopped (e.g. by another\n        // service or listener). Our contract says it is safe to call this method if\n        // all services were NEW when it was called, and this has already been verified above, so we\n        // don't propagate the exception.\n        logger.log(Level.WARNING, \"Unable to start Service \" + service, e);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy}.  The manager\n   * will become healthy after all the component services have reached the {@linkplain State#RUNNING\n   * running} state.\n   *\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy() {\n    state.awaitHealthy();\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy} for no more\n   * than the given time.  The manager will become healthy after all the component services have\n   * reached the {@linkplain State#RUNNING running} state.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have finished starting within the deadline\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitHealthy(timeout, unit);\n  }\n\n  /**\n   * Initiates service {@linkplain Service#stopAsync shutdown} if necessary on all the services\n   * being managed.\n   *\n   * @return this\n   */\n  public ServiceManager stopAsync() {\n    for (Service service : services) {\n      service.stopAsync();\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state. After this method returns all\n   * services will either be {@linkplain Service.State#TERMINATED terminated} or {@linkplain\n   * Service.State#FAILED failed}.\n   */\n  public void awaitStopped() {\n    state.awaitStopped();\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state for no more than the given time. After\n   * this method returns all services will either be {@linkplain Service.State#TERMINATED\n   * terminated} or {@linkplain Service.State#FAILED failed}.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have stopped within the deadline\n   */\n  public void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitStopped(timeout, unit);\n  }\n\n  /**\n   * Returns true if all services are currently in the {@linkplain State#RUNNING running} state.\n   *\n   * <p>Users who want more detailed information should use the {@link #servicesByState} method to\n   * get detailed information about which services are not running.\n   */\n  public boolean isHealthy() {\n    for (Service service : services) {\n      if (!service.isRunning()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Provides a snapshot of the current state of all the services under management.\n   *\n   * <p>N.B. This snapshot is guaranteed to be consistent, i.e. the set of states returned will\n   * correspond to a point in time view of the services.\n   */\n  public ImmutableMultimap<State, Service> servicesByState() {\n    return state.servicesByState();\n  }\n\n  /**\n   * Returns the service load times. This value will only return startup times for services that\n   * have finished starting.\n   *\n   * @return Map of services and their corresponding startup time in millis, the map entries will be\n   *     ordered by startup time.\n   */\n  public ImmutableMap<Service, Long> startupTimes() {\n    return state.startupTimes();\n  }\n\n  @Override public String toString() {\n    return MoreObjects.toStringHelper(ServiceManager.class)\n        .add(\"services\", Collections2.filter(services, not(instanceOf(NoOpService.class))))\n        .toString();\n  }\n\n  /**\n   * An encapsulation of all the mutable state of the {@link ServiceManager} that needs to be\n   * accessed by instances of {@link ServiceListener}.\n   */\n  private static final class ServiceManagerState {\n    final Monitor monitor = new Monitor();\n\n    @GuardedBy(\"monitor\")\n    final SetMultimap<State, Service> servicesByState =\n        MultimapBuilder.enumKeys(State.class).linkedHashSetValues().build();\n\n    @GuardedBy(\"monitor\")\n    final Multiset<State> states = servicesByState.keys();\n\n    @GuardedBy(\"monitor\")\n    final Map<Service, Stopwatch> startupTimers = Maps.newIdentityHashMap();\n\n    /**\n     * These two booleans are used to mark the state as ready to start.\n     * {@link #ready}: is set by {@link #markReady} to indicate that all listeners have been\n     *     correctly installed\n     * {@link #transitioned}: is set by {@link #transitionService} to indicate that some transition\n     *     has been performed.\n     *\n     * <p>Together, they allow us to enforce that all services have their listeners installed prior\n     * to any service performing a transition, then we can fail in the ServiceManager constructor\n     * rather than in a Service.Listener callback.\n     */\n    @GuardedBy(\"monitor\")\n    boolean ready;\n\n    @GuardedBy(\"monitor\")\n    boolean transitioned;\n\n    final int numberOfServices;\n\n    /**\n     * Controls how long to wait for all the services to either become healthy or reach a\n     * state from which it is guaranteed that it can never become healthy.\n     */\n    final Monitor.Guard awaitHealthGuard = new AwaitHealthGuard();\n\n    @WeakOuter\n    final class AwaitHealthGuard extends Monitor.Guard {\n      AwaitHealthGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        // All services have started or some service has terminated/failed.\n        return states.count(RUNNING) == numberOfServices\n            || states.contains(STOPPING)\n            || states.contains(TERMINATED)\n            || states.contains(FAILED);\n      }\n    }\n\n    /**\n     * Controls how long to wait for all services to reach a terminal state.\n     */\n    final Monitor.Guard stoppedGuard = new StoppedGuard();\n\n    @WeakOuter\n    final class StoppedGuard extends Monitor.Guard {\n      StoppedGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        return states.count(TERMINATED) + states.count(FAILED) == numberOfServices;\n      }\n    }\n\n    /** The listeners to notify during a state transition. */\n    @GuardedBy(\"monitor\")\n    final List<ListenerCallQueue<Listener>> listeners =\n        Collections.synchronizedList(new ArrayList<ListenerCallQueue<Listener>>());\n\n    /**\n     * It is implicitly assumed that all the services are NEW and that they will all remain NEW\n     * until all the Listeners are installed and {@link #markReady()} is called.  It is our caller's\n     * responsibility to only call {@link #markReady()} if all services were new at the time this\n     * method was called and when all the listeners were installed.\n     */\n    ServiceManagerState(ImmutableCollection<Service> services) {\n      this.numberOfServices = services.size();\n      servicesByState.putAll(NEW, services);\n    }\n\n    /**\n     * Attempts to start the timer immediately prior to the service being started via\n     * {@link Service#startAsync()}.\n     */\n    void tryStartTiming(Service service) {\n      monitor.enter();\n      try {\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          startupTimers.put(service, Stopwatch.createStarted());\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    /**\n     * Marks the {@link State} as ready to receive transitions. Returns true if no transitions have\n     * been observed yet.\n     */\n    void markReady() {\n      monitor.enter();\n      try {\n        if (!transitioned) {\n          // nothing has transitioned since construction, good.\n          ready = true;\n        } else {\n          // This should be an extremely rare race condition.\n          List<Service> servicesInBadStates = Lists.newArrayList();\n          for (Service service : servicesByState().values()) {\n            if (service.state() != NEW) {\n              servicesInBadStates.add(service);\n            }\n          }\n          throw new IllegalArgumentException(\"Services started transitioning asynchronously before \"\n              + \"the ServiceManager was constructed: \" + servicesInBadStates);\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void addListener(Listener listener, Executor executor) {\n      checkNotNull(listener, \"listener\");\n      checkNotNull(executor, \"executor\");\n      monitor.enter();\n      try {\n        // no point in adding a listener that will never be called\n        if (!stoppedGuard.isSatisfied()) {\n          listeners.add(new ListenerCallQueue<Listener>(listener, executor));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy() {\n      monitor.enterWhenUninterruptibly(awaitHealthGuard);\n      try {\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(awaitHealthGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to become healthy. The \"\n              + \"following services have not started: \"\n              + Multimaps.filterKeys(servicesByState, in(ImmutableSet.of(NEW, STARTING))));\n        }\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitStopped() {\n      monitor.enterWhenUninterruptibly(stoppedGuard);\n      monitor.leave();\n    }\n\n    void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(stoppedGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to stop. The following \"\n              + \"services have not stopped: \"\n              + Multimaps.filterKeys(servicesByState,\n                  not(in(EnumSet.of(TERMINATED, FAILED)))));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    ImmutableMultimap<State, Service> servicesByState() {\n      ImmutableSetMultimap.Builder<State, Service> builder = ImmutableSetMultimap.builder();\n      monitor.enter();\n      try {\n        for (Entry<State, Service> entry : servicesByState.entries()) {\n          if (!(entry.getValue() instanceof NoOpService)) {\n            builder.put(entry);\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      return builder.build();\n    }\n\n    ImmutableMap<Service, Long> startupTimes() {\n      List<Entry<Service, Long>> loadTimes;\n      monitor.enter();\n      try {\n        loadTimes = Lists.newArrayListWithCapacity(startupTimers.size());\n        // N.B. There will only be an entry in the map if the service has started\n        for (Entry<Service, Stopwatch> entry : startupTimers.entrySet()) {\n          Service service = entry.getKey();\n          Stopwatch stopWatch = entry.getValue();\n          if (!stopWatch.isRunning() && !(service instanceof NoOpService)) {\n            loadTimes.add(Maps.immutableEntry(service, stopWatch.elapsed(MILLISECONDS)));\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      Collections.sort(loadTimes, Ordering.natural()\n          .onResultOf(new Function<Entry<Service, Long>, Long>() {\n            @Override public Long apply(Map.Entry<Service, Long> input) {\n              return input.getValue();\n            }\n          }));\n      return ImmutableMap.copyOf(loadTimes);\n    }\n\n    /**\n     * Updates the state with the given service transition.\n     *\n     * <p>This method performs the main logic of ServiceManager in the following steps.\n     * <ol>\n     *      <li>Update the {@link #servicesByState()}\n     *      <li>Update the {@link #startupTimers}\n     *      <li>Based on the new state queue listeners to run\n     *      <li>Run the listeners (outside of the lock)\n     * </ol>\n     */\n    void transitionService(final Service service, State from, State to) {\n      checkNotNull(service);\n      checkArgument(from != to);\n      monitor.enter();\n      try {\n        transitioned = true;\n        if (!ready) {\n          return;\n        }\n        // Update state.\n        checkState(servicesByState.remove(from, service),\n            \"Service %s not at the expected location in the state map %s\", service, from);\n        checkState(servicesByState.put(to, service),\n            \"Service %s in the state map unexpectedly at %s\", service, to);\n        // Update the timer\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          // This means the service was started by some means other than ServiceManager.startAsync\n          stopwatch = Stopwatch.createStarted();\n          startupTimers.put(service, stopwatch);\n        }\n        if (to.compareTo(RUNNING) >= 0 && stopwatch.isRunning()) {\n          // N.B. if we miss the STARTING event then we may never record a startup time.\n          stopwatch.stop();\n          if (!(service instanceof NoOpService)) {\n            logger.log(Level.FINE, \"Started {0} in {1}.\", new Object[] {service, stopwatch});\n          }\n        }\n        // Queue our listeners\n\n        // Did a service fail?\n        if (to == FAILED) {\n          fireFailedListeners(service);\n        }\n\n        if (states.count(RUNNING) == numberOfServices) {\n          // This means that the manager is currently healthy. N.B. If other threads call isHealthy\n          // they are not guaranteed to get 'true', because any service could fail right now.\n          fireHealthyListeners();\n        } else if (states.count(TERMINATED) + states.count(FAILED) == numberOfServices) {\n          fireStoppedListeners();\n        }\n      } finally {\n        monitor.leave();\n        // Run our executors outside of the lock\n        executeListeners();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireStoppedListeners() {\n      STOPPED_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireHealthyListeners() {\n      HEALTHY_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireFailedListeners(final Service service) {\n      new Callback<Listener>(\"failed({service=\" + service + \"})\") {\n        @Override void call(Listener listener) {\n          listener.failure(service);\n        }\n      }.enqueueOn(listeners);\n    }\n\n    /** Attempts to execute all the listeners in {@link #listeners}. */\n    void executeListeners() {\n      checkState(!monitor.isOccupiedByCurrentThread(),\n          \"It is incorrect to execute listeners with the monitor held.\");\n      // iterate by index to avoid concurrent modification exceptions\n      for (int i = 0; i < listeners.size(); i++) {\n        listeners.get(i).execute();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void checkHealthy() {\n      if (states.count(RUNNING) != numberOfServices) {\n        IllegalStateException exception = new IllegalStateException(\n            \"Expected to be healthy after starting. The following services are not running: \"\n                + Multimaps.filterKeys(servicesByState, not(equalTo(RUNNING))));\n        throw exception;\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} that wraps another service and times how long it takes for it to start and\n   * also calls the {@link ServiceManagerState#transitionService(Service, State, State)},\n   * to record the state transitions.\n   */\n  private static final class ServiceListener extends Service.Listener {\n    final Service service;\n    // We store the state in a weak reference to ensure that if something went wrong while\n    // constructing the ServiceManager we don't pointlessly keep updating the state.\n    final WeakReference<ServiceManagerState> state;\n\n    ServiceListener(Service service, WeakReference<ServiceManagerState> state) {\n      this.service = service;\n      this.state = state;\n    }\n\n    @Override public void starting() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, NEW, STARTING);\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Starting {0}.\", service);\n        }\n      }\n    }\n\n    @Override public void running() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, STARTING, RUNNING);\n      }\n    }\n\n    @Override public void stopping(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, from, STOPPING);\n      }\n    }\n\n    @Override public void terminated(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Service {0} has terminated. Previous state was: {1}\",\n              new Object[] {service, from});\n        }\n        state.transitionService(service, from, TERMINATED);\n      }\n    }\n\n    @Override public void failed(State from, Throwable failure) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        // Log before the transition, so that if the process exits in response to server failure,\n        // there is a higher likelihood that the cause will be in the logs.\n        if (!(service instanceof NoOpService) ) {\n          logger.log(Level.SEVERE, \"Service \" + service + \" has failed in the \" + from + \" state.\",\n              failure);\n        }\n        state.transitionService(service, from, FAILED);\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} instance that does nothing.  This is only useful as a placeholder to\n   * ensure that the {@link ServiceManager} functions properly even when it is managing no services.\n   *\n   * <p>The use of this class is considered an implementation detail of ServiceManager and as such\n   * it is excluded from {@link #servicesByState}, {@link #startupTimes}, {@link #toString} and all\n   * logging statements.\n   */\n  private static final class NoOpService extends AbstractService {\n    @Override protected void doStart() { notifyStarted(); }\n    @Override protected void doStop() { notifyStopped(); }\n  }\n\n  /** This is never thrown but only used for logging. */\n  private static final class EmptyServiceManagerWarning extends Throwable {}\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53080687,"label":true,"oracleId":1448,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"ServiceManager","javadocTag":"@throws IllegalStateException if any of the Services are not {@link State#NEW new} when the\n    method is called.","methodJavadoc":"    /**\n   * Initiates service {@linkplain Service#startAsync startup} on all the services being managed.\n   * It is only valid to call this method if all of the services are {@linkplain State#NEW new}.\n   *\n   * @return this\n   * @throws IllegalStateException if any of the Services are not {@link State#NEW new} when the\n   *     method is called.\n   */","methodSourceCode":"public ServiceManager startAsync(){\n    for (Service service : services) {\n        State state = service.state();\n        checkState(state == NEW, \"Service %s is %s, cannot start it.\", service, state);\n    }\n    for (Service service : services) {\n        try {\n            state.tryStartTiming(service);\n            service.startAsync();\n        } catch (IllegalStateException e) {\n            // This can happen if the service has already been started or stopped (e.g. by another\n            // service or listener). Our contract says it is safe to call this method if\n            // all services were NEW when it was called, and this has already been verified above, so we\n            // don't propagate the exception.\n            logger.log(Level.WARNING, \"Unable to start Service \" + service, e);\n        }\n    }\n    return this;\n}","classJavadoc":"/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */","classSourceCode":"/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Predicates.equalTo;\nimport static com.google.common.base.Predicates.in;\nimport static com.google.common.base.Predicates.instanceOf;\nimport static com.google.common.base.Predicates.not;\nimport static com.google.common.util.concurrent.MoreExecutors.directExecutor;\nimport static com.google.common.util.concurrent.Service.State.FAILED;\nimport static com.google.common.util.concurrent.Service.State.NEW;\nimport static com.google.common.util.concurrent.Service.State.RUNNING;\nimport static com.google.common.util.concurrent.Service.State.STARTING;\nimport static com.google.common.util.concurrent.Service.State.STOPPING;\nimport static com.google.common.util.concurrent.Service.State.TERMINATED;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.base.Function;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Stopwatch;\nimport com.google.common.collect.Collections2;\nimport com.google.common.collect.ImmutableCollection;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableMultimap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSetMultimap;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.MultimapBuilder;\nimport com.google.common.collect.Multimaps;\nimport com.google.common.collect.Multiset;\nimport com.google.common.collect.Ordering;\nimport com.google.common.collect.SetMultimap;\nimport com.google.common.util.concurrent.ListenerCallQueue.Callback;\nimport com.google.common.util.concurrent.Service.State;\nimport com.google.j2objc.annotations.WeakOuter;\n\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */\n@Beta\npublic final class ServiceManager {\n  private static final Logger logger = Logger.getLogger(ServiceManager.class.getName());\n  private static final Callback<Listener> HEALTHY_CALLBACK = new Callback<Listener>(\"healthy()\") {\n    @Override void call(Listener listener) {\n      listener.healthy();\n    }\n  };\n  private static final Callback<Listener> STOPPED_CALLBACK = new Callback<Listener>(\"stopped()\") {\n    @Override void call(Listener listener) {\n      listener.stopped();\n    }\n  };\n\n  /**\n   * A listener for the aggregate state changes of the services that are under management. Users\n   * that need to listen to more fine-grained events (such as when each particular {@linkplain\n   * Service service} starts, or terminates), should attach {@linkplain Service.Listener service\n   * listeners} to each individual service.\n   *\n   * @author Luke Sandberg\n   * @since 15.0 (present as an interface in 14.0)\n   */\n  @Beta  // Should come out of Beta when ServiceManager does\n  public abstract static class Listener {\n    /**\n     * Called when the service initially becomes healthy.\n     *\n     * <p>This will be called at most once after all the services have entered the\n     * {@linkplain State#RUNNING running} state. If any services fail during start up or\n     * {@linkplain State#FAILED fail}/{@linkplain State#TERMINATED terminate} before all other\n     * services have started {@linkplain State#RUNNING running} then this method will not be called.\n     */\n    public void healthy() {}\n\n    /**\n     * Called when the all of the component services have reached a terminal state, either\n     * {@linkplain State#TERMINATED terminated} or {@linkplain State#FAILED failed}.\n     */\n    public void stopped() {}\n\n    /**\n     * Called when a component service has {@linkplain State#FAILED failed}.\n     *\n     * @param service The service that failed.\n     */\n    public void failure(Service service) {}\n  }\n\n  /**\n   * An encapsulation of all of the state that is accessed by the {@linkplain ServiceListener\n   * service listeners}.  This is extracted into its own object so that {@link ServiceListener}\n   * could be made {@code static} and its instances can be safely constructed and added in the\n   * {@link ServiceManager} constructor without having to close over the partially constructed\n   * {@link ServiceManager} instance (i.e. avoid leaking a pointer to {@code this}).\n   */\n  private final ServiceManagerState state;\n  private final ImmutableList<Service> services;\n\n  /**\n   * Constructs a new instance for managing the given services.\n   *\n   * @param services The services to manage\n   *\n   * @throws IllegalArgumentException if not all services are {@linkplain State#NEW new} or if there\n   * are any duplicate services.\n   */\n  public ServiceManager(Iterable<? extends Service> services) {\n    ImmutableList<Service> copy = ImmutableList.copyOf(services);\n    if (copy.isEmpty()) {\n      // Having no services causes the manager to behave strangely. Notably, listeners are never\n      // fired.  To avoid this we substitute a placeholder service.\n      logger.log(Level.WARNING,\n          \"ServiceManager configured with no services.  Is your application configured properly?\",\n          new EmptyServiceManagerWarning());\n      copy = ImmutableList.<Service>of(new NoOpService());\n    }\n    this.state = new ServiceManagerState(copy);\n    this.services = copy;\n    WeakReference<ServiceManagerState> stateReference =\n        new WeakReference<ServiceManagerState>(state);\n    for (Service service : copy) {\n      service.addListener(new ServiceListener(service, stateReference), directExecutor());\n      // We check the state after adding the listener as a way to ensure that our listener was added\n      // to a NEW service.\n      checkArgument(service.state() == NEW, \"Can only manage NEW services, %s\", service);\n    }\n    // We have installed all of our listeners and after this point any state transition should be\n    // correct.\n    this.state.markReady();\n  }\n\n  /**\n   * Registers a {@link Listener} to be {@linkplain Executor#execute executed} on the given\n   * executor. The listener will not have previous state changes replayed, so it is\n   * suggested that listeners are added before any of the managed services are\n   * {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged. Any exception thrown\n   * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException}) will be caught and\n   * logged.\n   *\n   * <p> For fast, lightweight listeners that would be safe to execute in any thread, consider\n   * calling {@link #addListener(Listener)}.\n   *\n   * @param listener the listener to run when the manager changes state\n   * @param executor the executor in which the listeners callback methods will be run.\n   */\n  public void addListener(Listener listener, Executor executor) {\n    state.addListener(listener, executor);\n  }\n\n  /**\n   * Registers a {@link Listener} to be run when this {@link ServiceManager} changes state. The\n   * listener will not have previous state changes replayed, so it is suggested that listeners are\n   * added before any of the managed services are {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged.\n   *\n   * @param listener the listener to run when the manager changes state\n   */\n  public void addListener(Listener listener) {\n    state.addListener(listener, directExecutor());\n  }\n\n  /**\n   * Initiates service {@linkplain Service#startAsync startup} on all the services being managed.\n   * It is only valid to call this method if all of the services are {@linkplain State#NEW new}.\n   *\n   * @return this\n   * @throws IllegalStateException if any of the Services are not {@link State#NEW new} when the\n   *     method is called.\n   */\n  public ServiceManager startAsync() {\n    for (Service service : services) {\n      State state = service.state();\n      checkState(state == NEW, \"Service %s is %s, cannot start it.\", service, state);\n    }\n    for (Service service : services) {\n      try {\n        state.tryStartTiming(service);\n        service.startAsync();\n      } catch (IllegalStateException e) {\n        // This can happen if the service has already been started or stopped (e.g. by another\n        // service or listener). Our contract says it is safe to call this method if\n        // all services were NEW when it was called, and this has already been verified above, so we\n        // don't propagate the exception.\n        logger.log(Level.WARNING, \"Unable to start Service \" + service, e);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy}.  The manager\n   * will become healthy after all the component services have reached the {@linkplain State#RUNNING\n   * running} state.\n   *\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy() {\n    state.awaitHealthy();\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy} for no more\n   * than the given time.  The manager will become healthy after all the component services have\n   * reached the {@linkplain State#RUNNING running} state.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have finished starting within the deadline\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitHealthy(timeout, unit);\n  }\n\n  /**\n   * Initiates service {@linkplain Service#stopAsync shutdown} if necessary on all the services\n   * being managed.\n   *\n   * @return this\n   */\n  public ServiceManager stopAsync() {\n    for (Service service : services) {\n      service.stopAsync();\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state. After this method returns all\n   * services will either be {@linkplain Service.State#TERMINATED terminated} or {@linkplain\n   * Service.State#FAILED failed}.\n   */\n  public void awaitStopped() {\n    state.awaitStopped();\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state for no more than the given time. After\n   * this method returns all services will either be {@linkplain Service.State#TERMINATED\n   * terminated} or {@linkplain Service.State#FAILED failed}.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have stopped within the deadline\n   */\n  public void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitStopped(timeout, unit);\n  }\n\n  /**\n   * Returns true if all services are currently in the {@linkplain State#RUNNING running} state.\n   *\n   * <p>Users who want more detailed information should use the {@link #servicesByState} method to\n   * get detailed information about which services are not running.\n   */\n  public boolean isHealthy() {\n    for (Service service : services) {\n      if (!service.isRunning()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Provides a snapshot of the current state of all the services under management.\n   *\n   * <p>N.B. This snapshot is guaranteed to be consistent, i.e. the set of states returned will\n   * correspond to a point in time view of the services.\n   */\n  public ImmutableMultimap<State, Service> servicesByState() {\n    return state.servicesByState();\n  }\n\n  /**\n   * Returns the service load times. This value will only return startup times for services that\n   * have finished starting.\n   *\n   * @return Map of services and their corresponding startup time in millis, the map entries will be\n   *     ordered by startup time.\n   */\n  public ImmutableMap<Service, Long> startupTimes() {\n    return state.startupTimes();\n  }\n\n  @Override public String toString() {\n    return MoreObjects.toStringHelper(ServiceManager.class)\n        .add(\"services\", Collections2.filter(services, not(instanceOf(NoOpService.class))))\n        .toString();\n  }\n\n  /**\n   * An encapsulation of all the mutable state of the {@link ServiceManager} that needs to be\n   * accessed by instances of {@link ServiceListener}.\n   */\n  private static final class ServiceManagerState {\n    final Monitor monitor = new Monitor();\n\n    @GuardedBy(\"monitor\")\n    final SetMultimap<State, Service> servicesByState =\n        MultimapBuilder.enumKeys(State.class).linkedHashSetValues().build();\n\n    @GuardedBy(\"monitor\")\n    final Multiset<State> states = servicesByState.keys();\n\n    @GuardedBy(\"monitor\")\n    final Map<Service, Stopwatch> startupTimers = Maps.newIdentityHashMap();\n\n    /**\n     * These two booleans are used to mark the state as ready to start.\n     * {@link #ready}: is set by {@link #markReady} to indicate that all listeners have been\n     *     correctly installed\n     * {@link #transitioned}: is set by {@link #transitionService} to indicate that some transition\n     *     has been performed.\n     *\n     * <p>Together, they allow us to enforce that all services have their listeners installed prior\n     * to any service performing a transition, then we can fail in the ServiceManager constructor\n     * rather than in a Service.Listener callback.\n     */\n    @GuardedBy(\"monitor\")\n    boolean ready;\n\n    @GuardedBy(\"monitor\")\n    boolean transitioned;\n\n    final int numberOfServices;\n\n    /**\n     * Controls how long to wait for all the services to either become healthy or reach a\n     * state from which it is guaranteed that it can never become healthy.\n     */\n    final Monitor.Guard awaitHealthGuard = new AwaitHealthGuard();\n\n    @WeakOuter\n    final class AwaitHealthGuard extends Monitor.Guard {\n      AwaitHealthGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        // All services have started or some service has terminated/failed.\n        return states.count(RUNNING) == numberOfServices\n            || states.contains(STOPPING)\n            || states.contains(TERMINATED)\n            || states.contains(FAILED);\n      }\n    }\n\n    /**\n     * Controls how long to wait for all services to reach a terminal state.\n     */\n    final Monitor.Guard stoppedGuard = new StoppedGuard();\n\n    @WeakOuter\n    final class StoppedGuard extends Monitor.Guard {\n      StoppedGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        return states.count(TERMINATED) + states.count(FAILED) == numberOfServices;\n      }\n    }\n\n    /** The listeners to notify during a state transition. */\n    @GuardedBy(\"monitor\")\n    final List<ListenerCallQueue<Listener>> listeners =\n        Collections.synchronizedList(new ArrayList<ListenerCallQueue<Listener>>());\n\n    /**\n     * It is implicitly assumed that all the services are NEW and that they will all remain NEW\n     * until all the Listeners are installed and {@link #markReady()} is called.  It is our caller's\n     * responsibility to only call {@link #markReady()} if all services were new at the time this\n     * method was called and when all the listeners were installed.\n     */\n    ServiceManagerState(ImmutableCollection<Service> services) {\n      this.numberOfServices = services.size();\n      servicesByState.putAll(NEW, services);\n    }\n\n    /**\n     * Attempts to start the timer immediately prior to the service being started via\n     * {@link Service#startAsync()}.\n     */\n    void tryStartTiming(Service service) {\n      monitor.enter();\n      try {\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          startupTimers.put(service, Stopwatch.createStarted());\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    /**\n     * Marks the {@link State} as ready to receive transitions. Returns true if no transitions have\n     * been observed yet.\n     */\n    void markReady() {\n      monitor.enter();\n      try {\n        if (!transitioned) {\n          // nothing has transitioned since construction, good.\n          ready = true;\n        } else {\n          // This should be an extremely rare race condition.\n          List<Service> servicesInBadStates = Lists.newArrayList();\n          for (Service service : servicesByState().values()) {\n            if (service.state() != NEW) {\n              servicesInBadStates.add(service);\n            }\n          }\n          throw new IllegalArgumentException(\"Services started transitioning asynchronously before \"\n              + \"the ServiceManager was constructed: \" + servicesInBadStates);\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void addListener(Listener listener, Executor executor) {\n      checkNotNull(listener, \"listener\");\n      checkNotNull(executor, \"executor\");\n      monitor.enter();\n      try {\n        // no point in adding a listener that will never be called\n        if (!stoppedGuard.isSatisfied()) {\n          listeners.add(new ListenerCallQueue<Listener>(listener, executor));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy() {\n      monitor.enterWhenUninterruptibly(awaitHealthGuard);\n      try {\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(awaitHealthGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to become healthy. The \"\n              + \"following services have not started: \"\n              + Multimaps.filterKeys(servicesByState, in(ImmutableSet.of(NEW, STARTING))));\n        }\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitStopped() {\n      monitor.enterWhenUninterruptibly(stoppedGuard);\n      monitor.leave();\n    }\n\n    void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(stoppedGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to stop. The following \"\n              + \"services have not stopped: \"\n              + Multimaps.filterKeys(servicesByState,\n                  not(in(EnumSet.of(TERMINATED, FAILED)))));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    ImmutableMultimap<State, Service> servicesByState() {\n      ImmutableSetMultimap.Builder<State, Service> builder = ImmutableSetMultimap.builder();\n      monitor.enter();\n      try {\n        for (Entry<State, Service> entry : servicesByState.entries()) {\n          if (!(entry.getValue() instanceof NoOpService)) {\n            builder.put(entry);\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      return builder.build();\n    }\n\n    ImmutableMap<Service, Long> startupTimes() {\n      List<Entry<Service, Long>> loadTimes;\n      monitor.enter();\n      try {\n        loadTimes = Lists.newArrayListWithCapacity(startupTimers.size());\n        // N.B. There will only be an entry in the map if the service has started\n        for (Entry<Service, Stopwatch> entry : startupTimers.entrySet()) {\n          Service service = entry.getKey();\n          Stopwatch stopWatch = entry.getValue();\n          if (!stopWatch.isRunning() && !(service instanceof NoOpService)) {\n            loadTimes.add(Maps.immutableEntry(service, stopWatch.elapsed(MILLISECONDS)));\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      Collections.sort(loadTimes, Ordering.natural()\n          .onResultOf(new Function<Entry<Service, Long>, Long>() {\n            @Override public Long apply(Map.Entry<Service, Long> input) {\n              return input.getValue();\n            }\n          }));\n      return ImmutableMap.copyOf(loadTimes);\n    }\n\n    /**\n     * Updates the state with the given service transition.\n     *\n     * <p>This method performs the main logic of ServiceManager in the following steps.\n     * <ol>\n     *      <li>Update the {@link #servicesByState()}\n     *      <li>Update the {@link #startupTimers}\n     *      <li>Based on the new state queue listeners to run\n     *      <li>Run the listeners (outside of the lock)\n     * </ol>\n     */\n    void transitionService(final Service service, State from, State to) {\n      checkNotNull(service);\n      checkArgument(from != to);\n      monitor.enter();\n      try {\n        transitioned = true;\n        if (!ready) {\n          return;\n        }\n        // Update state.\n        checkState(servicesByState.remove(from, service),\n            \"Service %s not at the expected location in the state map %s\", service, from);\n        checkState(servicesByState.put(to, service),\n            \"Service %s in the state map unexpectedly at %s\", service, to);\n        // Update the timer\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          // This means the service was started by some means other than ServiceManager.startAsync\n          stopwatch = Stopwatch.createStarted();\n          startupTimers.put(service, stopwatch);\n        }\n        if (to.compareTo(RUNNING) >= 0 && stopwatch.isRunning()) {\n          // N.B. if we miss the STARTING event then we may never record a startup time.\n          stopwatch.stop();\n          if (!(service instanceof NoOpService)) {\n            logger.log(Level.FINE, \"Started {0} in {1}.\", new Object[] {service, stopwatch});\n          }\n        }\n        // Queue our listeners\n\n        // Did a service fail?\n        if (to == FAILED) {\n          fireFailedListeners(service);\n        }\n\n        if (states.count(RUNNING) == numberOfServices) {\n          // This means that the manager is currently healthy. N.B. If other threads call isHealthy\n          // they are not guaranteed to get 'true', because any service could fail right now.\n          fireHealthyListeners();\n        } else if (states.count(TERMINATED) + states.count(FAILED) == numberOfServices) {\n          fireStoppedListeners();\n        }\n      } finally {\n        monitor.leave();\n        // Run our executors outside of the lock\n        executeListeners();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireStoppedListeners() {\n      STOPPED_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireHealthyListeners() {\n      HEALTHY_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireFailedListeners(final Service service) {\n      new Callback<Listener>(\"failed({service=\" + service + \"})\") {\n        @Override void call(Listener listener) {\n          listener.failure(service);\n        }\n      }.enqueueOn(listeners);\n    }\n\n    /** Attempts to execute all the listeners in {@link #listeners}. */\n    void executeListeners() {\n      checkState(!monitor.isOccupiedByCurrentThread(),\n          \"It is incorrect to execute listeners with the monitor held.\");\n      // iterate by index to avoid concurrent modification exceptions\n      for (int i = 0; i < listeners.size(); i++) {\n        listeners.get(i).execute();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void checkHealthy() {\n      if (states.count(RUNNING) != numberOfServices) {\n        IllegalStateException exception = new IllegalStateException(\n            \"Expected to be healthy after starting. The following services are not running: \"\n                + Multimaps.filterKeys(servicesByState, not(equalTo(RUNNING))));\n        throw exception;\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} that wraps another service and times how long it takes for it to start and\n   * also calls the {@link ServiceManagerState#transitionService(Service, State, State)},\n   * to record the state transitions.\n   */\n  private static final class ServiceListener extends Service.Listener {\n    final Service service;\n    // We store the state in a weak reference to ensure that if something went wrong while\n    // constructing the ServiceManager we don't pointlessly keep updating the state.\n    final WeakReference<ServiceManagerState> state;\n\n    ServiceListener(Service service, WeakReference<ServiceManagerState> state) {\n      this.service = service;\n      this.state = state;\n    }\n\n    @Override public void starting() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, NEW, STARTING);\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Starting {0}.\", service);\n        }\n      }\n    }\n\n    @Override public void running() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, STARTING, RUNNING);\n      }\n    }\n\n    @Override public void stopping(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, from, STOPPING);\n      }\n    }\n\n    @Override public void terminated(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Service {0} has terminated. Previous state was: {1}\",\n              new Object[] {service, from});\n        }\n        state.transitionService(service, from, TERMINATED);\n      }\n    }\n\n    @Override public void failed(State from, Throwable failure) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        // Log before the transition, so that if the process exits in response to server failure,\n        // there is a higher likelihood that the cause will be in the logs.\n        if (!(service instanceof NoOpService) ) {\n          logger.log(Level.SEVERE, \"Service \" + service + \" has failed in the \" + from + \" state.\",\n              failure);\n        }\n        state.transitionService(service, from, FAILED);\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} instance that does nothing.  This is only useful as a placeholder to\n   * ensure that the {@link ServiceManager} functions properly even when it is managing no services.\n   *\n   * <p>The use of this class is considered an implementation detail of ServiceManager and as such\n   * it is excluded from {@link #servicesByState}, {@link #startupTimes}, {@link #toString} and all\n   * logging statements.\n   */\n  private static final class NoOpService extends AbstractService {\n    @Override protected void doStart() { notifyStarted(); }\n    @Override protected void doStop() { notifyStopped(); }\n  }\n\n  /** This is never thrown but only used for logging. */\n  private static final class EmptyServiceManagerWarning extends Throwable {}\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53081145,"label":true,"oracleId":1449,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"ServiceManager","javadocTag":"@throws IllegalStateException if the service manager reaches a state from which it cannot\n    become {@linkplain #isHealthy() healthy}.","methodJavadoc":"    /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy}.  The manager\n   * will become healthy after all the component services have reached the {@linkplain State#RUNNING\n   * running} state.\n   *\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */","methodSourceCode":"public void awaitHealthy(){\n    state.awaitHealthy();\n}","classJavadoc":"/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */","classSourceCode":"/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Predicates.equalTo;\nimport static com.google.common.base.Predicates.in;\nimport static com.google.common.base.Predicates.instanceOf;\nimport static com.google.common.base.Predicates.not;\nimport static com.google.common.util.concurrent.MoreExecutors.directExecutor;\nimport static com.google.common.util.concurrent.Service.State.FAILED;\nimport static com.google.common.util.concurrent.Service.State.NEW;\nimport static com.google.common.util.concurrent.Service.State.RUNNING;\nimport static com.google.common.util.concurrent.Service.State.STARTING;\nimport static com.google.common.util.concurrent.Service.State.STOPPING;\nimport static com.google.common.util.concurrent.Service.State.TERMINATED;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.base.Function;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Stopwatch;\nimport com.google.common.collect.Collections2;\nimport com.google.common.collect.ImmutableCollection;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableMultimap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSetMultimap;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.MultimapBuilder;\nimport com.google.common.collect.Multimaps;\nimport com.google.common.collect.Multiset;\nimport com.google.common.collect.Ordering;\nimport com.google.common.collect.SetMultimap;\nimport com.google.common.util.concurrent.ListenerCallQueue.Callback;\nimport com.google.common.util.concurrent.Service.State;\nimport com.google.j2objc.annotations.WeakOuter;\n\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */\n@Beta\npublic final class ServiceManager {\n  private static final Logger logger = Logger.getLogger(ServiceManager.class.getName());\n  private static final Callback<Listener> HEALTHY_CALLBACK = new Callback<Listener>(\"healthy()\") {\n    @Override void call(Listener listener) {\n      listener.healthy();\n    }\n  };\n  private static final Callback<Listener> STOPPED_CALLBACK = new Callback<Listener>(\"stopped()\") {\n    @Override void call(Listener listener) {\n      listener.stopped();\n    }\n  };\n\n  /**\n   * A listener for the aggregate state changes of the services that are under management. Users\n   * that need to listen to more fine-grained events (such as when each particular {@linkplain\n   * Service service} starts, or terminates), should attach {@linkplain Service.Listener service\n   * listeners} to each individual service.\n   *\n   * @author Luke Sandberg\n   * @since 15.0 (present as an interface in 14.0)\n   */\n  @Beta  // Should come out of Beta when ServiceManager does\n  public abstract static class Listener {\n    /**\n     * Called when the service initially becomes healthy.\n     *\n     * <p>This will be called at most once after all the services have entered the\n     * {@linkplain State#RUNNING running} state. If any services fail during start up or\n     * {@linkplain State#FAILED fail}/{@linkplain State#TERMINATED terminate} before all other\n     * services have started {@linkplain State#RUNNING running} then this method will not be called.\n     */\n    public void healthy() {}\n\n    /**\n     * Called when the all of the component services have reached a terminal state, either\n     * {@linkplain State#TERMINATED terminated} or {@linkplain State#FAILED failed}.\n     */\n    public void stopped() {}\n\n    /**\n     * Called when a component service has {@linkplain State#FAILED failed}.\n     *\n     * @param service The service that failed.\n     */\n    public void failure(Service service) {}\n  }\n\n  /**\n   * An encapsulation of all of the state that is accessed by the {@linkplain ServiceListener\n   * service listeners}.  This is extracted into its own object so that {@link ServiceListener}\n   * could be made {@code static} and its instances can be safely constructed and added in the\n   * {@link ServiceManager} constructor without having to close over the partially constructed\n   * {@link ServiceManager} instance (i.e. avoid leaking a pointer to {@code this}).\n   */\n  private final ServiceManagerState state;\n  private final ImmutableList<Service> services;\n\n  /**\n   * Constructs a new instance for managing the given services.\n   *\n   * @param services The services to manage\n   *\n   * @throws IllegalArgumentException if not all services are {@linkplain State#NEW new} or if there\n   * are any duplicate services.\n   */\n  public ServiceManager(Iterable<? extends Service> services) {\n    ImmutableList<Service> copy = ImmutableList.copyOf(services);\n    if (copy.isEmpty()) {\n      // Having no services causes the manager to behave strangely. Notably, listeners are never\n      // fired.  To avoid this we substitute a placeholder service.\n      logger.log(Level.WARNING,\n          \"ServiceManager configured with no services.  Is your application configured properly?\",\n          new EmptyServiceManagerWarning());\n      copy = ImmutableList.<Service>of(new NoOpService());\n    }\n    this.state = new ServiceManagerState(copy);\n    this.services = copy;\n    WeakReference<ServiceManagerState> stateReference =\n        new WeakReference<ServiceManagerState>(state);\n    for (Service service : copy) {\n      service.addListener(new ServiceListener(service, stateReference), directExecutor());\n      // We check the state after adding the listener as a way to ensure that our listener was added\n      // to a NEW service.\n      checkArgument(service.state() == NEW, \"Can only manage NEW services, %s\", service);\n    }\n    // We have installed all of our listeners and after this point any state transition should be\n    // correct.\n    this.state.markReady();\n  }\n\n  /**\n   * Registers a {@link Listener} to be {@linkplain Executor#execute executed} on the given\n   * executor. The listener will not have previous state changes replayed, so it is\n   * suggested that listeners are added before any of the managed services are\n   * {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged. Any exception thrown\n   * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException}) will be caught and\n   * logged.\n   *\n   * <p> For fast, lightweight listeners that would be safe to execute in any thread, consider\n   * calling {@link #addListener(Listener)}.\n   *\n   * @param listener the listener to run when the manager changes state\n   * @param executor the executor in which the listeners callback methods will be run.\n   */\n  public void addListener(Listener listener, Executor executor) {\n    state.addListener(listener, executor);\n  }\n\n  /**\n   * Registers a {@link Listener} to be run when this {@link ServiceManager} changes state. The\n   * listener will not have previous state changes replayed, so it is suggested that listeners are\n   * added before any of the managed services are {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged.\n   *\n   * @param listener the listener to run when the manager changes state\n   */\n  public void addListener(Listener listener) {\n    state.addListener(listener, directExecutor());\n  }\n\n  /**\n   * Initiates service {@linkplain Service#startAsync startup} on all the services being managed.\n   * It is only valid to call this method if all of the services are {@linkplain State#NEW new}.\n   *\n   * @return this\n   * @throws IllegalStateException if any of the Services are not {@link State#NEW new} when the\n   *     method is called.\n   */\n  public ServiceManager startAsync() {\n    for (Service service : services) {\n      State state = service.state();\n      checkState(state == NEW, \"Service %s is %s, cannot start it.\", service, state);\n    }\n    for (Service service : services) {\n      try {\n        state.tryStartTiming(service);\n        service.startAsync();\n      } catch (IllegalStateException e) {\n        // This can happen if the service has already been started or stopped (e.g. by another\n        // service or listener). Our contract says it is safe to call this method if\n        // all services were NEW when it was called, and this has already been verified above, so we\n        // don't propagate the exception.\n        logger.log(Level.WARNING, \"Unable to start Service \" + service, e);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy}.  The manager\n   * will become healthy after all the component services have reached the {@linkplain State#RUNNING\n   * running} state.\n   *\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy() {\n    state.awaitHealthy();\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy} for no more\n   * than the given time.  The manager will become healthy after all the component services have\n   * reached the {@linkplain State#RUNNING running} state.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have finished starting within the deadline\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitHealthy(timeout, unit);\n  }\n\n  /**\n   * Initiates service {@linkplain Service#stopAsync shutdown} if necessary on all the services\n   * being managed.\n   *\n   * @return this\n   */\n  public ServiceManager stopAsync() {\n    for (Service service : services) {\n      service.stopAsync();\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state. After this method returns all\n   * services will either be {@linkplain Service.State#TERMINATED terminated} or {@linkplain\n   * Service.State#FAILED failed}.\n   */\n  public void awaitStopped() {\n    state.awaitStopped();\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state for no more than the given time. After\n   * this method returns all services will either be {@linkplain Service.State#TERMINATED\n   * terminated} or {@linkplain Service.State#FAILED failed}.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have stopped within the deadline\n   */\n  public void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitStopped(timeout, unit);\n  }\n\n  /**\n   * Returns true if all services are currently in the {@linkplain State#RUNNING running} state.\n   *\n   * <p>Users who want more detailed information should use the {@link #servicesByState} method to\n   * get detailed information about which services are not running.\n   */\n  public boolean isHealthy() {\n    for (Service service : services) {\n      if (!service.isRunning()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Provides a snapshot of the current state of all the services under management.\n   *\n   * <p>N.B. This snapshot is guaranteed to be consistent, i.e. the set of states returned will\n   * correspond to a point in time view of the services.\n   */\n  public ImmutableMultimap<State, Service> servicesByState() {\n    return state.servicesByState();\n  }\n\n  /**\n   * Returns the service load times. This value will only return startup times for services that\n   * have finished starting.\n   *\n   * @return Map of services and their corresponding startup time in millis, the map entries will be\n   *     ordered by startup time.\n   */\n  public ImmutableMap<Service, Long> startupTimes() {\n    return state.startupTimes();\n  }\n\n  @Override public String toString() {\n    return MoreObjects.toStringHelper(ServiceManager.class)\n        .add(\"services\", Collections2.filter(services, not(instanceOf(NoOpService.class))))\n        .toString();\n  }\n\n  /**\n   * An encapsulation of all the mutable state of the {@link ServiceManager} that needs to be\n   * accessed by instances of {@link ServiceListener}.\n   */\n  private static final class ServiceManagerState {\n    final Monitor monitor = new Monitor();\n\n    @GuardedBy(\"monitor\")\n    final SetMultimap<State, Service> servicesByState =\n        MultimapBuilder.enumKeys(State.class).linkedHashSetValues().build();\n\n    @GuardedBy(\"monitor\")\n    final Multiset<State> states = servicesByState.keys();\n\n    @GuardedBy(\"monitor\")\n    final Map<Service, Stopwatch> startupTimers = Maps.newIdentityHashMap();\n\n    /**\n     * These two booleans are used to mark the state as ready to start.\n     * {@link #ready}: is set by {@link #markReady} to indicate that all listeners have been\n     *     correctly installed\n     * {@link #transitioned}: is set by {@link #transitionService} to indicate that some transition\n     *     has been performed.\n     *\n     * <p>Together, they allow us to enforce that all services have their listeners installed prior\n     * to any service performing a transition, then we can fail in the ServiceManager constructor\n     * rather than in a Service.Listener callback.\n     */\n    @GuardedBy(\"monitor\")\n    boolean ready;\n\n    @GuardedBy(\"monitor\")\n    boolean transitioned;\n\n    final int numberOfServices;\n\n    /**\n     * Controls how long to wait for all the services to either become healthy or reach a\n     * state from which it is guaranteed that it can never become healthy.\n     */\n    final Monitor.Guard awaitHealthGuard = new AwaitHealthGuard();\n\n    @WeakOuter\n    final class AwaitHealthGuard extends Monitor.Guard {\n      AwaitHealthGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        // All services have started or some service has terminated/failed.\n        return states.count(RUNNING) == numberOfServices\n            || states.contains(STOPPING)\n            || states.contains(TERMINATED)\n            || states.contains(FAILED);\n      }\n    }\n\n    /**\n     * Controls how long to wait for all services to reach a terminal state.\n     */\n    final Monitor.Guard stoppedGuard = new StoppedGuard();\n\n    @WeakOuter\n    final class StoppedGuard extends Monitor.Guard {\n      StoppedGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        return states.count(TERMINATED) + states.count(FAILED) == numberOfServices;\n      }\n    }\n\n    /** The listeners to notify during a state transition. */\n    @GuardedBy(\"monitor\")\n    final List<ListenerCallQueue<Listener>> listeners =\n        Collections.synchronizedList(new ArrayList<ListenerCallQueue<Listener>>());\n\n    /**\n     * It is implicitly assumed that all the services are NEW and that they will all remain NEW\n     * until all the Listeners are installed and {@link #markReady()} is called.  It is our caller's\n     * responsibility to only call {@link #markReady()} if all services were new at the time this\n     * method was called and when all the listeners were installed.\n     */\n    ServiceManagerState(ImmutableCollection<Service> services) {\n      this.numberOfServices = services.size();\n      servicesByState.putAll(NEW, services);\n    }\n\n    /**\n     * Attempts to start the timer immediately prior to the service being started via\n     * {@link Service#startAsync()}.\n     */\n    void tryStartTiming(Service service) {\n      monitor.enter();\n      try {\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          startupTimers.put(service, Stopwatch.createStarted());\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    /**\n     * Marks the {@link State} as ready to receive transitions. Returns true if no transitions have\n     * been observed yet.\n     */\n    void markReady() {\n      monitor.enter();\n      try {\n        if (!transitioned) {\n          // nothing has transitioned since construction, good.\n          ready = true;\n        } else {\n          // This should be an extremely rare race condition.\n          List<Service> servicesInBadStates = Lists.newArrayList();\n          for (Service service : servicesByState().values()) {\n            if (service.state() != NEW) {\n              servicesInBadStates.add(service);\n            }\n          }\n          throw new IllegalArgumentException(\"Services started transitioning asynchronously before \"\n              + \"the ServiceManager was constructed: \" + servicesInBadStates);\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void addListener(Listener listener, Executor executor) {\n      checkNotNull(listener, \"listener\");\n      checkNotNull(executor, \"executor\");\n      monitor.enter();\n      try {\n        // no point in adding a listener that will never be called\n        if (!stoppedGuard.isSatisfied()) {\n          listeners.add(new ListenerCallQueue<Listener>(listener, executor));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy() {\n      monitor.enterWhenUninterruptibly(awaitHealthGuard);\n      try {\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(awaitHealthGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to become healthy. The \"\n              + \"following services have not started: \"\n              + Multimaps.filterKeys(servicesByState, in(ImmutableSet.of(NEW, STARTING))));\n        }\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitStopped() {\n      monitor.enterWhenUninterruptibly(stoppedGuard);\n      monitor.leave();\n    }\n\n    void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(stoppedGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to stop. The following \"\n              + \"services have not stopped: \"\n              + Multimaps.filterKeys(servicesByState,\n                  not(in(EnumSet.of(TERMINATED, FAILED)))));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    ImmutableMultimap<State, Service> servicesByState() {\n      ImmutableSetMultimap.Builder<State, Service> builder = ImmutableSetMultimap.builder();\n      monitor.enter();\n      try {\n        for (Entry<State, Service> entry : servicesByState.entries()) {\n          if (!(entry.getValue() instanceof NoOpService)) {\n            builder.put(entry);\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      return builder.build();\n    }\n\n    ImmutableMap<Service, Long> startupTimes() {\n      List<Entry<Service, Long>> loadTimes;\n      monitor.enter();\n      try {\n        loadTimes = Lists.newArrayListWithCapacity(startupTimers.size());\n        // N.B. There will only be an entry in the map if the service has started\n        for (Entry<Service, Stopwatch> entry : startupTimers.entrySet()) {\n          Service service = entry.getKey();\n          Stopwatch stopWatch = entry.getValue();\n          if (!stopWatch.isRunning() && !(service instanceof NoOpService)) {\n            loadTimes.add(Maps.immutableEntry(service, stopWatch.elapsed(MILLISECONDS)));\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      Collections.sort(loadTimes, Ordering.natural()\n          .onResultOf(new Function<Entry<Service, Long>, Long>() {\n            @Override public Long apply(Map.Entry<Service, Long> input) {\n              return input.getValue();\n            }\n          }));\n      return ImmutableMap.copyOf(loadTimes);\n    }\n\n    /**\n     * Updates the state with the given service transition.\n     *\n     * <p>This method performs the main logic of ServiceManager in the following steps.\n     * <ol>\n     *      <li>Update the {@link #servicesByState()}\n     *      <li>Update the {@link #startupTimers}\n     *      <li>Based on the new state queue listeners to run\n     *      <li>Run the listeners (outside of the lock)\n     * </ol>\n     */\n    void transitionService(final Service service, State from, State to) {\n      checkNotNull(service);\n      checkArgument(from != to);\n      monitor.enter();\n      try {\n        transitioned = true;\n        if (!ready) {\n          return;\n        }\n        // Update state.\n        checkState(servicesByState.remove(from, service),\n            \"Service %s not at the expected location in the state map %s\", service, from);\n        checkState(servicesByState.put(to, service),\n            \"Service %s in the state map unexpectedly at %s\", service, to);\n        // Update the timer\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          // This means the service was started by some means other than ServiceManager.startAsync\n          stopwatch = Stopwatch.createStarted();\n          startupTimers.put(service, stopwatch);\n        }\n        if (to.compareTo(RUNNING) >= 0 && stopwatch.isRunning()) {\n          // N.B. if we miss the STARTING event then we may never record a startup time.\n          stopwatch.stop();\n          if (!(service instanceof NoOpService)) {\n            logger.log(Level.FINE, \"Started {0} in {1}.\", new Object[] {service, stopwatch});\n          }\n        }\n        // Queue our listeners\n\n        // Did a service fail?\n        if (to == FAILED) {\n          fireFailedListeners(service);\n        }\n\n        if (states.count(RUNNING) == numberOfServices) {\n          // This means that the manager is currently healthy. N.B. If other threads call isHealthy\n          // they are not guaranteed to get 'true', because any service could fail right now.\n          fireHealthyListeners();\n        } else if (states.count(TERMINATED) + states.count(FAILED) == numberOfServices) {\n          fireStoppedListeners();\n        }\n      } finally {\n        monitor.leave();\n        // Run our executors outside of the lock\n        executeListeners();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireStoppedListeners() {\n      STOPPED_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireHealthyListeners() {\n      HEALTHY_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireFailedListeners(final Service service) {\n      new Callback<Listener>(\"failed({service=\" + service + \"})\") {\n        @Override void call(Listener listener) {\n          listener.failure(service);\n        }\n      }.enqueueOn(listeners);\n    }\n\n    /** Attempts to execute all the listeners in {@link #listeners}. */\n    void executeListeners() {\n      checkState(!monitor.isOccupiedByCurrentThread(),\n          \"It is incorrect to execute listeners with the monitor held.\");\n      // iterate by index to avoid concurrent modification exceptions\n      for (int i = 0; i < listeners.size(); i++) {\n        listeners.get(i).execute();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void checkHealthy() {\n      if (states.count(RUNNING) != numberOfServices) {\n        IllegalStateException exception = new IllegalStateException(\n            \"Expected to be healthy after starting. The following services are not running: \"\n                + Multimaps.filterKeys(servicesByState, not(equalTo(RUNNING))));\n        throw exception;\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} that wraps another service and times how long it takes for it to start and\n   * also calls the {@link ServiceManagerState#transitionService(Service, State, State)},\n   * to record the state transitions.\n   */\n  private static final class ServiceListener extends Service.Listener {\n    final Service service;\n    // We store the state in a weak reference to ensure that if something went wrong while\n    // constructing the ServiceManager we don't pointlessly keep updating the state.\n    final WeakReference<ServiceManagerState> state;\n\n    ServiceListener(Service service, WeakReference<ServiceManagerState> state) {\n      this.service = service;\n      this.state = state;\n    }\n\n    @Override public void starting() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, NEW, STARTING);\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Starting {0}.\", service);\n        }\n      }\n    }\n\n    @Override public void running() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, STARTING, RUNNING);\n      }\n    }\n\n    @Override public void stopping(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, from, STOPPING);\n      }\n    }\n\n    @Override public void terminated(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Service {0} has terminated. Previous state was: {1}\",\n              new Object[] {service, from});\n        }\n        state.transitionService(service, from, TERMINATED);\n      }\n    }\n\n    @Override public void failed(State from, Throwable failure) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        // Log before the transition, so that if the process exits in response to server failure,\n        // there is a higher likelihood that the cause will be in the logs.\n        if (!(service instanceof NoOpService) ) {\n          logger.log(Level.SEVERE, \"Service \" + service + \" has failed in the \" + from + \" state.\",\n              failure);\n        }\n        state.transitionService(service, from, FAILED);\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} instance that does nothing.  This is only useful as a placeholder to\n   * ensure that the {@link ServiceManager} functions properly even when it is managing no services.\n   *\n   * <p>The use of this class is considered an implementation detail of ServiceManager and as such\n   * it is excluded from {@link #servicesByState}, {@link #startupTimes}, {@link #toString} and all\n   * logging statements.\n   */\n  private static final class NoOpService extends AbstractService {\n    @Override protected void doStart() { notifyStarted(); }\n    @Override protected void doStop() { notifyStopped(); }\n  }\n\n  /** This is never thrown but only used for logging. */\n  private static final class EmptyServiceManagerWarning extends Throwable {}\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53081604,"label":true,"oracleId":1450,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"ServiceManager","javadocTag":"@param timeout the maximum time to wait","methodJavadoc":"    /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy} for no more\n   * than the given time.  The manager will become healthy after all the component services have\n   * reached the {@linkplain State#RUNNING running} state.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have finished starting within the deadline\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */","methodSourceCode":"public void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException{\n    state.awaitHealthy(timeout, unit);\n}","classJavadoc":"/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */","classSourceCode":"/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Predicates.equalTo;\nimport static com.google.common.base.Predicates.in;\nimport static com.google.common.base.Predicates.instanceOf;\nimport static com.google.common.base.Predicates.not;\nimport static com.google.common.util.concurrent.MoreExecutors.directExecutor;\nimport static com.google.common.util.concurrent.Service.State.FAILED;\nimport static com.google.common.util.concurrent.Service.State.NEW;\nimport static com.google.common.util.concurrent.Service.State.RUNNING;\nimport static com.google.common.util.concurrent.Service.State.STARTING;\nimport static com.google.common.util.concurrent.Service.State.STOPPING;\nimport static com.google.common.util.concurrent.Service.State.TERMINATED;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.base.Function;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Stopwatch;\nimport com.google.common.collect.Collections2;\nimport com.google.common.collect.ImmutableCollection;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableMultimap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSetMultimap;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.MultimapBuilder;\nimport com.google.common.collect.Multimaps;\nimport com.google.common.collect.Multiset;\nimport com.google.common.collect.Ordering;\nimport com.google.common.collect.SetMultimap;\nimport com.google.common.util.concurrent.ListenerCallQueue.Callback;\nimport com.google.common.util.concurrent.Service.State;\nimport com.google.j2objc.annotations.WeakOuter;\n\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */\n@Beta\npublic final class ServiceManager {\n  private static final Logger logger = Logger.getLogger(ServiceManager.class.getName());\n  private static final Callback<Listener> HEALTHY_CALLBACK = new Callback<Listener>(\"healthy()\") {\n    @Override void call(Listener listener) {\n      listener.healthy();\n    }\n  };\n  private static final Callback<Listener> STOPPED_CALLBACK = new Callback<Listener>(\"stopped()\") {\n    @Override void call(Listener listener) {\n      listener.stopped();\n    }\n  };\n\n  /**\n   * A listener for the aggregate state changes of the services that are under management. Users\n   * that need to listen to more fine-grained events (such as when each particular {@linkplain\n   * Service service} starts, or terminates), should attach {@linkplain Service.Listener service\n   * listeners} to each individual service.\n   *\n   * @author Luke Sandberg\n   * @since 15.0 (present as an interface in 14.0)\n   */\n  @Beta  // Should come out of Beta when ServiceManager does\n  public abstract static class Listener {\n    /**\n     * Called when the service initially becomes healthy.\n     *\n     * <p>This will be called at most once after all the services have entered the\n     * {@linkplain State#RUNNING running} state. If any services fail during start up or\n     * {@linkplain State#FAILED fail}/{@linkplain State#TERMINATED terminate} before all other\n     * services have started {@linkplain State#RUNNING running} then this method will not be called.\n     */\n    public void healthy() {}\n\n    /**\n     * Called when the all of the component services have reached a terminal state, either\n     * {@linkplain State#TERMINATED terminated} or {@linkplain State#FAILED failed}.\n     */\n    public void stopped() {}\n\n    /**\n     * Called when a component service has {@linkplain State#FAILED failed}.\n     *\n     * @param service The service that failed.\n     */\n    public void failure(Service service) {}\n  }\n\n  /**\n   * An encapsulation of all of the state that is accessed by the {@linkplain ServiceListener\n   * service listeners}.  This is extracted into its own object so that {@link ServiceListener}\n   * could be made {@code static} and its instances can be safely constructed and added in the\n   * {@link ServiceManager} constructor without having to close over the partially constructed\n   * {@link ServiceManager} instance (i.e. avoid leaking a pointer to {@code this}).\n   */\n  private final ServiceManagerState state;\n  private final ImmutableList<Service> services;\n\n  /**\n   * Constructs a new instance for managing the given services.\n   *\n   * @param services The services to manage\n   *\n   * @throws IllegalArgumentException if not all services are {@linkplain State#NEW new} or if there\n   * are any duplicate services.\n   */\n  public ServiceManager(Iterable<? extends Service> services) {\n    ImmutableList<Service> copy = ImmutableList.copyOf(services);\n    if (copy.isEmpty()) {\n      // Having no services causes the manager to behave strangely. Notably, listeners are never\n      // fired.  To avoid this we substitute a placeholder service.\n      logger.log(Level.WARNING,\n          \"ServiceManager configured with no services.  Is your application configured properly?\",\n          new EmptyServiceManagerWarning());\n      copy = ImmutableList.<Service>of(new NoOpService());\n    }\n    this.state = new ServiceManagerState(copy);\n    this.services = copy;\n    WeakReference<ServiceManagerState> stateReference =\n        new WeakReference<ServiceManagerState>(state);\n    for (Service service : copy) {\n      service.addListener(new ServiceListener(service, stateReference), directExecutor());\n      // We check the state after adding the listener as a way to ensure that our listener was added\n      // to a NEW service.\n      checkArgument(service.state() == NEW, \"Can only manage NEW services, %s\", service);\n    }\n    // We have installed all of our listeners and after this point any state transition should be\n    // correct.\n    this.state.markReady();\n  }\n\n  /**\n   * Registers a {@link Listener} to be {@linkplain Executor#execute executed} on the given\n   * executor. The listener will not have previous state changes replayed, so it is\n   * suggested that listeners are added before any of the managed services are\n   * {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged. Any exception thrown\n   * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException}) will be caught and\n   * logged.\n   *\n   * <p> For fast, lightweight listeners that would be safe to execute in any thread, consider\n   * calling {@link #addListener(Listener)}.\n   *\n   * @param listener the listener to run when the manager changes state\n   * @param executor the executor in which the listeners callback methods will be run.\n   */\n  public void addListener(Listener listener, Executor executor) {\n    state.addListener(listener, executor);\n  }\n\n  /**\n   * Registers a {@link Listener} to be run when this {@link ServiceManager} changes state. The\n   * listener will not have previous state changes replayed, so it is suggested that listeners are\n   * added before any of the managed services are {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged.\n   *\n   * @param listener the listener to run when the manager changes state\n   */\n  public void addListener(Listener listener) {\n    state.addListener(listener, directExecutor());\n  }\n\n  /**\n   * Initiates service {@linkplain Service#startAsync startup} on all the services being managed.\n   * It is only valid to call this method if all of the services are {@linkplain State#NEW new}.\n   *\n   * @return this\n   * @throws IllegalStateException if any of the Services are not {@link State#NEW new} when the\n   *     method is called.\n   */\n  public ServiceManager startAsync() {\n    for (Service service : services) {\n      State state = service.state();\n      checkState(state == NEW, \"Service %s is %s, cannot start it.\", service, state);\n    }\n    for (Service service : services) {\n      try {\n        state.tryStartTiming(service);\n        service.startAsync();\n      } catch (IllegalStateException e) {\n        // This can happen if the service has already been started or stopped (e.g. by another\n        // service or listener). Our contract says it is safe to call this method if\n        // all services were NEW when it was called, and this has already been verified above, so we\n        // don't propagate the exception.\n        logger.log(Level.WARNING, \"Unable to start Service \" + service, e);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy}.  The manager\n   * will become healthy after all the component services have reached the {@linkplain State#RUNNING\n   * running} state.\n   *\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy() {\n    state.awaitHealthy();\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy} for no more\n   * than the given time.  The manager will become healthy after all the component services have\n   * reached the {@linkplain State#RUNNING running} state.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have finished starting within the deadline\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitHealthy(timeout, unit);\n  }\n\n  /**\n   * Initiates service {@linkplain Service#stopAsync shutdown} if necessary on all the services\n   * being managed.\n   *\n   * @return this\n   */\n  public ServiceManager stopAsync() {\n    for (Service service : services) {\n      service.stopAsync();\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state. After this method returns all\n   * services will either be {@linkplain Service.State#TERMINATED terminated} or {@linkplain\n   * Service.State#FAILED failed}.\n   */\n  public void awaitStopped() {\n    state.awaitStopped();\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state for no more than the given time. After\n   * this method returns all services will either be {@linkplain Service.State#TERMINATED\n   * terminated} or {@linkplain Service.State#FAILED failed}.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have stopped within the deadline\n   */\n  public void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitStopped(timeout, unit);\n  }\n\n  /**\n   * Returns true if all services are currently in the {@linkplain State#RUNNING running} state.\n   *\n   * <p>Users who want more detailed information should use the {@link #servicesByState} method to\n   * get detailed information about which services are not running.\n   */\n  public boolean isHealthy() {\n    for (Service service : services) {\n      if (!service.isRunning()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Provides a snapshot of the current state of all the services under management.\n   *\n   * <p>N.B. This snapshot is guaranteed to be consistent, i.e. the set of states returned will\n   * correspond to a point in time view of the services.\n   */\n  public ImmutableMultimap<State, Service> servicesByState() {\n    return state.servicesByState();\n  }\n\n  /**\n   * Returns the service load times. This value will only return startup times for services that\n   * have finished starting.\n   *\n   * @return Map of services and their corresponding startup time in millis, the map entries will be\n   *     ordered by startup time.\n   */\n  public ImmutableMap<Service, Long> startupTimes() {\n    return state.startupTimes();\n  }\n\n  @Override public String toString() {\n    return MoreObjects.toStringHelper(ServiceManager.class)\n        .add(\"services\", Collections2.filter(services, not(instanceOf(NoOpService.class))))\n        .toString();\n  }\n\n  /**\n   * An encapsulation of all the mutable state of the {@link ServiceManager} that needs to be\n   * accessed by instances of {@link ServiceListener}.\n   */\n  private static final class ServiceManagerState {\n    final Monitor monitor = new Monitor();\n\n    @GuardedBy(\"monitor\")\n    final SetMultimap<State, Service> servicesByState =\n        MultimapBuilder.enumKeys(State.class).linkedHashSetValues().build();\n\n    @GuardedBy(\"monitor\")\n    final Multiset<State> states = servicesByState.keys();\n\n    @GuardedBy(\"monitor\")\n    final Map<Service, Stopwatch> startupTimers = Maps.newIdentityHashMap();\n\n    /**\n     * These two booleans are used to mark the state as ready to start.\n     * {@link #ready}: is set by {@link #markReady} to indicate that all listeners have been\n     *     correctly installed\n     * {@link #transitioned}: is set by {@link #transitionService} to indicate that some transition\n     *     has been performed.\n     *\n     * <p>Together, they allow us to enforce that all services have their listeners installed prior\n     * to any service performing a transition, then we can fail in the ServiceManager constructor\n     * rather than in a Service.Listener callback.\n     */\n    @GuardedBy(\"monitor\")\n    boolean ready;\n\n    @GuardedBy(\"monitor\")\n    boolean transitioned;\n\n    final int numberOfServices;\n\n    /**\n     * Controls how long to wait for all the services to either become healthy or reach a\n     * state from which it is guaranteed that it can never become healthy.\n     */\n    final Monitor.Guard awaitHealthGuard = new AwaitHealthGuard();\n\n    @WeakOuter\n    final class AwaitHealthGuard extends Monitor.Guard {\n      AwaitHealthGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        // All services have started or some service has terminated/failed.\n        return states.count(RUNNING) == numberOfServices\n            || states.contains(STOPPING)\n            || states.contains(TERMINATED)\n            || states.contains(FAILED);\n      }\n    }\n\n    /**\n     * Controls how long to wait for all services to reach a terminal state.\n     */\n    final Monitor.Guard stoppedGuard = new StoppedGuard();\n\n    @WeakOuter\n    final class StoppedGuard extends Monitor.Guard {\n      StoppedGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        return states.count(TERMINATED) + states.count(FAILED) == numberOfServices;\n      }\n    }\n\n    /** The listeners to notify during a state transition. */\n    @GuardedBy(\"monitor\")\n    final List<ListenerCallQueue<Listener>> listeners =\n        Collections.synchronizedList(new ArrayList<ListenerCallQueue<Listener>>());\n\n    /**\n     * It is implicitly assumed that all the services are NEW and that they will all remain NEW\n     * until all the Listeners are installed and {@link #markReady()} is called.  It is our caller's\n     * responsibility to only call {@link #markReady()} if all services were new at the time this\n     * method was called and when all the listeners were installed.\n     */\n    ServiceManagerState(ImmutableCollection<Service> services) {\n      this.numberOfServices = services.size();\n      servicesByState.putAll(NEW, services);\n    }\n\n    /**\n     * Attempts to start the timer immediately prior to the service being started via\n     * {@link Service#startAsync()}.\n     */\n    void tryStartTiming(Service service) {\n      monitor.enter();\n      try {\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          startupTimers.put(service, Stopwatch.createStarted());\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    /**\n     * Marks the {@link State} as ready to receive transitions. Returns true if no transitions have\n     * been observed yet.\n     */\n    void markReady() {\n      monitor.enter();\n      try {\n        if (!transitioned) {\n          // nothing has transitioned since construction, good.\n          ready = true;\n        } else {\n          // This should be an extremely rare race condition.\n          List<Service> servicesInBadStates = Lists.newArrayList();\n          for (Service service : servicesByState().values()) {\n            if (service.state() != NEW) {\n              servicesInBadStates.add(service);\n            }\n          }\n          throw new IllegalArgumentException(\"Services started transitioning asynchronously before \"\n              + \"the ServiceManager was constructed: \" + servicesInBadStates);\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void addListener(Listener listener, Executor executor) {\n      checkNotNull(listener, \"listener\");\n      checkNotNull(executor, \"executor\");\n      monitor.enter();\n      try {\n        // no point in adding a listener that will never be called\n        if (!stoppedGuard.isSatisfied()) {\n          listeners.add(new ListenerCallQueue<Listener>(listener, executor));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy() {\n      monitor.enterWhenUninterruptibly(awaitHealthGuard);\n      try {\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(awaitHealthGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to become healthy. The \"\n              + \"following services have not started: \"\n              + Multimaps.filterKeys(servicesByState, in(ImmutableSet.of(NEW, STARTING))));\n        }\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitStopped() {\n      monitor.enterWhenUninterruptibly(stoppedGuard);\n      monitor.leave();\n    }\n\n    void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(stoppedGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to stop. The following \"\n              + \"services have not stopped: \"\n              + Multimaps.filterKeys(servicesByState,\n                  not(in(EnumSet.of(TERMINATED, FAILED)))));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    ImmutableMultimap<State, Service> servicesByState() {\n      ImmutableSetMultimap.Builder<State, Service> builder = ImmutableSetMultimap.builder();\n      monitor.enter();\n      try {\n        for (Entry<State, Service> entry : servicesByState.entries()) {\n          if (!(entry.getValue() instanceof NoOpService)) {\n            builder.put(entry);\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      return builder.build();\n    }\n\n    ImmutableMap<Service, Long> startupTimes() {\n      List<Entry<Service, Long>> loadTimes;\n      monitor.enter();\n      try {\n        loadTimes = Lists.newArrayListWithCapacity(startupTimers.size());\n        // N.B. There will only be an entry in the map if the service has started\n        for (Entry<Service, Stopwatch> entry : startupTimers.entrySet()) {\n          Service service = entry.getKey();\n          Stopwatch stopWatch = entry.getValue();\n          if (!stopWatch.isRunning() && !(service instanceof NoOpService)) {\n            loadTimes.add(Maps.immutableEntry(service, stopWatch.elapsed(MILLISECONDS)));\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      Collections.sort(loadTimes, Ordering.natural()\n          .onResultOf(new Function<Entry<Service, Long>, Long>() {\n            @Override public Long apply(Map.Entry<Service, Long> input) {\n              return input.getValue();\n            }\n          }));\n      return ImmutableMap.copyOf(loadTimes);\n    }\n\n    /**\n     * Updates the state with the given service transition.\n     *\n     * <p>This method performs the main logic of ServiceManager in the following steps.\n     * <ol>\n     *      <li>Update the {@link #servicesByState()}\n     *      <li>Update the {@link #startupTimers}\n     *      <li>Based on the new state queue listeners to run\n     *      <li>Run the listeners (outside of the lock)\n     * </ol>\n     */\n    void transitionService(final Service service, State from, State to) {\n      checkNotNull(service);\n      checkArgument(from != to);\n      monitor.enter();\n      try {\n        transitioned = true;\n        if (!ready) {\n          return;\n        }\n        // Update state.\n        checkState(servicesByState.remove(from, service),\n            \"Service %s not at the expected location in the state map %s\", service, from);\n        checkState(servicesByState.put(to, service),\n            \"Service %s in the state map unexpectedly at %s\", service, to);\n        // Update the timer\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          // This means the service was started by some means other than ServiceManager.startAsync\n          stopwatch = Stopwatch.createStarted();\n          startupTimers.put(service, stopwatch);\n        }\n        if (to.compareTo(RUNNING) >= 0 && stopwatch.isRunning()) {\n          // N.B. if we miss the STARTING event then we may never record a startup time.\n          stopwatch.stop();\n          if (!(service instanceof NoOpService)) {\n            logger.log(Level.FINE, \"Started {0} in {1}.\", new Object[] {service, stopwatch});\n          }\n        }\n        // Queue our listeners\n\n        // Did a service fail?\n        if (to == FAILED) {\n          fireFailedListeners(service);\n        }\n\n        if (states.count(RUNNING) == numberOfServices) {\n          // This means that the manager is currently healthy. N.B. If other threads call isHealthy\n          // they are not guaranteed to get 'true', because any service could fail right now.\n          fireHealthyListeners();\n        } else if (states.count(TERMINATED) + states.count(FAILED) == numberOfServices) {\n          fireStoppedListeners();\n        }\n      } finally {\n        monitor.leave();\n        // Run our executors outside of the lock\n        executeListeners();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireStoppedListeners() {\n      STOPPED_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireHealthyListeners() {\n      HEALTHY_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireFailedListeners(final Service service) {\n      new Callback<Listener>(\"failed({service=\" + service + \"})\") {\n        @Override void call(Listener listener) {\n          listener.failure(service);\n        }\n      }.enqueueOn(listeners);\n    }\n\n    /** Attempts to execute all the listeners in {@link #listeners}. */\n    void executeListeners() {\n      checkState(!monitor.isOccupiedByCurrentThread(),\n          \"It is incorrect to execute listeners with the monitor held.\");\n      // iterate by index to avoid concurrent modification exceptions\n      for (int i = 0; i < listeners.size(); i++) {\n        listeners.get(i).execute();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void checkHealthy() {\n      if (states.count(RUNNING) != numberOfServices) {\n        IllegalStateException exception = new IllegalStateException(\n            \"Expected to be healthy after starting. The following services are not running: \"\n                + Multimaps.filterKeys(servicesByState, not(equalTo(RUNNING))));\n        throw exception;\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} that wraps another service and times how long it takes for it to start and\n   * also calls the {@link ServiceManagerState#transitionService(Service, State, State)},\n   * to record the state transitions.\n   */\n  private static final class ServiceListener extends Service.Listener {\n    final Service service;\n    // We store the state in a weak reference to ensure that if something went wrong while\n    // constructing the ServiceManager we don't pointlessly keep updating the state.\n    final WeakReference<ServiceManagerState> state;\n\n    ServiceListener(Service service, WeakReference<ServiceManagerState> state) {\n      this.service = service;\n      this.state = state;\n    }\n\n    @Override public void starting() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, NEW, STARTING);\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Starting {0}.\", service);\n        }\n      }\n    }\n\n    @Override public void running() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, STARTING, RUNNING);\n      }\n    }\n\n    @Override public void stopping(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, from, STOPPING);\n      }\n    }\n\n    @Override public void terminated(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Service {0} has terminated. Previous state was: {1}\",\n              new Object[] {service, from});\n        }\n        state.transitionService(service, from, TERMINATED);\n      }\n    }\n\n    @Override public void failed(State from, Throwable failure) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        // Log before the transition, so that if the process exits in response to server failure,\n        // there is a higher likelihood that the cause will be in the logs.\n        if (!(service instanceof NoOpService) ) {\n          logger.log(Level.SEVERE, \"Service \" + service + \" has failed in the \" + from + \" state.\",\n              failure);\n        }\n        state.transitionService(service, from, FAILED);\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} instance that does nothing.  This is only useful as a placeholder to\n   * ensure that the {@link ServiceManager} functions properly even when it is managing no services.\n   *\n   * <p>The use of this class is considered an implementation detail of ServiceManager and as such\n   * it is excluded from {@link #servicesByState}, {@link #startupTimes}, {@link #toString} and all\n   * logging statements.\n   */\n  private static final class NoOpService extends AbstractService {\n    @Override protected void doStart() { notifyStarted(); }\n    @Override protected void doStop() { notifyStopped(); }\n  }\n\n  /** This is never thrown but only used for logging. */\n  private static final class EmptyServiceManagerWarning extends Throwable {}\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53082063,"label":true,"oracleId":1451,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"ServiceManager","javadocTag":"@param unit the time unit of the timeout argument","methodJavadoc":"    /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy} for no more\n   * than the given time.  The manager will become healthy after all the component services have\n   * reached the {@linkplain State#RUNNING running} state.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have finished starting within the deadline\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */","methodSourceCode":"public void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException{\n    state.awaitHealthy(timeout, unit);\n}","classJavadoc":"/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */","classSourceCode":"/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Predicates.equalTo;\nimport static com.google.common.base.Predicates.in;\nimport static com.google.common.base.Predicates.instanceOf;\nimport static com.google.common.base.Predicates.not;\nimport static com.google.common.util.concurrent.MoreExecutors.directExecutor;\nimport static com.google.common.util.concurrent.Service.State.FAILED;\nimport static com.google.common.util.concurrent.Service.State.NEW;\nimport static com.google.common.util.concurrent.Service.State.RUNNING;\nimport static com.google.common.util.concurrent.Service.State.STARTING;\nimport static com.google.common.util.concurrent.Service.State.STOPPING;\nimport static com.google.common.util.concurrent.Service.State.TERMINATED;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.base.Function;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Stopwatch;\nimport com.google.common.collect.Collections2;\nimport com.google.common.collect.ImmutableCollection;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableMultimap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSetMultimap;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.MultimapBuilder;\nimport com.google.common.collect.Multimaps;\nimport com.google.common.collect.Multiset;\nimport com.google.common.collect.Ordering;\nimport com.google.common.collect.SetMultimap;\nimport com.google.common.util.concurrent.ListenerCallQueue.Callback;\nimport com.google.common.util.concurrent.Service.State;\nimport com.google.j2objc.annotations.WeakOuter;\n\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */\n@Beta\npublic final class ServiceManager {\n  private static final Logger logger = Logger.getLogger(ServiceManager.class.getName());\n  private static final Callback<Listener> HEALTHY_CALLBACK = new Callback<Listener>(\"healthy()\") {\n    @Override void call(Listener listener) {\n      listener.healthy();\n    }\n  };\n  private static final Callback<Listener> STOPPED_CALLBACK = new Callback<Listener>(\"stopped()\") {\n    @Override void call(Listener listener) {\n      listener.stopped();\n    }\n  };\n\n  /**\n   * A listener for the aggregate state changes of the services that are under management. Users\n   * that need to listen to more fine-grained events (such as when each particular {@linkplain\n   * Service service} starts, or terminates), should attach {@linkplain Service.Listener service\n   * listeners} to each individual service.\n   *\n   * @author Luke Sandberg\n   * @since 15.0 (present as an interface in 14.0)\n   */\n  @Beta  // Should come out of Beta when ServiceManager does\n  public abstract static class Listener {\n    /**\n     * Called when the service initially becomes healthy.\n     *\n     * <p>This will be called at most once after all the services have entered the\n     * {@linkplain State#RUNNING running} state. If any services fail during start up or\n     * {@linkplain State#FAILED fail}/{@linkplain State#TERMINATED terminate} before all other\n     * services have started {@linkplain State#RUNNING running} then this method will not be called.\n     */\n    public void healthy() {}\n\n    /**\n     * Called when the all of the component services have reached a terminal state, either\n     * {@linkplain State#TERMINATED terminated} or {@linkplain State#FAILED failed}.\n     */\n    public void stopped() {}\n\n    /**\n     * Called when a component service has {@linkplain State#FAILED failed}.\n     *\n     * @param service The service that failed.\n     */\n    public void failure(Service service) {}\n  }\n\n  /**\n   * An encapsulation of all of the state that is accessed by the {@linkplain ServiceListener\n   * service listeners}.  This is extracted into its own object so that {@link ServiceListener}\n   * could be made {@code static} and its instances can be safely constructed and added in the\n   * {@link ServiceManager} constructor without having to close over the partially constructed\n   * {@link ServiceManager} instance (i.e. avoid leaking a pointer to {@code this}).\n   */\n  private final ServiceManagerState state;\n  private final ImmutableList<Service> services;\n\n  /**\n   * Constructs a new instance for managing the given services.\n   *\n   * @param services The services to manage\n   *\n   * @throws IllegalArgumentException if not all services are {@linkplain State#NEW new} or if there\n   * are any duplicate services.\n   */\n  public ServiceManager(Iterable<? extends Service> services) {\n    ImmutableList<Service> copy = ImmutableList.copyOf(services);\n    if (copy.isEmpty()) {\n      // Having no services causes the manager to behave strangely. Notably, listeners are never\n      // fired.  To avoid this we substitute a placeholder service.\n      logger.log(Level.WARNING,\n          \"ServiceManager configured with no services.  Is your application configured properly?\",\n          new EmptyServiceManagerWarning());\n      copy = ImmutableList.<Service>of(new NoOpService());\n    }\n    this.state = new ServiceManagerState(copy);\n    this.services = copy;\n    WeakReference<ServiceManagerState> stateReference =\n        new WeakReference<ServiceManagerState>(state);\n    for (Service service : copy) {\n      service.addListener(new ServiceListener(service, stateReference), directExecutor());\n      // We check the state after adding the listener as a way to ensure that our listener was added\n      // to a NEW service.\n      checkArgument(service.state() == NEW, \"Can only manage NEW services, %s\", service);\n    }\n    // We have installed all of our listeners and after this point any state transition should be\n    // correct.\n    this.state.markReady();\n  }\n\n  /**\n   * Registers a {@link Listener} to be {@linkplain Executor#execute executed} on the given\n   * executor. The listener will not have previous state changes replayed, so it is\n   * suggested that listeners are added before any of the managed services are\n   * {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged. Any exception thrown\n   * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException}) will be caught and\n   * logged.\n   *\n   * <p> For fast, lightweight listeners that would be safe to execute in any thread, consider\n   * calling {@link #addListener(Listener)}.\n   *\n   * @param listener the listener to run when the manager changes state\n   * @param executor the executor in which the listeners callback methods will be run.\n   */\n  public void addListener(Listener listener, Executor executor) {\n    state.addListener(listener, executor);\n  }\n\n  /**\n   * Registers a {@link Listener} to be run when this {@link ServiceManager} changes state. The\n   * listener will not have previous state changes replayed, so it is suggested that listeners are\n   * added before any of the managed services are {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged.\n   *\n   * @param listener the listener to run when the manager changes state\n   */\n  public void addListener(Listener listener) {\n    state.addListener(listener, directExecutor());\n  }\n\n  /**\n   * Initiates service {@linkplain Service#startAsync startup} on all the services being managed.\n   * It is only valid to call this method if all of the services are {@linkplain State#NEW new}.\n   *\n   * @return this\n   * @throws IllegalStateException if any of the Services are not {@link State#NEW new} when the\n   *     method is called.\n   */\n  public ServiceManager startAsync() {\n    for (Service service : services) {\n      State state = service.state();\n      checkState(state == NEW, \"Service %s is %s, cannot start it.\", service, state);\n    }\n    for (Service service : services) {\n      try {\n        state.tryStartTiming(service);\n        service.startAsync();\n      } catch (IllegalStateException e) {\n        // This can happen if the service has already been started or stopped (e.g. by another\n        // service or listener). Our contract says it is safe to call this method if\n        // all services were NEW when it was called, and this has already been verified above, so we\n        // don't propagate the exception.\n        logger.log(Level.WARNING, \"Unable to start Service \" + service, e);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy}.  The manager\n   * will become healthy after all the component services have reached the {@linkplain State#RUNNING\n   * running} state.\n   *\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy() {\n    state.awaitHealthy();\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy} for no more\n   * than the given time.  The manager will become healthy after all the component services have\n   * reached the {@linkplain State#RUNNING running} state.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have finished starting within the deadline\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitHealthy(timeout, unit);\n  }\n\n  /**\n   * Initiates service {@linkplain Service#stopAsync shutdown} if necessary on all the services\n   * being managed.\n   *\n   * @return this\n   */\n  public ServiceManager stopAsync() {\n    for (Service service : services) {\n      service.stopAsync();\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state. After this method returns all\n   * services will either be {@linkplain Service.State#TERMINATED terminated} or {@linkplain\n   * Service.State#FAILED failed}.\n   */\n  public void awaitStopped() {\n    state.awaitStopped();\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state for no more than the given time. After\n   * this method returns all services will either be {@linkplain Service.State#TERMINATED\n   * terminated} or {@linkplain Service.State#FAILED failed}.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have stopped within the deadline\n   */\n  public void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitStopped(timeout, unit);\n  }\n\n  /**\n   * Returns true if all services are currently in the {@linkplain State#RUNNING running} state.\n   *\n   * <p>Users who want more detailed information should use the {@link #servicesByState} method to\n   * get detailed information about which services are not running.\n   */\n  public boolean isHealthy() {\n    for (Service service : services) {\n      if (!service.isRunning()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Provides a snapshot of the current state of all the services under management.\n   *\n   * <p>N.B. This snapshot is guaranteed to be consistent, i.e. the set of states returned will\n   * correspond to a point in time view of the services.\n   */\n  public ImmutableMultimap<State, Service> servicesByState() {\n    return state.servicesByState();\n  }\n\n  /**\n   * Returns the service load times. This value will only return startup times for services that\n   * have finished starting.\n   *\n   * @return Map of services and their corresponding startup time in millis, the map entries will be\n   *     ordered by startup time.\n   */\n  public ImmutableMap<Service, Long> startupTimes() {\n    return state.startupTimes();\n  }\n\n  @Override public String toString() {\n    return MoreObjects.toStringHelper(ServiceManager.class)\n        .add(\"services\", Collections2.filter(services, not(instanceOf(NoOpService.class))))\n        .toString();\n  }\n\n  /**\n   * An encapsulation of all the mutable state of the {@link ServiceManager} that needs to be\n   * accessed by instances of {@link ServiceListener}.\n   */\n  private static final class ServiceManagerState {\n    final Monitor monitor = new Monitor();\n\n    @GuardedBy(\"monitor\")\n    final SetMultimap<State, Service> servicesByState =\n        MultimapBuilder.enumKeys(State.class).linkedHashSetValues().build();\n\n    @GuardedBy(\"monitor\")\n    final Multiset<State> states = servicesByState.keys();\n\n    @GuardedBy(\"monitor\")\n    final Map<Service, Stopwatch> startupTimers = Maps.newIdentityHashMap();\n\n    /**\n     * These two booleans are used to mark the state as ready to start.\n     * {@link #ready}: is set by {@link #markReady} to indicate that all listeners have been\n     *     correctly installed\n     * {@link #transitioned}: is set by {@link #transitionService} to indicate that some transition\n     *     has been performed.\n     *\n     * <p>Together, they allow us to enforce that all services have their listeners installed prior\n     * to any service performing a transition, then we can fail in the ServiceManager constructor\n     * rather than in a Service.Listener callback.\n     */\n    @GuardedBy(\"monitor\")\n    boolean ready;\n\n    @GuardedBy(\"monitor\")\n    boolean transitioned;\n\n    final int numberOfServices;\n\n    /**\n     * Controls how long to wait for all the services to either become healthy or reach a\n     * state from which it is guaranteed that it can never become healthy.\n     */\n    final Monitor.Guard awaitHealthGuard = new AwaitHealthGuard();\n\n    @WeakOuter\n    final class AwaitHealthGuard extends Monitor.Guard {\n      AwaitHealthGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        // All services have started or some service has terminated/failed.\n        return states.count(RUNNING) == numberOfServices\n            || states.contains(STOPPING)\n            || states.contains(TERMINATED)\n            || states.contains(FAILED);\n      }\n    }\n\n    /**\n     * Controls how long to wait for all services to reach a terminal state.\n     */\n    final Monitor.Guard stoppedGuard = new StoppedGuard();\n\n    @WeakOuter\n    final class StoppedGuard extends Monitor.Guard {\n      StoppedGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        return states.count(TERMINATED) + states.count(FAILED) == numberOfServices;\n      }\n    }\n\n    /** The listeners to notify during a state transition. */\n    @GuardedBy(\"monitor\")\n    final List<ListenerCallQueue<Listener>> listeners =\n        Collections.synchronizedList(new ArrayList<ListenerCallQueue<Listener>>());\n\n    /**\n     * It is implicitly assumed that all the services are NEW and that they will all remain NEW\n     * until all the Listeners are installed and {@link #markReady()} is called.  It is our caller's\n     * responsibility to only call {@link #markReady()} if all services were new at the time this\n     * method was called and when all the listeners were installed.\n     */\n    ServiceManagerState(ImmutableCollection<Service> services) {\n      this.numberOfServices = services.size();\n      servicesByState.putAll(NEW, services);\n    }\n\n    /**\n     * Attempts to start the timer immediately prior to the service being started via\n     * {@link Service#startAsync()}.\n     */\n    void tryStartTiming(Service service) {\n      monitor.enter();\n      try {\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          startupTimers.put(service, Stopwatch.createStarted());\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    /**\n     * Marks the {@link State} as ready to receive transitions. Returns true if no transitions have\n     * been observed yet.\n     */\n    void markReady() {\n      monitor.enter();\n      try {\n        if (!transitioned) {\n          // nothing has transitioned since construction, good.\n          ready = true;\n        } else {\n          // This should be an extremely rare race condition.\n          List<Service> servicesInBadStates = Lists.newArrayList();\n          for (Service service : servicesByState().values()) {\n            if (service.state() != NEW) {\n              servicesInBadStates.add(service);\n            }\n          }\n          throw new IllegalArgumentException(\"Services started transitioning asynchronously before \"\n              + \"the ServiceManager was constructed: \" + servicesInBadStates);\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void addListener(Listener listener, Executor executor) {\n      checkNotNull(listener, \"listener\");\n      checkNotNull(executor, \"executor\");\n      monitor.enter();\n      try {\n        // no point in adding a listener that will never be called\n        if (!stoppedGuard.isSatisfied()) {\n          listeners.add(new ListenerCallQueue<Listener>(listener, executor));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy() {\n      monitor.enterWhenUninterruptibly(awaitHealthGuard);\n      try {\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(awaitHealthGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to become healthy. The \"\n              + \"following services have not started: \"\n              + Multimaps.filterKeys(servicesByState, in(ImmutableSet.of(NEW, STARTING))));\n        }\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitStopped() {\n      monitor.enterWhenUninterruptibly(stoppedGuard);\n      monitor.leave();\n    }\n\n    void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(stoppedGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to stop. The following \"\n              + \"services have not stopped: \"\n              + Multimaps.filterKeys(servicesByState,\n                  not(in(EnumSet.of(TERMINATED, FAILED)))));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    ImmutableMultimap<State, Service> servicesByState() {\n      ImmutableSetMultimap.Builder<State, Service> builder = ImmutableSetMultimap.builder();\n      monitor.enter();\n      try {\n        for (Entry<State, Service> entry : servicesByState.entries()) {\n          if (!(entry.getValue() instanceof NoOpService)) {\n            builder.put(entry);\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      return builder.build();\n    }\n\n    ImmutableMap<Service, Long> startupTimes() {\n      List<Entry<Service, Long>> loadTimes;\n      monitor.enter();\n      try {\n        loadTimes = Lists.newArrayListWithCapacity(startupTimers.size());\n        // N.B. There will only be an entry in the map if the service has started\n        for (Entry<Service, Stopwatch> entry : startupTimers.entrySet()) {\n          Service service = entry.getKey();\n          Stopwatch stopWatch = entry.getValue();\n          if (!stopWatch.isRunning() && !(service instanceof NoOpService)) {\n            loadTimes.add(Maps.immutableEntry(service, stopWatch.elapsed(MILLISECONDS)));\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      Collections.sort(loadTimes, Ordering.natural()\n          .onResultOf(new Function<Entry<Service, Long>, Long>() {\n            @Override public Long apply(Map.Entry<Service, Long> input) {\n              return input.getValue();\n            }\n          }));\n      return ImmutableMap.copyOf(loadTimes);\n    }\n\n    /**\n     * Updates the state with the given service transition.\n     *\n     * <p>This method performs the main logic of ServiceManager in the following steps.\n     * <ol>\n     *      <li>Update the {@link #servicesByState()}\n     *      <li>Update the {@link #startupTimers}\n     *      <li>Based on the new state queue listeners to run\n     *      <li>Run the listeners (outside of the lock)\n     * </ol>\n     */\n    void transitionService(final Service service, State from, State to) {\n      checkNotNull(service);\n      checkArgument(from != to);\n      monitor.enter();\n      try {\n        transitioned = true;\n        if (!ready) {\n          return;\n        }\n        // Update state.\n        checkState(servicesByState.remove(from, service),\n            \"Service %s not at the expected location in the state map %s\", service, from);\n        checkState(servicesByState.put(to, service),\n            \"Service %s in the state map unexpectedly at %s\", service, to);\n        // Update the timer\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          // This means the service was started by some means other than ServiceManager.startAsync\n          stopwatch = Stopwatch.createStarted();\n          startupTimers.put(service, stopwatch);\n        }\n        if (to.compareTo(RUNNING) >= 0 && stopwatch.isRunning()) {\n          // N.B. if we miss the STARTING event then we may never record a startup time.\n          stopwatch.stop();\n          if (!(service instanceof NoOpService)) {\n            logger.log(Level.FINE, \"Started {0} in {1}.\", new Object[] {service, stopwatch});\n          }\n        }\n        // Queue our listeners\n\n        // Did a service fail?\n        if (to == FAILED) {\n          fireFailedListeners(service);\n        }\n\n        if (states.count(RUNNING) == numberOfServices) {\n          // This means that the manager is currently healthy. N.B. If other threads call isHealthy\n          // they are not guaranteed to get 'true', because any service could fail right now.\n          fireHealthyListeners();\n        } else if (states.count(TERMINATED) + states.count(FAILED) == numberOfServices) {\n          fireStoppedListeners();\n        }\n      } finally {\n        monitor.leave();\n        // Run our executors outside of the lock\n        executeListeners();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireStoppedListeners() {\n      STOPPED_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireHealthyListeners() {\n      HEALTHY_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireFailedListeners(final Service service) {\n      new Callback<Listener>(\"failed({service=\" + service + \"})\") {\n        @Override void call(Listener listener) {\n          listener.failure(service);\n        }\n      }.enqueueOn(listeners);\n    }\n\n    /** Attempts to execute all the listeners in {@link #listeners}. */\n    void executeListeners() {\n      checkState(!monitor.isOccupiedByCurrentThread(),\n          \"It is incorrect to execute listeners with the monitor held.\");\n      // iterate by index to avoid concurrent modification exceptions\n      for (int i = 0; i < listeners.size(); i++) {\n        listeners.get(i).execute();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void checkHealthy() {\n      if (states.count(RUNNING) != numberOfServices) {\n        IllegalStateException exception = new IllegalStateException(\n            \"Expected to be healthy after starting. The following services are not running: \"\n                + Multimaps.filterKeys(servicesByState, not(equalTo(RUNNING))));\n        throw exception;\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} that wraps another service and times how long it takes for it to start and\n   * also calls the {@link ServiceManagerState#transitionService(Service, State, State)},\n   * to record the state transitions.\n   */\n  private static final class ServiceListener extends Service.Listener {\n    final Service service;\n    // We store the state in a weak reference to ensure that if something went wrong while\n    // constructing the ServiceManager we don't pointlessly keep updating the state.\n    final WeakReference<ServiceManagerState> state;\n\n    ServiceListener(Service service, WeakReference<ServiceManagerState> state) {\n      this.service = service;\n      this.state = state;\n    }\n\n    @Override public void starting() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, NEW, STARTING);\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Starting {0}.\", service);\n        }\n      }\n    }\n\n    @Override public void running() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, STARTING, RUNNING);\n      }\n    }\n\n    @Override public void stopping(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, from, STOPPING);\n      }\n    }\n\n    @Override public void terminated(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Service {0} has terminated. Previous state was: {1}\",\n              new Object[] {service, from});\n        }\n        state.transitionService(service, from, TERMINATED);\n      }\n    }\n\n    @Override public void failed(State from, Throwable failure) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        // Log before the transition, so that if the process exits in response to server failure,\n        // there is a higher likelihood that the cause will be in the logs.\n        if (!(service instanceof NoOpService) ) {\n          logger.log(Level.SEVERE, \"Service \" + service + \" has failed in the \" + from + \" state.\",\n              failure);\n        }\n        state.transitionService(service, from, FAILED);\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} instance that does nothing.  This is only useful as a placeholder to\n   * ensure that the {@link ServiceManager} functions properly even when it is managing no services.\n   *\n   * <p>The use of this class is considered an implementation detail of ServiceManager and as such\n   * it is excluded from {@link #servicesByState}, {@link #startupTimes}, {@link #toString} and all\n   * logging statements.\n   */\n  private static final class NoOpService extends AbstractService {\n    @Override protected void doStart() { notifyStarted(); }\n    @Override protected void doStop() { notifyStopped(); }\n  }\n\n  /** This is never thrown but only used for logging. */\n  private static final class EmptyServiceManagerWarning extends Throwable {}\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53082523,"label":true,"oracleId":1452,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"ServiceManager","javadocTag":"@throws TimeoutException if not all of the services have finished starting within the deadline","methodJavadoc":"    /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy} for no more\n   * than the given time.  The manager will become healthy after all the component services have\n   * reached the {@linkplain State#RUNNING running} state.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have finished starting within the deadline\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */","methodSourceCode":"public void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException{\n    state.awaitHealthy(timeout, unit);\n}","classJavadoc":"/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */","classSourceCode":"/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Predicates.equalTo;\nimport static com.google.common.base.Predicates.in;\nimport static com.google.common.base.Predicates.instanceOf;\nimport static com.google.common.base.Predicates.not;\nimport static com.google.common.util.concurrent.MoreExecutors.directExecutor;\nimport static com.google.common.util.concurrent.Service.State.FAILED;\nimport static com.google.common.util.concurrent.Service.State.NEW;\nimport static com.google.common.util.concurrent.Service.State.RUNNING;\nimport static com.google.common.util.concurrent.Service.State.STARTING;\nimport static com.google.common.util.concurrent.Service.State.STOPPING;\nimport static com.google.common.util.concurrent.Service.State.TERMINATED;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.base.Function;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Stopwatch;\nimport com.google.common.collect.Collections2;\nimport com.google.common.collect.ImmutableCollection;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableMultimap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSetMultimap;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.MultimapBuilder;\nimport com.google.common.collect.Multimaps;\nimport com.google.common.collect.Multiset;\nimport com.google.common.collect.Ordering;\nimport com.google.common.collect.SetMultimap;\nimport com.google.common.util.concurrent.ListenerCallQueue.Callback;\nimport com.google.common.util.concurrent.Service.State;\nimport com.google.j2objc.annotations.WeakOuter;\n\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */\n@Beta\npublic final class ServiceManager {\n  private static final Logger logger = Logger.getLogger(ServiceManager.class.getName());\n  private static final Callback<Listener> HEALTHY_CALLBACK = new Callback<Listener>(\"healthy()\") {\n    @Override void call(Listener listener) {\n      listener.healthy();\n    }\n  };\n  private static final Callback<Listener> STOPPED_CALLBACK = new Callback<Listener>(\"stopped()\") {\n    @Override void call(Listener listener) {\n      listener.stopped();\n    }\n  };\n\n  /**\n   * A listener for the aggregate state changes of the services that are under management. Users\n   * that need to listen to more fine-grained events (such as when each particular {@linkplain\n   * Service service} starts, or terminates), should attach {@linkplain Service.Listener service\n   * listeners} to each individual service.\n   *\n   * @author Luke Sandberg\n   * @since 15.0 (present as an interface in 14.0)\n   */\n  @Beta  // Should come out of Beta when ServiceManager does\n  public abstract static class Listener {\n    /**\n     * Called when the service initially becomes healthy.\n     *\n     * <p>This will be called at most once after all the services have entered the\n     * {@linkplain State#RUNNING running} state. If any services fail during start up or\n     * {@linkplain State#FAILED fail}/{@linkplain State#TERMINATED terminate} before all other\n     * services have started {@linkplain State#RUNNING running} then this method will not be called.\n     */\n    public void healthy() {}\n\n    /**\n     * Called when the all of the component services have reached a terminal state, either\n     * {@linkplain State#TERMINATED terminated} or {@linkplain State#FAILED failed}.\n     */\n    public void stopped() {}\n\n    /**\n     * Called when a component service has {@linkplain State#FAILED failed}.\n     *\n     * @param service The service that failed.\n     */\n    public void failure(Service service) {}\n  }\n\n  /**\n   * An encapsulation of all of the state that is accessed by the {@linkplain ServiceListener\n   * service listeners}.  This is extracted into its own object so that {@link ServiceListener}\n   * could be made {@code static} and its instances can be safely constructed and added in the\n   * {@link ServiceManager} constructor without having to close over the partially constructed\n   * {@link ServiceManager} instance (i.e. avoid leaking a pointer to {@code this}).\n   */\n  private final ServiceManagerState state;\n  private final ImmutableList<Service> services;\n\n  /**\n   * Constructs a new instance for managing the given services.\n   *\n   * @param services The services to manage\n   *\n   * @throws IllegalArgumentException if not all services are {@linkplain State#NEW new} or if there\n   * are any duplicate services.\n   */\n  public ServiceManager(Iterable<? extends Service> services) {\n    ImmutableList<Service> copy = ImmutableList.copyOf(services);\n    if (copy.isEmpty()) {\n      // Having no services causes the manager to behave strangely. Notably, listeners are never\n      // fired.  To avoid this we substitute a placeholder service.\n      logger.log(Level.WARNING,\n          \"ServiceManager configured with no services.  Is your application configured properly?\",\n          new EmptyServiceManagerWarning());\n      copy = ImmutableList.<Service>of(new NoOpService());\n    }\n    this.state = new ServiceManagerState(copy);\n    this.services = copy;\n    WeakReference<ServiceManagerState> stateReference =\n        new WeakReference<ServiceManagerState>(state);\n    for (Service service : copy) {\n      service.addListener(new ServiceListener(service, stateReference), directExecutor());\n      // We check the state after adding the listener as a way to ensure that our listener was added\n      // to a NEW service.\n      checkArgument(service.state() == NEW, \"Can only manage NEW services, %s\", service);\n    }\n    // We have installed all of our listeners and after this point any state transition should be\n    // correct.\n    this.state.markReady();\n  }\n\n  /**\n   * Registers a {@link Listener} to be {@linkplain Executor#execute executed} on the given\n   * executor. The listener will not have previous state changes replayed, so it is\n   * suggested that listeners are added before any of the managed services are\n   * {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged. Any exception thrown\n   * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException}) will be caught and\n   * logged.\n   *\n   * <p> For fast, lightweight listeners that would be safe to execute in any thread, consider\n   * calling {@link #addListener(Listener)}.\n   *\n   * @param listener the listener to run when the manager changes state\n   * @param executor the executor in which the listeners callback methods will be run.\n   */\n  public void addListener(Listener listener, Executor executor) {\n    state.addListener(listener, executor);\n  }\n\n  /**\n   * Registers a {@link Listener} to be run when this {@link ServiceManager} changes state. The\n   * listener will not have previous state changes replayed, so it is suggested that listeners are\n   * added before any of the managed services are {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged.\n   *\n   * @param listener the listener to run when the manager changes state\n   */\n  public void addListener(Listener listener) {\n    state.addListener(listener, directExecutor());\n  }\n\n  /**\n   * Initiates service {@linkplain Service#startAsync startup} on all the services being managed.\n   * It is only valid to call this method if all of the services are {@linkplain State#NEW new}.\n   *\n   * @return this\n   * @throws IllegalStateException if any of the Services are not {@link State#NEW new} when the\n   *     method is called.\n   */\n  public ServiceManager startAsync() {\n    for (Service service : services) {\n      State state = service.state();\n      checkState(state == NEW, \"Service %s is %s, cannot start it.\", service, state);\n    }\n    for (Service service : services) {\n      try {\n        state.tryStartTiming(service);\n        service.startAsync();\n      } catch (IllegalStateException e) {\n        // This can happen if the service has already been started or stopped (e.g. by another\n        // service or listener). Our contract says it is safe to call this method if\n        // all services were NEW when it was called, and this has already been verified above, so we\n        // don't propagate the exception.\n        logger.log(Level.WARNING, \"Unable to start Service \" + service, e);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy}.  The manager\n   * will become healthy after all the component services have reached the {@linkplain State#RUNNING\n   * running} state.\n   *\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy() {\n    state.awaitHealthy();\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy} for no more\n   * than the given time.  The manager will become healthy after all the component services have\n   * reached the {@linkplain State#RUNNING running} state.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have finished starting within the deadline\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitHealthy(timeout, unit);\n  }\n\n  /**\n   * Initiates service {@linkplain Service#stopAsync shutdown} if necessary on all the services\n   * being managed.\n   *\n   * @return this\n   */\n  public ServiceManager stopAsync() {\n    for (Service service : services) {\n      service.stopAsync();\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state. After this method returns all\n   * services will either be {@linkplain Service.State#TERMINATED terminated} or {@linkplain\n   * Service.State#FAILED failed}.\n   */\n  public void awaitStopped() {\n    state.awaitStopped();\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state for no more than the given time. After\n   * this method returns all services will either be {@linkplain Service.State#TERMINATED\n   * terminated} or {@linkplain Service.State#FAILED failed}.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have stopped within the deadline\n   */\n  public void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitStopped(timeout, unit);\n  }\n\n  /**\n   * Returns true if all services are currently in the {@linkplain State#RUNNING running} state.\n   *\n   * <p>Users who want more detailed information should use the {@link #servicesByState} method to\n   * get detailed information about which services are not running.\n   */\n  public boolean isHealthy() {\n    for (Service service : services) {\n      if (!service.isRunning()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Provides a snapshot of the current state of all the services under management.\n   *\n   * <p>N.B. This snapshot is guaranteed to be consistent, i.e. the set of states returned will\n   * correspond to a point in time view of the services.\n   */\n  public ImmutableMultimap<State, Service> servicesByState() {\n    return state.servicesByState();\n  }\n\n  /**\n   * Returns the service load times. This value will only return startup times for services that\n   * have finished starting.\n   *\n   * @return Map of services and their corresponding startup time in millis, the map entries will be\n   *     ordered by startup time.\n   */\n  public ImmutableMap<Service, Long> startupTimes() {\n    return state.startupTimes();\n  }\n\n  @Override public String toString() {\n    return MoreObjects.toStringHelper(ServiceManager.class)\n        .add(\"services\", Collections2.filter(services, not(instanceOf(NoOpService.class))))\n        .toString();\n  }\n\n  /**\n   * An encapsulation of all the mutable state of the {@link ServiceManager} that needs to be\n   * accessed by instances of {@link ServiceListener}.\n   */\n  private static final class ServiceManagerState {\n    final Monitor monitor = new Monitor();\n\n    @GuardedBy(\"monitor\")\n    final SetMultimap<State, Service> servicesByState =\n        MultimapBuilder.enumKeys(State.class).linkedHashSetValues().build();\n\n    @GuardedBy(\"monitor\")\n    final Multiset<State> states = servicesByState.keys();\n\n    @GuardedBy(\"monitor\")\n    final Map<Service, Stopwatch> startupTimers = Maps.newIdentityHashMap();\n\n    /**\n     * These two booleans are used to mark the state as ready to start.\n     * {@link #ready}: is set by {@link #markReady} to indicate that all listeners have been\n     *     correctly installed\n     * {@link #transitioned}: is set by {@link #transitionService} to indicate that some transition\n     *     has been performed.\n     *\n     * <p>Together, they allow us to enforce that all services have their listeners installed prior\n     * to any service performing a transition, then we can fail in the ServiceManager constructor\n     * rather than in a Service.Listener callback.\n     */\n    @GuardedBy(\"monitor\")\n    boolean ready;\n\n    @GuardedBy(\"monitor\")\n    boolean transitioned;\n\n    final int numberOfServices;\n\n    /**\n     * Controls how long to wait for all the services to either become healthy or reach a\n     * state from which it is guaranteed that it can never become healthy.\n     */\n    final Monitor.Guard awaitHealthGuard = new AwaitHealthGuard();\n\n    @WeakOuter\n    final class AwaitHealthGuard extends Monitor.Guard {\n      AwaitHealthGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        // All services have started or some service has terminated/failed.\n        return states.count(RUNNING) == numberOfServices\n            || states.contains(STOPPING)\n            || states.contains(TERMINATED)\n            || states.contains(FAILED);\n      }\n    }\n\n    /**\n     * Controls how long to wait for all services to reach a terminal state.\n     */\n    final Monitor.Guard stoppedGuard = new StoppedGuard();\n\n    @WeakOuter\n    final class StoppedGuard extends Monitor.Guard {\n      StoppedGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        return states.count(TERMINATED) + states.count(FAILED) == numberOfServices;\n      }\n    }\n\n    /** The listeners to notify during a state transition. */\n    @GuardedBy(\"monitor\")\n    final List<ListenerCallQueue<Listener>> listeners =\n        Collections.synchronizedList(new ArrayList<ListenerCallQueue<Listener>>());\n\n    /**\n     * It is implicitly assumed that all the services are NEW and that they will all remain NEW\n     * until all the Listeners are installed and {@link #markReady()} is called.  It is our caller's\n     * responsibility to only call {@link #markReady()} if all services were new at the time this\n     * method was called and when all the listeners were installed.\n     */\n    ServiceManagerState(ImmutableCollection<Service> services) {\n      this.numberOfServices = services.size();\n      servicesByState.putAll(NEW, services);\n    }\n\n    /**\n     * Attempts to start the timer immediately prior to the service being started via\n     * {@link Service#startAsync()}.\n     */\n    void tryStartTiming(Service service) {\n      monitor.enter();\n      try {\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          startupTimers.put(service, Stopwatch.createStarted());\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    /**\n     * Marks the {@link State} as ready to receive transitions. Returns true if no transitions have\n     * been observed yet.\n     */\n    void markReady() {\n      monitor.enter();\n      try {\n        if (!transitioned) {\n          // nothing has transitioned since construction, good.\n          ready = true;\n        } else {\n          // This should be an extremely rare race condition.\n          List<Service> servicesInBadStates = Lists.newArrayList();\n          for (Service service : servicesByState().values()) {\n            if (service.state() != NEW) {\n              servicesInBadStates.add(service);\n            }\n          }\n          throw new IllegalArgumentException(\"Services started transitioning asynchronously before \"\n              + \"the ServiceManager was constructed: \" + servicesInBadStates);\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void addListener(Listener listener, Executor executor) {\n      checkNotNull(listener, \"listener\");\n      checkNotNull(executor, \"executor\");\n      monitor.enter();\n      try {\n        // no point in adding a listener that will never be called\n        if (!stoppedGuard.isSatisfied()) {\n          listeners.add(new ListenerCallQueue<Listener>(listener, executor));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy() {\n      monitor.enterWhenUninterruptibly(awaitHealthGuard);\n      try {\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(awaitHealthGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to become healthy. The \"\n              + \"following services have not started: \"\n              + Multimaps.filterKeys(servicesByState, in(ImmutableSet.of(NEW, STARTING))));\n        }\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitStopped() {\n      monitor.enterWhenUninterruptibly(stoppedGuard);\n      monitor.leave();\n    }\n\n    void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(stoppedGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to stop. The following \"\n              + \"services have not stopped: \"\n              + Multimaps.filterKeys(servicesByState,\n                  not(in(EnumSet.of(TERMINATED, FAILED)))));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    ImmutableMultimap<State, Service> servicesByState() {\n      ImmutableSetMultimap.Builder<State, Service> builder = ImmutableSetMultimap.builder();\n      monitor.enter();\n      try {\n        for (Entry<State, Service> entry : servicesByState.entries()) {\n          if (!(entry.getValue() instanceof NoOpService)) {\n            builder.put(entry);\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      return builder.build();\n    }\n\n    ImmutableMap<Service, Long> startupTimes() {\n      List<Entry<Service, Long>> loadTimes;\n      monitor.enter();\n      try {\n        loadTimes = Lists.newArrayListWithCapacity(startupTimers.size());\n        // N.B. There will only be an entry in the map if the service has started\n        for (Entry<Service, Stopwatch> entry : startupTimers.entrySet()) {\n          Service service = entry.getKey();\n          Stopwatch stopWatch = entry.getValue();\n          if (!stopWatch.isRunning() && !(service instanceof NoOpService)) {\n            loadTimes.add(Maps.immutableEntry(service, stopWatch.elapsed(MILLISECONDS)));\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      Collections.sort(loadTimes, Ordering.natural()\n          .onResultOf(new Function<Entry<Service, Long>, Long>() {\n            @Override public Long apply(Map.Entry<Service, Long> input) {\n              return input.getValue();\n            }\n          }));\n      return ImmutableMap.copyOf(loadTimes);\n    }\n\n    /**\n     * Updates the state with the given service transition.\n     *\n     * <p>This method performs the main logic of ServiceManager in the following steps.\n     * <ol>\n     *      <li>Update the {@link #servicesByState()}\n     *      <li>Update the {@link #startupTimers}\n     *      <li>Based on the new state queue listeners to run\n     *      <li>Run the listeners (outside of the lock)\n     * </ol>\n     */\n    void transitionService(final Service service, State from, State to) {\n      checkNotNull(service);\n      checkArgument(from != to);\n      monitor.enter();\n      try {\n        transitioned = true;\n        if (!ready) {\n          return;\n        }\n        // Update state.\n        checkState(servicesByState.remove(from, service),\n            \"Service %s not at the expected location in the state map %s\", service, from);\n        checkState(servicesByState.put(to, service),\n            \"Service %s in the state map unexpectedly at %s\", service, to);\n        // Update the timer\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          // This means the service was started by some means other than ServiceManager.startAsync\n          stopwatch = Stopwatch.createStarted();\n          startupTimers.put(service, stopwatch);\n        }\n        if (to.compareTo(RUNNING) >= 0 && stopwatch.isRunning()) {\n          // N.B. if we miss the STARTING event then we may never record a startup time.\n          stopwatch.stop();\n          if (!(service instanceof NoOpService)) {\n            logger.log(Level.FINE, \"Started {0} in {1}.\", new Object[] {service, stopwatch});\n          }\n        }\n        // Queue our listeners\n\n        // Did a service fail?\n        if (to == FAILED) {\n          fireFailedListeners(service);\n        }\n\n        if (states.count(RUNNING) == numberOfServices) {\n          // This means that the manager is currently healthy. N.B. If other threads call isHealthy\n          // they are not guaranteed to get 'true', because any service could fail right now.\n          fireHealthyListeners();\n        } else if (states.count(TERMINATED) + states.count(FAILED) == numberOfServices) {\n          fireStoppedListeners();\n        }\n      } finally {\n        monitor.leave();\n        // Run our executors outside of the lock\n        executeListeners();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireStoppedListeners() {\n      STOPPED_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireHealthyListeners() {\n      HEALTHY_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireFailedListeners(final Service service) {\n      new Callback<Listener>(\"failed({service=\" + service + \"})\") {\n        @Override void call(Listener listener) {\n          listener.failure(service);\n        }\n      }.enqueueOn(listeners);\n    }\n\n    /** Attempts to execute all the listeners in {@link #listeners}. */\n    void executeListeners() {\n      checkState(!monitor.isOccupiedByCurrentThread(),\n          \"It is incorrect to execute listeners with the monitor held.\");\n      // iterate by index to avoid concurrent modification exceptions\n      for (int i = 0; i < listeners.size(); i++) {\n        listeners.get(i).execute();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void checkHealthy() {\n      if (states.count(RUNNING) != numberOfServices) {\n        IllegalStateException exception = new IllegalStateException(\n            \"Expected to be healthy after starting. The following services are not running: \"\n                + Multimaps.filterKeys(servicesByState, not(equalTo(RUNNING))));\n        throw exception;\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} that wraps another service and times how long it takes for it to start and\n   * also calls the {@link ServiceManagerState#transitionService(Service, State, State)},\n   * to record the state transitions.\n   */\n  private static final class ServiceListener extends Service.Listener {\n    final Service service;\n    // We store the state in a weak reference to ensure that if something went wrong while\n    // constructing the ServiceManager we don't pointlessly keep updating the state.\n    final WeakReference<ServiceManagerState> state;\n\n    ServiceListener(Service service, WeakReference<ServiceManagerState> state) {\n      this.service = service;\n      this.state = state;\n    }\n\n    @Override public void starting() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, NEW, STARTING);\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Starting {0}.\", service);\n        }\n      }\n    }\n\n    @Override public void running() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, STARTING, RUNNING);\n      }\n    }\n\n    @Override public void stopping(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, from, STOPPING);\n      }\n    }\n\n    @Override public void terminated(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Service {0} has terminated. Previous state was: {1}\",\n              new Object[] {service, from});\n        }\n        state.transitionService(service, from, TERMINATED);\n      }\n    }\n\n    @Override public void failed(State from, Throwable failure) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        // Log before the transition, so that if the process exits in response to server failure,\n        // there is a higher likelihood that the cause will be in the logs.\n        if (!(service instanceof NoOpService) ) {\n          logger.log(Level.SEVERE, \"Service \" + service + \" has failed in the \" + from + \" state.\",\n              failure);\n        }\n        state.transitionService(service, from, FAILED);\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} instance that does nothing.  This is only useful as a placeholder to\n   * ensure that the {@link ServiceManager} functions properly even when it is managing no services.\n   *\n   * <p>The use of this class is considered an implementation detail of ServiceManager and as such\n   * it is excluded from {@link #servicesByState}, {@link #startupTimes}, {@link #toString} and all\n   * logging statements.\n   */\n  private static final class NoOpService extends AbstractService {\n    @Override protected void doStart() { notifyStarted(); }\n    @Override protected void doStop() { notifyStopped(); }\n  }\n\n  /** This is never thrown but only used for logging. */\n  private static final class EmptyServiceManagerWarning extends Throwable {}\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53082983,"label":true,"oracleId":1453,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"ServiceManager","javadocTag":"@throws IllegalStateException if the service manager reaches a state from which it cannot\n    become {@linkplain #isHealthy() healthy}.","methodJavadoc":"    /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy} for no more\n   * than the given time.  The manager will become healthy after all the component services have\n   * reached the {@linkplain State#RUNNING running} state.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have finished starting within the deadline\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */","methodSourceCode":"public void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException{\n    state.awaitHealthy(timeout, unit);\n}","classJavadoc":"/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */","classSourceCode":"/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Predicates.equalTo;\nimport static com.google.common.base.Predicates.in;\nimport static com.google.common.base.Predicates.instanceOf;\nimport static com.google.common.base.Predicates.not;\nimport static com.google.common.util.concurrent.MoreExecutors.directExecutor;\nimport static com.google.common.util.concurrent.Service.State.FAILED;\nimport static com.google.common.util.concurrent.Service.State.NEW;\nimport static com.google.common.util.concurrent.Service.State.RUNNING;\nimport static com.google.common.util.concurrent.Service.State.STARTING;\nimport static com.google.common.util.concurrent.Service.State.STOPPING;\nimport static com.google.common.util.concurrent.Service.State.TERMINATED;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.base.Function;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Stopwatch;\nimport com.google.common.collect.Collections2;\nimport com.google.common.collect.ImmutableCollection;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableMultimap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSetMultimap;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.MultimapBuilder;\nimport com.google.common.collect.Multimaps;\nimport com.google.common.collect.Multiset;\nimport com.google.common.collect.Ordering;\nimport com.google.common.collect.SetMultimap;\nimport com.google.common.util.concurrent.ListenerCallQueue.Callback;\nimport com.google.common.util.concurrent.Service.State;\nimport com.google.j2objc.annotations.WeakOuter;\n\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */\n@Beta\npublic final class ServiceManager {\n  private static final Logger logger = Logger.getLogger(ServiceManager.class.getName());\n  private static final Callback<Listener> HEALTHY_CALLBACK = new Callback<Listener>(\"healthy()\") {\n    @Override void call(Listener listener) {\n      listener.healthy();\n    }\n  };\n  private static final Callback<Listener> STOPPED_CALLBACK = new Callback<Listener>(\"stopped()\") {\n    @Override void call(Listener listener) {\n      listener.stopped();\n    }\n  };\n\n  /**\n   * A listener for the aggregate state changes of the services that are under management. Users\n   * that need to listen to more fine-grained events (such as when each particular {@linkplain\n   * Service service} starts, or terminates), should attach {@linkplain Service.Listener service\n   * listeners} to each individual service.\n   *\n   * @author Luke Sandberg\n   * @since 15.0 (present as an interface in 14.0)\n   */\n  @Beta  // Should come out of Beta when ServiceManager does\n  public abstract static class Listener {\n    /**\n     * Called when the service initially becomes healthy.\n     *\n     * <p>This will be called at most once after all the services have entered the\n     * {@linkplain State#RUNNING running} state. If any services fail during start up or\n     * {@linkplain State#FAILED fail}/{@linkplain State#TERMINATED terminate} before all other\n     * services have started {@linkplain State#RUNNING running} then this method will not be called.\n     */\n    public void healthy() {}\n\n    /**\n     * Called when the all of the component services have reached a terminal state, either\n     * {@linkplain State#TERMINATED terminated} or {@linkplain State#FAILED failed}.\n     */\n    public void stopped() {}\n\n    /**\n     * Called when a component service has {@linkplain State#FAILED failed}.\n     *\n     * @param service The service that failed.\n     */\n    public void failure(Service service) {}\n  }\n\n  /**\n   * An encapsulation of all of the state that is accessed by the {@linkplain ServiceListener\n   * service listeners}.  This is extracted into its own object so that {@link ServiceListener}\n   * could be made {@code static} and its instances can be safely constructed and added in the\n   * {@link ServiceManager} constructor without having to close over the partially constructed\n   * {@link ServiceManager} instance (i.e. avoid leaking a pointer to {@code this}).\n   */\n  private final ServiceManagerState state;\n  private final ImmutableList<Service> services;\n\n  /**\n   * Constructs a new instance for managing the given services.\n   *\n   * @param services The services to manage\n   *\n   * @throws IllegalArgumentException if not all services are {@linkplain State#NEW new} or if there\n   * are any duplicate services.\n   */\n  public ServiceManager(Iterable<? extends Service> services) {\n    ImmutableList<Service> copy = ImmutableList.copyOf(services);\n    if (copy.isEmpty()) {\n      // Having no services causes the manager to behave strangely. Notably, listeners are never\n      // fired.  To avoid this we substitute a placeholder service.\n      logger.log(Level.WARNING,\n          \"ServiceManager configured with no services.  Is your application configured properly?\",\n          new EmptyServiceManagerWarning());\n      copy = ImmutableList.<Service>of(new NoOpService());\n    }\n    this.state = new ServiceManagerState(copy);\n    this.services = copy;\n    WeakReference<ServiceManagerState> stateReference =\n        new WeakReference<ServiceManagerState>(state);\n    for (Service service : copy) {\n      service.addListener(new ServiceListener(service, stateReference), directExecutor());\n      // We check the state after adding the listener as a way to ensure that our listener was added\n      // to a NEW service.\n      checkArgument(service.state() == NEW, \"Can only manage NEW services, %s\", service);\n    }\n    // We have installed all of our listeners and after this point any state transition should be\n    // correct.\n    this.state.markReady();\n  }\n\n  /**\n   * Registers a {@link Listener} to be {@linkplain Executor#execute executed} on the given\n   * executor. The listener will not have previous state changes replayed, so it is\n   * suggested that listeners are added before any of the managed services are\n   * {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged. Any exception thrown\n   * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException}) will be caught and\n   * logged.\n   *\n   * <p> For fast, lightweight listeners that would be safe to execute in any thread, consider\n   * calling {@link #addListener(Listener)}.\n   *\n   * @param listener the listener to run when the manager changes state\n   * @param executor the executor in which the listeners callback methods will be run.\n   */\n  public void addListener(Listener listener, Executor executor) {\n    state.addListener(listener, executor);\n  }\n\n  /**\n   * Registers a {@link Listener} to be run when this {@link ServiceManager} changes state. The\n   * listener will not have previous state changes replayed, so it is suggested that listeners are\n   * added before any of the managed services are {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged.\n   *\n   * @param listener the listener to run when the manager changes state\n   */\n  public void addListener(Listener listener) {\n    state.addListener(listener, directExecutor());\n  }\n\n  /**\n   * Initiates service {@linkplain Service#startAsync startup} on all the services being managed.\n   * It is only valid to call this method if all of the services are {@linkplain State#NEW new}.\n   *\n   * @return this\n   * @throws IllegalStateException if any of the Services are not {@link State#NEW new} when the\n   *     method is called.\n   */\n  public ServiceManager startAsync() {\n    for (Service service : services) {\n      State state = service.state();\n      checkState(state == NEW, \"Service %s is %s, cannot start it.\", service, state);\n    }\n    for (Service service : services) {\n      try {\n        state.tryStartTiming(service);\n        service.startAsync();\n      } catch (IllegalStateException e) {\n        // This can happen if the service has already been started or stopped (e.g. by another\n        // service or listener). Our contract says it is safe to call this method if\n        // all services were NEW when it was called, and this has already been verified above, so we\n        // don't propagate the exception.\n        logger.log(Level.WARNING, \"Unable to start Service \" + service, e);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy}.  The manager\n   * will become healthy after all the component services have reached the {@linkplain State#RUNNING\n   * running} state.\n   *\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy() {\n    state.awaitHealthy();\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy} for no more\n   * than the given time.  The manager will become healthy after all the component services have\n   * reached the {@linkplain State#RUNNING running} state.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have finished starting within the deadline\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitHealthy(timeout, unit);\n  }\n\n  /**\n   * Initiates service {@linkplain Service#stopAsync shutdown} if necessary on all the services\n   * being managed.\n   *\n   * @return this\n   */\n  public ServiceManager stopAsync() {\n    for (Service service : services) {\n      service.stopAsync();\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state. After this method returns all\n   * services will either be {@linkplain Service.State#TERMINATED terminated} or {@linkplain\n   * Service.State#FAILED failed}.\n   */\n  public void awaitStopped() {\n    state.awaitStopped();\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state for no more than the given time. After\n   * this method returns all services will either be {@linkplain Service.State#TERMINATED\n   * terminated} or {@linkplain Service.State#FAILED failed}.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have stopped within the deadline\n   */\n  public void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitStopped(timeout, unit);\n  }\n\n  /**\n   * Returns true if all services are currently in the {@linkplain State#RUNNING running} state.\n   *\n   * <p>Users who want more detailed information should use the {@link #servicesByState} method to\n   * get detailed information about which services are not running.\n   */\n  public boolean isHealthy() {\n    for (Service service : services) {\n      if (!service.isRunning()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Provides a snapshot of the current state of all the services under management.\n   *\n   * <p>N.B. This snapshot is guaranteed to be consistent, i.e. the set of states returned will\n   * correspond to a point in time view of the services.\n   */\n  public ImmutableMultimap<State, Service> servicesByState() {\n    return state.servicesByState();\n  }\n\n  /**\n   * Returns the service load times. This value will only return startup times for services that\n   * have finished starting.\n   *\n   * @return Map of services and their corresponding startup time in millis, the map entries will be\n   *     ordered by startup time.\n   */\n  public ImmutableMap<Service, Long> startupTimes() {\n    return state.startupTimes();\n  }\n\n  @Override public String toString() {\n    return MoreObjects.toStringHelper(ServiceManager.class)\n        .add(\"services\", Collections2.filter(services, not(instanceOf(NoOpService.class))))\n        .toString();\n  }\n\n  /**\n   * An encapsulation of all the mutable state of the {@link ServiceManager} that needs to be\n   * accessed by instances of {@link ServiceListener}.\n   */\n  private static final class ServiceManagerState {\n    final Monitor monitor = new Monitor();\n\n    @GuardedBy(\"monitor\")\n    final SetMultimap<State, Service> servicesByState =\n        MultimapBuilder.enumKeys(State.class).linkedHashSetValues().build();\n\n    @GuardedBy(\"monitor\")\n    final Multiset<State> states = servicesByState.keys();\n\n    @GuardedBy(\"monitor\")\n    final Map<Service, Stopwatch> startupTimers = Maps.newIdentityHashMap();\n\n    /**\n     * These two booleans are used to mark the state as ready to start.\n     * {@link #ready}: is set by {@link #markReady} to indicate that all listeners have been\n     *     correctly installed\n     * {@link #transitioned}: is set by {@link #transitionService} to indicate that some transition\n     *     has been performed.\n     *\n     * <p>Together, they allow us to enforce that all services have their listeners installed prior\n     * to any service performing a transition, then we can fail in the ServiceManager constructor\n     * rather than in a Service.Listener callback.\n     */\n    @GuardedBy(\"monitor\")\n    boolean ready;\n\n    @GuardedBy(\"monitor\")\n    boolean transitioned;\n\n    final int numberOfServices;\n\n    /**\n     * Controls how long to wait for all the services to either become healthy or reach a\n     * state from which it is guaranteed that it can never become healthy.\n     */\n    final Monitor.Guard awaitHealthGuard = new AwaitHealthGuard();\n\n    @WeakOuter\n    final class AwaitHealthGuard extends Monitor.Guard {\n      AwaitHealthGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        // All services have started or some service has terminated/failed.\n        return states.count(RUNNING) == numberOfServices\n            || states.contains(STOPPING)\n            || states.contains(TERMINATED)\n            || states.contains(FAILED);\n      }\n    }\n\n    /**\n     * Controls how long to wait for all services to reach a terminal state.\n     */\n    final Monitor.Guard stoppedGuard = new StoppedGuard();\n\n    @WeakOuter\n    final class StoppedGuard extends Monitor.Guard {\n      StoppedGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        return states.count(TERMINATED) + states.count(FAILED) == numberOfServices;\n      }\n    }\n\n    /** The listeners to notify during a state transition. */\n    @GuardedBy(\"monitor\")\n    final List<ListenerCallQueue<Listener>> listeners =\n        Collections.synchronizedList(new ArrayList<ListenerCallQueue<Listener>>());\n\n    /**\n     * It is implicitly assumed that all the services are NEW and that they will all remain NEW\n     * until all the Listeners are installed and {@link #markReady()} is called.  It is our caller's\n     * responsibility to only call {@link #markReady()} if all services were new at the time this\n     * method was called and when all the listeners were installed.\n     */\n    ServiceManagerState(ImmutableCollection<Service> services) {\n      this.numberOfServices = services.size();\n      servicesByState.putAll(NEW, services);\n    }\n\n    /**\n     * Attempts to start the timer immediately prior to the service being started via\n     * {@link Service#startAsync()}.\n     */\n    void tryStartTiming(Service service) {\n      monitor.enter();\n      try {\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          startupTimers.put(service, Stopwatch.createStarted());\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    /**\n     * Marks the {@link State} as ready to receive transitions. Returns true if no transitions have\n     * been observed yet.\n     */\n    void markReady() {\n      monitor.enter();\n      try {\n        if (!transitioned) {\n          // nothing has transitioned since construction, good.\n          ready = true;\n        } else {\n          // This should be an extremely rare race condition.\n          List<Service> servicesInBadStates = Lists.newArrayList();\n          for (Service service : servicesByState().values()) {\n            if (service.state() != NEW) {\n              servicesInBadStates.add(service);\n            }\n          }\n          throw new IllegalArgumentException(\"Services started transitioning asynchronously before \"\n              + \"the ServiceManager was constructed: \" + servicesInBadStates);\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void addListener(Listener listener, Executor executor) {\n      checkNotNull(listener, \"listener\");\n      checkNotNull(executor, \"executor\");\n      monitor.enter();\n      try {\n        // no point in adding a listener that will never be called\n        if (!stoppedGuard.isSatisfied()) {\n          listeners.add(new ListenerCallQueue<Listener>(listener, executor));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy() {\n      monitor.enterWhenUninterruptibly(awaitHealthGuard);\n      try {\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(awaitHealthGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to become healthy. The \"\n              + \"following services have not started: \"\n              + Multimaps.filterKeys(servicesByState, in(ImmutableSet.of(NEW, STARTING))));\n        }\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitStopped() {\n      monitor.enterWhenUninterruptibly(stoppedGuard);\n      monitor.leave();\n    }\n\n    void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(stoppedGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to stop. The following \"\n              + \"services have not stopped: \"\n              + Multimaps.filterKeys(servicesByState,\n                  not(in(EnumSet.of(TERMINATED, FAILED)))));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    ImmutableMultimap<State, Service> servicesByState() {\n      ImmutableSetMultimap.Builder<State, Service> builder = ImmutableSetMultimap.builder();\n      monitor.enter();\n      try {\n        for (Entry<State, Service> entry : servicesByState.entries()) {\n          if (!(entry.getValue() instanceof NoOpService)) {\n            builder.put(entry);\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      return builder.build();\n    }\n\n    ImmutableMap<Service, Long> startupTimes() {\n      List<Entry<Service, Long>> loadTimes;\n      monitor.enter();\n      try {\n        loadTimes = Lists.newArrayListWithCapacity(startupTimers.size());\n        // N.B. There will only be an entry in the map if the service has started\n        for (Entry<Service, Stopwatch> entry : startupTimers.entrySet()) {\n          Service service = entry.getKey();\n          Stopwatch stopWatch = entry.getValue();\n          if (!stopWatch.isRunning() && !(service instanceof NoOpService)) {\n            loadTimes.add(Maps.immutableEntry(service, stopWatch.elapsed(MILLISECONDS)));\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      Collections.sort(loadTimes, Ordering.natural()\n          .onResultOf(new Function<Entry<Service, Long>, Long>() {\n            @Override public Long apply(Map.Entry<Service, Long> input) {\n              return input.getValue();\n            }\n          }));\n      return ImmutableMap.copyOf(loadTimes);\n    }\n\n    /**\n     * Updates the state with the given service transition.\n     *\n     * <p>This method performs the main logic of ServiceManager in the following steps.\n     * <ol>\n     *      <li>Update the {@link #servicesByState()}\n     *      <li>Update the {@link #startupTimers}\n     *      <li>Based on the new state queue listeners to run\n     *      <li>Run the listeners (outside of the lock)\n     * </ol>\n     */\n    void transitionService(final Service service, State from, State to) {\n      checkNotNull(service);\n      checkArgument(from != to);\n      monitor.enter();\n      try {\n        transitioned = true;\n        if (!ready) {\n          return;\n        }\n        // Update state.\n        checkState(servicesByState.remove(from, service),\n            \"Service %s not at the expected location in the state map %s\", service, from);\n        checkState(servicesByState.put(to, service),\n            \"Service %s in the state map unexpectedly at %s\", service, to);\n        // Update the timer\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          // This means the service was started by some means other than ServiceManager.startAsync\n          stopwatch = Stopwatch.createStarted();\n          startupTimers.put(service, stopwatch);\n        }\n        if (to.compareTo(RUNNING) >= 0 && stopwatch.isRunning()) {\n          // N.B. if we miss the STARTING event then we may never record a startup time.\n          stopwatch.stop();\n          if (!(service instanceof NoOpService)) {\n            logger.log(Level.FINE, \"Started {0} in {1}.\", new Object[] {service, stopwatch});\n          }\n        }\n        // Queue our listeners\n\n        // Did a service fail?\n        if (to == FAILED) {\n          fireFailedListeners(service);\n        }\n\n        if (states.count(RUNNING) == numberOfServices) {\n          // This means that the manager is currently healthy. N.B. If other threads call isHealthy\n          // they are not guaranteed to get 'true', because any service could fail right now.\n          fireHealthyListeners();\n        } else if (states.count(TERMINATED) + states.count(FAILED) == numberOfServices) {\n          fireStoppedListeners();\n        }\n      } finally {\n        monitor.leave();\n        // Run our executors outside of the lock\n        executeListeners();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireStoppedListeners() {\n      STOPPED_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireHealthyListeners() {\n      HEALTHY_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireFailedListeners(final Service service) {\n      new Callback<Listener>(\"failed({service=\" + service + \"})\") {\n        @Override void call(Listener listener) {\n          listener.failure(service);\n        }\n      }.enqueueOn(listeners);\n    }\n\n    /** Attempts to execute all the listeners in {@link #listeners}. */\n    void executeListeners() {\n      checkState(!monitor.isOccupiedByCurrentThread(),\n          \"It is incorrect to execute listeners with the monitor held.\");\n      // iterate by index to avoid concurrent modification exceptions\n      for (int i = 0; i < listeners.size(); i++) {\n        listeners.get(i).execute();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void checkHealthy() {\n      if (states.count(RUNNING) != numberOfServices) {\n        IllegalStateException exception = new IllegalStateException(\n            \"Expected to be healthy after starting. The following services are not running: \"\n                + Multimaps.filterKeys(servicesByState, not(equalTo(RUNNING))));\n        throw exception;\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} that wraps another service and times how long it takes for it to start and\n   * also calls the {@link ServiceManagerState#transitionService(Service, State, State)},\n   * to record the state transitions.\n   */\n  private static final class ServiceListener extends Service.Listener {\n    final Service service;\n    // We store the state in a weak reference to ensure that if something went wrong while\n    // constructing the ServiceManager we don't pointlessly keep updating the state.\n    final WeakReference<ServiceManagerState> state;\n\n    ServiceListener(Service service, WeakReference<ServiceManagerState> state) {\n      this.service = service;\n      this.state = state;\n    }\n\n    @Override public void starting() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, NEW, STARTING);\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Starting {0}.\", service);\n        }\n      }\n    }\n\n    @Override public void running() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, STARTING, RUNNING);\n      }\n    }\n\n    @Override public void stopping(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, from, STOPPING);\n      }\n    }\n\n    @Override public void terminated(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Service {0} has terminated. Previous state was: {1}\",\n              new Object[] {service, from});\n        }\n        state.transitionService(service, from, TERMINATED);\n      }\n    }\n\n    @Override public void failed(State from, Throwable failure) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        // Log before the transition, so that if the process exits in response to server failure,\n        // there is a higher likelihood that the cause will be in the logs.\n        if (!(service instanceof NoOpService) ) {\n          logger.log(Level.SEVERE, \"Service \" + service + \" has failed in the \" + from + \" state.\",\n              failure);\n        }\n        state.transitionService(service, from, FAILED);\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} instance that does nothing.  This is only useful as a placeholder to\n   * ensure that the {@link ServiceManager} functions properly even when it is managing no services.\n   *\n   * <p>The use of this class is considered an implementation detail of ServiceManager and as such\n   * it is excluded from {@link #servicesByState}, {@link #startupTimes}, {@link #toString} and all\n   * logging statements.\n   */\n  private static final class NoOpService extends AbstractService {\n    @Override protected void doStart() { notifyStarted(); }\n    @Override protected void doStop() { notifyStopped(); }\n  }\n\n  /** This is never thrown but only used for logging. */\n  private static final class EmptyServiceManagerWarning extends Throwable {}\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53083441,"label":true,"oracleId":1454,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"ServiceManager","javadocTag":"@return this","methodJavadoc":"    /**\n   * Initiates service {@linkplain Service#stopAsync shutdown} if necessary on all the services\n   * being managed.\n   *\n   * @return this\n   */","methodSourceCode":"public ServiceManager stopAsync(){\n    for (Service service : services) {\n        service.stopAsync();\n    }\n    return this;\n}","classJavadoc":"/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */","classSourceCode":"/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Predicates.equalTo;\nimport static com.google.common.base.Predicates.in;\nimport static com.google.common.base.Predicates.instanceOf;\nimport static com.google.common.base.Predicates.not;\nimport static com.google.common.util.concurrent.MoreExecutors.directExecutor;\nimport static com.google.common.util.concurrent.Service.State.FAILED;\nimport static com.google.common.util.concurrent.Service.State.NEW;\nimport static com.google.common.util.concurrent.Service.State.RUNNING;\nimport static com.google.common.util.concurrent.Service.State.STARTING;\nimport static com.google.common.util.concurrent.Service.State.STOPPING;\nimport static com.google.common.util.concurrent.Service.State.TERMINATED;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.base.Function;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Stopwatch;\nimport com.google.common.collect.Collections2;\nimport com.google.common.collect.ImmutableCollection;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableMultimap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSetMultimap;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.MultimapBuilder;\nimport com.google.common.collect.Multimaps;\nimport com.google.common.collect.Multiset;\nimport com.google.common.collect.Ordering;\nimport com.google.common.collect.SetMultimap;\nimport com.google.common.util.concurrent.ListenerCallQueue.Callback;\nimport com.google.common.util.concurrent.Service.State;\nimport com.google.j2objc.annotations.WeakOuter;\n\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */\n@Beta\npublic final class ServiceManager {\n  private static final Logger logger = Logger.getLogger(ServiceManager.class.getName());\n  private static final Callback<Listener> HEALTHY_CALLBACK = new Callback<Listener>(\"healthy()\") {\n    @Override void call(Listener listener) {\n      listener.healthy();\n    }\n  };\n  private static final Callback<Listener> STOPPED_CALLBACK = new Callback<Listener>(\"stopped()\") {\n    @Override void call(Listener listener) {\n      listener.stopped();\n    }\n  };\n\n  /**\n   * A listener for the aggregate state changes of the services that are under management. Users\n   * that need to listen to more fine-grained events (such as when each particular {@linkplain\n   * Service service} starts, or terminates), should attach {@linkplain Service.Listener service\n   * listeners} to each individual service.\n   *\n   * @author Luke Sandberg\n   * @since 15.0 (present as an interface in 14.0)\n   */\n  @Beta  // Should come out of Beta when ServiceManager does\n  public abstract static class Listener {\n    /**\n     * Called when the service initially becomes healthy.\n     *\n     * <p>This will be called at most once after all the services have entered the\n     * {@linkplain State#RUNNING running} state. If any services fail during start up or\n     * {@linkplain State#FAILED fail}/{@linkplain State#TERMINATED terminate} before all other\n     * services have started {@linkplain State#RUNNING running} then this method will not be called.\n     */\n    public void healthy() {}\n\n    /**\n     * Called when the all of the component services have reached a terminal state, either\n     * {@linkplain State#TERMINATED terminated} or {@linkplain State#FAILED failed}.\n     */\n    public void stopped() {}\n\n    /**\n     * Called when a component service has {@linkplain State#FAILED failed}.\n     *\n     * @param service The service that failed.\n     */\n    public void failure(Service service) {}\n  }\n\n  /**\n   * An encapsulation of all of the state that is accessed by the {@linkplain ServiceListener\n   * service listeners}.  This is extracted into its own object so that {@link ServiceListener}\n   * could be made {@code static} and its instances can be safely constructed and added in the\n   * {@link ServiceManager} constructor without having to close over the partially constructed\n   * {@link ServiceManager} instance (i.e. avoid leaking a pointer to {@code this}).\n   */\n  private final ServiceManagerState state;\n  private final ImmutableList<Service> services;\n\n  /**\n   * Constructs a new instance for managing the given services.\n   *\n   * @param services The services to manage\n   *\n   * @throws IllegalArgumentException if not all services are {@linkplain State#NEW new} or if there\n   * are any duplicate services.\n   */\n  public ServiceManager(Iterable<? extends Service> services) {\n    ImmutableList<Service> copy = ImmutableList.copyOf(services);\n    if (copy.isEmpty()) {\n      // Having no services causes the manager to behave strangely. Notably, listeners are never\n      // fired.  To avoid this we substitute a placeholder service.\n      logger.log(Level.WARNING,\n          \"ServiceManager configured with no services.  Is your application configured properly?\",\n          new EmptyServiceManagerWarning());\n      copy = ImmutableList.<Service>of(new NoOpService());\n    }\n    this.state = new ServiceManagerState(copy);\n    this.services = copy;\n    WeakReference<ServiceManagerState> stateReference =\n        new WeakReference<ServiceManagerState>(state);\n    for (Service service : copy) {\n      service.addListener(new ServiceListener(service, stateReference), directExecutor());\n      // We check the state after adding the listener as a way to ensure that our listener was added\n      // to a NEW service.\n      checkArgument(service.state() == NEW, \"Can only manage NEW services, %s\", service);\n    }\n    // We have installed all of our listeners and after this point any state transition should be\n    // correct.\n    this.state.markReady();\n  }\n\n  /**\n   * Registers a {@link Listener} to be {@linkplain Executor#execute executed} on the given\n   * executor. The listener will not have previous state changes replayed, so it is\n   * suggested that listeners are added before any of the managed services are\n   * {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged. Any exception thrown\n   * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException}) will be caught and\n   * logged.\n   *\n   * <p> For fast, lightweight listeners that would be safe to execute in any thread, consider\n   * calling {@link #addListener(Listener)}.\n   *\n   * @param listener the listener to run when the manager changes state\n   * @param executor the executor in which the listeners callback methods will be run.\n   */\n  public void addListener(Listener listener, Executor executor) {\n    state.addListener(listener, executor);\n  }\n\n  /**\n   * Registers a {@link Listener} to be run when this {@link ServiceManager} changes state. The\n   * listener will not have previous state changes replayed, so it is suggested that listeners are\n   * added before any of the managed services are {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged.\n   *\n   * @param listener the listener to run when the manager changes state\n   */\n  public void addListener(Listener listener) {\n    state.addListener(listener, directExecutor());\n  }\n\n  /**\n   * Initiates service {@linkplain Service#startAsync startup} on all the services being managed.\n   * It is only valid to call this method if all of the services are {@linkplain State#NEW new}.\n   *\n   * @return this\n   * @throws IllegalStateException if any of the Services are not {@link State#NEW new} when the\n   *     method is called.\n   */\n  public ServiceManager startAsync() {\n    for (Service service : services) {\n      State state = service.state();\n      checkState(state == NEW, \"Service %s is %s, cannot start it.\", service, state);\n    }\n    for (Service service : services) {\n      try {\n        state.tryStartTiming(service);\n        service.startAsync();\n      } catch (IllegalStateException e) {\n        // This can happen if the service has already been started or stopped (e.g. by another\n        // service or listener). Our contract says it is safe to call this method if\n        // all services were NEW when it was called, and this has already been verified above, so we\n        // don't propagate the exception.\n        logger.log(Level.WARNING, \"Unable to start Service \" + service, e);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy}.  The manager\n   * will become healthy after all the component services have reached the {@linkplain State#RUNNING\n   * running} state.\n   *\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy() {\n    state.awaitHealthy();\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy} for no more\n   * than the given time.  The manager will become healthy after all the component services have\n   * reached the {@linkplain State#RUNNING running} state.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have finished starting within the deadline\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitHealthy(timeout, unit);\n  }\n\n  /**\n   * Initiates service {@linkplain Service#stopAsync shutdown} if necessary on all the services\n   * being managed.\n   *\n   * @return this\n   */\n  public ServiceManager stopAsync() {\n    for (Service service : services) {\n      service.stopAsync();\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state. After this method returns all\n   * services will either be {@linkplain Service.State#TERMINATED terminated} or {@linkplain\n   * Service.State#FAILED failed}.\n   */\n  public void awaitStopped() {\n    state.awaitStopped();\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state for no more than the given time. After\n   * this method returns all services will either be {@linkplain Service.State#TERMINATED\n   * terminated} or {@linkplain Service.State#FAILED failed}.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have stopped within the deadline\n   */\n  public void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitStopped(timeout, unit);\n  }\n\n  /**\n   * Returns true if all services are currently in the {@linkplain State#RUNNING running} state.\n   *\n   * <p>Users who want more detailed information should use the {@link #servicesByState} method to\n   * get detailed information about which services are not running.\n   */\n  public boolean isHealthy() {\n    for (Service service : services) {\n      if (!service.isRunning()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Provides a snapshot of the current state of all the services under management.\n   *\n   * <p>N.B. This snapshot is guaranteed to be consistent, i.e. the set of states returned will\n   * correspond to a point in time view of the services.\n   */\n  public ImmutableMultimap<State, Service> servicesByState() {\n    return state.servicesByState();\n  }\n\n  /**\n   * Returns the service load times. This value will only return startup times for services that\n   * have finished starting.\n   *\n   * @return Map of services and their corresponding startup time in millis, the map entries will be\n   *     ordered by startup time.\n   */\n  public ImmutableMap<Service, Long> startupTimes() {\n    return state.startupTimes();\n  }\n\n  @Override public String toString() {\n    return MoreObjects.toStringHelper(ServiceManager.class)\n        .add(\"services\", Collections2.filter(services, not(instanceOf(NoOpService.class))))\n        .toString();\n  }\n\n  /**\n   * An encapsulation of all the mutable state of the {@link ServiceManager} that needs to be\n   * accessed by instances of {@link ServiceListener}.\n   */\n  private static final class ServiceManagerState {\n    final Monitor monitor = new Monitor();\n\n    @GuardedBy(\"monitor\")\n    final SetMultimap<State, Service> servicesByState =\n        MultimapBuilder.enumKeys(State.class).linkedHashSetValues().build();\n\n    @GuardedBy(\"monitor\")\n    final Multiset<State> states = servicesByState.keys();\n\n    @GuardedBy(\"monitor\")\n    final Map<Service, Stopwatch> startupTimers = Maps.newIdentityHashMap();\n\n    /**\n     * These two booleans are used to mark the state as ready to start.\n     * {@link #ready}: is set by {@link #markReady} to indicate that all listeners have been\n     *     correctly installed\n     * {@link #transitioned}: is set by {@link #transitionService} to indicate that some transition\n     *     has been performed.\n     *\n     * <p>Together, they allow us to enforce that all services have their listeners installed prior\n     * to any service performing a transition, then we can fail in the ServiceManager constructor\n     * rather than in a Service.Listener callback.\n     */\n    @GuardedBy(\"monitor\")\n    boolean ready;\n\n    @GuardedBy(\"monitor\")\n    boolean transitioned;\n\n    final int numberOfServices;\n\n    /**\n     * Controls how long to wait for all the services to either become healthy or reach a\n     * state from which it is guaranteed that it can never become healthy.\n     */\n    final Monitor.Guard awaitHealthGuard = new AwaitHealthGuard();\n\n    @WeakOuter\n    final class AwaitHealthGuard extends Monitor.Guard {\n      AwaitHealthGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        // All services have started or some service has terminated/failed.\n        return states.count(RUNNING) == numberOfServices\n            || states.contains(STOPPING)\n            || states.contains(TERMINATED)\n            || states.contains(FAILED);\n      }\n    }\n\n    /**\n     * Controls how long to wait for all services to reach a terminal state.\n     */\n    final Monitor.Guard stoppedGuard = new StoppedGuard();\n\n    @WeakOuter\n    final class StoppedGuard extends Monitor.Guard {\n      StoppedGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        return states.count(TERMINATED) + states.count(FAILED) == numberOfServices;\n      }\n    }\n\n    /** The listeners to notify during a state transition. */\n    @GuardedBy(\"monitor\")\n    final List<ListenerCallQueue<Listener>> listeners =\n        Collections.synchronizedList(new ArrayList<ListenerCallQueue<Listener>>());\n\n    /**\n     * It is implicitly assumed that all the services are NEW and that they will all remain NEW\n     * until all the Listeners are installed and {@link #markReady()} is called.  It is our caller's\n     * responsibility to only call {@link #markReady()} if all services were new at the time this\n     * method was called and when all the listeners were installed.\n     */\n    ServiceManagerState(ImmutableCollection<Service> services) {\n      this.numberOfServices = services.size();\n      servicesByState.putAll(NEW, services);\n    }\n\n    /**\n     * Attempts to start the timer immediately prior to the service being started via\n     * {@link Service#startAsync()}.\n     */\n    void tryStartTiming(Service service) {\n      monitor.enter();\n      try {\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          startupTimers.put(service, Stopwatch.createStarted());\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    /**\n     * Marks the {@link State} as ready to receive transitions. Returns true if no transitions have\n     * been observed yet.\n     */\n    void markReady() {\n      monitor.enter();\n      try {\n        if (!transitioned) {\n          // nothing has transitioned since construction, good.\n          ready = true;\n        } else {\n          // This should be an extremely rare race condition.\n          List<Service> servicesInBadStates = Lists.newArrayList();\n          for (Service service : servicesByState().values()) {\n            if (service.state() != NEW) {\n              servicesInBadStates.add(service);\n            }\n          }\n          throw new IllegalArgumentException(\"Services started transitioning asynchronously before \"\n              + \"the ServiceManager was constructed: \" + servicesInBadStates);\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void addListener(Listener listener, Executor executor) {\n      checkNotNull(listener, \"listener\");\n      checkNotNull(executor, \"executor\");\n      monitor.enter();\n      try {\n        // no point in adding a listener that will never be called\n        if (!stoppedGuard.isSatisfied()) {\n          listeners.add(new ListenerCallQueue<Listener>(listener, executor));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy() {\n      monitor.enterWhenUninterruptibly(awaitHealthGuard);\n      try {\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(awaitHealthGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to become healthy. The \"\n              + \"following services have not started: \"\n              + Multimaps.filterKeys(servicesByState, in(ImmutableSet.of(NEW, STARTING))));\n        }\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitStopped() {\n      monitor.enterWhenUninterruptibly(stoppedGuard);\n      monitor.leave();\n    }\n\n    void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(stoppedGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to stop. The following \"\n              + \"services have not stopped: \"\n              + Multimaps.filterKeys(servicesByState,\n                  not(in(EnumSet.of(TERMINATED, FAILED)))));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    ImmutableMultimap<State, Service> servicesByState() {\n      ImmutableSetMultimap.Builder<State, Service> builder = ImmutableSetMultimap.builder();\n      monitor.enter();\n      try {\n        for (Entry<State, Service> entry : servicesByState.entries()) {\n          if (!(entry.getValue() instanceof NoOpService)) {\n            builder.put(entry);\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      return builder.build();\n    }\n\n    ImmutableMap<Service, Long> startupTimes() {\n      List<Entry<Service, Long>> loadTimes;\n      monitor.enter();\n      try {\n        loadTimes = Lists.newArrayListWithCapacity(startupTimers.size());\n        // N.B. There will only be an entry in the map if the service has started\n        for (Entry<Service, Stopwatch> entry : startupTimers.entrySet()) {\n          Service service = entry.getKey();\n          Stopwatch stopWatch = entry.getValue();\n          if (!stopWatch.isRunning() && !(service instanceof NoOpService)) {\n            loadTimes.add(Maps.immutableEntry(service, stopWatch.elapsed(MILLISECONDS)));\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      Collections.sort(loadTimes, Ordering.natural()\n          .onResultOf(new Function<Entry<Service, Long>, Long>() {\n            @Override public Long apply(Map.Entry<Service, Long> input) {\n              return input.getValue();\n            }\n          }));\n      return ImmutableMap.copyOf(loadTimes);\n    }\n\n    /**\n     * Updates the state with the given service transition.\n     *\n     * <p>This method performs the main logic of ServiceManager in the following steps.\n     * <ol>\n     *      <li>Update the {@link #servicesByState()}\n     *      <li>Update the {@link #startupTimers}\n     *      <li>Based on the new state queue listeners to run\n     *      <li>Run the listeners (outside of the lock)\n     * </ol>\n     */\n    void transitionService(final Service service, State from, State to) {\n      checkNotNull(service);\n      checkArgument(from != to);\n      monitor.enter();\n      try {\n        transitioned = true;\n        if (!ready) {\n          return;\n        }\n        // Update state.\n        checkState(servicesByState.remove(from, service),\n            \"Service %s not at the expected location in the state map %s\", service, from);\n        checkState(servicesByState.put(to, service),\n            \"Service %s in the state map unexpectedly at %s\", service, to);\n        // Update the timer\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          // This means the service was started by some means other than ServiceManager.startAsync\n          stopwatch = Stopwatch.createStarted();\n          startupTimers.put(service, stopwatch);\n        }\n        if (to.compareTo(RUNNING) >= 0 && stopwatch.isRunning()) {\n          // N.B. if we miss the STARTING event then we may never record a startup time.\n          stopwatch.stop();\n          if (!(service instanceof NoOpService)) {\n            logger.log(Level.FINE, \"Started {0} in {1}.\", new Object[] {service, stopwatch});\n          }\n        }\n        // Queue our listeners\n\n        // Did a service fail?\n        if (to == FAILED) {\n          fireFailedListeners(service);\n        }\n\n        if (states.count(RUNNING) == numberOfServices) {\n          // This means that the manager is currently healthy. N.B. If other threads call isHealthy\n          // they are not guaranteed to get 'true', because any service could fail right now.\n          fireHealthyListeners();\n        } else if (states.count(TERMINATED) + states.count(FAILED) == numberOfServices) {\n          fireStoppedListeners();\n        }\n      } finally {\n        monitor.leave();\n        // Run our executors outside of the lock\n        executeListeners();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireStoppedListeners() {\n      STOPPED_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireHealthyListeners() {\n      HEALTHY_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireFailedListeners(final Service service) {\n      new Callback<Listener>(\"failed({service=\" + service + \"})\") {\n        @Override void call(Listener listener) {\n          listener.failure(service);\n        }\n      }.enqueueOn(listeners);\n    }\n\n    /** Attempts to execute all the listeners in {@link #listeners}. */\n    void executeListeners() {\n      checkState(!monitor.isOccupiedByCurrentThread(),\n          \"It is incorrect to execute listeners with the monitor held.\");\n      // iterate by index to avoid concurrent modification exceptions\n      for (int i = 0; i < listeners.size(); i++) {\n        listeners.get(i).execute();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void checkHealthy() {\n      if (states.count(RUNNING) != numberOfServices) {\n        IllegalStateException exception = new IllegalStateException(\n            \"Expected to be healthy after starting. The following services are not running: \"\n                + Multimaps.filterKeys(servicesByState, not(equalTo(RUNNING))));\n        throw exception;\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} that wraps another service and times how long it takes for it to start and\n   * also calls the {@link ServiceManagerState#transitionService(Service, State, State)},\n   * to record the state transitions.\n   */\n  private static final class ServiceListener extends Service.Listener {\n    final Service service;\n    // We store the state in a weak reference to ensure that if something went wrong while\n    // constructing the ServiceManager we don't pointlessly keep updating the state.\n    final WeakReference<ServiceManagerState> state;\n\n    ServiceListener(Service service, WeakReference<ServiceManagerState> state) {\n      this.service = service;\n      this.state = state;\n    }\n\n    @Override public void starting() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, NEW, STARTING);\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Starting {0}.\", service);\n        }\n      }\n    }\n\n    @Override public void running() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, STARTING, RUNNING);\n      }\n    }\n\n    @Override public void stopping(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, from, STOPPING);\n      }\n    }\n\n    @Override public void terminated(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Service {0} has terminated. Previous state was: {1}\",\n              new Object[] {service, from});\n        }\n        state.transitionService(service, from, TERMINATED);\n      }\n    }\n\n    @Override public void failed(State from, Throwable failure) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        // Log before the transition, so that if the process exits in response to server failure,\n        // there is a higher likelihood that the cause will be in the logs.\n        if (!(service instanceof NoOpService) ) {\n          logger.log(Level.SEVERE, \"Service \" + service + \" has failed in the \" + from + \" state.\",\n              failure);\n        }\n        state.transitionService(service, from, FAILED);\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} instance that does nothing.  This is only useful as a placeholder to\n   * ensure that the {@link ServiceManager} functions properly even when it is managing no services.\n   *\n   * <p>The use of this class is considered an implementation detail of ServiceManager and as such\n   * it is excluded from {@link #servicesByState}, {@link #startupTimes}, {@link #toString} and all\n   * logging statements.\n   */\n  private static final class NoOpService extends AbstractService {\n    @Override protected void doStart() { notifyStarted(); }\n    @Override protected void doStop() { notifyStopped(); }\n  }\n\n  /** This is never thrown but only used for logging. */\n  private static final class EmptyServiceManagerWarning extends Throwable {}\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53083900,"label":true,"oracleId":1455,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"ServiceManager","javadocTag":"@param timeout the maximum time to wait","methodJavadoc":"    /**\n   * Waits for the all the services to reach a terminal state for no more than the given time. After\n   * this method returns all services will either be {@linkplain Service.State#TERMINATED\n   * terminated} or {@linkplain Service.State#FAILED failed}.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have stopped within the deadline\n   */","methodSourceCode":"public void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException{\n    state.awaitStopped(timeout, unit);\n}","classJavadoc":"/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */","classSourceCode":"/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Predicates.equalTo;\nimport static com.google.common.base.Predicates.in;\nimport static com.google.common.base.Predicates.instanceOf;\nimport static com.google.common.base.Predicates.not;\nimport static com.google.common.util.concurrent.MoreExecutors.directExecutor;\nimport static com.google.common.util.concurrent.Service.State.FAILED;\nimport static com.google.common.util.concurrent.Service.State.NEW;\nimport static com.google.common.util.concurrent.Service.State.RUNNING;\nimport static com.google.common.util.concurrent.Service.State.STARTING;\nimport static com.google.common.util.concurrent.Service.State.STOPPING;\nimport static com.google.common.util.concurrent.Service.State.TERMINATED;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.base.Function;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Stopwatch;\nimport com.google.common.collect.Collections2;\nimport com.google.common.collect.ImmutableCollection;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableMultimap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSetMultimap;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.MultimapBuilder;\nimport com.google.common.collect.Multimaps;\nimport com.google.common.collect.Multiset;\nimport com.google.common.collect.Ordering;\nimport com.google.common.collect.SetMultimap;\nimport com.google.common.util.concurrent.ListenerCallQueue.Callback;\nimport com.google.common.util.concurrent.Service.State;\nimport com.google.j2objc.annotations.WeakOuter;\n\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */\n@Beta\npublic final class ServiceManager {\n  private static final Logger logger = Logger.getLogger(ServiceManager.class.getName());\n  private static final Callback<Listener> HEALTHY_CALLBACK = new Callback<Listener>(\"healthy()\") {\n    @Override void call(Listener listener) {\n      listener.healthy();\n    }\n  };\n  private static final Callback<Listener> STOPPED_CALLBACK = new Callback<Listener>(\"stopped()\") {\n    @Override void call(Listener listener) {\n      listener.stopped();\n    }\n  };\n\n  /**\n   * A listener for the aggregate state changes of the services that are under management. Users\n   * that need to listen to more fine-grained events (such as when each particular {@linkplain\n   * Service service} starts, or terminates), should attach {@linkplain Service.Listener service\n   * listeners} to each individual service.\n   *\n   * @author Luke Sandberg\n   * @since 15.0 (present as an interface in 14.0)\n   */\n  @Beta  // Should come out of Beta when ServiceManager does\n  public abstract static class Listener {\n    /**\n     * Called when the service initially becomes healthy.\n     *\n     * <p>This will be called at most once after all the services have entered the\n     * {@linkplain State#RUNNING running} state. If any services fail during start up or\n     * {@linkplain State#FAILED fail}/{@linkplain State#TERMINATED terminate} before all other\n     * services have started {@linkplain State#RUNNING running} then this method will not be called.\n     */\n    public void healthy() {}\n\n    /**\n     * Called when the all of the component services have reached a terminal state, either\n     * {@linkplain State#TERMINATED terminated} or {@linkplain State#FAILED failed}.\n     */\n    public void stopped() {}\n\n    /**\n     * Called when a component service has {@linkplain State#FAILED failed}.\n     *\n     * @param service The service that failed.\n     */\n    public void failure(Service service) {}\n  }\n\n  /**\n   * An encapsulation of all of the state that is accessed by the {@linkplain ServiceListener\n   * service listeners}.  This is extracted into its own object so that {@link ServiceListener}\n   * could be made {@code static} and its instances can be safely constructed and added in the\n   * {@link ServiceManager} constructor without having to close over the partially constructed\n   * {@link ServiceManager} instance (i.e. avoid leaking a pointer to {@code this}).\n   */\n  private final ServiceManagerState state;\n  private final ImmutableList<Service> services;\n\n  /**\n   * Constructs a new instance for managing the given services.\n   *\n   * @param services The services to manage\n   *\n   * @throws IllegalArgumentException if not all services are {@linkplain State#NEW new} or if there\n   * are any duplicate services.\n   */\n  public ServiceManager(Iterable<? extends Service> services) {\n    ImmutableList<Service> copy = ImmutableList.copyOf(services);\n    if (copy.isEmpty()) {\n      // Having no services causes the manager to behave strangely. Notably, listeners are never\n      // fired.  To avoid this we substitute a placeholder service.\n      logger.log(Level.WARNING,\n          \"ServiceManager configured with no services.  Is your application configured properly?\",\n          new EmptyServiceManagerWarning());\n      copy = ImmutableList.<Service>of(new NoOpService());\n    }\n    this.state = new ServiceManagerState(copy);\n    this.services = copy;\n    WeakReference<ServiceManagerState> stateReference =\n        new WeakReference<ServiceManagerState>(state);\n    for (Service service : copy) {\n      service.addListener(new ServiceListener(service, stateReference), directExecutor());\n      // We check the state after adding the listener as a way to ensure that our listener was added\n      // to a NEW service.\n      checkArgument(service.state() == NEW, \"Can only manage NEW services, %s\", service);\n    }\n    // We have installed all of our listeners and after this point any state transition should be\n    // correct.\n    this.state.markReady();\n  }\n\n  /**\n   * Registers a {@link Listener} to be {@linkplain Executor#execute executed} on the given\n   * executor. The listener will not have previous state changes replayed, so it is\n   * suggested that listeners are added before any of the managed services are\n   * {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged. Any exception thrown\n   * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException}) will be caught and\n   * logged.\n   *\n   * <p> For fast, lightweight listeners that would be safe to execute in any thread, consider\n   * calling {@link #addListener(Listener)}.\n   *\n   * @param listener the listener to run when the manager changes state\n   * @param executor the executor in which the listeners callback methods will be run.\n   */\n  public void addListener(Listener listener, Executor executor) {\n    state.addListener(listener, executor);\n  }\n\n  /**\n   * Registers a {@link Listener} to be run when this {@link ServiceManager} changes state. The\n   * listener will not have previous state changes replayed, so it is suggested that listeners are\n   * added before any of the managed services are {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged.\n   *\n   * @param listener the listener to run when the manager changes state\n   */\n  public void addListener(Listener listener) {\n    state.addListener(listener, directExecutor());\n  }\n\n  /**\n   * Initiates service {@linkplain Service#startAsync startup} on all the services being managed.\n   * It is only valid to call this method if all of the services are {@linkplain State#NEW new}.\n   *\n   * @return this\n   * @throws IllegalStateException if any of the Services are not {@link State#NEW new} when the\n   *     method is called.\n   */\n  public ServiceManager startAsync() {\n    for (Service service : services) {\n      State state = service.state();\n      checkState(state == NEW, \"Service %s is %s, cannot start it.\", service, state);\n    }\n    for (Service service : services) {\n      try {\n        state.tryStartTiming(service);\n        service.startAsync();\n      } catch (IllegalStateException e) {\n        // This can happen if the service has already been started or stopped (e.g. by another\n        // service or listener). Our contract says it is safe to call this method if\n        // all services were NEW when it was called, and this has already been verified above, so we\n        // don't propagate the exception.\n        logger.log(Level.WARNING, \"Unable to start Service \" + service, e);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy}.  The manager\n   * will become healthy after all the component services have reached the {@linkplain State#RUNNING\n   * running} state.\n   *\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy() {\n    state.awaitHealthy();\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy} for no more\n   * than the given time.  The manager will become healthy after all the component services have\n   * reached the {@linkplain State#RUNNING running} state.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have finished starting within the deadline\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitHealthy(timeout, unit);\n  }\n\n  /**\n   * Initiates service {@linkplain Service#stopAsync shutdown} if necessary on all the services\n   * being managed.\n   *\n   * @return this\n   */\n  public ServiceManager stopAsync() {\n    for (Service service : services) {\n      service.stopAsync();\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state. After this method returns all\n   * services will either be {@linkplain Service.State#TERMINATED terminated} or {@linkplain\n   * Service.State#FAILED failed}.\n   */\n  public void awaitStopped() {\n    state.awaitStopped();\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state for no more than the given time. After\n   * this method returns all services will either be {@linkplain Service.State#TERMINATED\n   * terminated} or {@linkplain Service.State#FAILED failed}.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have stopped within the deadline\n   */\n  public void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitStopped(timeout, unit);\n  }\n\n  /**\n   * Returns true if all services are currently in the {@linkplain State#RUNNING running} state.\n   *\n   * <p>Users who want more detailed information should use the {@link #servicesByState} method to\n   * get detailed information about which services are not running.\n   */\n  public boolean isHealthy() {\n    for (Service service : services) {\n      if (!service.isRunning()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Provides a snapshot of the current state of all the services under management.\n   *\n   * <p>N.B. This snapshot is guaranteed to be consistent, i.e. the set of states returned will\n   * correspond to a point in time view of the services.\n   */\n  public ImmutableMultimap<State, Service> servicesByState() {\n    return state.servicesByState();\n  }\n\n  /**\n   * Returns the service load times. This value will only return startup times for services that\n   * have finished starting.\n   *\n   * @return Map of services and their corresponding startup time in millis, the map entries will be\n   *     ordered by startup time.\n   */\n  public ImmutableMap<Service, Long> startupTimes() {\n    return state.startupTimes();\n  }\n\n  @Override public String toString() {\n    return MoreObjects.toStringHelper(ServiceManager.class)\n        .add(\"services\", Collections2.filter(services, not(instanceOf(NoOpService.class))))\n        .toString();\n  }\n\n  /**\n   * An encapsulation of all the mutable state of the {@link ServiceManager} that needs to be\n   * accessed by instances of {@link ServiceListener}.\n   */\n  private static final class ServiceManagerState {\n    final Monitor monitor = new Monitor();\n\n    @GuardedBy(\"monitor\")\n    final SetMultimap<State, Service> servicesByState =\n        MultimapBuilder.enumKeys(State.class).linkedHashSetValues().build();\n\n    @GuardedBy(\"monitor\")\n    final Multiset<State> states = servicesByState.keys();\n\n    @GuardedBy(\"monitor\")\n    final Map<Service, Stopwatch> startupTimers = Maps.newIdentityHashMap();\n\n    /**\n     * These two booleans are used to mark the state as ready to start.\n     * {@link #ready}: is set by {@link #markReady} to indicate that all listeners have been\n     *     correctly installed\n     * {@link #transitioned}: is set by {@link #transitionService} to indicate that some transition\n     *     has been performed.\n     *\n     * <p>Together, they allow us to enforce that all services have their listeners installed prior\n     * to any service performing a transition, then we can fail in the ServiceManager constructor\n     * rather than in a Service.Listener callback.\n     */\n    @GuardedBy(\"monitor\")\n    boolean ready;\n\n    @GuardedBy(\"monitor\")\n    boolean transitioned;\n\n    final int numberOfServices;\n\n    /**\n     * Controls how long to wait for all the services to either become healthy or reach a\n     * state from which it is guaranteed that it can never become healthy.\n     */\n    final Monitor.Guard awaitHealthGuard = new AwaitHealthGuard();\n\n    @WeakOuter\n    final class AwaitHealthGuard extends Monitor.Guard {\n      AwaitHealthGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        // All services have started or some service has terminated/failed.\n        return states.count(RUNNING) == numberOfServices\n            || states.contains(STOPPING)\n            || states.contains(TERMINATED)\n            || states.contains(FAILED);\n      }\n    }\n\n    /**\n     * Controls how long to wait for all services to reach a terminal state.\n     */\n    final Monitor.Guard stoppedGuard = new StoppedGuard();\n\n    @WeakOuter\n    final class StoppedGuard extends Monitor.Guard {\n      StoppedGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        return states.count(TERMINATED) + states.count(FAILED) == numberOfServices;\n      }\n    }\n\n    /** The listeners to notify during a state transition. */\n    @GuardedBy(\"monitor\")\n    final List<ListenerCallQueue<Listener>> listeners =\n        Collections.synchronizedList(new ArrayList<ListenerCallQueue<Listener>>());\n\n    /**\n     * It is implicitly assumed that all the services are NEW and that they will all remain NEW\n     * until all the Listeners are installed and {@link #markReady()} is called.  It is our caller's\n     * responsibility to only call {@link #markReady()} if all services were new at the time this\n     * method was called and when all the listeners were installed.\n     */\n    ServiceManagerState(ImmutableCollection<Service> services) {\n      this.numberOfServices = services.size();\n      servicesByState.putAll(NEW, services);\n    }\n\n    /**\n     * Attempts to start the timer immediately prior to the service being started via\n     * {@link Service#startAsync()}.\n     */\n    void tryStartTiming(Service service) {\n      monitor.enter();\n      try {\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          startupTimers.put(service, Stopwatch.createStarted());\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    /**\n     * Marks the {@link State} as ready to receive transitions. Returns true if no transitions have\n     * been observed yet.\n     */\n    void markReady() {\n      monitor.enter();\n      try {\n        if (!transitioned) {\n          // nothing has transitioned since construction, good.\n          ready = true;\n        } else {\n          // This should be an extremely rare race condition.\n          List<Service> servicesInBadStates = Lists.newArrayList();\n          for (Service service : servicesByState().values()) {\n            if (service.state() != NEW) {\n              servicesInBadStates.add(service);\n            }\n          }\n          throw new IllegalArgumentException(\"Services started transitioning asynchronously before \"\n              + \"the ServiceManager was constructed: \" + servicesInBadStates);\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void addListener(Listener listener, Executor executor) {\n      checkNotNull(listener, \"listener\");\n      checkNotNull(executor, \"executor\");\n      monitor.enter();\n      try {\n        // no point in adding a listener that will never be called\n        if (!stoppedGuard.isSatisfied()) {\n          listeners.add(new ListenerCallQueue<Listener>(listener, executor));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy() {\n      monitor.enterWhenUninterruptibly(awaitHealthGuard);\n      try {\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(awaitHealthGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to become healthy. The \"\n              + \"following services have not started: \"\n              + Multimaps.filterKeys(servicesByState, in(ImmutableSet.of(NEW, STARTING))));\n        }\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitStopped() {\n      monitor.enterWhenUninterruptibly(stoppedGuard);\n      monitor.leave();\n    }\n\n    void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(stoppedGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to stop. The following \"\n              + \"services have not stopped: \"\n              + Multimaps.filterKeys(servicesByState,\n                  not(in(EnumSet.of(TERMINATED, FAILED)))));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    ImmutableMultimap<State, Service> servicesByState() {\n      ImmutableSetMultimap.Builder<State, Service> builder = ImmutableSetMultimap.builder();\n      monitor.enter();\n      try {\n        for (Entry<State, Service> entry : servicesByState.entries()) {\n          if (!(entry.getValue() instanceof NoOpService)) {\n            builder.put(entry);\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      return builder.build();\n    }\n\n    ImmutableMap<Service, Long> startupTimes() {\n      List<Entry<Service, Long>> loadTimes;\n      monitor.enter();\n      try {\n        loadTimes = Lists.newArrayListWithCapacity(startupTimers.size());\n        // N.B. There will only be an entry in the map if the service has started\n        for (Entry<Service, Stopwatch> entry : startupTimers.entrySet()) {\n          Service service = entry.getKey();\n          Stopwatch stopWatch = entry.getValue();\n          if (!stopWatch.isRunning() && !(service instanceof NoOpService)) {\n            loadTimes.add(Maps.immutableEntry(service, stopWatch.elapsed(MILLISECONDS)));\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      Collections.sort(loadTimes, Ordering.natural()\n          .onResultOf(new Function<Entry<Service, Long>, Long>() {\n            @Override public Long apply(Map.Entry<Service, Long> input) {\n              return input.getValue();\n            }\n          }));\n      return ImmutableMap.copyOf(loadTimes);\n    }\n\n    /**\n     * Updates the state with the given service transition.\n     *\n     * <p>This method performs the main logic of ServiceManager in the following steps.\n     * <ol>\n     *      <li>Update the {@link #servicesByState()}\n     *      <li>Update the {@link #startupTimers}\n     *      <li>Based on the new state queue listeners to run\n     *      <li>Run the listeners (outside of the lock)\n     * </ol>\n     */\n    void transitionService(final Service service, State from, State to) {\n      checkNotNull(service);\n      checkArgument(from != to);\n      monitor.enter();\n      try {\n        transitioned = true;\n        if (!ready) {\n          return;\n        }\n        // Update state.\n        checkState(servicesByState.remove(from, service),\n            \"Service %s not at the expected location in the state map %s\", service, from);\n        checkState(servicesByState.put(to, service),\n            \"Service %s in the state map unexpectedly at %s\", service, to);\n        // Update the timer\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          // This means the service was started by some means other than ServiceManager.startAsync\n          stopwatch = Stopwatch.createStarted();\n          startupTimers.put(service, stopwatch);\n        }\n        if (to.compareTo(RUNNING) >= 0 && stopwatch.isRunning()) {\n          // N.B. if we miss the STARTING event then we may never record a startup time.\n          stopwatch.stop();\n          if (!(service instanceof NoOpService)) {\n            logger.log(Level.FINE, \"Started {0} in {1}.\", new Object[] {service, stopwatch});\n          }\n        }\n        // Queue our listeners\n\n        // Did a service fail?\n        if (to == FAILED) {\n          fireFailedListeners(service);\n        }\n\n        if (states.count(RUNNING) == numberOfServices) {\n          // This means that the manager is currently healthy. N.B. If other threads call isHealthy\n          // they are not guaranteed to get 'true', because any service could fail right now.\n          fireHealthyListeners();\n        } else if (states.count(TERMINATED) + states.count(FAILED) == numberOfServices) {\n          fireStoppedListeners();\n        }\n      } finally {\n        monitor.leave();\n        // Run our executors outside of the lock\n        executeListeners();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireStoppedListeners() {\n      STOPPED_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireHealthyListeners() {\n      HEALTHY_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireFailedListeners(final Service service) {\n      new Callback<Listener>(\"failed({service=\" + service + \"})\") {\n        @Override void call(Listener listener) {\n          listener.failure(service);\n        }\n      }.enqueueOn(listeners);\n    }\n\n    /** Attempts to execute all the listeners in {@link #listeners}. */\n    void executeListeners() {\n      checkState(!monitor.isOccupiedByCurrentThread(),\n          \"It is incorrect to execute listeners with the monitor held.\");\n      // iterate by index to avoid concurrent modification exceptions\n      for (int i = 0; i < listeners.size(); i++) {\n        listeners.get(i).execute();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void checkHealthy() {\n      if (states.count(RUNNING) != numberOfServices) {\n        IllegalStateException exception = new IllegalStateException(\n            \"Expected to be healthy after starting. The following services are not running: \"\n                + Multimaps.filterKeys(servicesByState, not(equalTo(RUNNING))));\n        throw exception;\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} that wraps another service and times how long it takes for it to start and\n   * also calls the {@link ServiceManagerState#transitionService(Service, State, State)},\n   * to record the state transitions.\n   */\n  private static final class ServiceListener extends Service.Listener {\n    final Service service;\n    // We store the state in a weak reference to ensure that if something went wrong while\n    // constructing the ServiceManager we don't pointlessly keep updating the state.\n    final WeakReference<ServiceManagerState> state;\n\n    ServiceListener(Service service, WeakReference<ServiceManagerState> state) {\n      this.service = service;\n      this.state = state;\n    }\n\n    @Override public void starting() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, NEW, STARTING);\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Starting {0}.\", service);\n        }\n      }\n    }\n\n    @Override public void running() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, STARTING, RUNNING);\n      }\n    }\n\n    @Override public void stopping(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, from, STOPPING);\n      }\n    }\n\n    @Override public void terminated(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Service {0} has terminated. Previous state was: {1}\",\n              new Object[] {service, from});\n        }\n        state.transitionService(service, from, TERMINATED);\n      }\n    }\n\n    @Override public void failed(State from, Throwable failure) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        // Log before the transition, so that if the process exits in response to server failure,\n        // there is a higher likelihood that the cause will be in the logs.\n        if (!(service instanceof NoOpService) ) {\n          logger.log(Level.SEVERE, \"Service \" + service + \" has failed in the \" + from + \" state.\",\n              failure);\n        }\n        state.transitionService(service, from, FAILED);\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} instance that does nothing.  This is only useful as a placeholder to\n   * ensure that the {@link ServiceManager} functions properly even when it is managing no services.\n   *\n   * <p>The use of this class is considered an implementation detail of ServiceManager and as such\n   * it is excluded from {@link #servicesByState}, {@link #startupTimes}, {@link #toString} and all\n   * logging statements.\n   */\n  private static final class NoOpService extends AbstractService {\n    @Override protected void doStart() { notifyStarted(); }\n    @Override protected void doStop() { notifyStopped(); }\n  }\n\n  /** This is never thrown but only used for logging. */\n  private static final class EmptyServiceManagerWarning extends Throwable {}\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53084359,"label":true,"oracleId":1456,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"ServiceManager","javadocTag":"@param unit the time unit of the timeout argument","methodJavadoc":"    /**\n   * Waits for the all the services to reach a terminal state for no more than the given time. After\n   * this method returns all services will either be {@linkplain Service.State#TERMINATED\n   * terminated} or {@linkplain Service.State#FAILED failed}.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have stopped within the deadline\n   */","methodSourceCode":"public void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException{\n    state.awaitStopped(timeout, unit);\n}","classJavadoc":"/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */","classSourceCode":"/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Predicates.equalTo;\nimport static com.google.common.base.Predicates.in;\nimport static com.google.common.base.Predicates.instanceOf;\nimport static com.google.common.base.Predicates.not;\nimport static com.google.common.util.concurrent.MoreExecutors.directExecutor;\nimport static com.google.common.util.concurrent.Service.State.FAILED;\nimport static com.google.common.util.concurrent.Service.State.NEW;\nimport static com.google.common.util.concurrent.Service.State.RUNNING;\nimport static com.google.common.util.concurrent.Service.State.STARTING;\nimport static com.google.common.util.concurrent.Service.State.STOPPING;\nimport static com.google.common.util.concurrent.Service.State.TERMINATED;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.base.Function;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Stopwatch;\nimport com.google.common.collect.Collections2;\nimport com.google.common.collect.ImmutableCollection;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableMultimap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSetMultimap;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.MultimapBuilder;\nimport com.google.common.collect.Multimaps;\nimport com.google.common.collect.Multiset;\nimport com.google.common.collect.Ordering;\nimport com.google.common.collect.SetMultimap;\nimport com.google.common.util.concurrent.ListenerCallQueue.Callback;\nimport com.google.common.util.concurrent.Service.State;\nimport com.google.j2objc.annotations.WeakOuter;\n\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */\n@Beta\npublic final class ServiceManager {\n  private static final Logger logger = Logger.getLogger(ServiceManager.class.getName());\n  private static final Callback<Listener> HEALTHY_CALLBACK = new Callback<Listener>(\"healthy()\") {\n    @Override void call(Listener listener) {\n      listener.healthy();\n    }\n  };\n  private static final Callback<Listener> STOPPED_CALLBACK = new Callback<Listener>(\"stopped()\") {\n    @Override void call(Listener listener) {\n      listener.stopped();\n    }\n  };\n\n  /**\n   * A listener for the aggregate state changes of the services that are under management. Users\n   * that need to listen to more fine-grained events (such as when each particular {@linkplain\n   * Service service} starts, or terminates), should attach {@linkplain Service.Listener service\n   * listeners} to each individual service.\n   *\n   * @author Luke Sandberg\n   * @since 15.0 (present as an interface in 14.0)\n   */\n  @Beta  // Should come out of Beta when ServiceManager does\n  public abstract static class Listener {\n    /**\n     * Called when the service initially becomes healthy.\n     *\n     * <p>This will be called at most once after all the services have entered the\n     * {@linkplain State#RUNNING running} state. If any services fail during start up or\n     * {@linkplain State#FAILED fail}/{@linkplain State#TERMINATED terminate} before all other\n     * services have started {@linkplain State#RUNNING running} then this method will not be called.\n     */\n    public void healthy() {}\n\n    /**\n     * Called when the all of the component services have reached a terminal state, either\n     * {@linkplain State#TERMINATED terminated} or {@linkplain State#FAILED failed}.\n     */\n    public void stopped() {}\n\n    /**\n     * Called when a component service has {@linkplain State#FAILED failed}.\n     *\n     * @param service The service that failed.\n     */\n    public void failure(Service service) {}\n  }\n\n  /**\n   * An encapsulation of all of the state that is accessed by the {@linkplain ServiceListener\n   * service listeners}.  This is extracted into its own object so that {@link ServiceListener}\n   * could be made {@code static} and its instances can be safely constructed and added in the\n   * {@link ServiceManager} constructor without having to close over the partially constructed\n   * {@link ServiceManager} instance (i.e. avoid leaking a pointer to {@code this}).\n   */\n  private final ServiceManagerState state;\n  private final ImmutableList<Service> services;\n\n  /**\n   * Constructs a new instance for managing the given services.\n   *\n   * @param services The services to manage\n   *\n   * @throws IllegalArgumentException if not all services are {@linkplain State#NEW new} or if there\n   * are any duplicate services.\n   */\n  public ServiceManager(Iterable<? extends Service> services) {\n    ImmutableList<Service> copy = ImmutableList.copyOf(services);\n    if (copy.isEmpty()) {\n      // Having no services causes the manager to behave strangely. Notably, listeners are never\n      // fired.  To avoid this we substitute a placeholder service.\n      logger.log(Level.WARNING,\n          \"ServiceManager configured with no services.  Is your application configured properly?\",\n          new EmptyServiceManagerWarning());\n      copy = ImmutableList.<Service>of(new NoOpService());\n    }\n    this.state = new ServiceManagerState(copy);\n    this.services = copy;\n    WeakReference<ServiceManagerState> stateReference =\n        new WeakReference<ServiceManagerState>(state);\n    for (Service service : copy) {\n      service.addListener(new ServiceListener(service, stateReference), directExecutor());\n      // We check the state after adding the listener as a way to ensure that our listener was added\n      // to a NEW service.\n      checkArgument(service.state() == NEW, \"Can only manage NEW services, %s\", service);\n    }\n    // We have installed all of our listeners and after this point any state transition should be\n    // correct.\n    this.state.markReady();\n  }\n\n  /**\n   * Registers a {@link Listener} to be {@linkplain Executor#execute executed} on the given\n   * executor. The listener will not have previous state changes replayed, so it is\n   * suggested that listeners are added before any of the managed services are\n   * {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged. Any exception thrown\n   * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException}) will be caught and\n   * logged.\n   *\n   * <p> For fast, lightweight listeners that would be safe to execute in any thread, consider\n   * calling {@link #addListener(Listener)}.\n   *\n   * @param listener the listener to run when the manager changes state\n   * @param executor the executor in which the listeners callback methods will be run.\n   */\n  public void addListener(Listener listener, Executor executor) {\n    state.addListener(listener, executor);\n  }\n\n  /**\n   * Registers a {@link Listener} to be run when this {@link ServiceManager} changes state. The\n   * listener will not have previous state changes replayed, so it is suggested that listeners are\n   * added before any of the managed services are {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged.\n   *\n   * @param listener the listener to run when the manager changes state\n   */\n  public void addListener(Listener listener) {\n    state.addListener(listener, directExecutor());\n  }\n\n  /**\n   * Initiates service {@linkplain Service#startAsync startup} on all the services being managed.\n   * It is only valid to call this method if all of the services are {@linkplain State#NEW new}.\n   *\n   * @return this\n   * @throws IllegalStateException if any of the Services are not {@link State#NEW new} when the\n   *     method is called.\n   */\n  public ServiceManager startAsync() {\n    for (Service service : services) {\n      State state = service.state();\n      checkState(state == NEW, \"Service %s is %s, cannot start it.\", service, state);\n    }\n    for (Service service : services) {\n      try {\n        state.tryStartTiming(service);\n        service.startAsync();\n      } catch (IllegalStateException e) {\n        // This can happen if the service has already been started or stopped (e.g. by another\n        // service or listener). Our contract says it is safe to call this method if\n        // all services were NEW when it was called, and this has already been verified above, so we\n        // don't propagate the exception.\n        logger.log(Level.WARNING, \"Unable to start Service \" + service, e);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy}.  The manager\n   * will become healthy after all the component services have reached the {@linkplain State#RUNNING\n   * running} state.\n   *\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy() {\n    state.awaitHealthy();\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy} for no more\n   * than the given time.  The manager will become healthy after all the component services have\n   * reached the {@linkplain State#RUNNING running} state.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have finished starting within the deadline\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitHealthy(timeout, unit);\n  }\n\n  /**\n   * Initiates service {@linkplain Service#stopAsync shutdown} if necessary on all the services\n   * being managed.\n   *\n   * @return this\n   */\n  public ServiceManager stopAsync() {\n    for (Service service : services) {\n      service.stopAsync();\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state. After this method returns all\n   * services will either be {@linkplain Service.State#TERMINATED terminated} or {@linkplain\n   * Service.State#FAILED failed}.\n   */\n  public void awaitStopped() {\n    state.awaitStopped();\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state for no more than the given time. After\n   * this method returns all services will either be {@linkplain Service.State#TERMINATED\n   * terminated} or {@linkplain Service.State#FAILED failed}.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have stopped within the deadline\n   */\n  public void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitStopped(timeout, unit);\n  }\n\n  /**\n   * Returns true if all services are currently in the {@linkplain State#RUNNING running} state.\n   *\n   * <p>Users who want more detailed information should use the {@link #servicesByState} method to\n   * get detailed information about which services are not running.\n   */\n  public boolean isHealthy() {\n    for (Service service : services) {\n      if (!service.isRunning()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Provides a snapshot of the current state of all the services under management.\n   *\n   * <p>N.B. This snapshot is guaranteed to be consistent, i.e. the set of states returned will\n   * correspond to a point in time view of the services.\n   */\n  public ImmutableMultimap<State, Service> servicesByState() {\n    return state.servicesByState();\n  }\n\n  /**\n   * Returns the service load times. This value will only return startup times for services that\n   * have finished starting.\n   *\n   * @return Map of services and their corresponding startup time in millis, the map entries will be\n   *     ordered by startup time.\n   */\n  public ImmutableMap<Service, Long> startupTimes() {\n    return state.startupTimes();\n  }\n\n  @Override public String toString() {\n    return MoreObjects.toStringHelper(ServiceManager.class)\n        .add(\"services\", Collections2.filter(services, not(instanceOf(NoOpService.class))))\n        .toString();\n  }\n\n  /**\n   * An encapsulation of all the mutable state of the {@link ServiceManager} that needs to be\n   * accessed by instances of {@link ServiceListener}.\n   */\n  private static final class ServiceManagerState {\n    final Monitor monitor = new Monitor();\n\n    @GuardedBy(\"monitor\")\n    final SetMultimap<State, Service> servicesByState =\n        MultimapBuilder.enumKeys(State.class).linkedHashSetValues().build();\n\n    @GuardedBy(\"monitor\")\n    final Multiset<State> states = servicesByState.keys();\n\n    @GuardedBy(\"monitor\")\n    final Map<Service, Stopwatch> startupTimers = Maps.newIdentityHashMap();\n\n    /**\n     * These two booleans are used to mark the state as ready to start.\n     * {@link #ready}: is set by {@link #markReady} to indicate that all listeners have been\n     *     correctly installed\n     * {@link #transitioned}: is set by {@link #transitionService} to indicate that some transition\n     *     has been performed.\n     *\n     * <p>Together, they allow us to enforce that all services have their listeners installed prior\n     * to any service performing a transition, then we can fail in the ServiceManager constructor\n     * rather than in a Service.Listener callback.\n     */\n    @GuardedBy(\"monitor\")\n    boolean ready;\n\n    @GuardedBy(\"monitor\")\n    boolean transitioned;\n\n    final int numberOfServices;\n\n    /**\n     * Controls how long to wait for all the services to either become healthy or reach a\n     * state from which it is guaranteed that it can never become healthy.\n     */\n    final Monitor.Guard awaitHealthGuard = new AwaitHealthGuard();\n\n    @WeakOuter\n    final class AwaitHealthGuard extends Monitor.Guard {\n      AwaitHealthGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        // All services have started or some service has terminated/failed.\n        return states.count(RUNNING) == numberOfServices\n            || states.contains(STOPPING)\n            || states.contains(TERMINATED)\n            || states.contains(FAILED);\n      }\n    }\n\n    /**\n     * Controls how long to wait for all services to reach a terminal state.\n     */\n    final Monitor.Guard stoppedGuard = new StoppedGuard();\n\n    @WeakOuter\n    final class StoppedGuard extends Monitor.Guard {\n      StoppedGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        return states.count(TERMINATED) + states.count(FAILED) == numberOfServices;\n      }\n    }\n\n    /** The listeners to notify during a state transition. */\n    @GuardedBy(\"monitor\")\n    final List<ListenerCallQueue<Listener>> listeners =\n        Collections.synchronizedList(new ArrayList<ListenerCallQueue<Listener>>());\n\n    /**\n     * It is implicitly assumed that all the services are NEW and that they will all remain NEW\n     * until all the Listeners are installed and {@link #markReady()} is called.  It is our caller's\n     * responsibility to only call {@link #markReady()} if all services were new at the time this\n     * method was called and when all the listeners were installed.\n     */\n    ServiceManagerState(ImmutableCollection<Service> services) {\n      this.numberOfServices = services.size();\n      servicesByState.putAll(NEW, services);\n    }\n\n    /**\n     * Attempts to start the timer immediately prior to the service being started via\n     * {@link Service#startAsync()}.\n     */\n    void tryStartTiming(Service service) {\n      monitor.enter();\n      try {\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          startupTimers.put(service, Stopwatch.createStarted());\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    /**\n     * Marks the {@link State} as ready to receive transitions. Returns true if no transitions have\n     * been observed yet.\n     */\n    void markReady() {\n      monitor.enter();\n      try {\n        if (!transitioned) {\n          // nothing has transitioned since construction, good.\n          ready = true;\n        } else {\n          // This should be an extremely rare race condition.\n          List<Service> servicesInBadStates = Lists.newArrayList();\n          for (Service service : servicesByState().values()) {\n            if (service.state() != NEW) {\n              servicesInBadStates.add(service);\n            }\n          }\n          throw new IllegalArgumentException(\"Services started transitioning asynchronously before \"\n              + \"the ServiceManager was constructed: \" + servicesInBadStates);\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void addListener(Listener listener, Executor executor) {\n      checkNotNull(listener, \"listener\");\n      checkNotNull(executor, \"executor\");\n      monitor.enter();\n      try {\n        // no point in adding a listener that will never be called\n        if (!stoppedGuard.isSatisfied()) {\n          listeners.add(new ListenerCallQueue<Listener>(listener, executor));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy() {\n      monitor.enterWhenUninterruptibly(awaitHealthGuard);\n      try {\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(awaitHealthGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to become healthy. The \"\n              + \"following services have not started: \"\n              + Multimaps.filterKeys(servicesByState, in(ImmutableSet.of(NEW, STARTING))));\n        }\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitStopped() {\n      monitor.enterWhenUninterruptibly(stoppedGuard);\n      monitor.leave();\n    }\n\n    void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(stoppedGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to stop. The following \"\n              + \"services have not stopped: \"\n              + Multimaps.filterKeys(servicesByState,\n                  not(in(EnumSet.of(TERMINATED, FAILED)))));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    ImmutableMultimap<State, Service> servicesByState() {\n      ImmutableSetMultimap.Builder<State, Service> builder = ImmutableSetMultimap.builder();\n      monitor.enter();\n      try {\n        for (Entry<State, Service> entry : servicesByState.entries()) {\n          if (!(entry.getValue() instanceof NoOpService)) {\n            builder.put(entry);\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      return builder.build();\n    }\n\n    ImmutableMap<Service, Long> startupTimes() {\n      List<Entry<Service, Long>> loadTimes;\n      monitor.enter();\n      try {\n        loadTimes = Lists.newArrayListWithCapacity(startupTimers.size());\n        // N.B. There will only be an entry in the map if the service has started\n        for (Entry<Service, Stopwatch> entry : startupTimers.entrySet()) {\n          Service service = entry.getKey();\n          Stopwatch stopWatch = entry.getValue();\n          if (!stopWatch.isRunning() && !(service instanceof NoOpService)) {\n            loadTimes.add(Maps.immutableEntry(service, stopWatch.elapsed(MILLISECONDS)));\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      Collections.sort(loadTimes, Ordering.natural()\n          .onResultOf(new Function<Entry<Service, Long>, Long>() {\n            @Override public Long apply(Map.Entry<Service, Long> input) {\n              return input.getValue();\n            }\n          }));\n      return ImmutableMap.copyOf(loadTimes);\n    }\n\n    /**\n     * Updates the state with the given service transition.\n     *\n     * <p>This method performs the main logic of ServiceManager in the following steps.\n     * <ol>\n     *      <li>Update the {@link #servicesByState()}\n     *      <li>Update the {@link #startupTimers}\n     *      <li>Based on the new state queue listeners to run\n     *      <li>Run the listeners (outside of the lock)\n     * </ol>\n     */\n    void transitionService(final Service service, State from, State to) {\n      checkNotNull(service);\n      checkArgument(from != to);\n      monitor.enter();\n      try {\n        transitioned = true;\n        if (!ready) {\n          return;\n        }\n        // Update state.\n        checkState(servicesByState.remove(from, service),\n            \"Service %s not at the expected location in the state map %s\", service, from);\n        checkState(servicesByState.put(to, service),\n            \"Service %s in the state map unexpectedly at %s\", service, to);\n        // Update the timer\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          // This means the service was started by some means other than ServiceManager.startAsync\n          stopwatch = Stopwatch.createStarted();\n          startupTimers.put(service, stopwatch);\n        }\n        if (to.compareTo(RUNNING) >= 0 && stopwatch.isRunning()) {\n          // N.B. if we miss the STARTING event then we may never record a startup time.\n          stopwatch.stop();\n          if (!(service instanceof NoOpService)) {\n            logger.log(Level.FINE, \"Started {0} in {1}.\", new Object[] {service, stopwatch});\n          }\n        }\n        // Queue our listeners\n\n        // Did a service fail?\n        if (to == FAILED) {\n          fireFailedListeners(service);\n        }\n\n        if (states.count(RUNNING) == numberOfServices) {\n          // This means that the manager is currently healthy. N.B. If other threads call isHealthy\n          // they are not guaranteed to get 'true', because any service could fail right now.\n          fireHealthyListeners();\n        } else if (states.count(TERMINATED) + states.count(FAILED) == numberOfServices) {\n          fireStoppedListeners();\n        }\n      } finally {\n        monitor.leave();\n        // Run our executors outside of the lock\n        executeListeners();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireStoppedListeners() {\n      STOPPED_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireHealthyListeners() {\n      HEALTHY_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireFailedListeners(final Service service) {\n      new Callback<Listener>(\"failed({service=\" + service + \"})\") {\n        @Override void call(Listener listener) {\n          listener.failure(service);\n        }\n      }.enqueueOn(listeners);\n    }\n\n    /** Attempts to execute all the listeners in {@link #listeners}. */\n    void executeListeners() {\n      checkState(!monitor.isOccupiedByCurrentThread(),\n          \"It is incorrect to execute listeners with the monitor held.\");\n      // iterate by index to avoid concurrent modification exceptions\n      for (int i = 0; i < listeners.size(); i++) {\n        listeners.get(i).execute();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void checkHealthy() {\n      if (states.count(RUNNING) != numberOfServices) {\n        IllegalStateException exception = new IllegalStateException(\n            \"Expected to be healthy after starting. The following services are not running: \"\n                + Multimaps.filterKeys(servicesByState, not(equalTo(RUNNING))));\n        throw exception;\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} that wraps another service and times how long it takes for it to start and\n   * also calls the {@link ServiceManagerState#transitionService(Service, State, State)},\n   * to record the state transitions.\n   */\n  private static final class ServiceListener extends Service.Listener {\n    final Service service;\n    // We store the state in a weak reference to ensure that if something went wrong while\n    // constructing the ServiceManager we don't pointlessly keep updating the state.\n    final WeakReference<ServiceManagerState> state;\n\n    ServiceListener(Service service, WeakReference<ServiceManagerState> state) {\n      this.service = service;\n      this.state = state;\n    }\n\n    @Override public void starting() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, NEW, STARTING);\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Starting {0}.\", service);\n        }\n      }\n    }\n\n    @Override public void running() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, STARTING, RUNNING);\n      }\n    }\n\n    @Override public void stopping(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, from, STOPPING);\n      }\n    }\n\n    @Override public void terminated(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Service {0} has terminated. Previous state was: {1}\",\n              new Object[] {service, from});\n        }\n        state.transitionService(service, from, TERMINATED);\n      }\n    }\n\n    @Override public void failed(State from, Throwable failure) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        // Log before the transition, so that if the process exits in response to server failure,\n        // there is a higher likelihood that the cause will be in the logs.\n        if (!(service instanceof NoOpService) ) {\n          logger.log(Level.SEVERE, \"Service \" + service + \" has failed in the \" + from + \" state.\",\n              failure);\n        }\n        state.transitionService(service, from, FAILED);\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} instance that does nothing.  This is only useful as a placeholder to\n   * ensure that the {@link ServiceManager} functions properly even when it is managing no services.\n   *\n   * <p>The use of this class is considered an implementation detail of ServiceManager and as such\n   * it is excluded from {@link #servicesByState}, {@link #startupTimes}, {@link #toString} and all\n   * logging statements.\n   */\n  private static final class NoOpService extends AbstractService {\n    @Override protected void doStart() { notifyStarted(); }\n    @Override protected void doStop() { notifyStopped(); }\n  }\n\n  /** This is never thrown but only used for logging. */\n  private static final class EmptyServiceManagerWarning extends Throwable {}\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53084819,"label":true,"oracleId":1457,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"ServiceManager","javadocTag":"@throws TimeoutException if not all of the services have stopped within the deadline","methodJavadoc":"    /**\n   * Waits for the all the services to reach a terminal state for no more than the given time. After\n   * this method returns all services will either be {@linkplain Service.State#TERMINATED\n   * terminated} or {@linkplain Service.State#FAILED failed}.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have stopped within the deadline\n   */","methodSourceCode":"public void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException{\n    state.awaitStopped(timeout, unit);\n}","classJavadoc":"/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */","classSourceCode":"/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Predicates.equalTo;\nimport static com.google.common.base.Predicates.in;\nimport static com.google.common.base.Predicates.instanceOf;\nimport static com.google.common.base.Predicates.not;\nimport static com.google.common.util.concurrent.MoreExecutors.directExecutor;\nimport static com.google.common.util.concurrent.Service.State.FAILED;\nimport static com.google.common.util.concurrent.Service.State.NEW;\nimport static com.google.common.util.concurrent.Service.State.RUNNING;\nimport static com.google.common.util.concurrent.Service.State.STARTING;\nimport static com.google.common.util.concurrent.Service.State.STOPPING;\nimport static com.google.common.util.concurrent.Service.State.TERMINATED;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.base.Function;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Stopwatch;\nimport com.google.common.collect.Collections2;\nimport com.google.common.collect.ImmutableCollection;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableMultimap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSetMultimap;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.MultimapBuilder;\nimport com.google.common.collect.Multimaps;\nimport com.google.common.collect.Multiset;\nimport com.google.common.collect.Ordering;\nimport com.google.common.collect.SetMultimap;\nimport com.google.common.util.concurrent.ListenerCallQueue.Callback;\nimport com.google.common.util.concurrent.Service.State;\nimport com.google.j2objc.annotations.WeakOuter;\n\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */\n@Beta\npublic final class ServiceManager {\n  private static final Logger logger = Logger.getLogger(ServiceManager.class.getName());\n  private static final Callback<Listener> HEALTHY_CALLBACK = new Callback<Listener>(\"healthy()\") {\n    @Override void call(Listener listener) {\n      listener.healthy();\n    }\n  };\n  private static final Callback<Listener> STOPPED_CALLBACK = new Callback<Listener>(\"stopped()\") {\n    @Override void call(Listener listener) {\n      listener.stopped();\n    }\n  };\n\n  /**\n   * A listener for the aggregate state changes of the services that are under management. Users\n   * that need to listen to more fine-grained events (such as when each particular {@linkplain\n   * Service service} starts, or terminates), should attach {@linkplain Service.Listener service\n   * listeners} to each individual service.\n   *\n   * @author Luke Sandberg\n   * @since 15.0 (present as an interface in 14.0)\n   */\n  @Beta  // Should come out of Beta when ServiceManager does\n  public abstract static class Listener {\n    /**\n     * Called when the service initially becomes healthy.\n     *\n     * <p>This will be called at most once after all the services have entered the\n     * {@linkplain State#RUNNING running} state. If any services fail during start up or\n     * {@linkplain State#FAILED fail}/{@linkplain State#TERMINATED terminate} before all other\n     * services have started {@linkplain State#RUNNING running} then this method will not be called.\n     */\n    public void healthy() {}\n\n    /**\n     * Called when the all of the component services have reached a terminal state, either\n     * {@linkplain State#TERMINATED terminated} or {@linkplain State#FAILED failed}.\n     */\n    public void stopped() {}\n\n    /**\n     * Called when a component service has {@linkplain State#FAILED failed}.\n     *\n     * @param service The service that failed.\n     */\n    public void failure(Service service) {}\n  }\n\n  /**\n   * An encapsulation of all of the state that is accessed by the {@linkplain ServiceListener\n   * service listeners}.  This is extracted into its own object so that {@link ServiceListener}\n   * could be made {@code static} and its instances can be safely constructed and added in the\n   * {@link ServiceManager} constructor without having to close over the partially constructed\n   * {@link ServiceManager} instance (i.e. avoid leaking a pointer to {@code this}).\n   */\n  private final ServiceManagerState state;\n  private final ImmutableList<Service> services;\n\n  /**\n   * Constructs a new instance for managing the given services.\n   *\n   * @param services The services to manage\n   *\n   * @throws IllegalArgumentException if not all services are {@linkplain State#NEW new} or if there\n   * are any duplicate services.\n   */\n  public ServiceManager(Iterable<? extends Service> services) {\n    ImmutableList<Service> copy = ImmutableList.copyOf(services);\n    if (copy.isEmpty()) {\n      // Having no services causes the manager to behave strangely. Notably, listeners are never\n      // fired.  To avoid this we substitute a placeholder service.\n      logger.log(Level.WARNING,\n          \"ServiceManager configured with no services.  Is your application configured properly?\",\n          new EmptyServiceManagerWarning());\n      copy = ImmutableList.<Service>of(new NoOpService());\n    }\n    this.state = new ServiceManagerState(copy);\n    this.services = copy;\n    WeakReference<ServiceManagerState> stateReference =\n        new WeakReference<ServiceManagerState>(state);\n    for (Service service : copy) {\n      service.addListener(new ServiceListener(service, stateReference), directExecutor());\n      // We check the state after adding the listener as a way to ensure that our listener was added\n      // to a NEW service.\n      checkArgument(service.state() == NEW, \"Can only manage NEW services, %s\", service);\n    }\n    // We have installed all of our listeners and after this point any state transition should be\n    // correct.\n    this.state.markReady();\n  }\n\n  /**\n   * Registers a {@link Listener} to be {@linkplain Executor#execute executed} on the given\n   * executor. The listener will not have previous state changes replayed, so it is\n   * suggested that listeners are added before any of the managed services are\n   * {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged. Any exception thrown\n   * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException}) will be caught and\n   * logged.\n   *\n   * <p> For fast, lightweight listeners that would be safe to execute in any thread, consider\n   * calling {@link #addListener(Listener)}.\n   *\n   * @param listener the listener to run when the manager changes state\n   * @param executor the executor in which the listeners callback methods will be run.\n   */\n  public void addListener(Listener listener, Executor executor) {\n    state.addListener(listener, executor);\n  }\n\n  /**\n   * Registers a {@link Listener} to be run when this {@link ServiceManager} changes state. The\n   * listener will not have previous state changes replayed, so it is suggested that listeners are\n   * added before any of the managed services are {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged.\n   *\n   * @param listener the listener to run when the manager changes state\n   */\n  public void addListener(Listener listener) {\n    state.addListener(listener, directExecutor());\n  }\n\n  /**\n   * Initiates service {@linkplain Service#startAsync startup} on all the services being managed.\n   * It is only valid to call this method if all of the services are {@linkplain State#NEW new}.\n   *\n   * @return this\n   * @throws IllegalStateException if any of the Services are not {@link State#NEW new} when the\n   *     method is called.\n   */\n  public ServiceManager startAsync() {\n    for (Service service : services) {\n      State state = service.state();\n      checkState(state == NEW, \"Service %s is %s, cannot start it.\", service, state);\n    }\n    for (Service service : services) {\n      try {\n        state.tryStartTiming(service);\n        service.startAsync();\n      } catch (IllegalStateException e) {\n        // This can happen if the service has already been started or stopped (e.g. by another\n        // service or listener). Our contract says it is safe to call this method if\n        // all services were NEW when it was called, and this has already been verified above, so we\n        // don't propagate the exception.\n        logger.log(Level.WARNING, \"Unable to start Service \" + service, e);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy}.  The manager\n   * will become healthy after all the component services have reached the {@linkplain State#RUNNING\n   * running} state.\n   *\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy() {\n    state.awaitHealthy();\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy} for no more\n   * than the given time.  The manager will become healthy after all the component services have\n   * reached the {@linkplain State#RUNNING running} state.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have finished starting within the deadline\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitHealthy(timeout, unit);\n  }\n\n  /**\n   * Initiates service {@linkplain Service#stopAsync shutdown} if necessary on all the services\n   * being managed.\n   *\n   * @return this\n   */\n  public ServiceManager stopAsync() {\n    for (Service service : services) {\n      service.stopAsync();\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state. After this method returns all\n   * services will either be {@linkplain Service.State#TERMINATED terminated} or {@linkplain\n   * Service.State#FAILED failed}.\n   */\n  public void awaitStopped() {\n    state.awaitStopped();\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state for no more than the given time. After\n   * this method returns all services will either be {@linkplain Service.State#TERMINATED\n   * terminated} or {@linkplain Service.State#FAILED failed}.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have stopped within the deadline\n   */\n  public void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitStopped(timeout, unit);\n  }\n\n  /**\n   * Returns true if all services are currently in the {@linkplain State#RUNNING running} state.\n   *\n   * <p>Users who want more detailed information should use the {@link #servicesByState} method to\n   * get detailed information about which services are not running.\n   */\n  public boolean isHealthy() {\n    for (Service service : services) {\n      if (!service.isRunning()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Provides a snapshot of the current state of all the services under management.\n   *\n   * <p>N.B. This snapshot is guaranteed to be consistent, i.e. the set of states returned will\n   * correspond to a point in time view of the services.\n   */\n  public ImmutableMultimap<State, Service> servicesByState() {\n    return state.servicesByState();\n  }\n\n  /**\n   * Returns the service load times. This value will only return startup times for services that\n   * have finished starting.\n   *\n   * @return Map of services and their corresponding startup time in millis, the map entries will be\n   *     ordered by startup time.\n   */\n  public ImmutableMap<Service, Long> startupTimes() {\n    return state.startupTimes();\n  }\n\n  @Override public String toString() {\n    return MoreObjects.toStringHelper(ServiceManager.class)\n        .add(\"services\", Collections2.filter(services, not(instanceOf(NoOpService.class))))\n        .toString();\n  }\n\n  /**\n   * An encapsulation of all the mutable state of the {@link ServiceManager} that needs to be\n   * accessed by instances of {@link ServiceListener}.\n   */\n  private static final class ServiceManagerState {\n    final Monitor monitor = new Monitor();\n\n    @GuardedBy(\"monitor\")\n    final SetMultimap<State, Service> servicesByState =\n        MultimapBuilder.enumKeys(State.class).linkedHashSetValues().build();\n\n    @GuardedBy(\"monitor\")\n    final Multiset<State> states = servicesByState.keys();\n\n    @GuardedBy(\"monitor\")\n    final Map<Service, Stopwatch> startupTimers = Maps.newIdentityHashMap();\n\n    /**\n     * These two booleans are used to mark the state as ready to start.\n     * {@link #ready}: is set by {@link #markReady} to indicate that all listeners have been\n     *     correctly installed\n     * {@link #transitioned}: is set by {@link #transitionService} to indicate that some transition\n     *     has been performed.\n     *\n     * <p>Together, they allow us to enforce that all services have their listeners installed prior\n     * to any service performing a transition, then we can fail in the ServiceManager constructor\n     * rather than in a Service.Listener callback.\n     */\n    @GuardedBy(\"monitor\")\n    boolean ready;\n\n    @GuardedBy(\"monitor\")\n    boolean transitioned;\n\n    final int numberOfServices;\n\n    /**\n     * Controls how long to wait for all the services to either become healthy or reach a\n     * state from which it is guaranteed that it can never become healthy.\n     */\n    final Monitor.Guard awaitHealthGuard = new AwaitHealthGuard();\n\n    @WeakOuter\n    final class AwaitHealthGuard extends Monitor.Guard {\n      AwaitHealthGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        // All services have started or some service has terminated/failed.\n        return states.count(RUNNING) == numberOfServices\n            || states.contains(STOPPING)\n            || states.contains(TERMINATED)\n            || states.contains(FAILED);\n      }\n    }\n\n    /**\n     * Controls how long to wait for all services to reach a terminal state.\n     */\n    final Monitor.Guard stoppedGuard = new StoppedGuard();\n\n    @WeakOuter\n    final class StoppedGuard extends Monitor.Guard {\n      StoppedGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        return states.count(TERMINATED) + states.count(FAILED) == numberOfServices;\n      }\n    }\n\n    /** The listeners to notify during a state transition. */\n    @GuardedBy(\"monitor\")\n    final List<ListenerCallQueue<Listener>> listeners =\n        Collections.synchronizedList(new ArrayList<ListenerCallQueue<Listener>>());\n\n    /**\n     * It is implicitly assumed that all the services are NEW and that they will all remain NEW\n     * until all the Listeners are installed and {@link #markReady()} is called.  It is our caller's\n     * responsibility to only call {@link #markReady()} if all services were new at the time this\n     * method was called and when all the listeners were installed.\n     */\n    ServiceManagerState(ImmutableCollection<Service> services) {\n      this.numberOfServices = services.size();\n      servicesByState.putAll(NEW, services);\n    }\n\n    /**\n     * Attempts to start the timer immediately prior to the service being started via\n     * {@link Service#startAsync()}.\n     */\n    void tryStartTiming(Service service) {\n      monitor.enter();\n      try {\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          startupTimers.put(service, Stopwatch.createStarted());\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    /**\n     * Marks the {@link State} as ready to receive transitions. Returns true if no transitions have\n     * been observed yet.\n     */\n    void markReady() {\n      monitor.enter();\n      try {\n        if (!transitioned) {\n          // nothing has transitioned since construction, good.\n          ready = true;\n        } else {\n          // This should be an extremely rare race condition.\n          List<Service> servicesInBadStates = Lists.newArrayList();\n          for (Service service : servicesByState().values()) {\n            if (service.state() != NEW) {\n              servicesInBadStates.add(service);\n            }\n          }\n          throw new IllegalArgumentException(\"Services started transitioning asynchronously before \"\n              + \"the ServiceManager was constructed: \" + servicesInBadStates);\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void addListener(Listener listener, Executor executor) {\n      checkNotNull(listener, \"listener\");\n      checkNotNull(executor, \"executor\");\n      monitor.enter();\n      try {\n        // no point in adding a listener that will never be called\n        if (!stoppedGuard.isSatisfied()) {\n          listeners.add(new ListenerCallQueue<Listener>(listener, executor));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy() {\n      monitor.enterWhenUninterruptibly(awaitHealthGuard);\n      try {\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(awaitHealthGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to become healthy. The \"\n              + \"following services have not started: \"\n              + Multimaps.filterKeys(servicesByState, in(ImmutableSet.of(NEW, STARTING))));\n        }\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitStopped() {\n      monitor.enterWhenUninterruptibly(stoppedGuard);\n      monitor.leave();\n    }\n\n    void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(stoppedGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to stop. The following \"\n              + \"services have not stopped: \"\n              + Multimaps.filterKeys(servicesByState,\n                  not(in(EnumSet.of(TERMINATED, FAILED)))));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    ImmutableMultimap<State, Service> servicesByState() {\n      ImmutableSetMultimap.Builder<State, Service> builder = ImmutableSetMultimap.builder();\n      monitor.enter();\n      try {\n        for (Entry<State, Service> entry : servicesByState.entries()) {\n          if (!(entry.getValue() instanceof NoOpService)) {\n            builder.put(entry);\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      return builder.build();\n    }\n\n    ImmutableMap<Service, Long> startupTimes() {\n      List<Entry<Service, Long>> loadTimes;\n      monitor.enter();\n      try {\n        loadTimes = Lists.newArrayListWithCapacity(startupTimers.size());\n        // N.B. There will only be an entry in the map if the service has started\n        for (Entry<Service, Stopwatch> entry : startupTimers.entrySet()) {\n          Service service = entry.getKey();\n          Stopwatch stopWatch = entry.getValue();\n          if (!stopWatch.isRunning() && !(service instanceof NoOpService)) {\n            loadTimes.add(Maps.immutableEntry(service, stopWatch.elapsed(MILLISECONDS)));\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      Collections.sort(loadTimes, Ordering.natural()\n          .onResultOf(new Function<Entry<Service, Long>, Long>() {\n            @Override public Long apply(Map.Entry<Service, Long> input) {\n              return input.getValue();\n            }\n          }));\n      return ImmutableMap.copyOf(loadTimes);\n    }\n\n    /**\n     * Updates the state with the given service transition.\n     *\n     * <p>This method performs the main logic of ServiceManager in the following steps.\n     * <ol>\n     *      <li>Update the {@link #servicesByState()}\n     *      <li>Update the {@link #startupTimers}\n     *      <li>Based on the new state queue listeners to run\n     *      <li>Run the listeners (outside of the lock)\n     * </ol>\n     */\n    void transitionService(final Service service, State from, State to) {\n      checkNotNull(service);\n      checkArgument(from != to);\n      monitor.enter();\n      try {\n        transitioned = true;\n        if (!ready) {\n          return;\n        }\n        // Update state.\n        checkState(servicesByState.remove(from, service),\n            \"Service %s not at the expected location in the state map %s\", service, from);\n        checkState(servicesByState.put(to, service),\n            \"Service %s in the state map unexpectedly at %s\", service, to);\n        // Update the timer\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          // This means the service was started by some means other than ServiceManager.startAsync\n          stopwatch = Stopwatch.createStarted();\n          startupTimers.put(service, stopwatch);\n        }\n        if (to.compareTo(RUNNING) >= 0 && stopwatch.isRunning()) {\n          // N.B. if we miss the STARTING event then we may never record a startup time.\n          stopwatch.stop();\n          if (!(service instanceof NoOpService)) {\n            logger.log(Level.FINE, \"Started {0} in {1}.\", new Object[] {service, stopwatch});\n          }\n        }\n        // Queue our listeners\n\n        // Did a service fail?\n        if (to == FAILED) {\n          fireFailedListeners(service);\n        }\n\n        if (states.count(RUNNING) == numberOfServices) {\n          // This means that the manager is currently healthy. N.B. If other threads call isHealthy\n          // they are not guaranteed to get 'true', because any service could fail right now.\n          fireHealthyListeners();\n        } else if (states.count(TERMINATED) + states.count(FAILED) == numberOfServices) {\n          fireStoppedListeners();\n        }\n      } finally {\n        monitor.leave();\n        // Run our executors outside of the lock\n        executeListeners();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireStoppedListeners() {\n      STOPPED_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireHealthyListeners() {\n      HEALTHY_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireFailedListeners(final Service service) {\n      new Callback<Listener>(\"failed({service=\" + service + \"})\") {\n        @Override void call(Listener listener) {\n          listener.failure(service);\n        }\n      }.enqueueOn(listeners);\n    }\n\n    /** Attempts to execute all the listeners in {@link #listeners}. */\n    void executeListeners() {\n      checkState(!monitor.isOccupiedByCurrentThread(),\n          \"It is incorrect to execute listeners with the monitor held.\");\n      // iterate by index to avoid concurrent modification exceptions\n      for (int i = 0; i < listeners.size(); i++) {\n        listeners.get(i).execute();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void checkHealthy() {\n      if (states.count(RUNNING) != numberOfServices) {\n        IllegalStateException exception = new IllegalStateException(\n            \"Expected to be healthy after starting. The following services are not running: \"\n                + Multimaps.filterKeys(servicesByState, not(equalTo(RUNNING))));\n        throw exception;\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} that wraps another service and times how long it takes for it to start and\n   * also calls the {@link ServiceManagerState#transitionService(Service, State, State)},\n   * to record the state transitions.\n   */\n  private static final class ServiceListener extends Service.Listener {\n    final Service service;\n    // We store the state in a weak reference to ensure that if something went wrong while\n    // constructing the ServiceManager we don't pointlessly keep updating the state.\n    final WeakReference<ServiceManagerState> state;\n\n    ServiceListener(Service service, WeakReference<ServiceManagerState> state) {\n      this.service = service;\n      this.state = state;\n    }\n\n    @Override public void starting() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, NEW, STARTING);\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Starting {0}.\", service);\n        }\n      }\n    }\n\n    @Override public void running() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, STARTING, RUNNING);\n      }\n    }\n\n    @Override public void stopping(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, from, STOPPING);\n      }\n    }\n\n    @Override public void terminated(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Service {0} has terminated. Previous state was: {1}\",\n              new Object[] {service, from});\n        }\n        state.transitionService(service, from, TERMINATED);\n      }\n    }\n\n    @Override public void failed(State from, Throwable failure) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        // Log before the transition, so that if the process exits in response to server failure,\n        // there is a higher likelihood that the cause will be in the logs.\n        if (!(service instanceof NoOpService) ) {\n          logger.log(Level.SEVERE, \"Service \" + service + \" has failed in the \" + from + \" state.\",\n              failure);\n        }\n        state.transitionService(service, from, FAILED);\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} instance that does nothing.  This is only useful as a placeholder to\n   * ensure that the {@link ServiceManager} functions properly even when it is managing no services.\n   *\n   * <p>The use of this class is considered an implementation detail of ServiceManager and as such\n   * it is excluded from {@link #servicesByState}, {@link #startupTimes}, {@link #toString} and all\n   * logging statements.\n   */\n  private static final class NoOpService extends AbstractService {\n    @Override protected void doStart() { notifyStarted(); }\n    @Override protected void doStop() { notifyStopped(); }\n  }\n\n  /** This is never thrown but only used for logging. */\n  private static final class EmptyServiceManagerWarning extends Throwable {}\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53085277,"label":true,"oracleId":1458,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"ServiceManager","javadocTag":"@return Map of services and their corresponding startup time in millis, the map entries will be\n    ordered by startup time.","methodJavadoc":"    /**\n   * Returns the service load times. This value will only return startup times for services that\n   * have finished starting.\n   *\n   * @return Map of services and their corresponding startup time in millis, the map entries will be\n   *     ordered by startup time.\n   */","methodSourceCode":"public ImmutableMap<Service, Long> startupTimes(){\n    return state.startupTimes();\n}","classJavadoc":"/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */","classSourceCode":"/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Predicates.equalTo;\nimport static com.google.common.base.Predicates.in;\nimport static com.google.common.base.Predicates.instanceOf;\nimport static com.google.common.base.Predicates.not;\nimport static com.google.common.util.concurrent.MoreExecutors.directExecutor;\nimport static com.google.common.util.concurrent.Service.State.FAILED;\nimport static com.google.common.util.concurrent.Service.State.NEW;\nimport static com.google.common.util.concurrent.Service.State.RUNNING;\nimport static com.google.common.util.concurrent.Service.State.STARTING;\nimport static com.google.common.util.concurrent.Service.State.STOPPING;\nimport static com.google.common.util.concurrent.Service.State.TERMINATED;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.base.Function;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Stopwatch;\nimport com.google.common.collect.Collections2;\nimport com.google.common.collect.ImmutableCollection;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableMultimap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSetMultimap;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.MultimapBuilder;\nimport com.google.common.collect.Multimaps;\nimport com.google.common.collect.Multiset;\nimport com.google.common.collect.Ordering;\nimport com.google.common.collect.SetMultimap;\nimport com.google.common.util.concurrent.ListenerCallQueue.Callback;\nimport com.google.common.util.concurrent.Service.State;\nimport com.google.j2objc.annotations.WeakOuter;\n\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */\n@Beta\npublic final class ServiceManager {\n  private static final Logger logger = Logger.getLogger(ServiceManager.class.getName());\n  private static final Callback<Listener> HEALTHY_CALLBACK = new Callback<Listener>(\"healthy()\") {\n    @Override void call(Listener listener) {\n      listener.healthy();\n    }\n  };\n  private static final Callback<Listener> STOPPED_CALLBACK = new Callback<Listener>(\"stopped()\") {\n    @Override void call(Listener listener) {\n      listener.stopped();\n    }\n  };\n\n  /**\n   * A listener for the aggregate state changes of the services that are under management. Users\n   * that need to listen to more fine-grained events (such as when each particular {@linkplain\n   * Service service} starts, or terminates), should attach {@linkplain Service.Listener service\n   * listeners} to each individual service.\n   *\n   * @author Luke Sandberg\n   * @since 15.0 (present as an interface in 14.0)\n   */\n  @Beta  // Should come out of Beta when ServiceManager does\n  public abstract static class Listener {\n    /**\n     * Called when the service initially becomes healthy.\n     *\n     * <p>This will be called at most once after all the services have entered the\n     * {@linkplain State#RUNNING running} state. If any services fail during start up or\n     * {@linkplain State#FAILED fail}/{@linkplain State#TERMINATED terminate} before all other\n     * services have started {@linkplain State#RUNNING running} then this method will not be called.\n     */\n    public void healthy() {}\n\n    /**\n     * Called when the all of the component services have reached a terminal state, either\n     * {@linkplain State#TERMINATED terminated} or {@linkplain State#FAILED failed}.\n     */\n    public void stopped() {}\n\n    /**\n     * Called when a component service has {@linkplain State#FAILED failed}.\n     *\n     * @param service The service that failed.\n     */\n    public void failure(Service service) {}\n  }\n\n  /**\n   * An encapsulation of all of the state that is accessed by the {@linkplain ServiceListener\n   * service listeners}.  This is extracted into its own object so that {@link ServiceListener}\n   * could be made {@code static} and its instances can be safely constructed and added in the\n   * {@link ServiceManager} constructor without having to close over the partially constructed\n   * {@link ServiceManager} instance (i.e. avoid leaking a pointer to {@code this}).\n   */\n  private final ServiceManagerState state;\n  private final ImmutableList<Service> services;\n\n  /**\n   * Constructs a new instance for managing the given services.\n   *\n   * @param services The services to manage\n   *\n   * @throws IllegalArgumentException if not all services are {@linkplain State#NEW new} or if there\n   * are any duplicate services.\n   */\n  public ServiceManager(Iterable<? extends Service> services) {\n    ImmutableList<Service> copy = ImmutableList.copyOf(services);\n    if (copy.isEmpty()) {\n      // Having no services causes the manager to behave strangely. Notably, listeners are never\n      // fired.  To avoid this we substitute a placeholder service.\n      logger.log(Level.WARNING,\n          \"ServiceManager configured with no services.  Is your application configured properly?\",\n          new EmptyServiceManagerWarning());\n      copy = ImmutableList.<Service>of(new NoOpService());\n    }\n    this.state = new ServiceManagerState(copy);\n    this.services = copy;\n    WeakReference<ServiceManagerState> stateReference =\n        new WeakReference<ServiceManagerState>(state);\n    for (Service service : copy) {\n      service.addListener(new ServiceListener(service, stateReference), directExecutor());\n      // We check the state after adding the listener as a way to ensure that our listener was added\n      // to a NEW service.\n      checkArgument(service.state() == NEW, \"Can only manage NEW services, %s\", service);\n    }\n    // We have installed all of our listeners and after this point any state transition should be\n    // correct.\n    this.state.markReady();\n  }\n\n  /**\n   * Registers a {@link Listener} to be {@linkplain Executor#execute executed} on the given\n   * executor. The listener will not have previous state changes replayed, so it is\n   * suggested that listeners are added before any of the managed services are\n   * {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged. Any exception thrown\n   * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException}) will be caught and\n   * logged.\n   *\n   * <p> For fast, lightweight listeners that would be safe to execute in any thread, consider\n   * calling {@link #addListener(Listener)}.\n   *\n   * @param listener the listener to run when the manager changes state\n   * @param executor the executor in which the listeners callback methods will be run.\n   */\n  public void addListener(Listener listener, Executor executor) {\n    state.addListener(listener, executor);\n  }\n\n  /**\n   * Registers a {@link Listener} to be run when this {@link ServiceManager} changes state. The\n   * listener will not have previous state changes replayed, so it is suggested that listeners are\n   * added before any of the managed services are {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged.\n   *\n   * @param listener the listener to run when the manager changes state\n   */\n  public void addListener(Listener listener) {\n    state.addListener(listener, directExecutor());\n  }\n\n  /**\n   * Initiates service {@linkplain Service#startAsync startup} on all the services being managed.\n   * It is only valid to call this method if all of the services are {@linkplain State#NEW new}.\n   *\n   * @return this\n   * @throws IllegalStateException if any of the Services are not {@link State#NEW new} when the\n   *     method is called.\n   */\n  public ServiceManager startAsync() {\n    for (Service service : services) {\n      State state = service.state();\n      checkState(state == NEW, \"Service %s is %s, cannot start it.\", service, state);\n    }\n    for (Service service : services) {\n      try {\n        state.tryStartTiming(service);\n        service.startAsync();\n      } catch (IllegalStateException e) {\n        // This can happen if the service has already been started or stopped (e.g. by another\n        // service or listener). Our contract says it is safe to call this method if\n        // all services were NEW when it was called, and this has already been verified above, so we\n        // don't propagate the exception.\n        logger.log(Level.WARNING, \"Unable to start Service \" + service, e);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy}.  The manager\n   * will become healthy after all the component services have reached the {@linkplain State#RUNNING\n   * running} state.\n   *\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy() {\n    state.awaitHealthy();\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy} for no more\n   * than the given time.  The manager will become healthy after all the component services have\n   * reached the {@linkplain State#RUNNING running} state.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have finished starting within the deadline\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitHealthy(timeout, unit);\n  }\n\n  /**\n   * Initiates service {@linkplain Service#stopAsync shutdown} if necessary on all the services\n   * being managed.\n   *\n   * @return this\n   */\n  public ServiceManager stopAsync() {\n    for (Service service : services) {\n      service.stopAsync();\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state. After this method returns all\n   * services will either be {@linkplain Service.State#TERMINATED terminated} or {@linkplain\n   * Service.State#FAILED failed}.\n   */\n  public void awaitStopped() {\n    state.awaitStopped();\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state for no more than the given time. After\n   * this method returns all services will either be {@linkplain Service.State#TERMINATED\n   * terminated} or {@linkplain Service.State#FAILED failed}.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have stopped within the deadline\n   */\n  public void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitStopped(timeout, unit);\n  }\n\n  /**\n   * Returns true if all services are currently in the {@linkplain State#RUNNING running} state.\n   *\n   * <p>Users who want more detailed information should use the {@link #servicesByState} method to\n   * get detailed information about which services are not running.\n   */\n  public boolean isHealthy() {\n    for (Service service : services) {\n      if (!service.isRunning()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Provides a snapshot of the current state of all the services under management.\n   *\n   * <p>N.B. This snapshot is guaranteed to be consistent, i.e. the set of states returned will\n   * correspond to a point in time view of the services.\n   */\n  public ImmutableMultimap<State, Service> servicesByState() {\n    return state.servicesByState();\n  }\n\n  /**\n   * Returns the service load times. This value will only return startup times for services that\n   * have finished starting.\n   *\n   * @return Map of services and their corresponding startup time in millis, the map entries will be\n   *     ordered by startup time.\n   */\n  public ImmutableMap<Service, Long> startupTimes() {\n    return state.startupTimes();\n  }\n\n  @Override public String toString() {\n    return MoreObjects.toStringHelper(ServiceManager.class)\n        .add(\"services\", Collections2.filter(services, not(instanceOf(NoOpService.class))))\n        .toString();\n  }\n\n  /**\n   * An encapsulation of all the mutable state of the {@link ServiceManager} that needs to be\n   * accessed by instances of {@link ServiceListener}.\n   */\n  private static final class ServiceManagerState {\n    final Monitor monitor = new Monitor();\n\n    @GuardedBy(\"monitor\")\n    final SetMultimap<State, Service> servicesByState =\n        MultimapBuilder.enumKeys(State.class).linkedHashSetValues().build();\n\n    @GuardedBy(\"monitor\")\n    final Multiset<State> states = servicesByState.keys();\n\n    @GuardedBy(\"monitor\")\n    final Map<Service, Stopwatch> startupTimers = Maps.newIdentityHashMap();\n\n    /**\n     * These two booleans are used to mark the state as ready to start.\n     * {@link #ready}: is set by {@link #markReady} to indicate that all listeners have been\n     *     correctly installed\n     * {@link #transitioned}: is set by {@link #transitionService} to indicate that some transition\n     *     has been performed.\n     *\n     * <p>Together, they allow us to enforce that all services have their listeners installed prior\n     * to any service performing a transition, then we can fail in the ServiceManager constructor\n     * rather than in a Service.Listener callback.\n     */\n    @GuardedBy(\"monitor\")\n    boolean ready;\n\n    @GuardedBy(\"monitor\")\n    boolean transitioned;\n\n    final int numberOfServices;\n\n    /**\n     * Controls how long to wait for all the services to either become healthy or reach a\n     * state from which it is guaranteed that it can never become healthy.\n     */\n    final Monitor.Guard awaitHealthGuard = new AwaitHealthGuard();\n\n    @WeakOuter\n    final class AwaitHealthGuard extends Monitor.Guard {\n      AwaitHealthGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        // All services have started or some service has terminated/failed.\n        return states.count(RUNNING) == numberOfServices\n            || states.contains(STOPPING)\n            || states.contains(TERMINATED)\n            || states.contains(FAILED);\n      }\n    }\n\n    /**\n     * Controls how long to wait for all services to reach a terminal state.\n     */\n    final Monitor.Guard stoppedGuard = new StoppedGuard();\n\n    @WeakOuter\n    final class StoppedGuard extends Monitor.Guard {\n      StoppedGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        return states.count(TERMINATED) + states.count(FAILED) == numberOfServices;\n      }\n    }\n\n    /** The listeners to notify during a state transition. */\n    @GuardedBy(\"monitor\")\n    final List<ListenerCallQueue<Listener>> listeners =\n        Collections.synchronizedList(new ArrayList<ListenerCallQueue<Listener>>());\n\n    /**\n     * It is implicitly assumed that all the services are NEW and that they will all remain NEW\n     * until all the Listeners are installed and {@link #markReady()} is called.  It is our caller's\n     * responsibility to only call {@link #markReady()} if all services were new at the time this\n     * method was called and when all the listeners were installed.\n     */\n    ServiceManagerState(ImmutableCollection<Service> services) {\n      this.numberOfServices = services.size();\n      servicesByState.putAll(NEW, services);\n    }\n\n    /**\n     * Attempts to start the timer immediately prior to the service being started via\n     * {@link Service#startAsync()}.\n     */\n    void tryStartTiming(Service service) {\n      monitor.enter();\n      try {\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          startupTimers.put(service, Stopwatch.createStarted());\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    /**\n     * Marks the {@link State} as ready to receive transitions. Returns true if no transitions have\n     * been observed yet.\n     */\n    void markReady() {\n      monitor.enter();\n      try {\n        if (!transitioned) {\n          // nothing has transitioned since construction, good.\n          ready = true;\n        } else {\n          // This should be an extremely rare race condition.\n          List<Service> servicesInBadStates = Lists.newArrayList();\n          for (Service service : servicesByState().values()) {\n            if (service.state() != NEW) {\n              servicesInBadStates.add(service);\n            }\n          }\n          throw new IllegalArgumentException(\"Services started transitioning asynchronously before \"\n              + \"the ServiceManager was constructed: \" + servicesInBadStates);\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void addListener(Listener listener, Executor executor) {\n      checkNotNull(listener, \"listener\");\n      checkNotNull(executor, \"executor\");\n      monitor.enter();\n      try {\n        // no point in adding a listener that will never be called\n        if (!stoppedGuard.isSatisfied()) {\n          listeners.add(new ListenerCallQueue<Listener>(listener, executor));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy() {\n      monitor.enterWhenUninterruptibly(awaitHealthGuard);\n      try {\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(awaitHealthGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to become healthy. The \"\n              + \"following services have not started: \"\n              + Multimaps.filterKeys(servicesByState, in(ImmutableSet.of(NEW, STARTING))));\n        }\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitStopped() {\n      monitor.enterWhenUninterruptibly(stoppedGuard);\n      monitor.leave();\n    }\n\n    void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(stoppedGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to stop. The following \"\n              + \"services have not stopped: \"\n              + Multimaps.filterKeys(servicesByState,\n                  not(in(EnumSet.of(TERMINATED, FAILED)))));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    ImmutableMultimap<State, Service> servicesByState() {\n      ImmutableSetMultimap.Builder<State, Service> builder = ImmutableSetMultimap.builder();\n      monitor.enter();\n      try {\n        for (Entry<State, Service> entry : servicesByState.entries()) {\n          if (!(entry.getValue() instanceof NoOpService)) {\n            builder.put(entry);\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      return builder.build();\n    }\n\n    ImmutableMap<Service, Long> startupTimes() {\n      List<Entry<Service, Long>> loadTimes;\n      monitor.enter();\n      try {\n        loadTimes = Lists.newArrayListWithCapacity(startupTimers.size());\n        // N.B. There will only be an entry in the map if the service has started\n        for (Entry<Service, Stopwatch> entry : startupTimers.entrySet()) {\n          Service service = entry.getKey();\n          Stopwatch stopWatch = entry.getValue();\n          if (!stopWatch.isRunning() && !(service instanceof NoOpService)) {\n            loadTimes.add(Maps.immutableEntry(service, stopWatch.elapsed(MILLISECONDS)));\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      Collections.sort(loadTimes, Ordering.natural()\n          .onResultOf(new Function<Entry<Service, Long>, Long>() {\n            @Override public Long apply(Map.Entry<Service, Long> input) {\n              return input.getValue();\n            }\n          }));\n      return ImmutableMap.copyOf(loadTimes);\n    }\n\n    /**\n     * Updates the state with the given service transition.\n     *\n     * <p>This method performs the main logic of ServiceManager in the following steps.\n     * <ol>\n     *      <li>Update the {@link #servicesByState()}\n     *      <li>Update the {@link #startupTimers}\n     *      <li>Based on the new state queue listeners to run\n     *      <li>Run the listeners (outside of the lock)\n     * </ol>\n     */\n    void transitionService(final Service service, State from, State to) {\n      checkNotNull(service);\n      checkArgument(from != to);\n      monitor.enter();\n      try {\n        transitioned = true;\n        if (!ready) {\n          return;\n        }\n        // Update state.\n        checkState(servicesByState.remove(from, service),\n            \"Service %s not at the expected location in the state map %s\", service, from);\n        checkState(servicesByState.put(to, service),\n            \"Service %s in the state map unexpectedly at %s\", service, to);\n        // Update the timer\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          // This means the service was started by some means other than ServiceManager.startAsync\n          stopwatch = Stopwatch.createStarted();\n          startupTimers.put(service, stopwatch);\n        }\n        if (to.compareTo(RUNNING) >= 0 && stopwatch.isRunning()) {\n          // N.B. if we miss the STARTING event then we may never record a startup time.\n          stopwatch.stop();\n          if (!(service instanceof NoOpService)) {\n            logger.log(Level.FINE, \"Started {0} in {1}.\", new Object[] {service, stopwatch});\n          }\n        }\n        // Queue our listeners\n\n        // Did a service fail?\n        if (to == FAILED) {\n          fireFailedListeners(service);\n        }\n\n        if (states.count(RUNNING) == numberOfServices) {\n          // This means that the manager is currently healthy. N.B. If other threads call isHealthy\n          // they are not guaranteed to get 'true', because any service could fail right now.\n          fireHealthyListeners();\n        } else if (states.count(TERMINATED) + states.count(FAILED) == numberOfServices) {\n          fireStoppedListeners();\n        }\n      } finally {\n        monitor.leave();\n        // Run our executors outside of the lock\n        executeListeners();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireStoppedListeners() {\n      STOPPED_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireHealthyListeners() {\n      HEALTHY_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireFailedListeners(final Service service) {\n      new Callback<Listener>(\"failed({service=\" + service + \"})\") {\n        @Override void call(Listener listener) {\n          listener.failure(service);\n        }\n      }.enqueueOn(listeners);\n    }\n\n    /** Attempts to execute all the listeners in {@link #listeners}. */\n    void executeListeners() {\n      checkState(!monitor.isOccupiedByCurrentThread(),\n          \"It is incorrect to execute listeners with the monitor held.\");\n      // iterate by index to avoid concurrent modification exceptions\n      for (int i = 0; i < listeners.size(); i++) {\n        listeners.get(i).execute();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void checkHealthy() {\n      if (states.count(RUNNING) != numberOfServices) {\n        IllegalStateException exception = new IllegalStateException(\n            \"Expected to be healthy after starting. The following services are not running: \"\n                + Multimaps.filterKeys(servicesByState, not(equalTo(RUNNING))));\n        throw exception;\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} that wraps another service and times how long it takes for it to start and\n   * also calls the {@link ServiceManagerState#transitionService(Service, State, State)},\n   * to record the state transitions.\n   */\n  private static final class ServiceListener extends Service.Listener {\n    final Service service;\n    // We store the state in a weak reference to ensure that if something went wrong while\n    // constructing the ServiceManager we don't pointlessly keep updating the state.\n    final WeakReference<ServiceManagerState> state;\n\n    ServiceListener(Service service, WeakReference<ServiceManagerState> state) {\n      this.service = service;\n      this.state = state;\n    }\n\n    @Override public void starting() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, NEW, STARTING);\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Starting {0}.\", service);\n        }\n      }\n    }\n\n    @Override public void running() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, STARTING, RUNNING);\n      }\n    }\n\n    @Override public void stopping(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, from, STOPPING);\n      }\n    }\n\n    @Override public void terminated(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Service {0} has terminated. Previous state was: {1}\",\n              new Object[] {service, from});\n        }\n        state.transitionService(service, from, TERMINATED);\n      }\n    }\n\n    @Override public void failed(State from, Throwable failure) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        // Log before the transition, so that if the process exits in response to server failure,\n        // there is a higher likelihood that the cause will be in the logs.\n        if (!(service instanceof NoOpService) ) {\n          logger.log(Level.SEVERE, \"Service \" + service + \" has failed in the \" + from + \" state.\",\n              failure);\n        }\n        state.transitionService(service, from, FAILED);\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} instance that does nothing.  This is only useful as a placeholder to\n   * ensure that the {@link ServiceManager} functions properly even when it is managing no services.\n   *\n   * <p>The use of this class is considered an implementation detail of ServiceManager and as such\n   * it is excluded from {@link #servicesByState}, {@link #startupTimes}, {@link #toString} and all\n   * logging statements.\n   */\n  private static final class NoOpService extends AbstractService {\n    @Override protected void doStart() { notifyStarted(); }\n    @Override protected void doStop() { notifyStopped(); }\n  }\n\n  /** This is never thrown but only used for logging. */\n  private static final class EmptyServiceManagerWarning extends Throwable {}\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53085734,"label":true,"oracleId":1459,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"ServiceManager","javadocTag":"@param services The services to manage","methodJavadoc":"    /**\n   * Constructs a new instance for managing the given services.\n   *\n   * @param services The services to manage\n   *\n   * @throws IllegalArgumentException if not all services are {@linkplain State#NEW new} or if there\n   * are any duplicate services.\n   */","methodSourceCode":"public ServiceManager(Iterable<? extends Service> services){\n    ImmutableList<Service> copy = ImmutableList.copyOf(services);\n    if (copy.isEmpty()) {\n        // Having no services causes the manager to behave strangely. Notably, listeners are never\n        // fired.  To avoid this we substitute a placeholder service.\n        logger.log(Level.WARNING, \"ServiceManager configured with no services.  Is your application configured properly?\", new EmptyServiceManagerWarning());\n        copy = ImmutableList.<Service>of(new NoOpService());\n    }\n    this.state = new ServiceManagerState(copy);\n    this.services = copy;\n    WeakReference<ServiceManagerState> stateReference = new WeakReference<ServiceManagerState>(state);\n    for (Service service : copy) {\n        service.addListener(new ServiceListener(service, stateReference), directExecutor());\n        // We check the state after adding the listener as a way to ensure that our listener was added\n        // to a NEW service.\n        checkArgument(service.state() == NEW, \"Can only manage NEW services, %s\", service);\n    }\n    // We have installed all of our listeners and after this point any state transition should be\n    // correct.\n    this.state.markReady();\n}","classJavadoc":"/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */","classSourceCode":"/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Predicates.equalTo;\nimport static com.google.common.base.Predicates.in;\nimport static com.google.common.base.Predicates.instanceOf;\nimport static com.google.common.base.Predicates.not;\nimport static com.google.common.util.concurrent.MoreExecutors.directExecutor;\nimport static com.google.common.util.concurrent.Service.State.FAILED;\nimport static com.google.common.util.concurrent.Service.State.NEW;\nimport static com.google.common.util.concurrent.Service.State.RUNNING;\nimport static com.google.common.util.concurrent.Service.State.STARTING;\nimport static com.google.common.util.concurrent.Service.State.STOPPING;\nimport static com.google.common.util.concurrent.Service.State.TERMINATED;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.base.Function;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Stopwatch;\nimport com.google.common.collect.Collections2;\nimport com.google.common.collect.ImmutableCollection;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableMultimap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSetMultimap;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.MultimapBuilder;\nimport com.google.common.collect.Multimaps;\nimport com.google.common.collect.Multiset;\nimport com.google.common.collect.Ordering;\nimport com.google.common.collect.SetMultimap;\nimport com.google.common.util.concurrent.ListenerCallQueue.Callback;\nimport com.google.common.util.concurrent.Service.State;\nimport com.google.j2objc.annotations.WeakOuter;\n\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */\n@Beta\npublic final class ServiceManager {\n  private static final Logger logger = Logger.getLogger(ServiceManager.class.getName());\n  private static final Callback<Listener> HEALTHY_CALLBACK = new Callback<Listener>(\"healthy()\") {\n    @Override void call(Listener listener) {\n      listener.healthy();\n    }\n  };\n  private static final Callback<Listener> STOPPED_CALLBACK = new Callback<Listener>(\"stopped()\") {\n    @Override void call(Listener listener) {\n      listener.stopped();\n    }\n  };\n\n  /**\n   * A listener for the aggregate state changes of the services that are under management. Users\n   * that need to listen to more fine-grained events (such as when each particular {@linkplain\n   * Service service} starts, or terminates), should attach {@linkplain Service.Listener service\n   * listeners} to each individual service.\n   *\n   * @author Luke Sandberg\n   * @since 15.0 (present as an interface in 14.0)\n   */\n  @Beta  // Should come out of Beta when ServiceManager does\n  public abstract static class Listener {\n    /**\n     * Called when the service initially becomes healthy.\n     *\n     * <p>This will be called at most once after all the services have entered the\n     * {@linkplain State#RUNNING running} state. If any services fail during start up or\n     * {@linkplain State#FAILED fail}/{@linkplain State#TERMINATED terminate} before all other\n     * services have started {@linkplain State#RUNNING running} then this method will not be called.\n     */\n    public void healthy() {}\n\n    /**\n     * Called when the all of the component services have reached a terminal state, either\n     * {@linkplain State#TERMINATED terminated} or {@linkplain State#FAILED failed}.\n     */\n    public void stopped() {}\n\n    /**\n     * Called when a component service has {@linkplain State#FAILED failed}.\n     *\n     * @param service The service that failed.\n     */\n    public void failure(Service service) {}\n  }\n\n  /**\n   * An encapsulation of all of the state that is accessed by the {@linkplain ServiceListener\n   * service listeners}.  This is extracted into its own object so that {@link ServiceListener}\n   * could be made {@code static} and its instances can be safely constructed and added in the\n   * {@link ServiceManager} constructor without having to close over the partially constructed\n   * {@link ServiceManager} instance (i.e. avoid leaking a pointer to {@code this}).\n   */\n  private final ServiceManagerState state;\n  private final ImmutableList<Service> services;\n\n  /**\n   * Constructs a new instance for managing the given services.\n   *\n   * @param services The services to manage\n   *\n   * @throws IllegalArgumentException if not all services are {@linkplain State#NEW new} or if there\n   * are any duplicate services.\n   */\n  public ServiceManager(Iterable<? extends Service> services) {\n    ImmutableList<Service> copy = ImmutableList.copyOf(services);\n    if (copy.isEmpty()) {\n      // Having no services causes the manager to behave strangely. Notably, listeners are never\n      // fired.  To avoid this we substitute a placeholder service.\n      logger.log(Level.WARNING,\n          \"ServiceManager configured with no services.  Is your application configured properly?\",\n          new EmptyServiceManagerWarning());\n      copy = ImmutableList.<Service>of(new NoOpService());\n    }\n    this.state = new ServiceManagerState(copy);\n    this.services = copy;\n    WeakReference<ServiceManagerState> stateReference =\n        new WeakReference<ServiceManagerState>(state);\n    for (Service service : copy) {\n      service.addListener(new ServiceListener(service, stateReference), directExecutor());\n      // We check the state after adding the listener as a way to ensure that our listener was added\n      // to a NEW service.\n      checkArgument(service.state() == NEW, \"Can only manage NEW services, %s\", service);\n    }\n    // We have installed all of our listeners and after this point any state transition should be\n    // correct.\n    this.state.markReady();\n  }\n\n  /**\n   * Registers a {@link Listener} to be {@linkplain Executor#execute executed} on the given\n   * executor. The listener will not have previous state changes replayed, so it is\n   * suggested that listeners are added before any of the managed services are\n   * {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged. Any exception thrown\n   * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException}) will be caught and\n   * logged.\n   *\n   * <p> For fast, lightweight listeners that would be safe to execute in any thread, consider\n   * calling {@link #addListener(Listener)}.\n   *\n   * @param listener the listener to run when the manager changes state\n   * @param executor the executor in which the listeners callback methods will be run.\n   */\n  public void addListener(Listener listener, Executor executor) {\n    state.addListener(listener, executor);\n  }\n\n  /**\n   * Registers a {@link Listener} to be run when this {@link ServiceManager} changes state. The\n   * listener will not have previous state changes replayed, so it is suggested that listeners are\n   * added before any of the managed services are {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged.\n   *\n   * @param listener the listener to run when the manager changes state\n   */\n  public void addListener(Listener listener) {\n    state.addListener(listener, directExecutor());\n  }\n\n  /**\n   * Initiates service {@linkplain Service#startAsync startup} on all the services being managed.\n   * It is only valid to call this method if all of the services are {@linkplain State#NEW new}.\n   *\n   * @return this\n   * @throws IllegalStateException if any of the Services are not {@link State#NEW new} when the\n   *     method is called.\n   */\n  public ServiceManager startAsync() {\n    for (Service service : services) {\n      State state = service.state();\n      checkState(state == NEW, \"Service %s is %s, cannot start it.\", service, state);\n    }\n    for (Service service : services) {\n      try {\n        state.tryStartTiming(service);\n        service.startAsync();\n      } catch (IllegalStateException e) {\n        // This can happen if the service has already been started or stopped (e.g. by another\n        // service or listener). Our contract says it is safe to call this method if\n        // all services were NEW when it was called, and this has already been verified above, so we\n        // don't propagate the exception.\n        logger.log(Level.WARNING, \"Unable to start Service \" + service, e);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy}.  The manager\n   * will become healthy after all the component services have reached the {@linkplain State#RUNNING\n   * running} state.\n   *\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy() {\n    state.awaitHealthy();\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy} for no more\n   * than the given time.  The manager will become healthy after all the component services have\n   * reached the {@linkplain State#RUNNING running} state.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have finished starting within the deadline\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitHealthy(timeout, unit);\n  }\n\n  /**\n   * Initiates service {@linkplain Service#stopAsync shutdown} if necessary on all the services\n   * being managed.\n   *\n   * @return this\n   */\n  public ServiceManager stopAsync() {\n    for (Service service : services) {\n      service.stopAsync();\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state. After this method returns all\n   * services will either be {@linkplain Service.State#TERMINATED terminated} or {@linkplain\n   * Service.State#FAILED failed}.\n   */\n  public void awaitStopped() {\n    state.awaitStopped();\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state for no more than the given time. After\n   * this method returns all services will either be {@linkplain Service.State#TERMINATED\n   * terminated} or {@linkplain Service.State#FAILED failed}.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have stopped within the deadline\n   */\n  public void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitStopped(timeout, unit);\n  }\n\n  /**\n   * Returns true if all services are currently in the {@linkplain State#RUNNING running} state.\n   *\n   * <p>Users who want more detailed information should use the {@link #servicesByState} method to\n   * get detailed information about which services are not running.\n   */\n  public boolean isHealthy() {\n    for (Service service : services) {\n      if (!service.isRunning()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Provides a snapshot of the current state of all the services under management.\n   *\n   * <p>N.B. This snapshot is guaranteed to be consistent, i.e. the set of states returned will\n   * correspond to a point in time view of the services.\n   */\n  public ImmutableMultimap<State, Service> servicesByState() {\n    return state.servicesByState();\n  }\n\n  /**\n   * Returns the service load times. This value will only return startup times for services that\n   * have finished starting.\n   *\n   * @return Map of services and their corresponding startup time in millis, the map entries will be\n   *     ordered by startup time.\n   */\n  public ImmutableMap<Service, Long> startupTimes() {\n    return state.startupTimes();\n  }\n\n  @Override public String toString() {\n    return MoreObjects.toStringHelper(ServiceManager.class)\n        .add(\"services\", Collections2.filter(services, not(instanceOf(NoOpService.class))))\n        .toString();\n  }\n\n  /**\n   * An encapsulation of all the mutable state of the {@link ServiceManager} that needs to be\n   * accessed by instances of {@link ServiceListener}.\n   */\n  private static final class ServiceManagerState {\n    final Monitor monitor = new Monitor();\n\n    @GuardedBy(\"monitor\")\n    final SetMultimap<State, Service> servicesByState =\n        MultimapBuilder.enumKeys(State.class).linkedHashSetValues().build();\n\n    @GuardedBy(\"monitor\")\n    final Multiset<State> states = servicesByState.keys();\n\n    @GuardedBy(\"monitor\")\n    final Map<Service, Stopwatch> startupTimers = Maps.newIdentityHashMap();\n\n    /**\n     * These two booleans are used to mark the state as ready to start.\n     * {@link #ready}: is set by {@link #markReady} to indicate that all listeners have been\n     *     correctly installed\n     * {@link #transitioned}: is set by {@link #transitionService} to indicate that some transition\n     *     has been performed.\n     *\n     * <p>Together, they allow us to enforce that all services have their listeners installed prior\n     * to any service performing a transition, then we can fail in the ServiceManager constructor\n     * rather than in a Service.Listener callback.\n     */\n    @GuardedBy(\"monitor\")\n    boolean ready;\n\n    @GuardedBy(\"monitor\")\n    boolean transitioned;\n\n    final int numberOfServices;\n\n    /**\n     * Controls how long to wait for all the services to either become healthy or reach a\n     * state from which it is guaranteed that it can never become healthy.\n     */\n    final Monitor.Guard awaitHealthGuard = new AwaitHealthGuard();\n\n    @WeakOuter\n    final class AwaitHealthGuard extends Monitor.Guard {\n      AwaitHealthGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        // All services have started or some service has terminated/failed.\n        return states.count(RUNNING) == numberOfServices\n            || states.contains(STOPPING)\n            || states.contains(TERMINATED)\n            || states.contains(FAILED);\n      }\n    }\n\n    /**\n     * Controls how long to wait for all services to reach a terminal state.\n     */\n    final Monitor.Guard stoppedGuard = new StoppedGuard();\n\n    @WeakOuter\n    final class StoppedGuard extends Monitor.Guard {\n      StoppedGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        return states.count(TERMINATED) + states.count(FAILED) == numberOfServices;\n      }\n    }\n\n    /** The listeners to notify during a state transition. */\n    @GuardedBy(\"monitor\")\n    final List<ListenerCallQueue<Listener>> listeners =\n        Collections.synchronizedList(new ArrayList<ListenerCallQueue<Listener>>());\n\n    /**\n     * It is implicitly assumed that all the services are NEW and that they will all remain NEW\n     * until all the Listeners are installed and {@link #markReady()} is called.  It is our caller's\n     * responsibility to only call {@link #markReady()} if all services were new at the time this\n     * method was called and when all the listeners were installed.\n     */\n    ServiceManagerState(ImmutableCollection<Service> services) {\n      this.numberOfServices = services.size();\n      servicesByState.putAll(NEW, services);\n    }\n\n    /**\n     * Attempts to start the timer immediately prior to the service being started via\n     * {@link Service#startAsync()}.\n     */\n    void tryStartTiming(Service service) {\n      monitor.enter();\n      try {\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          startupTimers.put(service, Stopwatch.createStarted());\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    /**\n     * Marks the {@link State} as ready to receive transitions. Returns true if no transitions have\n     * been observed yet.\n     */\n    void markReady() {\n      monitor.enter();\n      try {\n        if (!transitioned) {\n          // nothing has transitioned since construction, good.\n          ready = true;\n        } else {\n          // This should be an extremely rare race condition.\n          List<Service> servicesInBadStates = Lists.newArrayList();\n          for (Service service : servicesByState().values()) {\n            if (service.state() != NEW) {\n              servicesInBadStates.add(service);\n            }\n          }\n          throw new IllegalArgumentException(\"Services started transitioning asynchronously before \"\n              + \"the ServiceManager was constructed: \" + servicesInBadStates);\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void addListener(Listener listener, Executor executor) {\n      checkNotNull(listener, \"listener\");\n      checkNotNull(executor, \"executor\");\n      monitor.enter();\n      try {\n        // no point in adding a listener that will never be called\n        if (!stoppedGuard.isSatisfied()) {\n          listeners.add(new ListenerCallQueue<Listener>(listener, executor));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy() {\n      monitor.enterWhenUninterruptibly(awaitHealthGuard);\n      try {\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(awaitHealthGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to become healthy. The \"\n              + \"following services have not started: \"\n              + Multimaps.filterKeys(servicesByState, in(ImmutableSet.of(NEW, STARTING))));\n        }\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitStopped() {\n      monitor.enterWhenUninterruptibly(stoppedGuard);\n      monitor.leave();\n    }\n\n    void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(stoppedGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to stop. The following \"\n              + \"services have not stopped: \"\n              + Multimaps.filterKeys(servicesByState,\n                  not(in(EnumSet.of(TERMINATED, FAILED)))));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    ImmutableMultimap<State, Service> servicesByState() {\n      ImmutableSetMultimap.Builder<State, Service> builder = ImmutableSetMultimap.builder();\n      monitor.enter();\n      try {\n        for (Entry<State, Service> entry : servicesByState.entries()) {\n          if (!(entry.getValue() instanceof NoOpService)) {\n            builder.put(entry);\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      return builder.build();\n    }\n\n    ImmutableMap<Service, Long> startupTimes() {\n      List<Entry<Service, Long>> loadTimes;\n      monitor.enter();\n      try {\n        loadTimes = Lists.newArrayListWithCapacity(startupTimers.size());\n        // N.B. There will only be an entry in the map if the service has started\n        for (Entry<Service, Stopwatch> entry : startupTimers.entrySet()) {\n          Service service = entry.getKey();\n          Stopwatch stopWatch = entry.getValue();\n          if (!stopWatch.isRunning() && !(service instanceof NoOpService)) {\n            loadTimes.add(Maps.immutableEntry(service, stopWatch.elapsed(MILLISECONDS)));\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      Collections.sort(loadTimes, Ordering.natural()\n          .onResultOf(new Function<Entry<Service, Long>, Long>() {\n            @Override public Long apply(Map.Entry<Service, Long> input) {\n              return input.getValue();\n            }\n          }));\n      return ImmutableMap.copyOf(loadTimes);\n    }\n\n    /**\n     * Updates the state with the given service transition.\n     *\n     * <p>This method performs the main logic of ServiceManager in the following steps.\n     * <ol>\n     *      <li>Update the {@link #servicesByState()}\n     *      <li>Update the {@link #startupTimers}\n     *      <li>Based on the new state queue listeners to run\n     *      <li>Run the listeners (outside of the lock)\n     * </ol>\n     */\n    void transitionService(final Service service, State from, State to) {\n      checkNotNull(service);\n      checkArgument(from != to);\n      monitor.enter();\n      try {\n        transitioned = true;\n        if (!ready) {\n          return;\n        }\n        // Update state.\n        checkState(servicesByState.remove(from, service),\n            \"Service %s not at the expected location in the state map %s\", service, from);\n        checkState(servicesByState.put(to, service),\n            \"Service %s in the state map unexpectedly at %s\", service, to);\n        // Update the timer\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          // This means the service was started by some means other than ServiceManager.startAsync\n          stopwatch = Stopwatch.createStarted();\n          startupTimers.put(service, stopwatch);\n        }\n        if (to.compareTo(RUNNING) >= 0 && stopwatch.isRunning()) {\n          // N.B. if we miss the STARTING event then we may never record a startup time.\n          stopwatch.stop();\n          if (!(service instanceof NoOpService)) {\n            logger.log(Level.FINE, \"Started {0} in {1}.\", new Object[] {service, stopwatch});\n          }\n        }\n        // Queue our listeners\n\n        // Did a service fail?\n        if (to == FAILED) {\n          fireFailedListeners(service);\n        }\n\n        if (states.count(RUNNING) == numberOfServices) {\n          // This means that the manager is currently healthy. N.B. If other threads call isHealthy\n          // they are not guaranteed to get 'true', because any service could fail right now.\n          fireHealthyListeners();\n        } else if (states.count(TERMINATED) + states.count(FAILED) == numberOfServices) {\n          fireStoppedListeners();\n        }\n      } finally {\n        monitor.leave();\n        // Run our executors outside of the lock\n        executeListeners();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireStoppedListeners() {\n      STOPPED_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireHealthyListeners() {\n      HEALTHY_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireFailedListeners(final Service service) {\n      new Callback<Listener>(\"failed({service=\" + service + \"})\") {\n        @Override void call(Listener listener) {\n          listener.failure(service);\n        }\n      }.enqueueOn(listeners);\n    }\n\n    /** Attempts to execute all the listeners in {@link #listeners}. */\n    void executeListeners() {\n      checkState(!monitor.isOccupiedByCurrentThread(),\n          \"It is incorrect to execute listeners with the monitor held.\");\n      // iterate by index to avoid concurrent modification exceptions\n      for (int i = 0; i < listeners.size(); i++) {\n        listeners.get(i).execute();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void checkHealthy() {\n      if (states.count(RUNNING) != numberOfServices) {\n        IllegalStateException exception = new IllegalStateException(\n            \"Expected to be healthy after starting. The following services are not running: \"\n                + Multimaps.filterKeys(servicesByState, not(equalTo(RUNNING))));\n        throw exception;\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} that wraps another service and times how long it takes for it to start and\n   * also calls the {@link ServiceManagerState#transitionService(Service, State, State)},\n   * to record the state transitions.\n   */\n  private static final class ServiceListener extends Service.Listener {\n    final Service service;\n    // We store the state in a weak reference to ensure that if something went wrong while\n    // constructing the ServiceManager we don't pointlessly keep updating the state.\n    final WeakReference<ServiceManagerState> state;\n\n    ServiceListener(Service service, WeakReference<ServiceManagerState> state) {\n      this.service = service;\n      this.state = state;\n    }\n\n    @Override public void starting() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, NEW, STARTING);\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Starting {0}.\", service);\n        }\n      }\n    }\n\n    @Override public void running() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, STARTING, RUNNING);\n      }\n    }\n\n    @Override public void stopping(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, from, STOPPING);\n      }\n    }\n\n    @Override public void terminated(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Service {0} has terminated. Previous state was: {1}\",\n              new Object[] {service, from});\n        }\n        state.transitionService(service, from, TERMINATED);\n      }\n    }\n\n    @Override public void failed(State from, Throwable failure) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        // Log before the transition, so that if the process exits in response to server failure,\n        // there is a higher likelihood that the cause will be in the logs.\n        if (!(service instanceof NoOpService) ) {\n          logger.log(Level.SEVERE, \"Service \" + service + \" has failed in the \" + from + \" state.\",\n              failure);\n        }\n        state.transitionService(service, from, FAILED);\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} instance that does nothing.  This is only useful as a placeholder to\n   * ensure that the {@link ServiceManager} functions properly even when it is managing no services.\n   *\n   * <p>The use of this class is considered an implementation detail of ServiceManager and as such\n   * it is excluded from {@link #servicesByState}, {@link #startupTimes}, {@link #toString} and all\n   * logging statements.\n   */\n  private static final class NoOpService extends AbstractService {\n    @Override protected void doStart() { notifyStarted(); }\n    @Override protected void doStop() { notifyStopped(); }\n  }\n\n  /** This is never thrown but only used for logging. */\n  private static final class EmptyServiceManagerWarning extends Throwable {}\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53086192,"label":true,"oracleId":1460,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"ServiceManager","javadocTag":"@throws IllegalArgumentException if not all services are {@linkplain State#NEW new} or if there\nare any duplicate services.","methodJavadoc":"    /**\n   * Constructs a new instance for managing the given services.\n   *\n   * @param services The services to manage\n   *\n   * @throws IllegalArgumentException if not all services are {@linkplain State#NEW new} or if there\n   * are any duplicate services.\n   */","methodSourceCode":"public ServiceManager(Iterable<? extends Service> services){\n    ImmutableList<Service> copy = ImmutableList.copyOf(services);\n    if (copy.isEmpty()) {\n        // Having no services causes the manager to behave strangely. Notably, listeners are never\n        // fired.  To avoid this we substitute a placeholder service.\n        logger.log(Level.WARNING, \"ServiceManager configured with no services.  Is your application configured properly?\", new EmptyServiceManagerWarning());\n        copy = ImmutableList.<Service>of(new NoOpService());\n    }\n    this.state = new ServiceManagerState(copy);\n    this.services = copy;\n    WeakReference<ServiceManagerState> stateReference = new WeakReference<ServiceManagerState>(state);\n    for (Service service : copy) {\n        service.addListener(new ServiceListener(service, stateReference), directExecutor());\n        // We check the state after adding the listener as a way to ensure that our listener was added\n        // to a NEW service.\n        checkArgument(service.state() == NEW, \"Can only manage NEW services, %s\", service);\n    }\n    // We have installed all of our listeners and after this point any state transition should be\n    // correct.\n    this.state.markReady();\n}","classJavadoc":"/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */","classSourceCode":"/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Predicates.equalTo;\nimport static com.google.common.base.Predicates.in;\nimport static com.google.common.base.Predicates.instanceOf;\nimport static com.google.common.base.Predicates.not;\nimport static com.google.common.util.concurrent.MoreExecutors.directExecutor;\nimport static com.google.common.util.concurrent.Service.State.FAILED;\nimport static com.google.common.util.concurrent.Service.State.NEW;\nimport static com.google.common.util.concurrent.Service.State.RUNNING;\nimport static com.google.common.util.concurrent.Service.State.STARTING;\nimport static com.google.common.util.concurrent.Service.State.STOPPING;\nimport static com.google.common.util.concurrent.Service.State.TERMINATED;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.base.Function;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Stopwatch;\nimport com.google.common.collect.Collections2;\nimport com.google.common.collect.ImmutableCollection;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableMultimap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSetMultimap;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.MultimapBuilder;\nimport com.google.common.collect.Multimaps;\nimport com.google.common.collect.Multiset;\nimport com.google.common.collect.Ordering;\nimport com.google.common.collect.SetMultimap;\nimport com.google.common.util.concurrent.ListenerCallQueue.Callback;\nimport com.google.common.util.concurrent.Service.State;\nimport com.google.j2objc.annotations.WeakOuter;\n\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * A manager for monitoring and controlling a set of {@linkplain Service services}. This class\n * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and\n * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.\n * Additionally, users can monitor state transitions with the {@linkplain Listener listener}\n * mechanism.\n *\n * <p>While it is recommended that service lifecycles be managed via this class, state transitions\n * initiated via other mechanisms do not impact the correctness of its methods. For example, if the\n * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked\n * when appropriate and {@link #awaitHealthy} will still work as expected.\n *\n * <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.\n * <pre>   {@code\n * class Server {\n *   public static void main(String[] args) {\n *     Set<Service> services = ...;\n *     ServiceManager manager = new ServiceManager(services);\n *     manager.addListener(new Listener() {\n *         public void stopped() {}\n *         public void healthy() {\n *           // Services have been initialized and are healthy, start accepting requests...\n *         }\n *         public void failure(Service service) {\n *           // Something failed, at this point we could log it, notify a load balancer, or take\n *           // some other action.  For now we will just exit.\n *           System.exit(1);\n *         }\n *       },\n *       MoreExecutors.directExecutor());\n *\n *     Runtime.getRuntime().addShutdownHook(new Thread() {\n *       public void run() {\n *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown\n *         // requests.\n *         try {\n *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);\n *         } catch (TimeoutException timeout) {\n *           // stopping timed out\n *         }\n *       }\n *     });\n *     manager.startAsync();  // start all the services asynchronously\n *   }\n * }}</pre>\n *\n * <p>This class uses the ServiceManager's methods to start all of its services, to respond to\n * service failure and to ensure that when the JVM is shutting down all the services are stopped.\n *\n * @author Luke Sandberg\n * @since 14.0\n */\n@Beta\npublic final class ServiceManager {\n  private static final Logger logger = Logger.getLogger(ServiceManager.class.getName());\n  private static final Callback<Listener> HEALTHY_CALLBACK = new Callback<Listener>(\"healthy()\") {\n    @Override void call(Listener listener) {\n      listener.healthy();\n    }\n  };\n  private static final Callback<Listener> STOPPED_CALLBACK = new Callback<Listener>(\"stopped()\") {\n    @Override void call(Listener listener) {\n      listener.stopped();\n    }\n  };\n\n  /**\n   * A listener for the aggregate state changes of the services that are under management. Users\n   * that need to listen to more fine-grained events (such as when each particular {@linkplain\n   * Service service} starts, or terminates), should attach {@linkplain Service.Listener service\n   * listeners} to each individual service.\n   *\n   * @author Luke Sandberg\n   * @since 15.0 (present as an interface in 14.0)\n   */\n  @Beta  // Should come out of Beta when ServiceManager does\n  public abstract static class Listener {\n    /**\n     * Called when the service initially becomes healthy.\n     *\n     * <p>This will be called at most once after all the services have entered the\n     * {@linkplain State#RUNNING running} state. If any services fail during start up or\n     * {@linkplain State#FAILED fail}/{@linkplain State#TERMINATED terminate} before all other\n     * services have started {@linkplain State#RUNNING running} then this method will not be called.\n     */\n    public void healthy() {}\n\n    /**\n     * Called when the all of the component services have reached a terminal state, either\n     * {@linkplain State#TERMINATED terminated} or {@linkplain State#FAILED failed}.\n     */\n    public void stopped() {}\n\n    /**\n     * Called when a component service has {@linkplain State#FAILED failed}.\n     *\n     * @param service The service that failed.\n     */\n    public void failure(Service service) {}\n  }\n\n  /**\n   * An encapsulation of all of the state that is accessed by the {@linkplain ServiceListener\n   * service listeners}.  This is extracted into its own object so that {@link ServiceListener}\n   * could be made {@code static} and its instances can be safely constructed and added in the\n   * {@link ServiceManager} constructor without having to close over the partially constructed\n   * {@link ServiceManager} instance (i.e. avoid leaking a pointer to {@code this}).\n   */\n  private final ServiceManagerState state;\n  private final ImmutableList<Service> services;\n\n  /**\n   * Constructs a new instance for managing the given services.\n   *\n   * @param services The services to manage\n   *\n   * @throws IllegalArgumentException if not all services are {@linkplain State#NEW new} or if there\n   * are any duplicate services.\n   */\n  public ServiceManager(Iterable<? extends Service> services) {\n    ImmutableList<Service> copy = ImmutableList.copyOf(services);\n    if (copy.isEmpty()) {\n      // Having no services causes the manager to behave strangely. Notably, listeners are never\n      // fired.  To avoid this we substitute a placeholder service.\n      logger.log(Level.WARNING,\n          \"ServiceManager configured with no services.  Is your application configured properly?\",\n          new EmptyServiceManagerWarning());\n      copy = ImmutableList.<Service>of(new NoOpService());\n    }\n    this.state = new ServiceManagerState(copy);\n    this.services = copy;\n    WeakReference<ServiceManagerState> stateReference =\n        new WeakReference<ServiceManagerState>(state);\n    for (Service service : copy) {\n      service.addListener(new ServiceListener(service, stateReference), directExecutor());\n      // We check the state after adding the listener as a way to ensure that our listener was added\n      // to a NEW service.\n      checkArgument(service.state() == NEW, \"Can only manage NEW services, %s\", service);\n    }\n    // We have installed all of our listeners and after this point any state transition should be\n    // correct.\n    this.state.markReady();\n  }\n\n  /**\n   * Registers a {@link Listener} to be {@linkplain Executor#execute executed} on the given\n   * executor. The listener will not have previous state changes replayed, so it is\n   * suggested that listeners are added before any of the managed services are\n   * {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged. Any exception thrown\n   * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException}) will be caught and\n   * logged.\n   *\n   * <p> For fast, lightweight listeners that would be safe to execute in any thread, consider\n   * calling {@link #addListener(Listener)}.\n   *\n   * @param listener the listener to run when the manager changes state\n   * @param executor the executor in which the listeners callback methods will be run.\n   */\n  public void addListener(Listener listener, Executor executor) {\n    state.addListener(listener, executor);\n  }\n\n  /**\n   * Registers a {@link Listener} to be run when this {@link ServiceManager} changes state. The\n   * listener will not have previous state changes replayed, so it is suggested that listeners are\n   * added before any of the managed services are {@linkplain Service#startAsync started}.\n   *\n   * <p>{@code addListener} guarantees execution ordering across calls to a given listener but not\n   * across calls to multiple listeners. Specifically, a given listener will have its callbacks\n   * invoked in the same order as the underlying service enters those states. Additionally, at most\n   * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks\n   * may execute concurrently, and listeners may execute in an order different from the one in which\n   * they were registered.\n   *\n   * <p>RuntimeExceptions thrown by a listener will be caught and logged.\n   *\n   * @param listener the listener to run when the manager changes state\n   */\n  public void addListener(Listener listener) {\n    state.addListener(listener, directExecutor());\n  }\n\n  /**\n   * Initiates service {@linkplain Service#startAsync startup} on all the services being managed.\n   * It is only valid to call this method if all of the services are {@linkplain State#NEW new}.\n   *\n   * @return this\n   * @throws IllegalStateException if any of the Services are not {@link State#NEW new} when the\n   *     method is called.\n   */\n  public ServiceManager startAsync() {\n    for (Service service : services) {\n      State state = service.state();\n      checkState(state == NEW, \"Service %s is %s, cannot start it.\", service, state);\n    }\n    for (Service service : services) {\n      try {\n        state.tryStartTiming(service);\n        service.startAsync();\n      } catch (IllegalStateException e) {\n        // This can happen if the service has already been started or stopped (e.g. by another\n        // service or listener). Our contract says it is safe to call this method if\n        // all services were NEW when it was called, and this has already been verified above, so we\n        // don't propagate the exception.\n        logger.log(Level.WARNING, \"Unable to start Service \" + service, e);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy}.  The manager\n   * will become healthy after all the component services have reached the {@linkplain State#RUNNING\n   * running} state.\n   *\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy() {\n    state.awaitHealthy();\n  }\n\n  /**\n   * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy} for no more\n   * than the given time.  The manager will become healthy after all the component services have\n   * reached the {@linkplain State#RUNNING running} state.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have finished starting within the deadline\n   * @throws IllegalStateException if the service manager reaches a state from which it cannot\n   *     become {@linkplain #isHealthy() healthy}.\n   */\n  public void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitHealthy(timeout, unit);\n  }\n\n  /**\n   * Initiates service {@linkplain Service#stopAsync shutdown} if necessary on all the services\n   * being managed.\n   *\n   * @return this\n   */\n  public ServiceManager stopAsync() {\n    for (Service service : services) {\n      service.stopAsync();\n    }\n    return this;\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state. After this method returns all\n   * services will either be {@linkplain Service.State#TERMINATED terminated} or {@linkplain\n   * Service.State#FAILED failed}.\n   */\n  public void awaitStopped() {\n    state.awaitStopped();\n  }\n\n  /**\n   * Waits for the all the services to reach a terminal state for no more than the given time. After\n   * this method returns all services will either be {@linkplain Service.State#TERMINATED\n   * terminated} or {@linkplain Service.State#FAILED failed}.\n   *\n   * @param timeout the maximum time to wait\n   * @param unit the time unit of the timeout argument\n   * @throws TimeoutException if not all of the services have stopped within the deadline\n   */\n  public void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n    state.awaitStopped(timeout, unit);\n  }\n\n  /**\n   * Returns true if all services are currently in the {@linkplain State#RUNNING running} state.\n   *\n   * <p>Users who want more detailed information should use the {@link #servicesByState} method to\n   * get detailed information about which services are not running.\n   */\n  public boolean isHealthy() {\n    for (Service service : services) {\n      if (!service.isRunning()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Provides a snapshot of the current state of all the services under management.\n   *\n   * <p>N.B. This snapshot is guaranteed to be consistent, i.e. the set of states returned will\n   * correspond to a point in time view of the services.\n   */\n  public ImmutableMultimap<State, Service> servicesByState() {\n    return state.servicesByState();\n  }\n\n  /**\n   * Returns the service load times. This value will only return startup times for services that\n   * have finished starting.\n   *\n   * @return Map of services and their corresponding startup time in millis, the map entries will be\n   *     ordered by startup time.\n   */\n  public ImmutableMap<Service, Long> startupTimes() {\n    return state.startupTimes();\n  }\n\n  @Override public String toString() {\n    return MoreObjects.toStringHelper(ServiceManager.class)\n        .add(\"services\", Collections2.filter(services, not(instanceOf(NoOpService.class))))\n        .toString();\n  }\n\n  /**\n   * An encapsulation of all the mutable state of the {@link ServiceManager} that needs to be\n   * accessed by instances of {@link ServiceListener}.\n   */\n  private static final class ServiceManagerState {\n    final Monitor monitor = new Monitor();\n\n    @GuardedBy(\"monitor\")\n    final SetMultimap<State, Service> servicesByState =\n        MultimapBuilder.enumKeys(State.class).linkedHashSetValues().build();\n\n    @GuardedBy(\"monitor\")\n    final Multiset<State> states = servicesByState.keys();\n\n    @GuardedBy(\"monitor\")\n    final Map<Service, Stopwatch> startupTimers = Maps.newIdentityHashMap();\n\n    /**\n     * These two booleans are used to mark the state as ready to start.\n     * {@link #ready}: is set by {@link #markReady} to indicate that all listeners have been\n     *     correctly installed\n     * {@link #transitioned}: is set by {@link #transitionService} to indicate that some transition\n     *     has been performed.\n     *\n     * <p>Together, they allow us to enforce that all services have their listeners installed prior\n     * to any service performing a transition, then we can fail in the ServiceManager constructor\n     * rather than in a Service.Listener callback.\n     */\n    @GuardedBy(\"monitor\")\n    boolean ready;\n\n    @GuardedBy(\"monitor\")\n    boolean transitioned;\n\n    final int numberOfServices;\n\n    /**\n     * Controls how long to wait for all the services to either become healthy or reach a\n     * state from which it is guaranteed that it can never become healthy.\n     */\n    final Monitor.Guard awaitHealthGuard = new AwaitHealthGuard();\n\n    @WeakOuter\n    final class AwaitHealthGuard extends Monitor.Guard {\n      AwaitHealthGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        // All services have started or some service has terminated/failed.\n        return states.count(RUNNING) == numberOfServices\n            || states.contains(STOPPING)\n            || states.contains(TERMINATED)\n            || states.contains(FAILED);\n      }\n    }\n\n    /**\n     * Controls how long to wait for all services to reach a terminal state.\n     */\n    final Monitor.Guard stoppedGuard = new StoppedGuard();\n\n    @WeakOuter\n    final class StoppedGuard extends Monitor.Guard {\n      StoppedGuard() {\n        super(ServiceManagerState.this.monitor);\n      }\n\n      @Override public boolean isSatisfied() {\n        return states.count(TERMINATED) + states.count(FAILED) == numberOfServices;\n      }\n    }\n\n    /** The listeners to notify during a state transition. */\n    @GuardedBy(\"monitor\")\n    final List<ListenerCallQueue<Listener>> listeners =\n        Collections.synchronizedList(new ArrayList<ListenerCallQueue<Listener>>());\n\n    /**\n     * It is implicitly assumed that all the services are NEW and that they will all remain NEW\n     * until all the Listeners are installed and {@link #markReady()} is called.  It is our caller's\n     * responsibility to only call {@link #markReady()} if all services were new at the time this\n     * method was called and when all the listeners were installed.\n     */\n    ServiceManagerState(ImmutableCollection<Service> services) {\n      this.numberOfServices = services.size();\n      servicesByState.putAll(NEW, services);\n    }\n\n    /**\n     * Attempts to start the timer immediately prior to the service being started via\n     * {@link Service#startAsync()}.\n     */\n    void tryStartTiming(Service service) {\n      monitor.enter();\n      try {\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          startupTimers.put(service, Stopwatch.createStarted());\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    /**\n     * Marks the {@link State} as ready to receive transitions. Returns true if no transitions have\n     * been observed yet.\n     */\n    void markReady() {\n      monitor.enter();\n      try {\n        if (!transitioned) {\n          // nothing has transitioned since construction, good.\n          ready = true;\n        } else {\n          // This should be an extremely rare race condition.\n          List<Service> servicesInBadStates = Lists.newArrayList();\n          for (Service service : servicesByState().values()) {\n            if (service.state() != NEW) {\n              servicesInBadStates.add(service);\n            }\n          }\n          throw new IllegalArgumentException(\"Services started transitioning asynchronously before \"\n              + \"the ServiceManager was constructed: \" + servicesInBadStates);\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void addListener(Listener listener, Executor executor) {\n      checkNotNull(listener, \"listener\");\n      checkNotNull(executor, \"executor\");\n      monitor.enter();\n      try {\n        // no point in adding a listener that will never be called\n        if (!stoppedGuard.isSatisfied()) {\n          listeners.add(new ListenerCallQueue<Listener>(listener, executor));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy() {\n      monitor.enterWhenUninterruptibly(awaitHealthGuard);\n      try {\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(awaitHealthGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to become healthy. The \"\n              + \"following services have not started: \"\n              + Multimaps.filterKeys(servicesByState, in(ImmutableSet.of(NEW, STARTING))));\n        }\n        checkHealthy();\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    void awaitStopped() {\n      monitor.enterWhenUninterruptibly(stoppedGuard);\n      monitor.leave();\n    }\n\n    void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n      monitor.enter();\n      try {\n        if (!monitor.waitForUninterruptibly(stoppedGuard, timeout, unit)) {\n          throw new TimeoutException(\"Timeout waiting for the services to stop. The following \"\n              + \"services have not stopped: \"\n              + Multimaps.filterKeys(servicesByState,\n                  not(in(EnumSet.of(TERMINATED, FAILED)))));\n        }\n      } finally {\n        monitor.leave();\n      }\n    }\n\n    ImmutableMultimap<State, Service> servicesByState() {\n      ImmutableSetMultimap.Builder<State, Service> builder = ImmutableSetMultimap.builder();\n      monitor.enter();\n      try {\n        for (Entry<State, Service> entry : servicesByState.entries()) {\n          if (!(entry.getValue() instanceof NoOpService)) {\n            builder.put(entry);\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      return builder.build();\n    }\n\n    ImmutableMap<Service, Long> startupTimes() {\n      List<Entry<Service, Long>> loadTimes;\n      monitor.enter();\n      try {\n        loadTimes = Lists.newArrayListWithCapacity(startupTimers.size());\n        // N.B. There will only be an entry in the map if the service has started\n        for (Entry<Service, Stopwatch> entry : startupTimers.entrySet()) {\n          Service service = entry.getKey();\n          Stopwatch stopWatch = entry.getValue();\n          if (!stopWatch.isRunning() && !(service instanceof NoOpService)) {\n            loadTimes.add(Maps.immutableEntry(service, stopWatch.elapsed(MILLISECONDS)));\n          }\n        }\n      } finally {\n        monitor.leave();\n      }\n      Collections.sort(loadTimes, Ordering.natural()\n          .onResultOf(new Function<Entry<Service, Long>, Long>() {\n            @Override public Long apply(Map.Entry<Service, Long> input) {\n              return input.getValue();\n            }\n          }));\n      return ImmutableMap.copyOf(loadTimes);\n    }\n\n    /**\n     * Updates the state with the given service transition.\n     *\n     * <p>This method performs the main logic of ServiceManager in the following steps.\n     * <ol>\n     *      <li>Update the {@link #servicesByState()}\n     *      <li>Update the {@link #startupTimers}\n     *      <li>Based on the new state queue listeners to run\n     *      <li>Run the listeners (outside of the lock)\n     * </ol>\n     */\n    void transitionService(final Service service, State from, State to) {\n      checkNotNull(service);\n      checkArgument(from != to);\n      monitor.enter();\n      try {\n        transitioned = true;\n        if (!ready) {\n          return;\n        }\n        // Update state.\n        checkState(servicesByState.remove(from, service),\n            \"Service %s not at the expected location in the state map %s\", service, from);\n        checkState(servicesByState.put(to, service),\n            \"Service %s in the state map unexpectedly at %s\", service, to);\n        // Update the timer\n        Stopwatch stopwatch = startupTimers.get(service);\n        if (stopwatch == null) {\n          // This means the service was started by some means other than ServiceManager.startAsync\n          stopwatch = Stopwatch.createStarted();\n          startupTimers.put(service, stopwatch);\n        }\n        if (to.compareTo(RUNNING) >= 0 && stopwatch.isRunning()) {\n          // N.B. if we miss the STARTING event then we may never record a startup time.\n          stopwatch.stop();\n          if (!(service instanceof NoOpService)) {\n            logger.log(Level.FINE, \"Started {0} in {1}.\", new Object[] {service, stopwatch});\n          }\n        }\n        // Queue our listeners\n\n        // Did a service fail?\n        if (to == FAILED) {\n          fireFailedListeners(service);\n        }\n\n        if (states.count(RUNNING) == numberOfServices) {\n          // This means that the manager is currently healthy. N.B. If other threads call isHealthy\n          // they are not guaranteed to get 'true', because any service could fail right now.\n          fireHealthyListeners();\n        } else if (states.count(TERMINATED) + states.count(FAILED) == numberOfServices) {\n          fireStoppedListeners();\n        }\n      } finally {\n        monitor.leave();\n        // Run our executors outside of the lock\n        executeListeners();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireStoppedListeners() {\n      STOPPED_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireHealthyListeners() {\n      HEALTHY_CALLBACK.enqueueOn(listeners);\n    }\n\n    @GuardedBy(\"monitor\")\n    void fireFailedListeners(final Service service) {\n      new Callback<Listener>(\"failed({service=\" + service + \"})\") {\n        @Override void call(Listener listener) {\n          listener.failure(service);\n        }\n      }.enqueueOn(listeners);\n    }\n\n    /** Attempts to execute all the listeners in {@link #listeners}. */\n    void executeListeners() {\n      checkState(!monitor.isOccupiedByCurrentThread(),\n          \"It is incorrect to execute listeners with the monitor held.\");\n      // iterate by index to avoid concurrent modification exceptions\n      for (int i = 0; i < listeners.size(); i++) {\n        listeners.get(i).execute();\n      }\n    }\n\n    @GuardedBy(\"monitor\")\n    void checkHealthy() {\n      if (states.count(RUNNING) != numberOfServices) {\n        IllegalStateException exception = new IllegalStateException(\n            \"Expected to be healthy after starting. The following services are not running: \"\n                + Multimaps.filterKeys(servicesByState, not(equalTo(RUNNING))));\n        throw exception;\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} that wraps another service and times how long it takes for it to start and\n   * also calls the {@link ServiceManagerState#transitionService(Service, State, State)},\n   * to record the state transitions.\n   */\n  private static final class ServiceListener extends Service.Listener {\n    final Service service;\n    // We store the state in a weak reference to ensure that if something went wrong while\n    // constructing the ServiceManager we don't pointlessly keep updating the state.\n    final WeakReference<ServiceManagerState> state;\n\n    ServiceListener(Service service, WeakReference<ServiceManagerState> state) {\n      this.service = service;\n      this.state = state;\n    }\n\n    @Override public void starting() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, NEW, STARTING);\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Starting {0}.\", service);\n        }\n      }\n    }\n\n    @Override public void running() {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, STARTING, RUNNING);\n      }\n    }\n\n    @Override public void stopping(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        state.transitionService(service, from, STOPPING);\n      }\n    }\n\n    @Override public void terminated(State from) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        if (!(service instanceof NoOpService)) {\n          logger.log(Level.FINE, \"Service {0} has terminated. Previous state was: {1}\",\n              new Object[] {service, from});\n        }\n        state.transitionService(service, from, TERMINATED);\n      }\n    }\n\n    @Override public void failed(State from, Throwable failure) {\n      ServiceManagerState state = this.state.get();\n      if (state != null) {\n        // Log before the transition, so that if the process exits in response to server failure,\n        // there is a higher likelihood that the cause will be in the logs.\n        if (!(service instanceof NoOpService) ) {\n          logger.log(Level.SEVERE, \"Service \" + service + \" has failed in the \" + from + \" state.\",\n              failure);\n        }\n        state.transitionService(service, from, FAILED);\n      }\n    }\n  }\n\n  /**\n   * A {@link Service} instance that does nothing.  This is only useful as a placeholder to\n   * ensure that the {@link ServiceManager} functions properly even when it is managing no services.\n   *\n   * <p>The use of this class is considered an implementation detail of ServiceManager and as such\n   * it is excluded from {@link #servicesByState}, {@link #startupTimes}, {@link #toString} and all\n   * logging statements.\n   */\n  private static final class NoOpService extends AbstractService {\n    @Override protected void doStart() { notifyStarted(); }\n    @Override protected void doStop() { notifyStopped(); }\n  }\n\n  /** This is never thrown but only used for logging. */\n  private static final class EmptyServiceManagerWarning extends Throwable {}\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53086653,"label":true,"oracleId":1461,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"TimeLimiter","javadocTag":"@param target the object to proxy","methodJavadoc":"    /**\n   * Returns an instance of {@code interfaceType} that delegates all method\n   * calls to the {@code target} object, enforcing the specified time limit on\n   * each call.  This time-limited delegation is also performed for calls to\n   * {@link Object#equals}, {@link Object#hashCode}, and\n   * {@link Object#toString}.\n   * <p>\n   * If the target method call finishes before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is. If, on the\n   * other hand, the time limit is reached, the proxy will attempt to abort the\n   * call to the target, and will throw an {@link UncheckedTimeoutException} to\n   * the caller.\n   * <p>\n   * It is important to note that the primary purpose of the proxy object is to\n   * return control to the caller when the timeout elapses; aborting the target\n   * method call is of secondary concern.  The particular nature and strength\n   * of the guarantees made by the proxy is implementation-dependent.  However,\n   * it is important that each of the methods on the target object behaves\n   * appropriately when its thread is interrupted.\n   *\n   * @param target the object to proxy\n   * @param interfaceType the interface you wish the returned proxy to\n   *     implement\n   * @param timeoutDuration with timeoutUnit, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @param timeoutUnit with timeoutDuration, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @return a time-limiting proxy\n   * @throws IllegalArgumentException if {@code interfaceType} is a regular\n   *     class, enum, or annotation type, rather than an interface\n   */","methodSourceCode":"<T> T newProxy(T target, Class<T> interfaceType, long timeoutDuration, TimeUnit timeoutUnit);","classJavadoc":"/**\n * Produces proxies that impose a time limit on method\n * calls to the proxied object.  For example, to return the value of\n * {@code target.someMethod()}, but substitute {@code DEFAULT_VALUE} if this\n * method call takes over 50 ms, you can use this code:\n * <pre>\n *   TimeLimiter limiter = . . .;\n *   TargetType proxy = limiter.newProxy(\n *       target, TargetType.class, 50, TimeUnit.MILLISECONDS);\n *   try {\n *     return proxy.someMethod();\n *   } catch (UncheckedTimeoutException e) {\n *     return DEFAULT_VALUE;\n *   }\n * </pre>\n * <p>Please see {@code SimpleTimeLimiterTest} for more usage examples.\n *\n * @author Kevin Bourrillion\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2006 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Produces proxies that impose a time limit on method\n * calls to the proxied object.  For example, to return the value of\n * {@code target.someMethod()}, but substitute {@code DEFAULT_VALUE} if this\n * method call takes over 50 ms, you can use this code:\n * <pre>\n *   TimeLimiter limiter = . . .;\n *   TargetType proxy = limiter.newProxy(\n *       target, TargetType.class, 50, TimeUnit.MILLISECONDS);\n *   try {\n *     return proxy.someMethod();\n *   } catch (UncheckedTimeoutException e) {\n *     return DEFAULT_VALUE;\n *   }\n * </pre>\n * <p>Please see {@code SimpleTimeLimiterTest} for more usage examples.\n *\n * @author Kevin Bourrillion\n * @since 1.0\n */\n@Beta\npublic interface TimeLimiter {\n\n  /**\n   * Returns an instance of {@code interfaceType} that delegates all method\n   * calls to the {@code target} object, enforcing the specified time limit on\n   * each call.  This time-limited delegation is also performed for calls to\n   * {@link Object#equals}, {@link Object#hashCode}, and\n   * {@link Object#toString}.\n   * <p>\n   * If the target method call finishes before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is. If, on the\n   * other hand, the time limit is reached, the proxy will attempt to abort the\n   * call to the target, and will throw an {@link UncheckedTimeoutException} to\n   * the caller.\n   * <p>\n   * It is important to note that the primary purpose of the proxy object is to\n   * return control to the caller when the timeout elapses; aborting the target\n   * method call is of secondary concern.  The particular nature and strength\n   * of the guarantees made by the proxy is implementation-dependent.  However,\n   * it is important that each of the methods on the target object behaves\n   * appropriately when its thread is interrupted.\n   *\n   * @param target the object to proxy\n   * @param interfaceType the interface you wish the returned proxy to\n   *     implement\n   * @param timeoutDuration with timeoutUnit, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @param timeoutUnit with timeoutDuration, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @return a time-limiting proxy\n   * @throws IllegalArgumentException if {@code interfaceType} is a regular\n   *     class, enum, or annotation type, rather than an interface\n   */\n  <T> T newProxy(T target, Class<T> interfaceType,\n      long timeoutDuration, TimeUnit timeoutUnit);\n\n  /**\n   * Invokes a specified Callable, timing out after the specified time limit.\n   * If the target method call finished before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is.  If, on the\n   * other hand, the time limit is reached, we attempt to abort the call to the\n   * target, and throw an {@link UncheckedTimeoutException} to the caller.\n   * <p>\n   * <b>Warning:</b> The future of this method is in doubt.  It may be nuked, or\n   * changed significantly.\n   *\n   * @param callable the Callable to execute\n   * @param timeoutDuration with timeoutUnit, the maximum length of time to wait\n   * @param timeoutUnit with timeoutDuration, the maximum length of time to wait\n   * @param interruptible whether to respond to thread interruption by aborting\n   *     the operation and throwing InterruptedException; if false, the\n   *     operation is allowed to complete or time out, and the current thread's\n   *     interrupt status is re-asserted.\n   * @return the result returned by the Callable\n   * @throws InterruptedException if {@code interruptible} is true and our\n   *     thread is interrupted during execution\n   * @throws UncheckedTimeoutException if the time limit is reached\n   * @throws Exception\n   */\n  <T> T callWithTimeout(Callable<T> callable, long timeoutDuration,\n      TimeUnit timeoutUnit, boolean interruptible) throws Exception;\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53087114,"label":true,"oracleId":1462,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"TimeLimiter","javadocTag":"@param interfaceType the interface you wish the returned proxy to\n    implement","methodJavadoc":"    /**\n   * Returns an instance of {@code interfaceType} that delegates all method\n   * calls to the {@code target} object, enforcing the specified time limit on\n   * each call.  This time-limited delegation is also performed for calls to\n   * {@link Object#equals}, {@link Object#hashCode}, and\n   * {@link Object#toString}.\n   * <p>\n   * If the target method call finishes before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is. If, on the\n   * other hand, the time limit is reached, the proxy will attempt to abort the\n   * call to the target, and will throw an {@link UncheckedTimeoutException} to\n   * the caller.\n   * <p>\n   * It is important to note that the primary purpose of the proxy object is to\n   * return control to the caller when the timeout elapses; aborting the target\n   * method call is of secondary concern.  The particular nature and strength\n   * of the guarantees made by the proxy is implementation-dependent.  However,\n   * it is important that each of the methods on the target object behaves\n   * appropriately when its thread is interrupted.\n   *\n   * @param target the object to proxy\n   * @param interfaceType the interface you wish the returned proxy to\n   *     implement\n   * @param timeoutDuration with timeoutUnit, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @param timeoutUnit with timeoutDuration, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @return a time-limiting proxy\n   * @throws IllegalArgumentException if {@code interfaceType} is a regular\n   *     class, enum, or annotation type, rather than an interface\n   */","methodSourceCode":"<T> T newProxy(T target, Class<T> interfaceType, long timeoutDuration, TimeUnit timeoutUnit);","classJavadoc":"/**\n * Produces proxies that impose a time limit on method\n * calls to the proxied object.  For example, to return the value of\n * {@code target.someMethod()}, but substitute {@code DEFAULT_VALUE} if this\n * method call takes over 50 ms, you can use this code:\n * <pre>\n *   TimeLimiter limiter = . . .;\n *   TargetType proxy = limiter.newProxy(\n *       target, TargetType.class, 50, TimeUnit.MILLISECONDS);\n *   try {\n *     return proxy.someMethod();\n *   } catch (UncheckedTimeoutException e) {\n *     return DEFAULT_VALUE;\n *   }\n * </pre>\n * <p>Please see {@code SimpleTimeLimiterTest} for more usage examples.\n *\n * @author Kevin Bourrillion\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2006 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Produces proxies that impose a time limit on method\n * calls to the proxied object.  For example, to return the value of\n * {@code target.someMethod()}, but substitute {@code DEFAULT_VALUE} if this\n * method call takes over 50 ms, you can use this code:\n * <pre>\n *   TimeLimiter limiter = . . .;\n *   TargetType proxy = limiter.newProxy(\n *       target, TargetType.class, 50, TimeUnit.MILLISECONDS);\n *   try {\n *     return proxy.someMethod();\n *   } catch (UncheckedTimeoutException e) {\n *     return DEFAULT_VALUE;\n *   }\n * </pre>\n * <p>Please see {@code SimpleTimeLimiterTest} for more usage examples.\n *\n * @author Kevin Bourrillion\n * @since 1.0\n */\n@Beta\npublic interface TimeLimiter {\n\n  /**\n   * Returns an instance of {@code interfaceType} that delegates all method\n   * calls to the {@code target} object, enforcing the specified time limit on\n   * each call.  This time-limited delegation is also performed for calls to\n   * {@link Object#equals}, {@link Object#hashCode}, and\n   * {@link Object#toString}.\n   * <p>\n   * If the target method call finishes before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is. If, on the\n   * other hand, the time limit is reached, the proxy will attempt to abort the\n   * call to the target, and will throw an {@link UncheckedTimeoutException} to\n   * the caller.\n   * <p>\n   * It is important to note that the primary purpose of the proxy object is to\n   * return control to the caller when the timeout elapses; aborting the target\n   * method call is of secondary concern.  The particular nature and strength\n   * of the guarantees made by the proxy is implementation-dependent.  However,\n   * it is important that each of the methods on the target object behaves\n   * appropriately when its thread is interrupted.\n   *\n   * @param target the object to proxy\n   * @param interfaceType the interface you wish the returned proxy to\n   *     implement\n   * @param timeoutDuration with timeoutUnit, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @param timeoutUnit with timeoutDuration, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @return a time-limiting proxy\n   * @throws IllegalArgumentException if {@code interfaceType} is a regular\n   *     class, enum, or annotation type, rather than an interface\n   */\n  <T> T newProxy(T target, Class<T> interfaceType,\n      long timeoutDuration, TimeUnit timeoutUnit);\n\n  /**\n   * Invokes a specified Callable, timing out after the specified time limit.\n   * If the target method call finished before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is.  If, on the\n   * other hand, the time limit is reached, we attempt to abort the call to the\n   * target, and throw an {@link UncheckedTimeoutException} to the caller.\n   * <p>\n   * <b>Warning:</b> The future of this method is in doubt.  It may be nuked, or\n   * changed significantly.\n   *\n   * @param callable the Callable to execute\n   * @param timeoutDuration with timeoutUnit, the maximum length of time to wait\n   * @param timeoutUnit with timeoutDuration, the maximum length of time to wait\n   * @param interruptible whether to respond to thread interruption by aborting\n   *     the operation and throwing InterruptedException; if false, the\n   *     operation is allowed to complete or time out, and the current thread's\n   *     interrupt status is re-asserted.\n   * @return the result returned by the Callable\n   * @throws InterruptedException if {@code interruptible} is true and our\n   *     thread is interrupted during execution\n   * @throws UncheckedTimeoutException if the time limit is reached\n   * @throws Exception\n   */\n  <T> T callWithTimeout(Callable<T> callable, long timeoutDuration,\n      TimeUnit timeoutUnit, boolean interruptible) throws Exception;\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53087575,"label":true,"oracleId":1463,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"TimeLimiter","javadocTag":"@param timeoutDuration with timeoutUnit, the maximum length of time that\n    callers are willing to wait on each method call to the proxy","methodJavadoc":"    /**\n   * Returns an instance of {@code interfaceType} that delegates all method\n   * calls to the {@code target} object, enforcing the specified time limit on\n   * each call.  This time-limited delegation is also performed for calls to\n   * {@link Object#equals}, {@link Object#hashCode}, and\n   * {@link Object#toString}.\n   * <p>\n   * If the target method call finishes before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is. If, on the\n   * other hand, the time limit is reached, the proxy will attempt to abort the\n   * call to the target, and will throw an {@link UncheckedTimeoutException} to\n   * the caller.\n   * <p>\n   * It is important to note that the primary purpose of the proxy object is to\n   * return control to the caller when the timeout elapses; aborting the target\n   * method call is of secondary concern.  The particular nature and strength\n   * of the guarantees made by the proxy is implementation-dependent.  However,\n   * it is important that each of the methods on the target object behaves\n   * appropriately when its thread is interrupted.\n   *\n   * @param target the object to proxy\n   * @param interfaceType the interface you wish the returned proxy to\n   *     implement\n   * @param timeoutDuration with timeoutUnit, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @param timeoutUnit with timeoutDuration, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @return a time-limiting proxy\n   * @throws IllegalArgumentException if {@code interfaceType} is a regular\n   *     class, enum, or annotation type, rather than an interface\n   */","methodSourceCode":"<T> T newProxy(T target, Class<T> interfaceType, long timeoutDuration, TimeUnit timeoutUnit);","classJavadoc":"/**\n * Produces proxies that impose a time limit on method\n * calls to the proxied object.  For example, to return the value of\n * {@code target.someMethod()}, but substitute {@code DEFAULT_VALUE} if this\n * method call takes over 50 ms, you can use this code:\n * <pre>\n *   TimeLimiter limiter = . . .;\n *   TargetType proxy = limiter.newProxy(\n *       target, TargetType.class, 50, TimeUnit.MILLISECONDS);\n *   try {\n *     return proxy.someMethod();\n *   } catch (UncheckedTimeoutException e) {\n *     return DEFAULT_VALUE;\n *   }\n * </pre>\n * <p>Please see {@code SimpleTimeLimiterTest} for more usage examples.\n *\n * @author Kevin Bourrillion\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2006 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Produces proxies that impose a time limit on method\n * calls to the proxied object.  For example, to return the value of\n * {@code target.someMethod()}, but substitute {@code DEFAULT_VALUE} if this\n * method call takes over 50 ms, you can use this code:\n * <pre>\n *   TimeLimiter limiter = . . .;\n *   TargetType proxy = limiter.newProxy(\n *       target, TargetType.class, 50, TimeUnit.MILLISECONDS);\n *   try {\n *     return proxy.someMethod();\n *   } catch (UncheckedTimeoutException e) {\n *     return DEFAULT_VALUE;\n *   }\n * </pre>\n * <p>Please see {@code SimpleTimeLimiterTest} for more usage examples.\n *\n * @author Kevin Bourrillion\n * @since 1.0\n */\n@Beta\npublic interface TimeLimiter {\n\n  /**\n   * Returns an instance of {@code interfaceType} that delegates all method\n   * calls to the {@code target} object, enforcing the specified time limit on\n   * each call.  This time-limited delegation is also performed for calls to\n   * {@link Object#equals}, {@link Object#hashCode}, and\n   * {@link Object#toString}.\n   * <p>\n   * If the target method call finishes before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is. If, on the\n   * other hand, the time limit is reached, the proxy will attempt to abort the\n   * call to the target, and will throw an {@link UncheckedTimeoutException} to\n   * the caller.\n   * <p>\n   * It is important to note that the primary purpose of the proxy object is to\n   * return control to the caller when the timeout elapses; aborting the target\n   * method call is of secondary concern.  The particular nature and strength\n   * of the guarantees made by the proxy is implementation-dependent.  However,\n   * it is important that each of the methods on the target object behaves\n   * appropriately when its thread is interrupted.\n   *\n   * @param target the object to proxy\n   * @param interfaceType the interface you wish the returned proxy to\n   *     implement\n   * @param timeoutDuration with timeoutUnit, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @param timeoutUnit with timeoutDuration, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @return a time-limiting proxy\n   * @throws IllegalArgumentException if {@code interfaceType} is a regular\n   *     class, enum, or annotation type, rather than an interface\n   */\n  <T> T newProxy(T target, Class<T> interfaceType,\n      long timeoutDuration, TimeUnit timeoutUnit);\n\n  /**\n   * Invokes a specified Callable, timing out after the specified time limit.\n   * If the target method call finished before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is.  If, on the\n   * other hand, the time limit is reached, we attempt to abort the call to the\n   * target, and throw an {@link UncheckedTimeoutException} to the caller.\n   * <p>\n   * <b>Warning:</b> The future of this method is in doubt.  It may be nuked, or\n   * changed significantly.\n   *\n   * @param callable the Callable to execute\n   * @param timeoutDuration with timeoutUnit, the maximum length of time to wait\n   * @param timeoutUnit with timeoutDuration, the maximum length of time to wait\n   * @param interruptible whether to respond to thread interruption by aborting\n   *     the operation and throwing InterruptedException; if false, the\n   *     operation is allowed to complete or time out, and the current thread's\n   *     interrupt status is re-asserted.\n   * @return the result returned by the Callable\n   * @throws InterruptedException if {@code interruptible} is true and our\n   *     thread is interrupted during execution\n   * @throws UncheckedTimeoutException if the time limit is reached\n   * @throws Exception\n   */\n  <T> T callWithTimeout(Callable<T> callable, long timeoutDuration,\n      TimeUnit timeoutUnit, boolean interruptible) throws Exception;\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53088036,"label":true,"oracleId":1464,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"TimeLimiter","javadocTag":"@param timeoutUnit with timeoutDuration, the maximum length of time that\n    callers are willing to wait on each method call to the proxy","methodJavadoc":"    /**\n   * Returns an instance of {@code interfaceType} that delegates all method\n   * calls to the {@code target} object, enforcing the specified time limit on\n   * each call.  This time-limited delegation is also performed for calls to\n   * {@link Object#equals}, {@link Object#hashCode}, and\n   * {@link Object#toString}.\n   * <p>\n   * If the target method call finishes before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is. If, on the\n   * other hand, the time limit is reached, the proxy will attempt to abort the\n   * call to the target, and will throw an {@link UncheckedTimeoutException} to\n   * the caller.\n   * <p>\n   * It is important to note that the primary purpose of the proxy object is to\n   * return control to the caller when the timeout elapses; aborting the target\n   * method call is of secondary concern.  The particular nature and strength\n   * of the guarantees made by the proxy is implementation-dependent.  However,\n   * it is important that each of the methods on the target object behaves\n   * appropriately when its thread is interrupted.\n   *\n   * @param target the object to proxy\n   * @param interfaceType the interface you wish the returned proxy to\n   *     implement\n   * @param timeoutDuration with timeoutUnit, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @param timeoutUnit with timeoutDuration, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @return a time-limiting proxy\n   * @throws IllegalArgumentException if {@code interfaceType} is a regular\n   *     class, enum, or annotation type, rather than an interface\n   */","methodSourceCode":"<T> T newProxy(T target, Class<T> interfaceType, long timeoutDuration, TimeUnit timeoutUnit);","classJavadoc":"/**\n * Produces proxies that impose a time limit on method\n * calls to the proxied object.  For example, to return the value of\n * {@code target.someMethod()}, but substitute {@code DEFAULT_VALUE} if this\n * method call takes over 50 ms, you can use this code:\n * <pre>\n *   TimeLimiter limiter = . . .;\n *   TargetType proxy = limiter.newProxy(\n *       target, TargetType.class, 50, TimeUnit.MILLISECONDS);\n *   try {\n *     return proxy.someMethod();\n *   } catch (UncheckedTimeoutException e) {\n *     return DEFAULT_VALUE;\n *   }\n * </pre>\n * <p>Please see {@code SimpleTimeLimiterTest} for more usage examples.\n *\n * @author Kevin Bourrillion\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2006 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Produces proxies that impose a time limit on method\n * calls to the proxied object.  For example, to return the value of\n * {@code target.someMethod()}, but substitute {@code DEFAULT_VALUE} if this\n * method call takes over 50 ms, you can use this code:\n * <pre>\n *   TimeLimiter limiter = . . .;\n *   TargetType proxy = limiter.newProxy(\n *       target, TargetType.class, 50, TimeUnit.MILLISECONDS);\n *   try {\n *     return proxy.someMethod();\n *   } catch (UncheckedTimeoutException e) {\n *     return DEFAULT_VALUE;\n *   }\n * </pre>\n * <p>Please see {@code SimpleTimeLimiterTest} for more usage examples.\n *\n * @author Kevin Bourrillion\n * @since 1.0\n */\n@Beta\npublic interface TimeLimiter {\n\n  /**\n   * Returns an instance of {@code interfaceType} that delegates all method\n   * calls to the {@code target} object, enforcing the specified time limit on\n   * each call.  This time-limited delegation is also performed for calls to\n   * {@link Object#equals}, {@link Object#hashCode}, and\n   * {@link Object#toString}.\n   * <p>\n   * If the target method call finishes before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is. If, on the\n   * other hand, the time limit is reached, the proxy will attempt to abort the\n   * call to the target, and will throw an {@link UncheckedTimeoutException} to\n   * the caller.\n   * <p>\n   * It is important to note that the primary purpose of the proxy object is to\n   * return control to the caller when the timeout elapses; aborting the target\n   * method call is of secondary concern.  The particular nature and strength\n   * of the guarantees made by the proxy is implementation-dependent.  However,\n   * it is important that each of the methods on the target object behaves\n   * appropriately when its thread is interrupted.\n   *\n   * @param target the object to proxy\n   * @param interfaceType the interface you wish the returned proxy to\n   *     implement\n   * @param timeoutDuration with timeoutUnit, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @param timeoutUnit with timeoutDuration, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @return a time-limiting proxy\n   * @throws IllegalArgumentException if {@code interfaceType} is a regular\n   *     class, enum, or annotation type, rather than an interface\n   */\n  <T> T newProxy(T target, Class<T> interfaceType,\n      long timeoutDuration, TimeUnit timeoutUnit);\n\n  /**\n   * Invokes a specified Callable, timing out after the specified time limit.\n   * If the target method call finished before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is.  If, on the\n   * other hand, the time limit is reached, we attempt to abort the call to the\n   * target, and throw an {@link UncheckedTimeoutException} to the caller.\n   * <p>\n   * <b>Warning:</b> The future of this method is in doubt.  It may be nuked, or\n   * changed significantly.\n   *\n   * @param callable the Callable to execute\n   * @param timeoutDuration with timeoutUnit, the maximum length of time to wait\n   * @param timeoutUnit with timeoutDuration, the maximum length of time to wait\n   * @param interruptible whether to respond to thread interruption by aborting\n   *     the operation and throwing InterruptedException; if false, the\n   *     operation is allowed to complete or time out, and the current thread's\n   *     interrupt status is re-asserted.\n   * @return the result returned by the Callable\n   * @throws InterruptedException if {@code interruptible} is true and our\n   *     thread is interrupted during execution\n   * @throws UncheckedTimeoutException if the time limit is reached\n   * @throws Exception\n   */\n  <T> T callWithTimeout(Callable<T> callable, long timeoutDuration,\n      TimeUnit timeoutUnit, boolean interruptible) throws Exception;\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53088498,"label":true,"oracleId":1465,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"TimeLimiter","javadocTag":"@return a time-limiting proxy","methodJavadoc":"    /**\n   * Returns an instance of {@code interfaceType} that delegates all method\n   * calls to the {@code target} object, enforcing the specified time limit on\n   * each call.  This time-limited delegation is also performed for calls to\n   * {@link Object#equals}, {@link Object#hashCode}, and\n   * {@link Object#toString}.\n   * <p>\n   * If the target method call finishes before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is. If, on the\n   * other hand, the time limit is reached, the proxy will attempt to abort the\n   * call to the target, and will throw an {@link UncheckedTimeoutException} to\n   * the caller.\n   * <p>\n   * It is important to note that the primary purpose of the proxy object is to\n   * return control to the caller when the timeout elapses; aborting the target\n   * method call is of secondary concern.  The particular nature and strength\n   * of the guarantees made by the proxy is implementation-dependent.  However,\n   * it is important that each of the methods on the target object behaves\n   * appropriately when its thread is interrupted.\n   *\n   * @param target the object to proxy\n   * @param interfaceType the interface you wish the returned proxy to\n   *     implement\n   * @param timeoutDuration with timeoutUnit, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @param timeoutUnit with timeoutDuration, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @return a time-limiting proxy\n   * @throws IllegalArgumentException if {@code interfaceType} is a regular\n   *     class, enum, or annotation type, rather than an interface\n   */","methodSourceCode":"<T> T newProxy(T target, Class<T> interfaceType, long timeoutDuration, TimeUnit timeoutUnit);","classJavadoc":"/**\n * Produces proxies that impose a time limit on method\n * calls to the proxied object.  For example, to return the value of\n * {@code target.someMethod()}, but substitute {@code DEFAULT_VALUE} if this\n * method call takes over 50 ms, you can use this code:\n * <pre>\n *   TimeLimiter limiter = . . .;\n *   TargetType proxy = limiter.newProxy(\n *       target, TargetType.class, 50, TimeUnit.MILLISECONDS);\n *   try {\n *     return proxy.someMethod();\n *   } catch (UncheckedTimeoutException e) {\n *     return DEFAULT_VALUE;\n *   }\n * </pre>\n * <p>Please see {@code SimpleTimeLimiterTest} for more usage examples.\n *\n * @author Kevin Bourrillion\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2006 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Produces proxies that impose a time limit on method\n * calls to the proxied object.  For example, to return the value of\n * {@code target.someMethod()}, but substitute {@code DEFAULT_VALUE} if this\n * method call takes over 50 ms, you can use this code:\n * <pre>\n *   TimeLimiter limiter = . . .;\n *   TargetType proxy = limiter.newProxy(\n *       target, TargetType.class, 50, TimeUnit.MILLISECONDS);\n *   try {\n *     return proxy.someMethod();\n *   } catch (UncheckedTimeoutException e) {\n *     return DEFAULT_VALUE;\n *   }\n * </pre>\n * <p>Please see {@code SimpleTimeLimiterTest} for more usage examples.\n *\n * @author Kevin Bourrillion\n * @since 1.0\n */\n@Beta\npublic interface TimeLimiter {\n\n  /**\n   * Returns an instance of {@code interfaceType} that delegates all method\n   * calls to the {@code target} object, enforcing the specified time limit on\n   * each call.  This time-limited delegation is also performed for calls to\n   * {@link Object#equals}, {@link Object#hashCode}, and\n   * {@link Object#toString}.\n   * <p>\n   * If the target method call finishes before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is. If, on the\n   * other hand, the time limit is reached, the proxy will attempt to abort the\n   * call to the target, and will throw an {@link UncheckedTimeoutException} to\n   * the caller.\n   * <p>\n   * It is important to note that the primary purpose of the proxy object is to\n   * return control to the caller when the timeout elapses; aborting the target\n   * method call is of secondary concern.  The particular nature and strength\n   * of the guarantees made by the proxy is implementation-dependent.  However,\n   * it is important that each of the methods on the target object behaves\n   * appropriately when its thread is interrupted.\n   *\n   * @param target the object to proxy\n   * @param interfaceType the interface you wish the returned proxy to\n   *     implement\n   * @param timeoutDuration with timeoutUnit, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @param timeoutUnit with timeoutDuration, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @return a time-limiting proxy\n   * @throws IllegalArgumentException if {@code interfaceType} is a regular\n   *     class, enum, or annotation type, rather than an interface\n   */\n  <T> T newProxy(T target, Class<T> interfaceType,\n      long timeoutDuration, TimeUnit timeoutUnit);\n\n  /**\n   * Invokes a specified Callable, timing out after the specified time limit.\n   * If the target method call finished before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is.  If, on the\n   * other hand, the time limit is reached, we attempt to abort the call to the\n   * target, and throw an {@link UncheckedTimeoutException} to the caller.\n   * <p>\n   * <b>Warning:</b> The future of this method is in doubt.  It may be nuked, or\n   * changed significantly.\n   *\n   * @param callable the Callable to execute\n   * @param timeoutDuration with timeoutUnit, the maximum length of time to wait\n   * @param timeoutUnit with timeoutDuration, the maximum length of time to wait\n   * @param interruptible whether to respond to thread interruption by aborting\n   *     the operation and throwing InterruptedException; if false, the\n   *     operation is allowed to complete or time out, and the current thread's\n   *     interrupt status is re-asserted.\n   * @return the result returned by the Callable\n   * @throws InterruptedException if {@code interruptible} is true and our\n   *     thread is interrupted during execution\n   * @throws UncheckedTimeoutException if the time limit is reached\n   * @throws Exception\n   */\n  <T> T callWithTimeout(Callable<T> callable, long timeoutDuration,\n      TimeUnit timeoutUnit, boolean interruptible) throws Exception;\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53088959,"label":true,"oracleId":1466,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"TimeLimiter","javadocTag":"@param callable the Callable to execute","methodJavadoc":"    /**\n   * Invokes a specified Callable, timing out after the specified time limit.\n   * If the target method call finished before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is.  If, on the\n   * other hand, the time limit is reached, we attempt to abort the call to the\n   * target, and throw an {@link UncheckedTimeoutException} to the caller.\n   * <p>\n   * <b>Warning:</b> The future of this method is in doubt.  It may be nuked, or\n   * changed significantly.\n   *\n   * @param callable the Callable to execute\n   * @param timeoutDuration with timeoutUnit, the maximum length of time to wait\n   * @param timeoutUnit with timeoutDuration, the maximum length of time to wait\n   * @param interruptible whether to respond to thread interruption by aborting\n   *     the operation and throwing InterruptedException; if false, the\n   *     operation is allowed to complete or time out, and the current thread's\n   *     interrupt status is re-asserted.\n   * @return the result returned by the Callable\n   * @throws InterruptedException if {@code interruptible} is true and our\n   *     thread is interrupted during execution\n   * @throws UncheckedTimeoutException if the time limit is reached\n   * @throws Exception\n   */","methodSourceCode":"<T> T callWithTimeout(Callable<T> callable, long timeoutDuration, TimeUnit timeoutUnit, boolean interruptible) throws Exception;","classJavadoc":"/**\n * Produces proxies that impose a time limit on method\n * calls to the proxied object.  For example, to return the value of\n * {@code target.someMethod()}, but substitute {@code DEFAULT_VALUE} if this\n * method call takes over 50 ms, you can use this code:\n * <pre>\n *   TimeLimiter limiter = . . .;\n *   TargetType proxy = limiter.newProxy(\n *       target, TargetType.class, 50, TimeUnit.MILLISECONDS);\n *   try {\n *     return proxy.someMethod();\n *   } catch (UncheckedTimeoutException e) {\n *     return DEFAULT_VALUE;\n *   }\n * </pre>\n * <p>Please see {@code SimpleTimeLimiterTest} for more usage examples.\n *\n * @author Kevin Bourrillion\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2006 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Produces proxies that impose a time limit on method\n * calls to the proxied object.  For example, to return the value of\n * {@code target.someMethod()}, but substitute {@code DEFAULT_VALUE} if this\n * method call takes over 50 ms, you can use this code:\n * <pre>\n *   TimeLimiter limiter = . . .;\n *   TargetType proxy = limiter.newProxy(\n *       target, TargetType.class, 50, TimeUnit.MILLISECONDS);\n *   try {\n *     return proxy.someMethod();\n *   } catch (UncheckedTimeoutException e) {\n *     return DEFAULT_VALUE;\n *   }\n * </pre>\n * <p>Please see {@code SimpleTimeLimiterTest} for more usage examples.\n *\n * @author Kevin Bourrillion\n * @since 1.0\n */\n@Beta\npublic interface TimeLimiter {\n\n  /**\n   * Returns an instance of {@code interfaceType} that delegates all method\n   * calls to the {@code target} object, enforcing the specified time limit on\n   * each call.  This time-limited delegation is also performed for calls to\n   * {@link Object#equals}, {@link Object#hashCode}, and\n   * {@link Object#toString}.\n   * <p>\n   * If the target method call finishes before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is. If, on the\n   * other hand, the time limit is reached, the proxy will attempt to abort the\n   * call to the target, and will throw an {@link UncheckedTimeoutException} to\n   * the caller.\n   * <p>\n   * It is important to note that the primary purpose of the proxy object is to\n   * return control to the caller when the timeout elapses; aborting the target\n   * method call is of secondary concern.  The particular nature and strength\n   * of the guarantees made by the proxy is implementation-dependent.  However,\n   * it is important that each of the methods on the target object behaves\n   * appropriately when its thread is interrupted.\n   *\n   * @param target the object to proxy\n   * @param interfaceType the interface you wish the returned proxy to\n   *     implement\n   * @param timeoutDuration with timeoutUnit, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @param timeoutUnit with timeoutDuration, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @return a time-limiting proxy\n   * @throws IllegalArgumentException if {@code interfaceType} is a regular\n   *     class, enum, or annotation type, rather than an interface\n   */\n  <T> T newProxy(T target, Class<T> interfaceType,\n      long timeoutDuration, TimeUnit timeoutUnit);\n\n  /**\n   * Invokes a specified Callable, timing out after the specified time limit.\n   * If the target method call finished before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is.  If, on the\n   * other hand, the time limit is reached, we attempt to abort the call to the\n   * target, and throw an {@link UncheckedTimeoutException} to the caller.\n   * <p>\n   * <b>Warning:</b> The future of this method is in doubt.  It may be nuked, or\n   * changed significantly.\n   *\n   * @param callable the Callable to execute\n   * @param timeoutDuration with timeoutUnit, the maximum length of time to wait\n   * @param timeoutUnit with timeoutDuration, the maximum length of time to wait\n   * @param interruptible whether to respond to thread interruption by aborting\n   *     the operation and throwing InterruptedException; if false, the\n   *     operation is allowed to complete or time out, and the current thread's\n   *     interrupt status is re-asserted.\n   * @return the result returned by the Callable\n   * @throws InterruptedException if {@code interruptible} is true and our\n   *     thread is interrupted during execution\n   * @throws UncheckedTimeoutException if the time limit is reached\n   * @throws Exception\n   */\n  <T> T callWithTimeout(Callable<T> callable, long timeoutDuration,\n      TimeUnit timeoutUnit, boolean interruptible) throws Exception;\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53089420,"label":true,"oracleId":1467,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"TimeLimiter","javadocTag":"@param timeoutDuration with timeoutUnit, the maximum length of time to wait","methodJavadoc":"    /**\n   * Invokes a specified Callable, timing out after the specified time limit.\n   * If the target method call finished before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is.  If, on the\n   * other hand, the time limit is reached, we attempt to abort the call to the\n   * target, and throw an {@link UncheckedTimeoutException} to the caller.\n   * <p>\n   * <b>Warning:</b> The future of this method is in doubt.  It may be nuked, or\n   * changed significantly.\n   *\n   * @param callable the Callable to execute\n   * @param timeoutDuration with timeoutUnit, the maximum length of time to wait\n   * @param timeoutUnit with timeoutDuration, the maximum length of time to wait\n   * @param interruptible whether to respond to thread interruption by aborting\n   *     the operation and throwing InterruptedException; if false, the\n   *     operation is allowed to complete or time out, and the current thread's\n   *     interrupt status is re-asserted.\n   * @return the result returned by the Callable\n   * @throws InterruptedException if {@code interruptible} is true and our\n   *     thread is interrupted during execution\n   * @throws UncheckedTimeoutException if the time limit is reached\n   * @throws Exception\n   */","methodSourceCode":"<T> T callWithTimeout(Callable<T> callable, long timeoutDuration, TimeUnit timeoutUnit, boolean interruptible) throws Exception;","classJavadoc":"/**\n * Produces proxies that impose a time limit on method\n * calls to the proxied object.  For example, to return the value of\n * {@code target.someMethod()}, but substitute {@code DEFAULT_VALUE} if this\n * method call takes over 50 ms, you can use this code:\n * <pre>\n *   TimeLimiter limiter = . . .;\n *   TargetType proxy = limiter.newProxy(\n *       target, TargetType.class, 50, TimeUnit.MILLISECONDS);\n *   try {\n *     return proxy.someMethod();\n *   } catch (UncheckedTimeoutException e) {\n *     return DEFAULT_VALUE;\n *   }\n * </pre>\n * <p>Please see {@code SimpleTimeLimiterTest} for more usage examples.\n *\n * @author Kevin Bourrillion\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2006 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Produces proxies that impose a time limit on method\n * calls to the proxied object.  For example, to return the value of\n * {@code target.someMethod()}, but substitute {@code DEFAULT_VALUE} if this\n * method call takes over 50 ms, you can use this code:\n * <pre>\n *   TimeLimiter limiter = . . .;\n *   TargetType proxy = limiter.newProxy(\n *       target, TargetType.class, 50, TimeUnit.MILLISECONDS);\n *   try {\n *     return proxy.someMethod();\n *   } catch (UncheckedTimeoutException e) {\n *     return DEFAULT_VALUE;\n *   }\n * </pre>\n * <p>Please see {@code SimpleTimeLimiterTest} for more usage examples.\n *\n * @author Kevin Bourrillion\n * @since 1.0\n */\n@Beta\npublic interface TimeLimiter {\n\n  /**\n   * Returns an instance of {@code interfaceType} that delegates all method\n   * calls to the {@code target} object, enforcing the specified time limit on\n   * each call.  This time-limited delegation is also performed for calls to\n   * {@link Object#equals}, {@link Object#hashCode}, and\n   * {@link Object#toString}.\n   * <p>\n   * If the target method call finishes before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is. If, on the\n   * other hand, the time limit is reached, the proxy will attempt to abort the\n   * call to the target, and will throw an {@link UncheckedTimeoutException} to\n   * the caller.\n   * <p>\n   * It is important to note that the primary purpose of the proxy object is to\n   * return control to the caller when the timeout elapses; aborting the target\n   * method call is of secondary concern.  The particular nature and strength\n   * of the guarantees made by the proxy is implementation-dependent.  However,\n   * it is important that each of the methods on the target object behaves\n   * appropriately when its thread is interrupted.\n   *\n   * @param target the object to proxy\n   * @param interfaceType the interface you wish the returned proxy to\n   *     implement\n   * @param timeoutDuration with timeoutUnit, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @param timeoutUnit with timeoutDuration, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @return a time-limiting proxy\n   * @throws IllegalArgumentException if {@code interfaceType} is a regular\n   *     class, enum, or annotation type, rather than an interface\n   */\n  <T> T newProxy(T target, Class<T> interfaceType,\n      long timeoutDuration, TimeUnit timeoutUnit);\n\n  /**\n   * Invokes a specified Callable, timing out after the specified time limit.\n   * If the target method call finished before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is.  If, on the\n   * other hand, the time limit is reached, we attempt to abort the call to the\n   * target, and throw an {@link UncheckedTimeoutException} to the caller.\n   * <p>\n   * <b>Warning:</b> The future of this method is in doubt.  It may be nuked, or\n   * changed significantly.\n   *\n   * @param callable the Callable to execute\n   * @param timeoutDuration with timeoutUnit, the maximum length of time to wait\n   * @param timeoutUnit with timeoutDuration, the maximum length of time to wait\n   * @param interruptible whether to respond to thread interruption by aborting\n   *     the operation and throwing InterruptedException; if false, the\n   *     operation is allowed to complete or time out, and the current thread's\n   *     interrupt status is re-asserted.\n   * @return the result returned by the Callable\n   * @throws InterruptedException if {@code interruptible} is true and our\n   *     thread is interrupted during execution\n   * @throws UncheckedTimeoutException if the time limit is reached\n   * @throws Exception\n   */\n  <T> T callWithTimeout(Callable<T> callable, long timeoutDuration,\n      TimeUnit timeoutUnit, boolean interruptible) throws Exception;\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53089881,"label":true,"oracleId":1468,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"TimeLimiter","javadocTag":"@param timeoutUnit with timeoutDuration, the maximum length of time to wait","methodJavadoc":"    /**\n   * Invokes a specified Callable, timing out after the specified time limit.\n   * If the target method call finished before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is.  If, on the\n   * other hand, the time limit is reached, we attempt to abort the call to the\n   * target, and throw an {@link UncheckedTimeoutException} to the caller.\n   * <p>\n   * <b>Warning:</b> The future of this method is in doubt.  It may be nuked, or\n   * changed significantly.\n   *\n   * @param callable the Callable to execute\n   * @param timeoutDuration with timeoutUnit, the maximum length of time to wait\n   * @param timeoutUnit with timeoutDuration, the maximum length of time to wait\n   * @param interruptible whether to respond to thread interruption by aborting\n   *     the operation and throwing InterruptedException; if false, the\n   *     operation is allowed to complete or time out, and the current thread's\n   *     interrupt status is re-asserted.\n   * @return the result returned by the Callable\n   * @throws InterruptedException if {@code interruptible} is true and our\n   *     thread is interrupted during execution\n   * @throws UncheckedTimeoutException if the time limit is reached\n   * @throws Exception\n   */","methodSourceCode":"<T> T callWithTimeout(Callable<T> callable, long timeoutDuration, TimeUnit timeoutUnit, boolean interruptible) throws Exception;","classJavadoc":"/**\n * Produces proxies that impose a time limit on method\n * calls to the proxied object.  For example, to return the value of\n * {@code target.someMethod()}, but substitute {@code DEFAULT_VALUE} if this\n * method call takes over 50 ms, you can use this code:\n * <pre>\n *   TimeLimiter limiter = . . .;\n *   TargetType proxy = limiter.newProxy(\n *       target, TargetType.class, 50, TimeUnit.MILLISECONDS);\n *   try {\n *     return proxy.someMethod();\n *   } catch (UncheckedTimeoutException e) {\n *     return DEFAULT_VALUE;\n *   }\n * </pre>\n * <p>Please see {@code SimpleTimeLimiterTest} for more usage examples.\n *\n * @author Kevin Bourrillion\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2006 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Produces proxies that impose a time limit on method\n * calls to the proxied object.  For example, to return the value of\n * {@code target.someMethod()}, but substitute {@code DEFAULT_VALUE} if this\n * method call takes over 50 ms, you can use this code:\n * <pre>\n *   TimeLimiter limiter = . . .;\n *   TargetType proxy = limiter.newProxy(\n *       target, TargetType.class, 50, TimeUnit.MILLISECONDS);\n *   try {\n *     return proxy.someMethod();\n *   } catch (UncheckedTimeoutException e) {\n *     return DEFAULT_VALUE;\n *   }\n * </pre>\n * <p>Please see {@code SimpleTimeLimiterTest} for more usage examples.\n *\n * @author Kevin Bourrillion\n * @since 1.0\n */\n@Beta\npublic interface TimeLimiter {\n\n  /**\n   * Returns an instance of {@code interfaceType} that delegates all method\n   * calls to the {@code target} object, enforcing the specified time limit on\n   * each call.  This time-limited delegation is also performed for calls to\n   * {@link Object#equals}, {@link Object#hashCode}, and\n   * {@link Object#toString}.\n   * <p>\n   * If the target method call finishes before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is. If, on the\n   * other hand, the time limit is reached, the proxy will attempt to abort the\n   * call to the target, and will throw an {@link UncheckedTimeoutException} to\n   * the caller.\n   * <p>\n   * It is important to note that the primary purpose of the proxy object is to\n   * return control to the caller when the timeout elapses; aborting the target\n   * method call is of secondary concern.  The particular nature and strength\n   * of the guarantees made by the proxy is implementation-dependent.  However,\n   * it is important that each of the methods on the target object behaves\n   * appropriately when its thread is interrupted.\n   *\n   * @param target the object to proxy\n   * @param interfaceType the interface you wish the returned proxy to\n   *     implement\n   * @param timeoutDuration with timeoutUnit, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @param timeoutUnit with timeoutDuration, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @return a time-limiting proxy\n   * @throws IllegalArgumentException if {@code interfaceType} is a regular\n   *     class, enum, or annotation type, rather than an interface\n   */\n  <T> T newProxy(T target, Class<T> interfaceType,\n      long timeoutDuration, TimeUnit timeoutUnit);\n\n  /**\n   * Invokes a specified Callable, timing out after the specified time limit.\n   * If the target method call finished before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is.  If, on the\n   * other hand, the time limit is reached, we attempt to abort the call to the\n   * target, and throw an {@link UncheckedTimeoutException} to the caller.\n   * <p>\n   * <b>Warning:</b> The future of this method is in doubt.  It may be nuked, or\n   * changed significantly.\n   *\n   * @param callable the Callable to execute\n   * @param timeoutDuration with timeoutUnit, the maximum length of time to wait\n   * @param timeoutUnit with timeoutDuration, the maximum length of time to wait\n   * @param interruptible whether to respond to thread interruption by aborting\n   *     the operation and throwing InterruptedException; if false, the\n   *     operation is allowed to complete or time out, and the current thread's\n   *     interrupt status is re-asserted.\n   * @return the result returned by the Callable\n   * @throws InterruptedException if {@code interruptible} is true and our\n   *     thread is interrupted during execution\n   * @throws UncheckedTimeoutException if the time limit is reached\n   * @throws Exception\n   */\n  <T> T callWithTimeout(Callable<T> callable, long timeoutDuration,\n      TimeUnit timeoutUnit, boolean interruptible) throws Exception;\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53090342,"label":true,"oracleId":1469,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"TimeLimiter","javadocTag":"@param interruptible whether to respond to thread interruption by aborting\n    the operation and throwing InterruptedException; if false, the\n    operation is allowed to complete or time out, and the current thread's\n    interrupt status is re-asserted.","methodJavadoc":"    /**\n   * Invokes a specified Callable, timing out after the specified time limit.\n   * If the target method call finished before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is.  If, on the\n   * other hand, the time limit is reached, we attempt to abort the call to the\n   * target, and throw an {@link UncheckedTimeoutException} to the caller.\n   * <p>\n   * <b>Warning:</b> The future of this method is in doubt.  It may be nuked, or\n   * changed significantly.\n   *\n   * @param callable the Callable to execute\n   * @param timeoutDuration with timeoutUnit, the maximum length of time to wait\n   * @param timeoutUnit with timeoutDuration, the maximum length of time to wait\n   * @param interruptible whether to respond to thread interruption by aborting\n   *     the operation and throwing InterruptedException; if false, the\n   *     operation is allowed to complete or time out, and the current thread's\n   *     interrupt status is re-asserted.\n   * @return the result returned by the Callable\n   * @throws InterruptedException if {@code interruptible} is true and our\n   *     thread is interrupted during execution\n   * @throws UncheckedTimeoutException if the time limit is reached\n   * @throws Exception\n   */","methodSourceCode":"<T> T callWithTimeout(Callable<T> callable, long timeoutDuration, TimeUnit timeoutUnit, boolean interruptible) throws Exception;","classJavadoc":"/**\n * Produces proxies that impose a time limit on method\n * calls to the proxied object.  For example, to return the value of\n * {@code target.someMethod()}, but substitute {@code DEFAULT_VALUE} if this\n * method call takes over 50 ms, you can use this code:\n * <pre>\n *   TimeLimiter limiter = . . .;\n *   TargetType proxy = limiter.newProxy(\n *       target, TargetType.class, 50, TimeUnit.MILLISECONDS);\n *   try {\n *     return proxy.someMethod();\n *   } catch (UncheckedTimeoutException e) {\n *     return DEFAULT_VALUE;\n *   }\n * </pre>\n * <p>Please see {@code SimpleTimeLimiterTest} for more usage examples.\n *\n * @author Kevin Bourrillion\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2006 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Produces proxies that impose a time limit on method\n * calls to the proxied object.  For example, to return the value of\n * {@code target.someMethod()}, but substitute {@code DEFAULT_VALUE} if this\n * method call takes over 50 ms, you can use this code:\n * <pre>\n *   TimeLimiter limiter = . . .;\n *   TargetType proxy = limiter.newProxy(\n *       target, TargetType.class, 50, TimeUnit.MILLISECONDS);\n *   try {\n *     return proxy.someMethod();\n *   } catch (UncheckedTimeoutException e) {\n *     return DEFAULT_VALUE;\n *   }\n * </pre>\n * <p>Please see {@code SimpleTimeLimiterTest} for more usage examples.\n *\n * @author Kevin Bourrillion\n * @since 1.0\n */\n@Beta\npublic interface TimeLimiter {\n\n  /**\n   * Returns an instance of {@code interfaceType} that delegates all method\n   * calls to the {@code target} object, enforcing the specified time limit on\n   * each call.  This time-limited delegation is also performed for calls to\n   * {@link Object#equals}, {@link Object#hashCode}, and\n   * {@link Object#toString}.\n   * <p>\n   * If the target method call finishes before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is. If, on the\n   * other hand, the time limit is reached, the proxy will attempt to abort the\n   * call to the target, and will throw an {@link UncheckedTimeoutException} to\n   * the caller.\n   * <p>\n   * It is important to note that the primary purpose of the proxy object is to\n   * return control to the caller when the timeout elapses; aborting the target\n   * method call is of secondary concern.  The particular nature and strength\n   * of the guarantees made by the proxy is implementation-dependent.  However,\n   * it is important that each of the methods on the target object behaves\n   * appropriately when its thread is interrupted.\n   *\n   * @param target the object to proxy\n   * @param interfaceType the interface you wish the returned proxy to\n   *     implement\n   * @param timeoutDuration with timeoutUnit, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @param timeoutUnit with timeoutDuration, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @return a time-limiting proxy\n   * @throws IllegalArgumentException if {@code interfaceType} is a regular\n   *     class, enum, or annotation type, rather than an interface\n   */\n  <T> T newProxy(T target, Class<T> interfaceType,\n      long timeoutDuration, TimeUnit timeoutUnit);\n\n  /**\n   * Invokes a specified Callable, timing out after the specified time limit.\n   * If the target method call finished before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is.  If, on the\n   * other hand, the time limit is reached, we attempt to abort the call to the\n   * target, and throw an {@link UncheckedTimeoutException} to the caller.\n   * <p>\n   * <b>Warning:</b> The future of this method is in doubt.  It may be nuked, or\n   * changed significantly.\n   *\n   * @param callable the Callable to execute\n   * @param timeoutDuration with timeoutUnit, the maximum length of time to wait\n   * @param timeoutUnit with timeoutDuration, the maximum length of time to wait\n   * @param interruptible whether to respond to thread interruption by aborting\n   *     the operation and throwing InterruptedException; if false, the\n   *     operation is allowed to complete or time out, and the current thread's\n   *     interrupt status is re-asserted.\n   * @return the result returned by the Callable\n   * @throws InterruptedException if {@code interruptible} is true and our\n   *     thread is interrupted during execution\n   * @throws UncheckedTimeoutException if the time limit is reached\n   * @throws Exception\n   */\n  <T> T callWithTimeout(Callable<T> callable, long timeoutDuration,\n      TimeUnit timeoutUnit, boolean interruptible) throws Exception;\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53090804,"label":true,"oracleId":1470,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"TimeLimiter","javadocTag":"@return the result returned by the Callable","methodJavadoc":"    /**\n   * Invokes a specified Callable, timing out after the specified time limit.\n   * If the target method call finished before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is.  If, on the\n   * other hand, the time limit is reached, we attempt to abort the call to the\n   * target, and throw an {@link UncheckedTimeoutException} to the caller.\n   * <p>\n   * <b>Warning:</b> The future of this method is in doubt.  It may be nuked, or\n   * changed significantly.\n   *\n   * @param callable the Callable to execute\n   * @param timeoutDuration with timeoutUnit, the maximum length of time to wait\n   * @param timeoutUnit with timeoutDuration, the maximum length of time to wait\n   * @param interruptible whether to respond to thread interruption by aborting\n   *     the operation and throwing InterruptedException; if false, the\n   *     operation is allowed to complete or time out, and the current thread's\n   *     interrupt status is re-asserted.\n   * @return the result returned by the Callable\n   * @throws InterruptedException if {@code interruptible} is true and our\n   *     thread is interrupted during execution\n   * @throws UncheckedTimeoutException if the time limit is reached\n   * @throws Exception\n   */","methodSourceCode":"<T> T callWithTimeout(Callable<T> callable, long timeoutDuration, TimeUnit timeoutUnit, boolean interruptible) throws Exception;","classJavadoc":"/**\n * Produces proxies that impose a time limit on method\n * calls to the proxied object.  For example, to return the value of\n * {@code target.someMethod()}, but substitute {@code DEFAULT_VALUE} if this\n * method call takes over 50 ms, you can use this code:\n * <pre>\n *   TimeLimiter limiter = . . .;\n *   TargetType proxy = limiter.newProxy(\n *       target, TargetType.class, 50, TimeUnit.MILLISECONDS);\n *   try {\n *     return proxy.someMethod();\n *   } catch (UncheckedTimeoutException e) {\n *     return DEFAULT_VALUE;\n *   }\n * </pre>\n * <p>Please see {@code SimpleTimeLimiterTest} for more usage examples.\n *\n * @author Kevin Bourrillion\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2006 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Produces proxies that impose a time limit on method\n * calls to the proxied object.  For example, to return the value of\n * {@code target.someMethod()}, but substitute {@code DEFAULT_VALUE} if this\n * method call takes over 50 ms, you can use this code:\n * <pre>\n *   TimeLimiter limiter = . . .;\n *   TargetType proxy = limiter.newProxy(\n *       target, TargetType.class, 50, TimeUnit.MILLISECONDS);\n *   try {\n *     return proxy.someMethod();\n *   } catch (UncheckedTimeoutException e) {\n *     return DEFAULT_VALUE;\n *   }\n * </pre>\n * <p>Please see {@code SimpleTimeLimiterTest} for more usage examples.\n *\n * @author Kevin Bourrillion\n * @since 1.0\n */\n@Beta\npublic interface TimeLimiter {\n\n  /**\n   * Returns an instance of {@code interfaceType} that delegates all method\n   * calls to the {@code target} object, enforcing the specified time limit on\n   * each call.  This time-limited delegation is also performed for calls to\n   * {@link Object#equals}, {@link Object#hashCode}, and\n   * {@link Object#toString}.\n   * <p>\n   * If the target method call finishes before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is. If, on the\n   * other hand, the time limit is reached, the proxy will attempt to abort the\n   * call to the target, and will throw an {@link UncheckedTimeoutException} to\n   * the caller.\n   * <p>\n   * It is important to note that the primary purpose of the proxy object is to\n   * return control to the caller when the timeout elapses; aborting the target\n   * method call is of secondary concern.  The particular nature and strength\n   * of the guarantees made by the proxy is implementation-dependent.  However,\n   * it is important that each of the methods on the target object behaves\n   * appropriately when its thread is interrupted.\n   *\n   * @param target the object to proxy\n   * @param interfaceType the interface you wish the returned proxy to\n   *     implement\n   * @param timeoutDuration with timeoutUnit, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @param timeoutUnit with timeoutDuration, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @return a time-limiting proxy\n   * @throws IllegalArgumentException if {@code interfaceType} is a regular\n   *     class, enum, or annotation type, rather than an interface\n   */\n  <T> T newProxy(T target, Class<T> interfaceType,\n      long timeoutDuration, TimeUnit timeoutUnit);\n\n  /**\n   * Invokes a specified Callable, timing out after the specified time limit.\n   * If the target method call finished before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is.  If, on the\n   * other hand, the time limit is reached, we attempt to abort the call to the\n   * target, and throw an {@link UncheckedTimeoutException} to the caller.\n   * <p>\n   * <b>Warning:</b> The future of this method is in doubt.  It may be nuked, or\n   * changed significantly.\n   *\n   * @param callable the Callable to execute\n   * @param timeoutDuration with timeoutUnit, the maximum length of time to wait\n   * @param timeoutUnit with timeoutDuration, the maximum length of time to wait\n   * @param interruptible whether to respond to thread interruption by aborting\n   *     the operation and throwing InterruptedException; if false, the\n   *     operation is allowed to complete or time out, and the current thread's\n   *     interrupt status is re-asserted.\n   * @return the result returned by the Callable\n   * @throws InterruptedException if {@code interruptible} is true and our\n   *     thread is interrupted during execution\n   * @throws UncheckedTimeoutException if the time limit is reached\n   * @throws Exception\n   */\n  <T> T callWithTimeout(Callable<T> callable, long timeoutDuration,\n      TimeUnit timeoutUnit, boolean interruptible) throws Exception;\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53091266,"label":true,"oracleId":1471,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"TimeLimiter","javadocTag":"@throws UncheckedTimeoutException if the time limit is reached","methodJavadoc":"    /**\n   * Invokes a specified Callable, timing out after the specified time limit.\n   * If the target method call finished before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is.  If, on the\n   * other hand, the time limit is reached, we attempt to abort the call to the\n   * target, and throw an {@link UncheckedTimeoutException} to the caller.\n   * <p>\n   * <b>Warning:</b> The future of this method is in doubt.  It may be nuked, or\n   * changed significantly.\n   *\n   * @param callable the Callable to execute\n   * @param timeoutDuration with timeoutUnit, the maximum length of time to wait\n   * @param timeoutUnit with timeoutDuration, the maximum length of time to wait\n   * @param interruptible whether to respond to thread interruption by aborting\n   *     the operation and throwing InterruptedException; if false, the\n   *     operation is allowed to complete or time out, and the current thread's\n   *     interrupt status is re-asserted.\n   * @return the result returned by the Callable\n   * @throws InterruptedException if {@code interruptible} is true and our\n   *     thread is interrupted during execution\n   * @throws UncheckedTimeoutException if the time limit is reached\n   * @throws Exception\n   */","methodSourceCode":"<T> T callWithTimeout(Callable<T> callable, long timeoutDuration, TimeUnit timeoutUnit, boolean interruptible) throws Exception;","classJavadoc":"/**\n * Produces proxies that impose a time limit on method\n * calls to the proxied object.  For example, to return the value of\n * {@code target.someMethod()}, but substitute {@code DEFAULT_VALUE} if this\n * method call takes over 50 ms, you can use this code:\n * <pre>\n *   TimeLimiter limiter = . . .;\n *   TargetType proxy = limiter.newProxy(\n *       target, TargetType.class, 50, TimeUnit.MILLISECONDS);\n *   try {\n *     return proxy.someMethod();\n *   } catch (UncheckedTimeoutException e) {\n *     return DEFAULT_VALUE;\n *   }\n * </pre>\n * <p>Please see {@code SimpleTimeLimiterTest} for more usage examples.\n *\n * @author Kevin Bourrillion\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2006 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Produces proxies that impose a time limit on method\n * calls to the proxied object.  For example, to return the value of\n * {@code target.someMethod()}, but substitute {@code DEFAULT_VALUE} if this\n * method call takes over 50 ms, you can use this code:\n * <pre>\n *   TimeLimiter limiter = . . .;\n *   TargetType proxy = limiter.newProxy(\n *       target, TargetType.class, 50, TimeUnit.MILLISECONDS);\n *   try {\n *     return proxy.someMethod();\n *   } catch (UncheckedTimeoutException e) {\n *     return DEFAULT_VALUE;\n *   }\n * </pre>\n * <p>Please see {@code SimpleTimeLimiterTest} for more usage examples.\n *\n * @author Kevin Bourrillion\n * @since 1.0\n */\n@Beta\npublic interface TimeLimiter {\n\n  /**\n   * Returns an instance of {@code interfaceType} that delegates all method\n   * calls to the {@code target} object, enforcing the specified time limit on\n   * each call.  This time-limited delegation is also performed for calls to\n   * {@link Object#equals}, {@link Object#hashCode}, and\n   * {@link Object#toString}.\n   * <p>\n   * If the target method call finishes before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is. If, on the\n   * other hand, the time limit is reached, the proxy will attempt to abort the\n   * call to the target, and will throw an {@link UncheckedTimeoutException} to\n   * the caller.\n   * <p>\n   * It is important to note that the primary purpose of the proxy object is to\n   * return control to the caller when the timeout elapses; aborting the target\n   * method call is of secondary concern.  The particular nature and strength\n   * of the guarantees made by the proxy is implementation-dependent.  However,\n   * it is important that each of the methods on the target object behaves\n   * appropriately when its thread is interrupted.\n   *\n   * @param target the object to proxy\n   * @param interfaceType the interface you wish the returned proxy to\n   *     implement\n   * @param timeoutDuration with timeoutUnit, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @param timeoutUnit with timeoutDuration, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @return a time-limiting proxy\n   * @throws IllegalArgumentException if {@code interfaceType} is a regular\n   *     class, enum, or annotation type, rather than an interface\n   */\n  <T> T newProxy(T target, Class<T> interfaceType,\n      long timeoutDuration, TimeUnit timeoutUnit);\n\n  /**\n   * Invokes a specified Callable, timing out after the specified time limit.\n   * If the target method call finished before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is.  If, on the\n   * other hand, the time limit is reached, we attempt to abort the call to the\n   * target, and throw an {@link UncheckedTimeoutException} to the caller.\n   * <p>\n   * <b>Warning:</b> The future of this method is in doubt.  It may be nuked, or\n   * changed significantly.\n   *\n   * @param callable the Callable to execute\n   * @param timeoutDuration with timeoutUnit, the maximum length of time to wait\n   * @param timeoutUnit with timeoutDuration, the maximum length of time to wait\n   * @param interruptible whether to respond to thread interruption by aborting\n   *     the operation and throwing InterruptedException; if false, the\n   *     operation is allowed to complete or time out, and the current thread's\n   *     interrupt status is re-asserted.\n   * @return the result returned by the Callable\n   * @throws InterruptedException if {@code interruptible} is true and our\n   *     thread is interrupted during execution\n   * @throws UncheckedTimeoutException if the time limit is reached\n   * @throws Exception\n   */\n  <T> T callWithTimeout(Callable<T> callable, long timeoutDuration,\n      TimeUnit timeoutUnit, boolean interruptible) throws Exception;\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53091728,"label":true,"oracleId":1472,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"TimeLimiter","javadocTag":"@throws Exception ","methodJavadoc":"    /**\n   * Invokes a specified Callable, timing out after the specified time limit.\n   * If the target method call finished before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is.  If, on the\n   * other hand, the time limit is reached, we attempt to abort the call to the\n   * target, and throw an {@link UncheckedTimeoutException} to the caller.\n   * <p>\n   * <b>Warning:</b> The future of this method is in doubt.  It may be nuked, or\n   * changed significantly.\n   *\n   * @param callable the Callable to execute\n   * @param timeoutDuration with timeoutUnit, the maximum length of time to wait\n   * @param timeoutUnit with timeoutDuration, the maximum length of time to wait\n   * @param interruptible whether to respond to thread interruption by aborting\n   *     the operation and throwing InterruptedException; if false, the\n   *     operation is allowed to complete or time out, and the current thread's\n   *     interrupt status is re-asserted.\n   * @return the result returned by the Callable\n   * @throws InterruptedException if {@code interruptible} is true and our\n   *     thread is interrupted during execution\n   * @throws UncheckedTimeoutException if the time limit is reached\n   * @throws Exception\n   */","methodSourceCode":"<T> T callWithTimeout(Callable<T> callable, long timeoutDuration, TimeUnit timeoutUnit, boolean interruptible) throws Exception;","classJavadoc":"/**\n * Produces proxies that impose a time limit on method\n * calls to the proxied object.  For example, to return the value of\n * {@code target.someMethod()}, but substitute {@code DEFAULT_VALUE} if this\n * method call takes over 50 ms, you can use this code:\n * <pre>\n *   TimeLimiter limiter = . . .;\n *   TargetType proxy = limiter.newProxy(\n *       target, TargetType.class, 50, TimeUnit.MILLISECONDS);\n *   try {\n *     return proxy.someMethod();\n *   } catch (UncheckedTimeoutException e) {\n *     return DEFAULT_VALUE;\n *   }\n * </pre>\n * <p>Please see {@code SimpleTimeLimiterTest} for more usage examples.\n *\n * @author Kevin Bourrillion\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2006 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Produces proxies that impose a time limit on method\n * calls to the proxied object.  For example, to return the value of\n * {@code target.someMethod()}, but substitute {@code DEFAULT_VALUE} if this\n * method call takes over 50 ms, you can use this code:\n * <pre>\n *   TimeLimiter limiter = . . .;\n *   TargetType proxy = limiter.newProxy(\n *       target, TargetType.class, 50, TimeUnit.MILLISECONDS);\n *   try {\n *     return proxy.someMethod();\n *   } catch (UncheckedTimeoutException e) {\n *     return DEFAULT_VALUE;\n *   }\n * </pre>\n * <p>Please see {@code SimpleTimeLimiterTest} for more usage examples.\n *\n * @author Kevin Bourrillion\n * @since 1.0\n */\n@Beta\npublic interface TimeLimiter {\n\n  /**\n   * Returns an instance of {@code interfaceType} that delegates all method\n   * calls to the {@code target} object, enforcing the specified time limit on\n   * each call.  This time-limited delegation is also performed for calls to\n   * {@link Object#equals}, {@link Object#hashCode}, and\n   * {@link Object#toString}.\n   * <p>\n   * If the target method call finishes before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is. If, on the\n   * other hand, the time limit is reached, the proxy will attempt to abort the\n   * call to the target, and will throw an {@link UncheckedTimeoutException} to\n   * the caller.\n   * <p>\n   * It is important to note that the primary purpose of the proxy object is to\n   * return control to the caller when the timeout elapses; aborting the target\n   * method call is of secondary concern.  The particular nature and strength\n   * of the guarantees made by the proxy is implementation-dependent.  However,\n   * it is important that each of the methods on the target object behaves\n   * appropriately when its thread is interrupted.\n   *\n   * @param target the object to proxy\n   * @param interfaceType the interface you wish the returned proxy to\n   *     implement\n   * @param timeoutDuration with timeoutUnit, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @param timeoutUnit with timeoutDuration, the maximum length of time that\n   *     callers are willing to wait on each method call to the proxy\n   * @return a time-limiting proxy\n   * @throws IllegalArgumentException if {@code interfaceType} is a regular\n   *     class, enum, or annotation type, rather than an interface\n   */\n  <T> T newProxy(T target, Class<T> interfaceType,\n      long timeoutDuration, TimeUnit timeoutUnit);\n\n  /**\n   * Invokes a specified Callable, timing out after the specified time limit.\n   * If the target method call finished before the limit is reached, the return\n   * value or exception is propagated to the caller exactly as-is.  If, on the\n   * other hand, the time limit is reached, we attempt to abort the call to the\n   * target, and throw an {@link UncheckedTimeoutException} to the caller.\n   * <p>\n   * <b>Warning:</b> The future of this method is in doubt.  It may be nuked, or\n   * changed significantly.\n   *\n   * @param callable the Callable to execute\n   * @param timeoutDuration with timeoutUnit, the maximum length of time to wait\n   * @param timeoutUnit with timeoutDuration, the maximum length of time to wait\n   * @param interruptible whether to respond to thread interruption by aborting\n   *     the operation and throwing InterruptedException; if false, the\n   *     operation is allowed to complete or time out, and the current thread's\n   *     interrupt status is re-asserted.\n   * @return the result returned by the Callable\n   * @throws InterruptedException if {@code interruptible} is true and our\n   *     thread is interrupted during execution\n   * @throws UncheckedTimeoutException if the time limit is reached\n   * @throws Exception\n   */\n  <T> T callWithTimeout(Callable<T> callable, long timeoutDuration,\n      TimeUnit timeoutUnit, boolean interruptible) throws Exception;\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53092186,"label":true,"oracleId":1473,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the current value","methodJavadoc":"    /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */","methodSourceCode":"public final double get(){\n    return longBitsToDouble(value);\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53092644,"label":true,"oracleId":1474,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param newValue the new value","methodJavadoc":"    /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */","methodSourceCode":"public final void set(double newValue){\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53093102,"label":true,"oracleId":1475,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param newValue the new value","methodJavadoc":"    /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */","methodSourceCode":"public final void lazySet(double newValue){\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53093560,"label":true,"oracleId":1476,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param newValue the new value","methodJavadoc":"    /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndSet(double newValue){\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53094019,"label":true,"oracleId":1477,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the previous value","methodJavadoc":"    /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndSet(double newValue){\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53094478,"label":true,"oracleId":1478,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param expect the expected value","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */","methodSourceCode":"public final boolean compareAndSet(double expect, double update){\n    return updater.compareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53094937,"label":true,"oracleId":1479,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param update the new value","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */","methodSourceCode":"public final boolean compareAndSet(double expect, double update){\n    return updater.compareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53095397,"label":true,"oracleId":1480,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} if successful. False return indicates that\nthe actual value was not bitwise equal to the expected value.","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */","methodSourceCode":"public final boolean compareAndSet(double expect, double update){\n    return updater.compareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53095856,"label":true,"oracleId":1481,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param expect the expected value","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53096315,"label":true,"oracleId":1482,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param update the new value","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53096775,"label":true,"oracleId":1483,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return {@code true} if successful","methodJavadoc":"    /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */","methodSourceCode":"public final boolean weakCompareAndSet(double expect, double update){\n    return updater.weakCompareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53097233,"label":true,"oracleId":1484,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to add","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53097692,"label":true,"oracleId":1485,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the previous value","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */","methodSourceCode":"public final double getAndAdd(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return currentVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53098150,"label":true,"oracleId":1486,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param delta the value to add","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53098609,"label":true,"oracleId":1487,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the updated value","methodJavadoc":"    /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */","methodSourceCode":"public final double addAndGet(double delta){\n    while (true) {\n        long current = value;\n        double currentVal = longBitsToDouble(current);\n        double nextVal = currentVal + delta;\n        long next = doubleToRawLongBits(nextVal);\n        if (updater.compareAndSet(this, current, next)) {\n            return nextVal;\n        }\n    }\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53099067,"label":true,"oracleId":1488,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@return the String representation of the current value","methodJavadoc":"    /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */","methodSourceCode":"public String toString(){\n    return Double.toString(get());\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53099524,"label":true,"oracleId":1489,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AtomicDouble","javadocTag":"@param initialValue the initial value","methodJavadoc":"    /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */","methodSourceCode":"public AtomicDouble(double initialValue){\n    value = doubleToRawLongBits(initialValue);\n}","classJavadoc":"/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */","classSourceCode":"/*\n * Written by Doug Lea and Martin Buchholz with assistance from\n * members of JCP JSR-166 Expert Group and released to the public\n * domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n/*\n * Source:\n * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/extra/AtomicDouble.java?revision=1.13\n * (Modified to adapt to guava coding conventions and\n * to use AtomicLongFieldUpdater instead of sun.misc.Unsafe)\n */\n\npackage com.google.common.util.concurrent;\n\nimport static java.lang.Double.doubleToRawLongBits;\nimport static java.lang.Double.longBitsToDouble;\n\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\n/**\n * A {@code double} value that may be updated atomically.  See the\n * {@link java.util.concurrent.atomic} package specification for\n * description of the properties of atomic variables.  An {@code\n * AtomicDouble} is used in applications such as atomic accumulation,\n * and cannot be used as a replacement for a {@link Double}.  However,\n * this class does extend {@code Number} to allow uniform access by\n * tools and utilities that deal with numerically-based classes.\n *\n * <p><a name=\"bitEquals\">This class compares primitive {@code double}\n * values in methods such as {@link #compareAndSet} by comparing their\n * bitwise representation using {@link Double#doubleToRawLongBits},\n * which differs from both the primitive double {@code ==} operator\n * and from {@link Double#equals}, as if implemented by:\n *  <pre> {@code\n * static boolean bitEquals(double x, double y) {\n *   long xBits = Double.doubleToRawLongBits(x);\n *   long yBits = Double.doubleToRawLongBits(y);\n *   return xBits == yBits;\n * }}</pre>\n *\n * <p>It is possible to write a more scalable updater, at the cost of\n * giving up strict atomicity.  See for example\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html\">\n * DoubleAdder</a>\n * and\n * <a href=\"http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html\">\n * DoubleMaxUpdater</a>.\n *\n * @author Doug Lea\n * @author Martin Buchholz\n * @since 11.0\n */\npublic class AtomicDouble extends Number implements java.io.Serializable {\n  private static final long serialVersionUID = 0L;\n\n  private transient volatile long value;\n\n  private static final AtomicLongFieldUpdater<AtomicDouble> updater =\n      AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, \"value\");\n\n  /**\n   * Creates a new {@code AtomicDouble} with the given initial value.\n   *\n   * @param initialValue the initial value\n   */\n  public AtomicDouble(double initialValue) {\n    value = doubleToRawLongBits(initialValue);\n  }\n\n  /**\n   * Creates a new {@code AtomicDouble} with initial value {@code 0.0}.\n   */\n  public AtomicDouble() {\n    // assert doubleToRawLongBits(0.0) == 0L;\n  }\n\n  /**\n   * Gets the current value.\n   *\n   * @return the current value\n   */\n  public final double get() {\n    return longBitsToDouble(value);\n  }\n\n  /**\n   * Sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void set(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    value = next;\n  }\n\n  /**\n   * Eventually sets to the given value.\n   *\n   * @param newValue the new value\n   */\n  public final void lazySet(double newValue) {\n    set(newValue);\n    // TODO(user): replace with code below when jdk5 support is dropped.\n    // long next = doubleToRawLongBits(newValue);\n    // updater.lazySet(this, next);\n  }\n\n  /**\n   * Atomically sets to the given value and returns the old value.\n   *\n   * @param newValue the new value\n   * @return the previous value\n   */\n  public final double getAndSet(double newValue) {\n    long next = doubleToRawLongBits(newValue);\n    return longBitsToDouble(updater.getAndSet(this, next));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful. False return indicates that\n   * the actual value was not bitwise equal to the expected value.\n   */\n  public final boolean compareAndSet(double expect, double update) {\n    return updater.compareAndSet(this,\n                                 doubleToRawLongBits(expect),\n                                 doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically sets the value to the given updated value\n   * if the current value is <a href=\"#bitEquals\">bitwise equal</a>\n   * to the expected value.\n   *\n   * <p>May <a\n   * href=\"http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious\">\n   * fail spuriously</a>\n   * and does not provide ordering guarantees, so is only rarely an\n   * appropriate alternative to {@code compareAndSet}.\n   *\n   * @param expect the expected value\n   * @param update the new value\n   * @return {@code true} if successful\n   */\n  public final boolean weakCompareAndSet(double expect, double update) {\n    return updater.weakCompareAndSet(this,\n                                     doubleToRawLongBits(expect),\n                                     doubleToRawLongBits(update));\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the previous value\n   */\n  public final double getAndAdd(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return currentVal;\n      }\n    }\n  }\n\n  /**\n   * Atomically adds the given value to the current value.\n   *\n   * @param delta the value to add\n   * @return the updated value\n   */\n  public final double addAndGet(double delta) {\n    while (true) {\n      long current = value;\n      double currentVal = longBitsToDouble(current);\n      double nextVal = currentVal + delta;\n      long next = doubleToRawLongBits(nextVal);\n      if (updater.compareAndSet(this, current, next)) {\n        return nextVal;\n      }\n    }\n  }\n\n  /**\n   * Returns the String representation of the current value.\n   * @return the String representation of the current value\n   */\n  public String toString() {\n    return Double.toString(get());\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as an {@code int}\n   * after a narrowing primitive conversion.\n   */\n  public int intValue() {\n    return (int) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code long}\n   * after a narrowing primitive conversion.\n   */\n  public long longValue() {\n    return (long) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code float}\n   * after a narrowing primitive conversion.\n   */\n  public float floatValue() {\n    return (float) get();\n  }\n\n  /**\n   * Returns the value of this {@code AtomicDouble} as a {@code double}.\n   */\n  public double doubleValue() {\n    return get();\n  }\n\n  /**\n   * Saves the state to a stream (that is, serializes it).\n   *\n   * @serialData The current value is emitted (a {@code double}).\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException {\n    s.defaultWriteObject();\n\n    s.writeDouble(get());\n  }\n\n  /**\n   * Reconstitutes the instance from a stream (that is, deserializes it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    set(s.readDouble());\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53099981,"label":true,"oracleId":1490,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a new {@code AtomicReference} with no initial value","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(){\n    return new AtomicReference<V>();\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53100438,"label":true,"oracleId":1491,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param initialValue the initial value","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53100896,"label":true,"oracleId":1492,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a new {@code AtomicReference} with the given initial value","methodJavadoc":"    /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */","methodSourceCode":"public static <V> AtomicReference<V> newReference(@Nullable V initialValue){\n    return new AtomicReference<V>(initialValue);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53101353,"label":true,"oracleId":1493,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param length the length of the array","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53101811,"label":true,"oracleId":1494,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a new {@code AtomicReferenceArray} with the given length","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(int length){\n    return new AtomicReferenceArray<E>(length);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53102268,"label":true,"oracleId":1495,"oracleType":"PRE","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@param array the array to copy elements from","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53102727,"label":true,"oracleId":1496,"oracleType":"NORMAL_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"Atomics","javadocTag":"@return a new {@code AtomicReferenceArray} copied from the given array","methodJavadoc":"    /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */","methodSourceCode":"public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array){\n    return new AtomicReferenceArray<E>(array);\n}","classJavadoc":"/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */","classSourceCode":"/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\nimport javax.annotation.Nullable;\n\n/**\n * Static utility methods pertaining to classes in the\n * {@code java.util.concurrent.atomic} package.\n *\n * @author Kurt Alfred Kluever\n * @since 10.0\n */\npublic final class Atomics {\n  private Atomics() {}\n\n  /**\n   * Creates an {@code AtomicReference} instance with no initial value.\n   *\n   * @return a new {@code AtomicReference} with no initial value\n   */\n  public static <V> AtomicReference<V> newReference() {\n    return new AtomicReference<V>();\n  }\n\n  /**\n   * Creates an {@code AtomicReference} instance with the given initial value.\n   *\n   * @param initialValue the initial value\n   * @return a new {@code AtomicReference} with the given initial value\n   */\n  public static <V> AtomicReference<V> newReference(@Nullable V initialValue) {\n    return new AtomicReference<V>(initialValue);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance of given length.\n   *\n   * @param length the length of the array\n   * @return a new {@code AtomicReferenceArray} with the given length\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(int length) {\n    return new AtomicReferenceArray<E>(length);\n  }\n\n  /**\n   * Creates an {@code AtomicReferenceArray} instance with the same length as,\n   * and all elements copied from, the given array.\n   *\n   * @param array the array to copy elements from\n   * @return a new {@code AtomicReferenceArray} copied from the given array\n   */\n  public static <E> AtomicReferenceArray<E> newReferenceArray(E[] array) {\n    return new AtomicReferenceArray<E>(array);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53103187,"label":true,"oracleId":1497,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"WrappingExecutorService","javadocTag":"@throws NullPointerException if any element of {@code tasks} is null","methodJavadoc":"    /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */","methodSourceCode":"private final <T> ImmutableList<Callable<T>> wrapTasks(Collection<? extends Callable<T>> tasks){\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n        builder.add(wrapTask(task));\n    }\n    return builder.build();\n}","classJavadoc":"/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */","classSourceCode":"/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * An abstract {@code ExecutorService} that allows subclasses to\n * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted\n * to the underlying executor.\n *\n * <p>Note that task wrapping may occur even if the task is never executed.\n *\n * <p>For delegation without task-wrapping, see\n * {@link ForwardingExecutorService}.\n *\n * @author Chris Nokleberg\n */\nabstract class WrappingExecutorService implements ExecutorService {\n  private final ExecutorService delegate;\n\n  protected WrappingExecutorService(ExecutorService delegate) {\n    this.delegate = checkNotNull(delegate);\n  }\n\n  /**\n   * Wraps a {@code Callable} for submission to the underlying executor. This\n   * method is also applied to any {@code Runnable} passed to the default\n   * implementation of {@link #wrapTask(Runnable)}.\n   */\n  protected abstract <T> Callable<T> wrapTask(Callable<T> callable);\n\n  /**\n   * Wraps a {@code Runnable} for submission to the underlying executor. The\n   * default implementation delegates to {@link #wrapTask(Callable)}.\n   */\n  protected Runnable wrapTask(Runnable command) {\n    final Callable<Object> wrapped = wrapTask(\n        Executors.callable(command, null));\n    return new Runnable() {\n      @Override public void run() {\n        try {\n          wrapped.call();\n        } catch (Exception e) {\n          Throwables.propagate(e);\n        }\n      }\n    };\n  }\n\n  /**\n   * Wraps a collection of tasks.\n   *\n   * @throws NullPointerException if any element of {@code tasks} is null\n   */\n  private final <T> ImmutableList<Callable<T>> wrapTasks(\n      Collection<? extends Callable<T>> tasks) {\n    ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();\n    for (Callable<T> task : tasks) {\n      builder.add(wrapTask(task));\n    }\n    return builder.build();\n  }\n\n  // These methods wrap before delegating.\n  @Override\n  public final void execute(Runnable command) {\n    delegate.execute(wrapTask(command));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Callable<T> task) {\n    return delegate.submit(wrapTask(checkNotNull(task)));\n  }\n\n  @Override\n  public final Future<?> submit(Runnable task) {\n    return delegate.submit(wrapTask(task));\n  }\n\n  @Override\n  public final <T> Future<T> submit(Runnable task, T result) {\n    return delegate.submit(wrapTask(task), result);\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks) throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> List<Future<T>> invokeAll(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.invokeAll(wrapTasks(tasks), timeout, unit);\n  }\n\n  @Override\n  public final <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n      throws InterruptedException, ExecutionException {\n    return delegate.invokeAny(wrapTasks(tasks));\n  }\n\n  @Override\n  public final <T> T invokeAny(\n      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n      throws InterruptedException, ExecutionException, TimeoutException {\n    return delegate.invokeAny(wrapTasks(tasks), timeout, unit);\n  }\n\n  // The remaining methods just delegate.\n\n  @Override\n  public final void shutdown() {\n    delegate.shutdown();\n  }\n\n  @Override\n  public final List<Runnable> shutdownNow() {\n    return delegate.shutdownNow();\n  }\n\n  @Override\n  public final boolean isShutdown() {\n    return delegate.isShutdown();\n  }\n\n  @Override\n  public final boolean isTerminated() {\n    return delegate.isTerminated();\n  }\n\n  @Override\n  public final boolean awaitTermination(long timeout, TimeUnit unit)\n      throws InterruptedException {\n    return delegate.awaitTermination(timeout, unit);\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53103645,"label":true,"oracleId":1498,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"SerializingExecutor","javadocTag":"@throws java.lang.IllegalStateException if this executor is not suspended.","methodJavadoc":"    /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */","methodSourceCode":"public void resume(){\n    synchronized (internalLock) {\n        Preconditions.checkState(suspensions > 0);\n        suspensions--;\n    }\n    startQueueWorker();\n}","classJavadoc":"/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.concurrent.Executor;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Executor ensuring that all Runnables submitted are executed in order,\n * using the provided Executor, and serially such that no two will ever\n * be running at the same time.\n *\n * <p>Tasks submitted to {@link #execute(Runnable)} are executed in FIFO order.\n *\n * <p>Tasks can also be prepended to the queue to be executed in LIFO order before any other\n * submitted tasks. Primarily intended for the currently executing task to be able to schedule a\n * continuation task.\n *\n * <p>Execution on the queue can be {@linkplain #suspend suspended}, e.g. while waiting for an RPC,\n * and execution can be {@linkplain #resume resumed} later.\n *\n * <p>The execution of tasks is done by one thread as long as there are tasks left in the queue and\n * execution has not been suspended. (Even if one task is {@linkplain Thread#interrupt interrupted},\n * execution of subsequent tasks continues.) {@code RuntimeException}s thrown by tasks are simply\n * logged and the executor keeps trucking. If an {@code Error} is thrown, the error will propagate\n * and execution will stop until it is restarted by external calls.\n */\nfinal class SerializingExecutor implements Executor {\n  private static final Logger log =\n      Logger.getLogger(SerializingExecutor.class.getName());\n\n  /** Underlying executor that all submitted Runnable objects are run on. */\n  private final Executor executor;\n\n  @GuardedBy(\"internalLock\")\n  private final Deque<Runnable> queue = new ArrayDeque<Runnable>();\n  @GuardedBy(\"internalLock\")\n  private boolean isWorkerRunning = false;\n  @GuardedBy(\"internalLock\")\n  private int suspensions = 0;\n\n  private final Object internalLock = new Object();\n\n  public SerializingExecutor(Executor executor) {\n    this.executor = Preconditions.checkNotNull(executor);\n  }\n\n  /**\n   * Adds a task to the queue and makes sure a worker thread is running, unless the queue has been\n   * suspended.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #resume()} is\n   * made.\n   */\n  public void execute(Runnable task) {\n    synchronized (internalLock) {\n      queue.add(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Prepends a task to the front of the queue and makes sure a worker thread is running, unless the\n   * queue has been suspended.\n   */\n  public void executeFirst(Runnable task) {\n    synchronized (internalLock) {\n      queue.addFirst(task);\n    }\n    startQueueWorker();\n  }\n\n  /**\n   * Suspends the running of tasks until {@link #resume()} is called. This can be called multiple\n   * times to increase the suspensions count and execution will not continue until {@link #resume}\n   * has been called the same number of times as {@code suspend} has been.\n   *\n   * <p>Any task that has already been pulled off the queue for execution will be completed\n   * before execution is suspended.\n   */\n  public void suspend() {\n    synchronized (internalLock) {\n      suspensions++;\n    }\n  }\n\n  /**\n   * Continue execution of tasks after a call to {@link #suspend()}. More accurately, decreases the\n   * suspension counter, as has been incremented by calls to {@link #suspend}, and resumes execution\n   * if the suspension counter is zero.\n   *\n   * <p>If this method throws, e.g. a {@code RejectedExecutionException} from the delegate executor,\n   * execution of tasks will stop until a call to this method or to {@link #execute(Runnable)} or\n   * {@link #executeFirst(Runnable)} is made.\n   *\n   * @throws java.lang.IllegalStateException if this executor is not suspended.\n   */\n  public void resume() {\n    synchronized (internalLock) {\n      Preconditions.checkState(suspensions > 0);\n      suspensions--;\n    }\n    startQueueWorker();\n  }\n\n  private void startQueueWorker() {\n    synchronized (internalLock) {\n      // We sometimes try to start a queue worker without knowing if there is any work to do.\n      if (queue.peek() == null) {\n        return;\n      }\n      if (suspensions > 0) {\n        return;\n      }\n      if (isWorkerRunning) {\n        return;\n      }\n      isWorkerRunning = true;\n    }\n    boolean executionRejected = true;\n    try {\n      executor.execute(new QueueWorker());\n      executionRejected = false;\n    } finally {\n      if (executionRejected) {\n        // The best we can do is to stop executing the queue, but reset the state so that\n        // execution can be resumed later if the caller so wishes.\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n      }\n    }\n  }\n\n  /**\n   * Worker that runs tasks off the queue until it is empty or the queue is suspended.\n   */\n  private final class QueueWorker implements Runnable {\n    @Override\n    public void run() {\n      try {\n        workOnQueue();\n      } catch (Error e) {\n        synchronized (internalLock) {\n          isWorkerRunning = false;\n        }\n        throw e;\n        // The execution of a task has ended abnormally.\n        // We could have tasks left in the queue, so should perhaps try to restart a worker,\n        // but then the Error will get delayed if we are using a direct (same thread) executor.\n      }\n    }\n\n    private void workOnQueue() {\n      while (true) {\n        Runnable task = null;\n        synchronized (internalLock) {\n          // TODO(user): How should we handle interrupts and shutdowns?\n          if (suspensions == 0) {\n            task = queue.poll();\n          }\n          if (task == null) {\n            isWorkerRunning = false;\n            return;\n          }\n        }\n        try {\n          task.run();\n        } catch (RuntimeException e) {\n          log.log(Level.SEVERE, \"Exception while executing runnable \" + task, e);\n        }\n      }\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":53104103,"label":true,"oracleId":1499,"oracleType":"EXCEPT_POST","projectName":"guava-19.0","packageName":"com.google.common.util.concurrent","className":"AbstractCheckedFuture","javadocTag":"@throws X if {@link #get()} throws an {@link InterruptedException},\n        {@link CancellationException}, or {@link ExecutionException}","methodJavadoc":"    /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */","methodSourceCode":"public V checkedGet() throws X{\n    try {\n        return get();\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw mapException(e);\n    } catch (CancellationException e) {\n        throw mapException(e);\n    } catch (ExecutionException e) {\n        throw mapException(e);\n    }\n}","classJavadoc":"/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */","classSourceCode":"/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport com.google.common.annotations.Beta;\n\nimport java.util.concurrent.CancellationException;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * A delegating wrapper around a {@link ListenableFuture} that adds support for\n * the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.\n *\n * @author Sven Mawson\n * @since 1.0\n */\n@Beta\npublic abstract class AbstractCheckedFuture<V, X extends Exception>\n    extends ForwardingListenableFuture.SimpleForwardingListenableFuture<V>\n    implements CheckedFuture<V, X> {\n  /**\n   * Constructs an {@code AbstractCheckedFuture} that wraps a delegate.\n   */\n  protected AbstractCheckedFuture(ListenableFuture<V> delegate) {\n    super(delegate);\n  }\n\n  /**\n   * Translates from an {@link InterruptedException},\n   * {@link CancellationException} or {@link ExecutionException} thrown by\n   * {@code get} to an exception of type {@code X} to be thrown by\n   * {@code checkedGet}. Subclasses must implement this method.\n   *\n   * <p>If {@code e} is an {@code InterruptedException}, the calling\n   * {@code checkedGet} method has already restored the interrupt after catching\n   * the exception. If an implementation of {@link #mapException(Exception)}\n   * wishes to swallow the interrupt, it can do so by calling\n   * {@link Thread#interrupted()}.\n   *\n   * <p>Subclasses may choose to throw, rather than return, a subclass of\n   * {@code RuntimeException} to allow creating a CheckedFuture that throws\n   * both checked and unchecked exceptions.\n   */\n  protected abstract X mapException(Exception e);\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get()} and maps that method's standard\n   * exceptions to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   */\n  @Override\n  public V checkedGet() throws X {\n    try {\n      return get();\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>This implementation calls {@link #get(long, TimeUnit)} and maps that\n   * method's standard exceptions (excluding {@link TimeoutException}, which is\n   * propagated) to instances of type {@code X} using {@link #mapException}.\n   *\n   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this\n   * implementation will set the current thread's interrupt status before\n   * calling {@code mapException}.\n   *\n   * @throws X if {@link #get()} throws an {@link InterruptedException},\n   *         {@link CancellationException}, or {@link ExecutionException}\n   * @throws TimeoutException {@inheritDoc}\n   */\n  @Override\n  public V checkedGet(long timeout, TimeUnit unit) throws TimeoutException, X {\n    try {\n      return get(timeout, unit);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw mapException(e);\n    } catch (CancellationException e) {\n      throw mapException(e);\n    } catch (ExecutionException e) {\n      throw mapException(e);\n    }\n  }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]}]